diff --git a/LICENSE b/LICENSE
index 11d14d5..46ffc94 100644
--- a/LICENSE
+++ b/LICENSE
@@ -15,3 +15,27 @@ A copy of the GNU Lesser General Public License is included in the
 Wine distribution in the file COPYING.LIB. If you did not receive this
 copy, write to the Free Software Foundation, Inc., 51 Franklin St,
 Fifth Floor, Boston, MA 02110-1301, USA.
+
+-----------------------------------------------------------------------
+
+Exceptions (for Wine Staging):
+
+The following files are shipped with Wine Staging, but are not linked to
+the rest of the project in any way. They are simply installed for
+end-user convenience and use a different license as explained below.
+
+    * fonts/arial.ttf and fonts/arial.sfd
+      The Liberation Sans font is licensed under the
+      LIBERATION FONT SOFTWARE LICENSE. See COPYING.arial.
+
+    * fonts/times.ttf and fonts/times.sfd
+      The Liberation Serif font is licensed under the
+      LIBERATION FONT SOFTWARE LICENSE. See COPYING.times.
+
+    * fonts/cour.ttf and fonts/cour.sfd
+      The Liberation Mono font is licensed under the
+      LIBERATION FONT SOFTWARE LICENSE. See COPYING.cour.
+
+    * fonts/msyh.ttf and fonts/msyh.sfd
+      The WenQuanYi Micro Hei font is licensed under both the APACHE 2
+      license and GPLv3. See COPYING.msyh for GPLv3.
diff --git a/MAINTAINERS b/MAINTAINERS
index 4bab36b..f326dcc 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -182,6 +182,7 @@ F:	dlls/user32/input.c
 F:	dlls/win32u/input.c
 F:	dlls/win32u/rawinput.c
 F:	server/queue.c
+F:	programs/winecfg/input.c
 
 Input methods
 M:	RÃ©mi Bernon <rbernon@codeweavers.com>
diff --git a/configure b/configure
index ae5def6..acffe96 100755
--- a/configure
+++ b/configure
@@ -21659,6 +21659,7 @@ wine_fn_config_makefile dlls/crypt32/tests enable_tests
 wine_fn_config_makefile dlls/cryptdlg enable_cryptdlg
 wine_fn_config_makefile dlls/cryptdll enable_cryptdll
 wine_fn_config_makefile dlls/cryptext enable_cryptext
+wine_fn_config_makefile dlls/cryptext/tests enable_tests
 wine_fn_config_makefile dlls/cryptnet enable_cryptnet
 wine_fn_config_makefile dlls/cryptnet/tests enable_tests
 wine_fn_config_makefile dlls/cryptowinrt enable_cryptowinrt
@@ -22137,6 +22138,7 @@ wine_fn_config_makefile dlls/ntprint enable_ntprint
 wine_fn_config_makefile dlls/ntprint/tests enable_tests
 wine_fn_config_makefile dlls/objsel enable_objsel
 wine_fn_config_makefile dlls/odbc32 enable_odbc32
+wine_fn_config_makefile dlls/odbc32/tests enable_tests
 wine_fn_config_makefile dlls/odbcbcp enable_odbcbcp
 wine_fn_config_makefile dlls/odbccp32 enable_odbccp32
 wine_fn_config_makefile dlls/odbccp32/tests enable_tests
diff --git a/configure.ac b/configure.ac
index 475743b..fb7ff4c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -73,6 +73,8 @@ AC_ARG_WITH(xinput,    AS_HELP_STRING([--without-xinput],[do not use the Xinput
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput_h=no; fi])
 AC_ARG_WITH(xinput2,   AS_HELP_STRING([--without-xinput2],[do not use the Xinput 2 extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput2_h=no; fi])
+AC_ARG_WITH(xpresent,  AS_HELP_STRING([--without-xpresent],[do not use the Xpresent extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xpresent_h=no; fi])
 AC_ARG_WITH(xrandr,    AS_HELP_STRING([--without-xrandr],[do not use Xrandr (multi-monitor support)]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrandr_h=no; fi])
 AC_ARG_WITH(xrender,   AS_HELP_STRING([--without-xrender],[do not use the Xrender extension]),
@@ -426,6 +428,7 @@ AC_CHECK_HEADERS(\
 	linux/ioctl.h \
 	linux/major.h \
 	linux/param.h \
+	linux/seccomp.h \
 	linux/serial.h \
 	linux/types.h \
 	linux/ucdrom.h \
@@ -454,6 +457,7 @@ AC_CHECK_HEADERS(\
 	sys/cdio.h \
 	sys/epoll.h \
 	sys/event.h \
+	sys/eventfd.h \
 	sys/extattr.h \
 	sys/filio.h \
 	sys/ipc.h \
@@ -1828,9 +1832,6 @@ then
                   AC_SUBST(PROCSTAT_LIBS,"-lprocstat")])
 fi
 
-dnl **** Check for libodbc ****
-WINE_CHECK_SONAME(odbc,SQLConnect,,[AC_DEFINE_UNQUOTED(SONAME_LIBODBC,["libodbc.$LIBEXT"])])
-
 dnl **** Check for libnetapi ****
 if test "x$with_netapi" != "xno"
 then
@@ -2086,9 +2087,12 @@ AC_CHECK_FUNCS(\
 	port_create \
 	posix_fadvise \
 	posix_fallocate \
+	ppoll \
 	prctl \
 	proc_pidinfo \
 	sched_yield \
+	renameat \
+	renameat2 \
 	setproctitle \
 	setprogname \
 	sigprocmask \
@@ -2109,6 +2113,12 @@ case $host_os in
     ;;
 esac
 
+ac_save_LIBS=$LIBS
+AC_SEARCH_LIBS(shm_open, rt,
+               [AC_DEFINE(HAVE_SHM_OPEN, 1, [Define to 1 if you have the `shm_open' function.])
+                test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
+LIBS=$ac_save_LIBS
+
 AC_CACHE_CHECK([for sched_setaffinity],wine_cv_have_sched_setaffinity,
                 AC_LINK_IFELSE([AC_LANG_PROGRAM(
 [[#include <sched.h>]], [[sched_setaffinity(0, 0, 0);]])],[wine_cv_have_sched_setaffinity=yes],[wine_cv_have_sched_setaffinity=no]))
@@ -2476,6 +2486,7 @@ WINE_CONFIG_MAKEFILE(dlls/crypt32/tests)
 WINE_CONFIG_MAKEFILE(dlls/cryptdlg)
 WINE_CONFIG_MAKEFILE(dlls/cryptdll)
 WINE_CONFIG_MAKEFILE(dlls/cryptext)
+WINE_CONFIG_MAKEFILE(dlls/cryptext/tests)
 WINE_CONFIG_MAKEFILE(dlls/cryptnet)
 WINE_CONFIG_MAKEFILE(dlls/cryptnet/tests)
 WINE_CONFIG_MAKEFILE(dlls/cryptowinrt)
@@ -2654,6 +2665,8 @@ WINE_CONFIG_MAKEFILE(dlls/dxdiagn)
 WINE_CONFIG_MAKEFILE(dlls/dxdiagn/tests)
 WINE_CONFIG_MAKEFILE(dlls/dxgi)
 WINE_CONFIG_MAKEFILE(dlls/dxgi/tests)
+WINE_CONFIG_MAKEFILE(dlls/dxgkrnl.sys)
+WINE_CONFIG_MAKEFILE(dlls/dxgmms1.sys)
 WINE_CONFIG_MAKEFILE(dlls/dxtrans)
 WINE_CONFIG_MAKEFILE(dlls/dxva2)
 WINE_CONFIG_MAKEFILE(dlls/dxva2/tests)
@@ -2954,6 +2967,7 @@ WINE_CONFIG_MAKEFILE(dlls/ntprint)
 WINE_CONFIG_MAKEFILE(dlls/ntprint/tests)
 WINE_CONFIG_MAKEFILE(dlls/objsel)
 WINE_CONFIG_MAKEFILE(dlls/odbc32)
+WINE_CONFIG_MAKEFILE(dlls/odbc32/tests)
 WINE_CONFIG_MAKEFILE(dlls/odbcbcp)
 WINE_CONFIG_MAKEFILE(dlls/odbccp32)
 WINE_CONFIG_MAKEFILE(dlls/odbccp32/tests)
@@ -3191,6 +3205,7 @@ WINE_CONFIG_MAKEFILE(dlls/wevtsvc)
 WINE_CONFIG_MAKEFILE(dlls/wiaservc)
 WINE_CONFIG_MAKEFILE(dlls/wiaservc/tests)
 WINE_CONFIG_MAKEFILE(dlls/wimgapi)
+WINE_CONFIG_MAKEFILE(dlls/win32k.sys)
 WINE_CONFIG_MAKEFILE(dlls/win32s16.dll16,enable_win16)
 WINE_CONFIG_MAKEFILE(dlls/win32u)
 WINE_CONFIG_MAKEFILE(dlls/win32u/tests)
@@ -3219,6 +3234,7 @@ WINE_CONFIG_MAKEFILE(dlls/windows.media.speech)
 WINE_CONFIG_MAKEFILE(dlls/windows.media.speech/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.media)
 WINE_CONFIG_MAKEFILE(dlls/windows.media/tests)
+WINE_CONFIG_MAKEFILE(dlls/windows.networking.connectivity)
 WINE_CONFIG_MAKEFILE(dlls/windows.networking.hostname)
 WINE_CONFIG_MAKEFILE(dlls/windows.networking.hostname/tests)
 WINE_CONFIG_MAKEFILE(dlls/windows.networking)
@@ -3690,7 +3706,7 @@ dnl Rules for generated source files
 
 WINE_APPEND_RULE(
 [dlls/ntdll/unix/version.c: dummy
-	@version=\`(GIT_DIR=${wine_srcdir}.git git describe HEAD 2>/dev/null || echo \"wine-\$(PACKAGE_VERSION)\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[[]] = \"\\1\";/p'\` && (echo \$\$version | cmp -s - \$[@]) || echo \$\$version >\$[@] || (rm -f \$[@] && exit 1)
+	@version=\`(GIT_DIR=${wine_srcdir}.git git describe HEAD 2>/dev/null || echo \"wine-\$(PACKAGE_VERSION)\") | sed -n -e '\$\$s/\(.*\)/const char wine_build[[]] = \"\\1 (Staging)\";/p'\` && (echo \$\$version | cmp -s - \$[@]) || echo \$\$version >\$[@] || (rm -f \$[@] && exit 1)
 programs/winetest/build.rc: dummy
 	@build=\"STRINGTABLE { 1 \\\"\`GIT_DIR=${wine_srcdir}.git git rev-parse HEAD 2>/dev/null\`\\\" }\" && (echo \$\$build | cmp -s - \$[@]) || echo \$\$build >\$[@] || (rm -f \$[@] && exit 1)
 programs/winetest/build.nfo:
diff --git a/dlls/advapi32/lsa.c b/dlls/advapi32/lsa.c
index 8c349a4..0bb99f5 100644
--- a/dlls/advapi32/lsa.c
+++ b/dlls/advapi32/lsa.c
@@ -766,7 +766,7 @@ NTSTATUS WINAPI LsaOpenPolicy(
           ObjectAttributes, DesiredAccess, PolicyHandle);
 
     ADVAPI_ForceLocalComputer(SystemName ? SystemName->Buffer : NULL,
-                              STATUS_ACCESS_VIOLATION);
+                              RPC_NT_SERVER_UNAVAILABLE);
     dumpLsaAttributes(ObjectAttributes);
 
     if(PolicyHandle) *PolicyHandle = (LSA_HANDLE)0xcafe;
diff --git a/dlls/advapi32/tests/lsa.c b/dlls/advapi32/tests/lsa.c
index e68de38..32d0b99 100644
--- a/dlls/advapi32/tests/lsa.c
+++ b/dlls/advapi32/tests/lsa.c
@@ -43,6 +43,8 @@ static NTSTATUS (WINAPI *pLsaGetUserName)(PUNICODE_STRING *user, PUNICODE_STRING
 
 static void test_lsa(void)
 {
+    static WCHAR machineW[] = {'W','i','n','e','N','o','M','a','c','h','i','n','e',0};
+    LSA_UNICODE_STRING machine;
     NTSTATUS status;
     LSA_HANDLE handle;
     LSA_OBJECT_ATTRIBUTES object_attributes;
@@ -50,6 +52,14 @@ static void test_lsa(void)
     ZeroMemory(&object_attributes, sizeof(object_attributes));
     object_attributes.Length = sizeof(object_attributes);
 
+    machine.Buffer = machineW;
+    machine.Length = sizeof(machineW) - 2;
+    machine.MaximumLength = sizeof(machineW);
+
+    status = LsaOpenPolicy( &machine, &object_attributes, POLICY_LOOKUP_NAMES, &handle);
+    ok(status == RPC_NT_SERVER_UNAVAILABLE,
+       "LsaOpenPolicy(POLICY_LOOKUP_NAMES) for invalid machine returned 0x%08lx\n", status);
+
     status = LsaOpenPolicy( NULL, &object_attributes, POLICY_ALL_ACCESS, &handle);
     ok(status == STATUS_SUCCESS || status == STATUS_ACCESS_DENIED,
        "LsaOpenPolicy(POLICY_ALL_ACCESS) returned 0x%08lx\n", status);
diff --git a/dlls/advapi32/tests/registry.c b/dlls/advapi32/tests/registry.c
index c2b73a8..3888718 100644
--- a/dlls/advapi32/tests/registry.c
+++ b/dlls/advapi32/tests/registry.c
@@ -1321,6 +1321,13 @@ static void test_reg_create_key(void)
     RegDeleteKeyA(hkey1, "");
     RegCloseKey(hkey1);
 
+    /* System\CurrentControlSet\Control\Video should be non-volatile */
+    ret = RegCreateKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\Video\\Wine",
+                          0, NULL, 0, KEY_NOTIFY, NULL, &hkey1, NULL);
+    ok(ret == ERROR_SUCCESS, "RegCreateKeyExA failed with error %lx\n", ret);
+    RegDeleteKeyA(hkey1, "");
+    RegCloseKey(hkey1);
+
     /* WOW64 flags - open an existing key */
     hkey1 = NULL;
     ret = RegCreateKeyExA(HKEY_LOCAL_MACHINE, "Software", 0, NULL, 0, KEY_READ|KEY_WOW64_32KEY, NULL, &hkey1, NULL);
diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
index 2840f6b..50e166f 100644
--- a/dlls/advapi32/tests/security.c
+++ b/dlls/advapi32/tests/security.c
@@ -3728,7 +3728,7 @@ static void test_CreateDirectoryA(void)
     }
     ok(!error, "GetNamedSecurityInfo failed with error %ld\n", error);
     test_inherited_dacl(pDacl, admin_sid, user_sid, OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE,
-                        0x1f01ff, FALSE, TRUE, FALSE, __LINE__);
+                        0x1f01ff, FALSE, FALSE, FALSE, __LINE__);
     LocalFree(pSD);
 
     /* Test inheritance of ACLs in CreateFile without security descriptor */
@@ -3774,7 +3774,6 @@ static void test_CreateDirectoryA(void)
     ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %ld\n", error);
     bret = GetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
     ok(bret, "GetAclInformation failed\n");
-    todo_wine
     ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%ld != 0).\n",
                                acl_size.AceCount);
     LocalFree(pSD);
@@ -3782,17 +3781,12 @@ static void test_CreateDirectoryA(void)
     error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
                                    OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                    (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
-    todo_wine
     ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %ld\n", error);
-    if (error == ERROR_SUCCESS)
-    {
-        bret = GetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
-        ok(bret, "GetAclInformation failed\n");
-        todo_wine
-        ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%ld != 0).\n",
-                                   acl_size.AceCount);
-        LocalFree(pSD);
-    }
+    bret = GetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%ld != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
     CloseHandle(hTemp);
 
     /* Test inheritance of ACLs in NtCreateFile without security descriptor */
@@ -3861,17 +3855,158 @@ static void test_CreateDirectoryA(void)
     error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
                                    OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                    (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %ld\n", error);
+    bret = GetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
     todo_wine
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%ld != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
+    CloseHandle(hTemp);
+
+    /* Test inheritance of ACLs in CreateDirectory without security descriptor */
+    strcpy(tmpfile, tmpdir);
+    lstrcatA(tmpfile, "/tmpdir");
+    bret = CreateDirectoryA(tmpfile, NULL);
+    ok(bret == TRUE, "CreateDirectoryA failed with error %lx\n", GetLastError());
+
+    error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
+                                   OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                                   (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "Failed to get permissions on file\n");
+    test_inherited_dacl(pDacl, admin_sid, user_sid,
+                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERITED_ACE,
+                        0x1f01ff, TRUE, TRUE, TRUE, __LINE__);
+    LocalFree(pSD);
+    bret = RemoveDirectoryA(tmpfile);
+    ok(bret == TRUE, "RemoveDirectoryA failed with error %lx\n", GetLastError());
+
+    /* Test inheritance of ACLs in CreateDirectory with security descriptor */
+    pSD = &sd;
+    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
+    pDacl = HeapAlloc(GetProcessHeap(), 0, sizeof(ACL));
+    bret = InitializeAcl(pDacl, sizeof(ACL), ACL_REVISION);
+    ok(bret, "Failed to initialize ACL\n");
+    bret = SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE);
+    ok(bret, "Failed to add ACL to security desciptor\n");
+
+    strcpy(tmpfile, tmpdir);
+    lstrcatA(tmpfile, "/tmpdir1");
+
+    sa.nLength = sizeof(sa);
+    sa.lpSecurityDescriptor = pSD;
+    sa.bInheritHandle = TRUE;
+    bret = CreateDirectoryA(tmpfile, &sa);
+    ok(bret == TRUE, "CreateDirectoryA failed with error %lx\n", GetLastError());
+    HeapFree(GetProcessHeap(), 0, pDacl);
+
+    error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
+                                   OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                                   (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
+    bret = GetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%ld != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
+
+    SetLastError(0xdeadbeef);
+    bret = RemoveDirectoryA(tmpfile);
+    error = GetLastError();
+    ok(bret == FALSE, "RemoveDirectoryA unexpected succeeded\n");
+    ok(error == ERROR_ACCESS_DENIED, "expected ERROR_ACCESS_DENIED, got %ld\n", error);
+
+    pSD = &sd;
+    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
+    pDacl = HeapAlloc(GetProcessHeap(), 0, 100);
+    bret = InitializeAcl(pDacl, 100, ACL_REVISION);
+    ok(bret, "Failed to initialize ACL.\n");
+    bret = pAddAccessAllowedAceEx(pDacl, ACL_REVISION, 0, GENERIC_ALL, user_sid);
+    ok(bret, "Failed to add Current User to ACL.\n");
+    bret = SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE);
+    ok(bret, "Failed to add ACL to security desciptor.\n");
+    error = pSetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL,
+                                   NULL, pDacl, NULL);
+    ok(error == ERROR_SUCCESS, "SetNamedSecurityInfoA failed with error %ld\n", error);
+    HeapFree(GetProcessHeap(), 0, pDacl);
+
+    bret = RemoveDirectoryA(tmpfile);
+    ok(bret == TRUE, "RemoveDirectoryA failed with error %lx\n", GetLastError());
+
+    /* Test inheritance of ACLs in NtCreateFile(..., FILE_DIRECTORY_FILE, ...) without security descriptor */
+    strcpy(tmpfile, tmpdir);
+    lstrcatA(tmpfile, "/tmpdir");
+    get_nt_pathW(tmpfile, &tmpfileW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.ObjectName = &tmpfileW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    status = pNtCreateFile(&hTemp, GENERIC_READ | DELETE, &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
+                           FILE_SHARE_READ, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE, NULL, 0);
+    ok(!status, "NtCreateFile failed with %08lx\n", status);
+    RtlFreeUnicodeString(&tmpfileW);
+
+    error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
+                                   OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                                   (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "Failed to get permissions on file\n");
+    test_inherited_dacl(pDacl, admin_sid, user_sid,
+                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERITED_ACE,
+                        0x1f01ff, TRUE, TRUE, TRUE, __LINE__);
+    LocalFree(pSD);
+    CloseHandle(hTemp);
+
+    /* Test inheritance of ACLs in NtCreateFile(..., FILE_DIRECTORY_FILE, ...) with security descriptor */
+    pSD = &sd;
+    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
+    pDacl = HeapAlloc(GetProcessHeap(), 0, sizeof(ACL));
+    bret = InitializeAcl(pDacl, sizeof(ACL), ACL_REVISION);
+    ok(bret, "Failed to initialize ACL\n");
+    bret = SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE);
+    ok(bret, "Failed to add ACL to security desciptor\n");
+
+    strcpy(tmpfile, tmpdir);
+    lstrcatA(tmpfile, "/tmpdir2");
+    get_nt_pathW(tmpfile, &tmpfileW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.ObjectName = &tmpfileW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = pSD;
+    attr.SecurityQualityOfService = NULL;
+
+    status = pNtCreateFile(&hTemp, GENERIC_READ | DELETE, &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
+                           FILE_SHARE_READ, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE, NULL, 0);
+    ok(!status, "NtCreateFile failed with %08lx\n", status);
+    RtlFreeUnicodeString(&tmpfileW);
+    HeapFree(GetProcessHeap(), 0, pDacl);
+
+    error = GetSecurityInfo(hTemp, SE_FILE_OBJECT,
+                             OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                             (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
+    bret = GetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
+    todo_wine
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%ld != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
+
+    error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
+                                   OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                                   (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
     ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %ld\n", error);
-    if (error == ERROR_SUCCESS)
-    {
-        bret = GetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
-        ok(bret, "GetAclInformation failed\n");
-        todo_wine
-        ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%ld != 0).\n",
-                                   acl_size.AceCount);
-        LocalFree(pSD);
-    }
+    bret = GetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
+    todo_wine
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%ld != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
     CloseHandle(hTemp);
 
 done:
@@ -4047,21 +4182,20 @@ static void test_GetNamedSecurityInfoA(void)
         bret = GetAce(pDacl, 0, (VOID **)&ace);
         ok(bret, "Failed to get Current User ACE.\n");
         bret = EqualSid(&ace->SidStart, user_sid);
-        todo_wine ok(bret, "Current User ACE (%s) != Current User SID (%s).\n",
-                     debugstr_sid(&ace->SidStart), debugstr_sid(user_sid));
+        ok(bret, "Current User ACE (%s) != Current User SID (%s).\n",
+           debugstr_sid(&ace->SidStart), debugstr_sid(user_sid));
         ok(((ACE_HEADER *)ace)->AceFlags == 0,
            "Current User ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
-        ok(ace->Mask == 0x1f01ff, "Current User ACE has unexpected mask (0x%lx != 0x1f01ff)\n",
-                                  ace->Mask);
+        ok(ace->Mask == 0x1f01ff,
+           "Current User ACE has unexpected mask (0x%lx != 0x1f01ff)\n", ace->Mask);
     }
     if (acl_size.AceCount > 1)
     {
         bret = GetAce(pDacl, 1, (VOID **)&ace);
         ok(bret, "Failed to get Administators Group ACE.\n");
         bret = EqualSid(&ace->SidStart, admin_sid);
-        todo_wine ok(bret || broken(!bret) /* win2k */,
-                     "Administators Group ACE (%s) != Administators Group SID (%s).\n",
-                     debugstr_sid(&ace->SidStart), debugstr_sid(admin_sid));
+        ok(bret || broken(!bret) /* win2k */, "Administators Group ACE (%s) != Administators Group SID (%s).\n",
+           debugstr_sid(&ace->SidStart), debugstr_sid(admin_sid));
         ok(((ACE_HEADER *)ace)->AceFlags == 0,
            "Administators Group ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
         ok(ace->Mask == 0x1f01ff || broken(ace->Mask == GENERIC_ALL) /* win2k */,
@@ -4088,8 +4222,8 @@ static void test_GetNamedSecurityInfoA(void)
     {
         bret = GetAce(pDacl, 0, (VOID **)&ace);
         ok(bret, "Failed to get ACE.\n");
-        todo_wine ok(((ACE_HEADER *)ace)->AceFlags & INHERITED_ACE,
-                "ACE has unexpected flags: 0x%x\n", ((ACE_HEADER *)ace)->AceFlags);
+        ok(((ACE_HEADER *)ace)->AceFlags & INHERITED_ACE,
+           "ACE has unexpected flags: 0x%x\n", ((ACE_HEADER *)ace)->AceFlags);
     }
     LocalFree(pSD);
 
@@ -4905,23 +5039,22 @@ static void test_GetSecurityInfo(void)
         bret = GetAce(pDacl, 0, (VOID **)&ace);
         ok(bret, "Failed to get Current User ACE.\n");
         bret = EqualSid(&ace->SidStart, user_sid);
-        todo_wine ok(bret, "Current User ACE (%s) != Current User SID (%s).\n",
-                     debugstr_sid(&ace->SidStart), debugstr_sid(user_sid));
+        ok(bret, "Current User ACE (%s) != Current User SID (%s).\n", debugstr_sid(&ace->SidStart), debugstr_sid(user_sid));
         ok(((ACE_HEADER *)ace)->AceFlags == 0,
            "Current User ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
         ok(ace->Mask == 0x1f01ff, "Current User ACE has unexpected mask (0x%lx != 0x1f01ff)\n",
-                                    ace->Mask);
+                                  ace->Mask);
     }
     if (acl_size.AceCount > 1)
     {
         bret = GetAce(pDacl, 1, (VOID **)&ace);
         ok(bret, "Failed to get Administators Group ACE.\n");
         bret = EqualSid(&ace->SidStart, admin_sid);
-        todo_wine ok(bret, "Administators Group ACE (%s) != Administators Group SID (%s).\n", debugstr_sid(&ace->SidStart), debugstr_sid(admin_sid));
+        ok(bret, "Administators Group ACE (%s) != Administators Group SID (%s).\n", debugstr_sid(&ace->SidStart), debugstr_sid(admin_sid));
         ok(((ACE_HEADER *)ace)->AceFlags == 0,
            "Administators Group ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
-        ok(ace->Mask == 0x1f01ff, "Administators Group ACE has unexpected mask (0x%lx != 0x1f01ff)\n",
-                                  ace->Mask);
+        ok(ace->Mask == 0x1f01ff,
+                     "Administators Group ACE has unexpected mask (0x%lx != 0x1f01ff)\n", ace->Mask);
     }
     LocalFree(pSD);
     CloseHandle(obj);
diff --git a/dlls/bcrypt/gnutls.c b/dlls/bcrypt/gnutls.c
index ec1f0fb..9f679b2 100644
--- a/dlls/bcrypt/gnutls.c
+++ b/dlls/bcrypt/gnutls.c
@@ -24,9 +24,10 @@
 
 #include "config.h"
 
+#include <stdarg.h>
+
 #ifdef HAVE_GNUTLS_CIPHER_INIT
 
-#include <stdarg.h>
 #include <stdlib.h>
 #include <assert.h>
 #include <sys/types.h>
diff --git a/dlls/comctl32/comctl32.h b/dlls/comctl32/comctl32.h
index 51f4337..3fe8905 100644
--- a/dlls/comctl32/comctl32.h
+++ b/dlls/comctl32/comctl32.h
@@ -194,7 +194,7 @@ BOOL Str_SetPtrAtoW(LPWSTR *lppDest, LPCSTR lpSrc);
 BOOL Str_SetPtrWtoA(LPSTR *lppDest, LPCWSTR lpSrc);
 BOOL imagelist_has_alpha(HIMAGELIST, UINT);
 
-#define COMCTL32_VERSION_MINOR 81
+#define COMCTL32_VERSION_MINOR 0
 
 /* Our internal stack structure of the window procedures to subclass */
 typedef struct _SUBCLASSPROCS {
diff --git a/dlls/comctl32/comctl32.rc b/dlls/comctl32/comctl32.rc
index c9aa1ba..be6e242 100644
--- a/dlls/comctl32/comctl32.rc
+++ b/dlls/comctl32/comctl32.rc
@@ -114,7 +114,7 @@ LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
 #define WINE_FILEDESCRIPTION_STR "Wine Common Controls"
 #define WINE_FILENAME_STR "comctl32.dll"
 #define WINE_FILEVERSION COMCTL32_VERSION, COMCTL32_VERSION_MINOR, 4704, 1100
-#define WINE_FILEVERSION_STR "5.81"
+#define WINE_FILEVERSION_STR "6.00.4704.1100"
 #define WINE_PRODUCTVERSION WINE_FILEVERSION
 #define WINE_PRODUCTVERSION_STR WINE_FILEVERSION_STR
 
diff --git a/dlls/comctl32/rebar.c b/dlls/comctl32/rebar.c
index 61fd30c..5d7f353 100644
--- a/dlls/comctl32/rebar.c
+++ b/dlls/comctl32/rebar.c
@@ -3111,7 +3111,15 @@ REBAR_MouseMove (REBAR_INFO *infoPtr, LPARAM lParam)
         int yPtMove = (infoPtr->dwStyle & CCS_VERT ? ptMove.x : ptMove.y);
 
         if (GetCapture() != infoPtr->hwndSelf)
-            ERR("We are dragging but haven't got capture?!?\n");
+        {
+            if (infoPtr->fStatus & BEGIN_DRAG_ISSUED)
+            {
+                REBAR_Notify_NMREBAR (infoPtr, infoPtr->iGrabbedBand, RBN_ENDDRAG);
+                infoPtr->fStatus &= ~BEGIN_DRAG_ISSUED;
+            }
+            infoPtr->iGrabbedBand = -1;
+            return 0;
+        }
 
         band = REBAR_GetBand(infoPtr, infoPtr->iGrabbedBand);
 
diff --git a/dlls/comdlg32/filedlg.c b/dlls/comdlg32/filedlg.c
index 441f203..6d593b0 100644
--- a/dlls/comdlg32/filedlg.c
+++ b/dlls/comdlg32/filedlg.c
@@ -559,6 +559,23 @@ static BOOL GetFileDialog95(FileOpenDlgInfos *info, UINT dlg_type)
         ret = FALSE;
     }
 
+    /* set the lpstrFileTitle */
+    if (ret && info->ofnInfos->lpstrFile && info->ofnInfos->lpstrFileTitle)
+    {
+        if (info->unicode)
+        {
+            LPOPENFILENAMEW ofn = info->ofnInfos;
+            WCHAR *file_title = PathFindFileNameW(ofn->lpstrFile);
+            lstrcpynW(ofn->lpstrFileTitle, file_title, ofn->nMaxFileTitle);
+        }
+        else
+        {
+            LPOPENFILENAMEA ofn = (LPOPENFILENAMEA)info->ofnInfos;
+            char *file_title = PathFindFileNameA(ofn->lpstrFile);
+            lstrcpynA(ofn->lpstrFileTitle, file_title, ofn->nMaxFileTitle);
+        }
+    }
+
     if (current_dir)
     {
         SetCurrentDirectoryW(current_dir);
@@ -2869,23 +2886,6 @@ BOOL FILEDLG95_OnOpen(HWND hwnd)
               fodInfos->ofnInfos->nFileExtension = (*lpszTemp) ? (lpszTemp - tempFileA) + 1 : 0;
           }
 
-          /* set the lpstrFileTitle */
-          if(fodInfos->ofnInfos->lpstrFileTitle)
-	  {
-            LPWSTR lpstrFileTitle = PathFindFileNameW(lpstrPathAndFile);
-            if(fodInfos->unicode)
-            {
-              LPOPENFILENAMEW ofn = fodInfos->ofnInfos;
-	      lstrcpynW(ofn->lpstrFileTitle, lpstrFileTitle, ofn->nMaxFileTitle);
-            }
-            else
-            {
-              LPOPENFILENAMEA ofn = (LPOPENFILENAMEA)fodInfos->ofnInfos;
-              WideCharToMultiByte(CP_ACP, 0, lpstrFileTitle, -1,
-                    ofn->lpstrFileTitle, ofn->nMaxFileTitle, NULL, NULL);
-            }
-	  }
-
           /* copy currently selected filter to lpstrCustomFilter */
           if (fodInfos->ofnInfos->lpstrCustomFilter)
           {
diff --git a/dlls/crypt32/decode.c b/dlls/crypt32/decode.c
index 6d68397..293f157 100644
--- a/dlls/crypt32/decode.c
+++ b/dlls/crypt32/decode.c
@@ -5848,6 +5848,9 @@ static BOOL CRYPT_AsnDecodeCMSSignerInfoInternal(const BYTE *pbEncoded,
        offsetof(CMSG_CMS_SIGNER_INFO, AuthAttrs),
        CRYPT_AsnDecodePKCSAttributesInternal, sizeof(CRYPT_ATTRIBUTES),
        TRUE, TRUE, offsetof(CMSG_CMS_SIGNER_INFO, AuthAttrs.rgAttr), 0 },
+     /* FIXME: Tests show that CertOpenStore accepts such certificates, but
+      * how exactly should they be interpreted? */
+     { ASN_CONSTRUCTOR | ASN_UNIVERSAL | 0x11, 0, NULL, 0, TRUE, FALSE, 0, 0 },
      { ASN_SEQUENCEOF, offsetof(CMSG_CMS_SIGNER_INFO, HashEncryptionAlgorithm),
        CRYPT_AsnDecodeAlgorithmId, sizeof(CRYPT_ALGORITHM_IDENTIFIER),
        FALSE, TRUE, offsetof(CMSG_CMS_SIGNER_INFO,
diff --git a/dlls/cryptext/Makefile.in b/dlls/cryptext/Makefile.in
index 5598bfb..acda4e4 100644
--- a/dlls/cryptext/Makefile.in
+++ b/dlls/cryptext/Makefile.in
@@ -1,4 +1,5 @@
-MODULE = cryptext.dll
+MODULE  = cryptext.dll
+IMPORTS = crypt32 cryptui user32
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
diff --git a/dlls/cryptext/cryptext.spec b/dlls/cryptext/cryptext.spec
index ee3e155..24b4794 100644
--- a/dlls/cryptext/cryptext.spec
+++ b/dlls/cryptext/cryptext.spec
@@ -12,8 +12,8 @@
 @ stub CryptExtAddSPCW
 @ stub CryptExtOpenCAT
 @ stub CryptExtOpenCATW
-@ stub CryptExtOpenCER
-@ stub CryptExtOpenCERW
+@ stdcall CryptExtOpenCER(long ptr str long)
+@ stdcall CryptExtOpenCERW(long ptr wstr long)
 @ stub CryptExtOpenCRL
 @ stub CryptExtOpenCRLW
 @ stub CryptExtOpenCTL
diff --git a/dlls/cryptext/cryptext_main.c b/dlls/cryptext/cryptext_main.c
index 537ba66..a431451 100644
--- a/dlls/cryptext/cryptext_main.c
+++ b/dlls/cryptext/cryptext_main.c
@@ -22,10 +22,29 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "winnls.h"
+#include "wincrypt.h"
+#include "winuser.h"
+#include "cryptuiapi.h"
+
+#include "wine/heap.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(cryptext);
 
+static WCHAR *heap_strdupAtoW(const char *str)
+{
+    WCHAR *ret;
+    INT len;
+
+    if (!str) return NULL;
+    len = MultiByteToWideChar(CP_ACP, 0, str, -1, NULL, 0);
+    ret = heap_alloc(len * sizeof(WCHAR));
+    if (ret)
+        MultiByteToWideChar(CP_ACP, 0, str, -1, ret, len);
+    return ret;
+}
+
 /***********************************************************************
  * CryptExtAddPFX (CRYPTEXT.@)
  */
@@ -43,3 +62,48 @@ HRESULT WINAPI CryptExtAddPFXW(LPCWSTR filename)
     FIXME("stub: %s\n", debugstr_w(filename));
     return E_NOTIMPL;
 }
+
+/***********************************************************************
+ * CryptExtOpenCERW (CRYPTEXT.@)
+ */
+HRESULT WINAPI CryptExtOpenCERW(HWND hwnd, HINSTANCE hinst, LPCWSTR filename, DWORD showcmd)
+{
+    PCCERT_CONTEXT ctx;
+    CRYPTUI_VIEWCERTIFICATE_STRUCTW info;
+
+    TRACE("(%p, %p, %s, %lu)\n", hwnd, hinst, debugstr_w(filename), showcmd);
+
+    if (!CryptQueryObject(CERT_QUERY_OBJECT_FILE, filename, CERT_QUERY_CONTENT_FLAG_CERT,
+                          CERT_QUERY_FORMAT_FLAG_ALL, 0, NULL, NULL, NULL, NULL, NULL,
+                          (const void **)&ctx))
+    {
+        /* FIXME: move to the resources */
+        static const WCHAR msg[] = {'T','h','i','s',' ','i','s',' ','n','o','t',' ','a',' ','v','a','l','i','d',' ','c','e','r','t','i','f','i','c','a','t','e',0};
+        MessageBoxW(NULL, msg, filename, MB_OK | MB_ICONERROR);
+        return S_OK; /* according to the tests */
+    }
+
+    memset(&info, 0, sizeof(info));
+    info.dwSize = sizeof(info);
+    info.pCertContext = ctx;
+    CryptUIDlgViewCertificateW(&info, NULL);
+    CertFreeCertificateContext(ctx);
+
+    return S_OK;
+}
+
+/***********************************************************************
+ * CryptExtOpenCER (CRYPTEXT.@)
+ */
+HRESULT WINAPI CryptExtOpenCER(HWND hwnd, HINSTANCE hinst, LPCSTR filename, DWORD showcmd)
+{
+    HRESULT hr;
+    LPWSTR filenameW;
+
+    TRACE("(%p, %p, %s, %lu)\n", hwnd, hinst, debugstr_a(filename), showcmd);
+
+    filenameW = heap_strdupAtoW(filename);
+    hr = CryptExtOpenCERW(hwnd, hinst, filenameW, showcmd);
+    heap_free(filenameW);
+    return hr;
+}
diff --git a/dlls/d2d1/bitmap.c b/dlls/d2d1/bitmap.c
index e504861..8e03129 100644
--- a/dlls/d2d1/bitmap.c
+++ b/dlls/d2d1/bitmap.c
@@ -771,5 +771,5 @@ struct d2d_bitmap *unsafe_impl_from_ID2D1Bitmap(ID2D1Bitmap *iface)
     if (!iface)
         return NULL;
     assert(iface->lpVtbl == (ID2D1BitmapVtbl *)&d2d_bitmap_vtbl);
-    return CONTAINING_RECORD(iface, struct d2d_bitmap, ID2D1Bitmap1_iface);
+    return CONTAINING_RECORD((ID2D1Bitmap1*)iface, struct d2d_bitmap, ID2D1Bitmap1_iface);
 }
diff --git a/dlls/d2d1/brush.c b/dlls/d2d1/brush.c
index 75cd72b..3141233 100644
--- a/dlls/d2d1/brush.c
+++ b/dlls/d2d1/brush.c
@@ -259,7 +259,7 @@ static void d2d_brush_init(struct d2d_brush *brush, ID2D1Factory *factory,
 
 static inline struct d2d_brush *impl_from_ID2D1SolidColorBrush(ID2D1SolidColorBrush *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_brush, ID2D1Brush_iface);
+    return CONTAINING_RECORD((ID2D1Brush *)iface, struct d2d_brush, ID2D1Brush_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_solid_color_brush_QueryInterface(ID2D1SolidColorBrush *iface,
@@ -402,7 +402,7 @@ HRESULT d2d_solid_color_brush_create(ID2D1Factory *factory, const D2D1_COLOR_F *
 
 static inline struct d2d_brush *impl_from_ID2D1LinearGradientBrush(ID2D1LinearGradientBrush *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_brush, ID2D1Brush_iface);
+    return CONTAINING_RECORD((ID2D1Brush *)iface, struct d2d_brush, ID2D1Brush_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_linear_gradient_brush_QueryInterface(ID2D1LinearGradientBrush *iface,
@@ -589,7 +589,7 @@ HRESULT d2d_linear_gradient_brush_create(ID2D1Factory *factory,
 
 static inline struct d2d_brush *impl_from_ID2D1RadialGradientBrush(ID2D1RadialGradientBrush *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_brush, ID2D1Brush_iface);
+    return CONTAINING_RECORD((ID2D1Brush *)iface, struct d2d_brush, ID2D1Brush_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_radial_gradient_brush_QueryInterface(ID2D1RadialGradientBrush *iface,
@@ -821,7 +821,7 @@ HRESULT d2d_radial_gradient_brush_create(ID2D1Factory *factory,
 
 static inline struct d2d_brush *impl_from_ID2D1BitmapBrush1(ID2D1BitmapBrush1 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_brush, ID2D1Brush_iface);
+    return CONTAINING_RECORD((ID2D1Brush *)iface, struct d2d_brush, ID2D1Brush_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_bitmap_brush_QueryInterface(ID2D1BitmapBrush1 *iface,
diff --git a/dlls/d2d1/dc_render_target.c b/dlls/d2d1/dc_render_target.c
index aa0c715..31389b1 100644
--- a/dlls/d2d1/dc_render_target.c
+++ b/dlls/d2d1/dc_render_target.c
@@ -23,7 +23,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(d2d);
 
 static inline struct d2d_dc_render_target *impl_from_IUnknown(IUnknown *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_dc_render_target, ID2D1DCRenderTarget_iface);
+    return CONTAINING_RECORD((ID2D1DCRenderTarget*)iface, struct d2d_dc_render_target, ID2D1DCRenderTarget_iface);
 }
 
 static HRESULT d2d_dc_render_target_present(IUnknown *outer_unknown)
diff --git a/dlls/d2d1/geometry.c b/dlls/d2d1/geometry.c
index 3da3ad2..849a2cd 100644
--- a/dlls/d2d1/geometry.c
+++ b/dlls/d2d1/geometry.c
@@ -3373,7 +3373,7 @@ static const struct ID2D1GeometrySinkVtbl d2d_geometry_sink_vtbl =
 
 static inline struct d2d_geometry *impl_from_ID2D1PathGeometry1(ID2D1PathGeometry1 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_geometry, ID2D1Geometry_iface);
+    return CONTAINING_RECORD((ID2D1Geometry *)iface, struct d2d_geometry, ID2D1Geometry_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_path_geometry_QueryInterface(ID2D1PathGeometry1 *iface, REFIID iid, void **out)
@@ -3974,7 +3974,7 @@ void d2d_path_geometry_init(struct d2d_geometry *geometry, ID2D1Factory *factory
 
 static inline struct d2d_geometry *impl_from_ID2D1EllipseGeometry(ID2D1EllipseGeometry *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_geometry, ID2D1Geometry_iface);
+    return CONTAINING_RECORD((ID2D1Geometry*)iface, struct d2d_geometry, ID2D1Geometry_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_ellipse_geometry_QueryInterface(ID2D1EllipseGeometry *iface,
@@ -4246,7 +4246,7 @@ fail:
 
 static inline struct d2d_geometry *impl_from_ID2D1RectangleGeometry(ID2D1RectangleGeometry *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_geometry, ID2D1Geometry_iface);
+    return CONTAINING_RECORD((ID2D1Geometry *)iface, struct d2d_geometry, ID2D1Geometry_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_rectangle_geometry_QueryInterface(ID2D1RectangleGeometry *iface,
@@ -4662,7 +4662,7 @@ fail:
 
 static inline struct d2d_geometry *impl_from_ID2D1RoundedRectangleGeometry(ID2D1RoundedRectangleGeometry *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_geometry, ID2D1Geometry_iface);
+    return CONTAINING_RECORD((ID2D1Geometry*)iface, struct d2d_geometry, ID2D1Geometry_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_rounded_rectangle_geometry_QueryInterface(ID2D1RoundedRectangleGeometry *iface,
@@ -4958,7 +4958,7 @@ fail:
 
 static inline struct d2d_geometry *impl_from_ID2D1TransformedGeometry(ID2D1TransformedGeometry *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_geometry, ID2D1Geometry_iface);
+    return CONTAINING_RECORD((ID2D1Geometry *)iface, struct d2d_geometry, ID2D1Geometry_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_transformed_geometry_QueryInterface(ID2D1TransformedGeometry *iface,
@@ -5242,7 +5242,7 @@ void d2d_transformed_geometry_init(struct d2d_geometry *geometry, ID2D1Factory *
 
 static inline struct d2d_geometry *impl_from_ID2D1GeometryGroup(ID2D1GeometryGroup *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_geometry, ID2D1Geometry_iface);
+    return CONTAINING_RECORD( (ID2D1Geometry*)iface, struct d2d_geometry, ID2D1Geometry_iface);
 }
 
 static HRESULT STDMETHODCALLTYPE d2d_geometry_group_QueryInterface(ID2D1GeometryGroup *iface,
diff --git a/dlls/d2d1/hwnd_render_target.c b/dlls/d2d1/hwnd_render_target.c
index 7f16ff0..e19228b 100644
--- a/dlls/d2d1/hwnd_render_target.c
+++ b/dlls/d2d1/hwnd_render_target.c
@@ -23,7 +23,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(d2d);
 
 static inline struct d2d_hwnd_render_target *impl_from_IUnknown(IUnknown *iface)
 {
-    return CONTAINING_RECORD(iface, struct d2d_hwnd_render_target, ID2D1HwndRenderTarget_iface);
+    return CONTAINING_RECORD((ID2D1HwndRenderTarget*)iface, struct d2d_hwnd_render_target, ID2D1HwndRenderTarget_iface);
 }
 
 static HRESULT d2d_hwnd_render_target_present(IUnknown *outer_unknown)
diff --git a/dlls/d2d1/state_block.c b/dlls/d2d1/state_block.c
index 770c165..a3b4809 100644
--- a/dlls/d2d1/state_block.c
+++ b/dlls/d2d1/state_block.c
@@ -191,5 +191,5 @@ struct d2d_state_block *unsafe_impl_from_ID2D1DrawingStateBlock(ID2D1DrawingStat
         WARN("Unexpected state block vtbl %p.\n", iface->lpVtbl);
         return NULL;
     }
-    return CONTAINING_RECORD(iface, struct d2d_state_block, ID2D1DrawingStateBlock1_iface);
+    return CONTAINING_RECORD((ID2D1DrawingStateBlock1*)iface, struct d2d_state_block, ID2D1DrawingStateBlock1_iface);
 }
diff --git a/dlls/d3d10/effect.c b/dlls/d3d10/effect.c
index 534eadb..dacc24c 100644
--- a/dlls/d3d10/effect.c
+++ b/dlls/d3d10/effect.c
@@ -137,7 +137,7 @@ static inline struct d3d10_effect_variable *impl_from_ID3D10EffectVariable(ID3D1
 
 static inline struct d3d10_effect_variable *impl_from_ID3D10EffectShaderVariable(ID3D10EffectShaderVariable *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
+    return CONTAINING_RECORD((ID3D10EffectVariable*)iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
 }
 
 static struct d3d10_effect_variable * d3d10_array_get_element(struct d3d10_effect_variable *v,
@@ -6428,7 +6428,7 @@ static void read_variable_array_from_buffer(struct d3d10_effect_variable *variab
 
 static inline struct d3d10_effect_variable *impl_from_ID3D10EffectScalarVariable(ID3D10EffectScalarVariable *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
+    return CONTAINING_RECORD((ID3D10EffectVariable*)iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
 }
 
 static BOOL STDMETHODCALLTYPE d3d10_effect_scalar_variable_IsValid(ID3D10EffectScalarVariable *iface)
@@ -6766,7 +6766,7 @@ static const struct ID3D10EffectScalarVariableVtbl d3d10_effect_scalar_variable_
 
 static inline struct d3d10_effect_variable *impl_from_ID3D10EffectVectorVariable(ID3D10EffectVectorVariable *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
+    return CONTAINING_RECORD((ID3D10EffectVariable*)iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
 }
 
 static BOOL STDMETHODCALLTYPE d3d10_effect_vector_variable_IsValid(ID3D10EffectVectorVariable *iface)
@@ -7255,7 +7255,7 @@ static void read_matrix_variable_array_from_buffer(struct d3d10_effect_variable
 
 static inline struct d3d10_effect_variable *impl_from_ID3D10EffectMatrixVariable(ID3D10EffectMatrixVariable *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
+    return CONTAINING_RECORD((ID3D10EffectVariable*)iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
 }
 
 static BOOL STDMETHODCALLTYPE d3d10_effect_matrix_variable_IsValid(ID3D10EffectMatrixVariable *iface)
@@ -7782,7 +7782,7 @@ static void set_shader_resource_variable(ID3D10ShaderResourceView **src, ID3D10S
 static inline struct d3d10_effect_variable *impl_from_ID3D10EffectShaderResourceVariable(
         ID3D10EffectShaderResourceVariable *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
+    return CONTAINING_RECORD((ID3D10EffectVariable*)iface, struct d3d10_effect_variable, ID3D10EffectVariable_iface);
 }
 
 static BOOL STDMETHODCALLTYPE d3d10_effect_shader_resource_variable_IsValid(ID3D10EffectShaderResourceVariable *iface)
diff --git a/dlls/d3d11/view.c b/dlls/d3d11/view.c
index 228bed0..23df10c 100644
--- a/dlls/d3d11/view.c
+++ b/dlls/d3d11/view.c
@@ -2282,7 +2282,7 @@ struct d3d_shader_resource_view *unsafe_impl_from_ID3D10ShaderResourceView(ID3D1
     if (!iface)
         return NULL;
     assert(iface->lpVtbl == (ID3D10ShaderResourceViewVtbl *)&d3d10_shader_resource_view_vtbl);
-    return CONTAINING_RECORD(iface, struct d3d_shader_resource_view, ID3D10ShaderResourceView1_iface);
+    return CONTAINING_RECORD((ID3D10ShaderResourceView1 *)iface, struct d3d_shader_resource_view, ID3D10ShaderResourceView1_iface);
 }
 
 /* ID3D11UnorderedAccessView methods */
diff --git a/dlls/d3d8/texture.c b/dlls/d3d8/texture.c
index b1ad3c0..6ce4536 100644
--- a/dlls/d3d8/texture.c
+++ b/dlls/d3d8/texture.c
@@ -81,17 +81,17 @@ static void d3d8_texture_preload(struct d3d8_texture *texture)
 
 static inline struct d3d8_texture *impl_from_IDirect3DTexture8(IDirect3DTexture8 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d8_texture, IDirect3DBaseTexture8_iface);
+    return CONTAINING_RECORD((IDirect3DBaseTexture8 *)iface, struct d3d8_texture, IDirect3DBaseTexture8_iface);
 }
 
 static inline struct d3d8_texture *impl_from_IDirect3DCubeTexture8(IDirect3DCubeTexture8 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d8_texture, IDirect3DBaseTexture8_iface);
+    return CONTAINING_RECORD((IDirect3DBaseTexture8 *)iface, struct d3d8_texture, IDirect3DBaseTexture8_iface);
 }
 
 static inline struct d3d8_texture *impl_from_IDirect3DVolumeTexture8(IDirect3DVolumeTexture8 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d8_texture, IDirect3DBaseTexture8_iface);
+    return CONTAINING_RECORD((IDirect3DBaseTexture8 *)iface, struct d3d8_texture, IDirect3DBaseTexture8_iface);
 }
 
 static HRESULT WINAPI d3d8_texture_2d_QueryInterface(IDirect3DTexture8 *iface, REFIID riid, void **out)
diff --git a/dlls/d3d9/texture.c b/dlls/d3d9/texture.c
index 4de7d2e..9a4ab36 100644
--- a/dlls/d3d9/texture.c
+++ b/dlls/d3d9/texture.c
@@ -77,17 +77,17 @@ static void d3d9_texture_preload(struct d3d9_texture *texture)
 
 static inline struct d3d9_texture *impl_from_IDirect3DTexture9(IDirect3DTexture9 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d9_texture, IDirect3DBaseTexture9_iface);
+    return CONTAINING_RECORD((IDirect3DBaseTexture9 *)iface, struct d3d9_texture, IDirect3DBaseTexture9_iface);
 }
 
 static inline struct d3d9_texture *impl_from_IDirect3DCubeTexture9(IDirect3DCubeTexture9 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d9_texture, IDirect3DBaseTexture9_iface);
+    return CONTAINING_RECORD((IDirect3DBaseTexture9 *)iface, struct d3d9_texture, IDirect3DBaseTexture9_iface);
 }
 
 static inline struct d3d9_texture *impl_from_IDirect3DVolumeTexture9(IDirect3DVolumeTexture9 *iface)
 {
-    return CONTAINING_RECORD(iface, struct d3d9_texture, IDirect3DBaseTexture9_iface);
+    return CONTAINING_RECORD((IDirect3DBaseTexture9 *)iface, struct d3d9_texture, IDirect3DBaseTexture9_iface);
 }
 
 /* wined3d critical section must be taken by the caller. */
diff --git a/dlls/d3dx11_42/Makefile.in b/dlls/d3dx11_42/Makefile.in
index 985fc1c..bbf3bba 100644
--- a/dlls/d3dx11_42/Makefile.in
+++ b/dlls/d3dx11_42/Makefile.in
@@ -2,6 +2,7 @@ EXTRADEFS = -DD3DX11_SDK_VERSION=42
 MODULE    = d3dx11_42.dll
 IMPORTLIB = d3dx11_42
 IMPORTS = d3dcompiler
+DELAYIMPORTS = windowscodecs
 PARENTSRC = ../d3dx11_43
 
 EXTRADLLFLAGS = -Wb,--prefer-native
diff --git a/dlls/d3dx11_43/Makefile.in b/dlls/d3dx11_43/Makefile.in
index 762987a..71cabef 100644
--- a/dlls/d3dx11_43/Makefile.in
+++ b/dlls/d3dx11_43/Makefile.in
@@ -2,6 +2,7 @@ EXTRADEFS = -DD3DX11_SDK_VERSION=43
 MODULE = d3dx11_43.dll
 IMPORTLIB = d3dx11
 IMPORTS   = d3dcompiler
+DELAYIMPORTS = windowscodecs
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
diff --git a/dlls/d3dx11_43/main.c b/dlls/d3dx11_43/main.c
index 5dad027..00c1db3 100644
--- a/dlls/d3dx11_43/main.c
+++ b/dlls/d3dx11_43/main.c
@@ -66,12 +66,3 @@ HRESULT WINAPI D3DX11GetImageInfoFromFileW(const WCHAR *filename, ID3DX11ThreadP
 
     return E_NOTIMPL;
 }
-
-HRESULT WINAPI D3DX11GetImageInfoFromMemory(const void *src_data, SIZE_T src_data_size, ID3DX11ThreadPump *pump,
-        D3DX11_IMAGE_INFO *img_info, HRESULT *hresult)
-{
-    FIXME("src_data %p, src_data_size %Iu, pump %p, img_info %p, hresult %p stub!\n",
-            src_data, src_data_size, pump, img_info, hresult);
-
-    return E_NOTIMPL;
-}
diff --git a/dlls/d3dx11_43/texture.c b/dlls/d3dx11_43/texture.c
index fe7ab85..403ce1a 100644
--- a/dlls/d3dx11_43/texture.c
+++ b/dlls/d3dx11_43/texture.c
@@ -15,14 +15,390 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
+#define COBJMACROS
 
 #include "d3dx11.h"
 #include "d3dcompiler.h"
+#include "wincodec.h"
 
 #include "wine/debug.h"
+#include "wine/heap.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
+HRESULT WINAPI WICCreateImagingFactory_Proxy(UINT sdk_version, IWICImagingFactory **imaging_factory);
+
+static const struct
+{
+    const GUID *wic_container_guid;
+    D3DX11_IMAGE_FILE_FORMAT d3dx_file_format;
+}
+file_formats[] =
+{
+    { &GUID_ContainerFormatBmp,  D3DX11_IFF_BMP },
+    { &GUID_ContainerFormatJpeg, D3DX11_IFF_JPG },
+    { &GUID_ContainerFormatPng,  D3DX11_IFF_PNG },
+    { &GUID_ContainerFormatDds,  D3DX11_IFF_DDS },
+    { &GUID_ContainerFormatTiff, D3DX11_IFF_TIFF },
+    { &GUID_ContainerFormatGif,  D3DX11_IFF_GIF },
+    { &GUID_ContainerFormatWmp,  D3DX11_IFF_WMP },
+};
+
+static const struct
+{
+    const GUID *wic_guid;
+    DXGI_FORMAT dxgi_format;
+}
+wic_pixel_formats[] =
+{
+    { &GUID_WICPixelFormatBlackWhite,         DXGI_FORMAT_R1_UNORM },
+    { &GUID_WICPixelFormat8bppAlpha,          DXGI_FORMAT_A8_UNORM },
+    { &GUID_WICPixelFormat8bppGray,           DXGI_FORMAT_R8_UNORM },
+    { &GUID_WICPixelFormat16bppGray,          DXGI_FORMAT_R16_UNORM },
+    { &GUID_WICPixelFormat16bppGrayHalf,      DXGI_FORMAT_R16_FLOAT },
+    { &GUID_WICPixelFormat32bppGrayFloat,     DXGI_FORMAT_R32_FLOAT },
+    { &GUID_WICPixelFormat16bppBGR565,        DXGI_FORMAT_B5G6R5_UNORM },
+    { &GUID_WICPixelFormat16bppBGRA5551,      DXGI_FORMAT_B5G5R5A1_UNORM },
+    { &GUID_WICPixelFormat32bppBGR,           DXGI_FORMAT_B8G8R8X8_UNORM },
+    { &GUID_WICPixelFormat32bppBGRA,          DXGI_FORMAT_B8G8R8A8_UNORM },
+    { &GUID_WICPixelFormat32bppRGBA,          DXGI_FORMAT_R8G8B8A8_UNORM },
+    { &GUID_WICPixelFormat32bppRGBA,          DXGI_FORMAT_R8G8B8A8_UNORM_SRGB },
+    { &GUID_WICPixelFormat32bppRGBA1010102,   DXGI_FORMAT_R10G10B10A2_UNORM },
+    { &GUID_WICPixelFormat32bppRGBA1010102XR, DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM },
+    { &GUID_WICPixelFormat64bppRGBA,          DXGI_FORMAT_R16G16B16A16_UNORM },
+    { &GUID_WICPixelFormat64bppRGBAHalf,      DXGI_FORMAT_R16G16B16A16_FLOAT },
+    { &GUID_WICPixelFormat96bppRGBFloat,      DXGI_FORMAT_R32G32B32_FLOAT },
+    { &GUID_WICPixelFormat128bppRGBAFloat,    DXGI_FORMAT_R32G32B32A32_FLOAT }
+};
+
+static D3DX11_IMAGE_FILE_FORMAT wic_container_guid_to_file_format(GUID *container_format)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(file_formats); ++i)
+    {
+        if (IsEqualGUID(file_formats[i].wic_container_guid, container_format))
+            return file_formats[i].d3dx_file_format;
+    }
+    return D3DX11_IFF_FORCE_DWORD;
+}
+
+static D3D11_RESOURCE_DIMENSION wic_dimension_to_d3dx11_dimension(WICDdsDimension wic_dimension)
+{
+    switch (wic_dimension)
+    {
+        case WICDdsTexture1D:
+            return D3D11_RESOURCE_DIMENSION_TEXTURE1D;
+        case WICDdsTexture2D:
+        case WICDdsTextureCube:
+            return D3D11_RESOURCE_DIMENSION_TEXTURE2D;
+        case WICDdsTexture3D:
+            return D3D11_RESOURCE_DIMENSION_TEXTURE3D;
+        default:
+            return D3D11_RESOURCE_DIMENSION_UNKNOWN;
+    }
+}
+
+static const DXGI_FORMAT to_be_converted_format[] =
+{
+    DXGI_FORMAT_UNKNOWN,
+    DXGI_FORMAT_R8_UNORM,
+    DXGI_FORMAT_R8G8_UNORM,
+    DXGI_FORMAT_B5G6R5_UNORM,
+    DXGI_FORMAT_B4G4R4A4_UNORM,
+    DXGI_FORMAT_B5G5R5A1_UNORM,
+    DXGI_FORMAT_B8G8R8X8_UNORM,
+    DXGI_FORMAT_B8G8R8A8_UNORM
+};
+
+static DXGI_FORMAT get_d3dx11_dds_format(DXGI_FORMAT format)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(to_be_converted_format); ++i)
+    {
+        if (format == to_be_converted_format[i])
+            return DXGI_FORMAT_R8G8B8A8_UNORM;
+    }
+    return format;
+}
+
+static const DXGI_FORMAT block_compressed_formats[] =
+{
+    DXGI_FORMAT_BC1_TYPELESS,  DXGI_FORMAT_BC1_UNORM, DXGI_FORMAT_BC1_UNORM_SRGB,
+    DXGI_FORMAT_BC2_TYPELESS,  DXGI_FORMAT_BC2_UNORM, DXGI_FORMAT_BC2_UNORM_SRGB,
+    DXGI_FORMAT_BC3_TYPELESS,  DXGI_FORMAT_BC3_UNORM, DXGI_FORMAT_BC3_UNORM_SRGB,
+    DXGI_FORMAT_BC4_TYPELESS,  DXGI_FORMAT_BC4_UNORM, DXGI_FORMAT_BC4_SNORM,
+    DXGI_FORMAT_BC5_TYPELESS,  DXGI_FORMAT_BC5_UNORM, DXGI_FORMAT_BC5_SNORM,
+    DXGI_FORMAT_BC6H_TYPELESS, DXGI_FORMAT_BC6H_UF16, DXGI_FORMAT_BC6H_SF16,
+    DXGI_FORMAT_BC7_TYPELESS,  DXGI_FORMAT_BC7_UNORM, DXGI_FORMAT_BC7_UNORM_SRGB
+};
+
+static BOOL is_block_compressed(DXGI_FORMAT format)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(block_compressed_formats); ++i)
+        if (format == block_compressed_formats[i])
+            return TRUE;
+
+    return FALSE;
+}
+
+static unsigned int get_bpp_from_format(DXGI_FORMAT format)
+{
+    switch (format)
+    {
+        case DXGI_FORMAT_R32G32B32A32_TYPELESS:
+        case DXGI_FORMAT_R32G32B32A32_FLOAT:
+        case DXGI_FORMAT_R32G32B32A32_UINT:
+        case DXGI_FORMAT_R32G32B32A32_SINT:
+            return 128;
+        case DXGI_FORMAT_R32G32B32_TYPELESS:
+        case DXGI_FORMAT_R32G32B32_FLOAT:
+        case DXGI_FORMAT_R32G32B32_UINT:
+        case DXGI_FORMAT_R32G32B32_SINT:
+            return 96;
+        case DXGI_FORMAT_R16G16B16A16_TYPELESS:
+        case DXGI_FORMAT_R16G16B16A16_FLOAT:
+        case DXGI_FORMAT_R16G16B16A16_UNORM:
+        case DXGI_FORMAT_R16G16B16A16_UINT:
+        case DXGI_FORMAT_R16G16B16A16_SNORM:
+        case DXGI_FORMAT_R16G16B16A16_SINT:
+        case DXGI_FORMAT_R32G32_TYPELESS:
+        case DXGI_FORMAT_R32G32_FLOAT:
+        case DXGI_FORMAT_R32G32_UINT:
+        case DXGI_FORMAT_R32G32_SINT:
+        case DXGI_FORMAT_R32G8X24_TYPELESS:
+        case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
+        case DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS:
+        case DXGI_FORMAT_X32_TYPELESS_G8X24_UINT:
+        case DXGI_FORMAT_Y416:
+        case DXGI_FORMAT_Y210:
+        case DXGI_FORMAT_Y216:
+            return 64;
+        case DXGI_FORMAT_R10G10B10A2_TYPELESS:
+        case DXGI_FORMAT_R10G10B10A2_UNORM:
+        case DXGI_FORMAT_R10G10B10A2_UINT:
+        case DXGI_FORMAT_R11G11B10_FLOAT:
+        case DXGI_FORMAT_R8G8B8A8_TYPELESS:
+        case DXGI_FORMAT_R8G8B8A8_UNORM:
+        case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
+        case DXGI_FORMAT_R8G8B8A8_UINT:
+        case DXGI_FORMAT_R8G8B8A8_SNORM:
+        case DXGI_FORMAT_R8G8B8A8_SINT:
+        case DXGI_FORMAT_R16G16_TYPELESS:
+        case DXGI_FORMAT_R16G16_FLOAT:
+        case DXGI_FORMAT_R16G16_UNORM:
+        case DXGI_FORMAT_R16G16_UINT:
+        case DXGI_FORMAT_R16G16_SNORM:
+        case DXGI_FORMAT_R16G16_SINT:
+        case DXGI_FORMAT_R32_TYPELESS:
+        case DXGI_FORMAT_D32_FLOAT:
+        case DXGI_FORMAT_R32_FLOAT:
+        case DXGI_FORMAT_R32_UINT:
+        case DXGI_FORMAT_R32_SINT:
+        case DXGI_FORMAT_R24G8_TYPELESS:
+        case DXGI_FORMAT_D24_UNORM_S8_UINT:
+        case DXGI_FORMAT_R24_UNORM_X8_TYPELESS:
+        case DXGI_FORMAT_X24_TYPELESS_G8_UINT:
+        case DXGI_FORMAT_R9G9B9E5_SHAREDEXP:
+        case DXGI_FORMAT_R8G8_B8G8_UNORM:
+        case DXGI_FORMAT_G8R8_G8B8_UNORM:
+        case DXGI_FORMAT_B8G8R8A8_UNORM:
+        case DXGI_FORMAT_B8G8R8X8_UNORM:
+        case DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM:
+        case DXGI_FORMAT_B8G8R8A8_TYPELESS:
+        case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
+        case DXGI_FORMAT_B8G8R8X8_TYPELESS:
+        case DXGI_FORMAT_B8G8R8X8_UNORM_SRGB:
+        case DXGI_FORMAT_AYUV:
+        case DXGI_FORMAT_Y410:
+        case DXGI_FORMAT_YUY2:
+            return 32;
+        case DXGI_FORMAT_P010:
+        case DXGI_FORMAT_P016:
+            return 24;
+        case DXGI_FORMAT_R8G8_TYPELESS:
+        case DXGI_FORMAT_R8G8_UNORM:
+        case DXGI_FORMAT_R8G8_UINT:
+        case DXGI_FORMAT_R8G8_SNORM:
+        case DXGI_FORMAT_R8G8_SINT:
+        case DXGI_FORMAT_R16_TYPELESS:
+        case DXGI_FORMAT_R16_FLOAT:
+        case DXGI_FORMAT_D16_UNORM:
+        case DXGI_FORMAT_R16_UNORM:
+        case DXGI_FORMAT_R16_UINT:
+        case DXGI_FORMAT_R16_SNORM:
+        case DXGI_FORMAT_R16_SINT:
+        case DXGI_FORMAT_B5G6R5_UNORM:
+        case DXGI_FORMAT_B5G5R5A1_UNORM:
+        case DXGI_FORMAT_A8P8:
+        case DXGI_FORMAT_B4G4R4A4_UNORM:
+            return 16;
+        case DXGI_FORMAT_NV12:
+        case DXGI_FORMAT_420_OPAQUE:
+        case DXGI_FORMAT_NV11:
+            return 12;
+        case DXGI_FORMAT_R8_TYPELESS:
+        case DXGI_FORMAT_R8_UNORM:
+        case DXGI_FORMAT_R8_UINT:
+        case DXGI_FORMAT_R8_SNORM:
+        case DXGI_FORMAT_R8_SINT:
+        case DXGI_FORMAT_A8_UNORM:
+        case DXGI_FORMAT_AI44:
+        case DXGI_FORMAT_IA44:
+        case DXGI_FORMAT_P8:
+        case DXGI_FORMAT_BC2_TYPELESS:
+        case DXGI_FORMAT_BC2_UNORM:
+        case DXGI_FORMAT_BC2_UNORM_SRGB:
+        case DXGI_FORMAT_BC3_TYPELESS:
+        case DXGI_FORMAT_BC3_UNORM:
+        case DXGI_FORMAT_BC3_UNORM_SRGB:
+        case DXGI_FORMAT_BC5_TYPELESS:
+        case DXGI_FORMAT_BC5_UNORM:
+        case DXGI_FORMAT_BC5_SNORM:
+        case DXGI_FORMAT_BC6H_TYPELESS:
+        case DXGI_FORMAT_BC6H_UF16:
+        case DXGI_FORMAT_BC6H_SF16:
+        case DXGI_FORMAT_BC7_TYPELESS:
+        case DXGI_FORMAT_BC7_UNORM:
+        case DXGI_FORMAT_BC7_UNORM_SRGB:
+            return 8;
+        case DXGI_FORMAT_BC1_TYPELESS:
+        case DXGI_FORMAT_BC1_UNORM:
+        case DXGI_FORMAT_BC1_UNORM_SRGB:
+        case DXGI_FORMAT_BC4_TYPELESS:
+        case DXGI_FORMAT_BC4_UNORM:
+        case DXGI_FORMAT_BC4_SNORM:
+            return 4;
+        case DXGI_FORMAT_R1_UNORM:
+            return 1;
+        default:
+            return 0;
+    }
+}
+
+static const GUID *dxgi_format_to_wic_guid(DXGI_FORMAT format)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(wic_pixel_formats); ++i)
+    {
+        if (wic_pixel_formats[i].dxgi_format == format)
+            return wic_pixel_formats[i].wic_guid;
+    }
+
+    return NULL;
+}
+
+HRESULT WINAPI D3DX11GetImageInfoFromMemory(const void *src_data, SIZE_T src_data_size, ID3DX11ThreadPump *pump,
+        D3DX11_IMAGE_INFO *img_info, HRESULT *hresult)
+{
+    IWICBitmapFrameDecode *frame = NULL;
+    IWICImagingFactory *factory = NULL;
+    IWICDdsDecoder *dds_decoder = NULL;
+    IWICBitmapDecoder *decoder = NULL;
+    WICDdsParameters dds_params;
+    IWICStream *stream = NULL;
+    GUID container_format;
+    HRESULT hr;
+
+    TRACE("src_data %p, src_data_size %Iu, pump %p, img_info %p, hresult %p.\n",
+            src_data, src_data_size, pump, img_info, hresult);
+
+    if (!src_data || !src_data_size || !img_info)
+        return E_FAIL;
+    if (pump)
+        FIXME("Thread pump is not supported yet.\n");
+
+    WICCreateImagingFactory_Proxy(WINCODEC_SDK_VERSION, &factory);
+    IWICImagingFactory_CreateStream(factory, &stream);
+    hr = IWICStream_InitializeFromMemory(stream, (BYTE *)src_data, src_data_size);
+    if (FAILED(hr))
+    {
+        WARN("Failed to initialize stream.\n");
+        goto end;
+    }
+    hr = IWICImagingFactory_CreateDecoderFromStream(factory, (IStream *)stream, NULL, 0, &decoder);
+    if (FAILED(hr))
+        goto end;
+
+    hr = IWICBitmapDecoder_GetContainerFormat(decoder, &container_format);
+    if (FAILED(hr))
+        goto end;
+    img_info->ImageFileFormat = wic_container_guid_to_file_format(&container_format);
+    if (img_info->ImageFileFormat == D3DX11_IFF_FORCE_DWORD)
+    {
+        hr = E_FAIL;
+        WARN("Unsupported image file format %s.\n", debugstr_guid(&container_format));
+        goto end;
+    }
+
+    if (img_info->ImageFileFormat == D3DX11_IFF_DDS)
+    {
+        hr = IWICBitmapDecoder_QueryInterface(decoder, &IID_IWICDdsDecoder, (void **)&dds_decoder);
+        if (FAILED(hr))
+            goto end;
+        hr = IWICDdsDecoder_GetParameters(dds_decoder, &dds_params);
+        if (FAILED(hr))
+            goto end;
+        img_info->Width = dds_params.Width;
+        img_info->Height = dds_params.Height;
+        img_info->ArraySize = dds_params.ArraySize;
+        img_info->Depth = dds_params.Depth;
+        img_info->MipLevels = dds_params.MipLevels;
+        img_info->ResourceDimension = wic_dimension_to_d3dx11_dimension(dds_params.Dimension);
+        img_info->Format = get_d3dx11_dds_format(dds_params.DxgiFormat);
+        img_info->MiscFlags = 0;
+        if (dds_params.Dimension == WICDdsTextureCube)
+        {
+            img_info->MiscFlags = D3D11_RESOURCE_MISC_TEXTURECUBE;
+            img_info->ArraySize *= 6;
+        }
+    }
+    else
+    {
+        unsigned int frame_count;
+
+        hr = IWICBitmapDecoder_GetFrameCount(decoder, &frame_count);
+        if (FAILED(hr) || !frame_count)
+            goto end;
+        hr = IWICBitmapDecoder_GetFrame(decoder, 0, &frame);
+        if (FAILED(hr))
+            goto end;
+        hr = IWICBitmapFrameDecode_GetSize(frame, &img_info->Width, &img_info->Height);
+        if (FAILED(hr))
+            goto end;
+
+        img_info->ArraySize = 1;
+        img_info->Depth = 1;
+        img_info->MipLevels = 1;
+        img_info->ResourceDimension = D3D11_RESOURCE_DIMENSION_TEXTURE2D;
+        img_info->Format = DXGI_FORMAT_R8G8B8A8_UNORM;
+        img_info->MiscFlags = 0;
+    }
+
+end:
+    if (dds_decoder)
+        IWICDdsDecoder_Release(dds_decoder);
+    if (frame)
+        IWICBitmapFrameDecode_Release(frame);
+    if (decoder)
+        IWICBitmapDecoder_Release(decoder);
+    if (stream)
+        IWICStream_Release(stream);
+    if (factory)
+        IWICImagingFactory_Release(factory);
+
+    if (hr != S_OK)
+    {
+        WARN("Invalid or unsupported image file.\n");
+        return E_FAIL;
+    }
+    return S_OK;
+}
+
 HRESULT WINAPI D3DX11CreateShaderResourceViewFromMemory(ID3D11Device *device, const void *data,
         SIZE_T data_size, D3DX11_IMAGE_LOAD_INFO *load_info, ID3DX11ThreadPump *pump,
         ID3D11ShaderResourceView **view, HRESULT *hresult)
@@ -53,14 +429,166 @@ HRESULT WINAPI D3DX11CreateTextureFromFileW(ID3D11Device *device, const WCHAR *f
     return E_NOTIMPL;
 }
 
-HRESULT WINAPI D3DX11CreateTextureFromMemory(ID3D11Device *device, const void *data,
-        SIZE_T data_size, D3DX11_IMAGE_LOAD_INFO *load_info, ID3DX11ThreadPump *pump,
+HRESULT WINAPI D3DX11CreateTextureFromMemory(ID3D11Device *device, const void *src_data,
+        SIZE_T src_data_size, D3DX11_IMAGE_LOAD_INFO *load_info, ID3DX11ThreadPump *pump,
         ID3D11Resource **texture, HRESULT *hresult)
 {
-    FIXME("device %p, data %p, data_size %Iu, load_info %p, pump %p, texture %p, hresult %p stub.\n",
-            device, data, data_size, load_info, pump, texture, hresult);
+    unsigned int frame_count, width, height, stride, frame_size;
+    IWICFormatConverter *converter = NULL;
+    IWICDdsFrameDecode *dds_frame = NULL;
+    D3D11_TEXTURE2D_DESC texture_2d_desc;
+    D3D11_SUBRESOURCE_DATA resource_data;
+    IWICBitmapFrameDecode *frame = NULL;
+    IWICImagingFactory *factory = NULL;
+    IWICBitmapDecoder *decoder = NULL;
+    ID3D11Texture2D *texture_2d;
+    D3DX11_IMAGE_INFO img_info;
+    IWICStream *stream = NULL;
+    const GUID *dst_format;
+    BYTE *buffer = NULL;
+    BOOL can_convert;
+    GUID src_format;
+    HRESULT hr;
 
-    return E_NOTIMPL;
+    TRACE("device %p, data %p, data_size %Iu, load_info %p, pump %p, texture %p, hresult %p.\n",
+            device, src_data, src_data_size, load_info, pump, texture, hresult);
+
+    if (!src_data || !src_data_size || !texture)
+        return E_FAIL;
+    if (pump)
+        FIXME("Thread pump is not supported yet.\n");
+
+    if (load_info)
+    {
+        img_info.Width = load_info->Width;
+        img_info.Height = load_info->Height;
+        img_info.Depth  = load_info->Depth;
+        img_info.ArraySize = 1;
+        img_info.MipLevels = load_info->MipLevels;
+        img_info.MiscFlags = load_info->MiscFlags;
+        img_info.Format = load_info->Format;
+    }
+    else
+    {
+        if (FAILED(D3DX11GetImageInfoFromMemory(src_data, src_data_size, NULL, &img_info, NULL)))
+            return E_FAIL;
+        if (img_info.MiscFlags & D3D11_RESOURCE_MISC_TEXTURECUBE)
+        {
+            FIXME("Cube map is not supported.\n");
+            return E_FAIL;
+        }
+    }
+
+    if (FAILED(hr = WICCreateImagingFactory_Proxy(WINCODEC_SDK_VERSION, &factory)))
+        goto end;
+    if (FAILED(hr = IWICImagingFactory_CreateStream(factory, &stream)))
+        goto end;
+    if (FAILED(hr = IWICStream_InitializeFromMemory(stream, (BYTE *)src_data, src_data_size)))
+        goto end;
+    if (FAILED(hr = IWICImagingFactory_CreateDecoderFromStream(factory, (IStream *)stream, NULL, 0, &decoder)))
+        goto end;
+    if (FAILED(hr = IWICBitmapDecoder_GetFrameCount(decoder, &frame_count)) || !frame_count)
+        goto end;
+    if (FAILED(hr = IWICBitmapDecoder_GetFrame(decoder, 0, &frame)))
+        goto end;
+    if (FAILED(hr = IWICBitmapFrameDecode_GetPixelFormat(frame, &src_format)))
+        goto end;
+
+    width = img_info.Width;
+    height = img_info.Height;
+    if (is_block_compressed(img_info.Format))
+    {
+        width = (width + 3) & ~3;
+        height = (height + 3) & ~3;
+    }
+    stride = (width * get_bpp_from_format(img_info.Format) + 7) / 8;
+    frame_size = stride * height;
+
+    if (!(buffer = heap_alloc(frame_size)))
+    {
+        hr = E_FAIL;
+        goto end;
+    }
+
+    if (is_block_compressed(img_info.Format))
+    {
+        if (FAILED(hr = IWICBitmapFrameDecode_QueryInterface(frame, &IID_IWICDdsFrameDecode, (void **)&dds_frame)))
+            goto end;
+        if (FAILED(hr = IWICDdsFrameDecode_CopyBlocks(dds_frame, NULL, stride * 4, frame_size, buffer)))
+            goto end;
+    }
+    else
+    {
+        if (!(dst_format = dxgi_format_to_wic_guid(img_info.Format)))
+        {
+            hr = E_FAIL;
+            FIXME("Unsupported DXGI format %#x.\n", img_info.Format);
+            goto end;
+        }
+
+        if (IsEqualGUID(&src_format, dst_format))
+        {
+            if (FAILED(hr = IWICBitmapFrameDecode_CopyPixels(frame, NULL, stride, frame_size, buffer)))
+                goto end;
+        }
+        else
+        {
+            if (FAILED(hr = IWICImagingFactory_CreateFormatConverter(factory, &converter)))
+                goto end;
+            if (FAILED(hr = IWICFormatConverter_CanConvert(converter, &src_format, dst_format, &can_convert)))
+                goto end;
+            if (!can_convert)
+            {
+                WARN("Format converting %s to %s is not supported by WIC.\n",
+                        debugstr_guid(&src_format), debugstr_guid(dst_format));
+                goto end;
+            }
+            if (FAILED(hr = IWICFormatConverter_Initialize(converter, (IWICBitmapSource *)frame, dst_format,
+                    WICBitmapDitherTypeErrorDiffusion, 0, 0, WICBitmapPaletteTypeCustom)))
+                goto end;
+            if (FAILED(hr = IWICFormatConverter_CopyPixels(converter, NULL, stride, frame_size, buffer)))
+                goto end;
+        }
+    }
+
+    memset(&texture_2d_desc, 0, sizeof(texture_2d_desc));
+    texture_2d_desc.Width = width;
+    texture_2d_desc.Height = height;
+    texture_2d_desc.MipLevels = 1;
+    texture_2d_desc.ArraySize = img_info.ArraySize;
+    texture_2d_desc.Format = img_info.Format;
+    texture_2d_desc.SampleDesc.Count = 1;
+    texture_2d_desc.Usage = D3D11_USAGE_DEFAULT;
+    texture_2d_desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
+    texture_2d_desc.MiscFlags = img_info.MiscFlags;
+
+    resource_data.pSysMem = buffer;
+    resource_data.SysMemPitch = stride;
+    resource_data.SysMemSlicePitch = frame_size;
+
+    if (FAILED(hr = ID3D11Device_CreateTexture2D(device, &texture_2d_desc, &resource_data, &texture_2d)))
+        goto end;
+
+    *texture = (ID3D11Resource *)texture_2d;
+    hr = S_OK;
+
+end:
+    if (converter)
+        IWICFormatConverter_Release(converter);
+    if (dds_frame)
+        IWICDdsFrameDecode_Release(dds_frame);
+    if (buffer)
+        heap_free(buffer);
+    if (frame)
+        IWICBitmapFrameDecode_Release(frame);
+    if (decoder)
+        IWICBitmapDecoder_Release(decoder);
+    if (stream)
+        IWICStream_Release(stream);
+    if (factory)
+        IWICImagingFactory_Release(factory);
+
+    return hr;
 }
 
 HRESULT WINAPI D3DX11SaveTextureToFileW(ID3D11DeviceContext *context, ID3D11Resource *texture,
diff --git a/dlls/d3dx9_24/d3dx9_24.spec b/dlls/d3dx9_24/d3dx9_24.spec
index 8791e4e..0d51a21 100644
--- a/dlls/d3dx9_24/d3dx9_24.spec
+++ b/dlls/d3dx9_24/d3dx9_24.spec
@@ -20,7 +20,7 @@
 @ stdcall D3DXComputeBoundingSphere(ptr long long ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -226,7 +226,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_25/d3dx9_25.spec b/dlls/d3dx9_25/d3dx9_25.spec
index 0431a9f..5ad6e3d 100644
--- a/dlls/d3dx9_25/d3dx9_25.spec
+++ b/dlls/d3dx9_25/d3dx9_25.spec
@@ -20,7 +20,7 @@
 @ stdcall D3DXComputeBoundingSphere(ptr long long ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -226,7 +226,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_26/d3dx9_26.spec b/dlls/d3dx9_26/d3dx9_26.spec
index 5ab0a1d..ee22087 100644
--- a/dlls/d3dx9_26/d3dx9_26.spec
+++ b/dlls/d3dx9_26/d3dx9_26.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -230,7 +230,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_27/d3dx9_27.spec b/dlls/d3dx9_27/d3dx9_27.spec
index 5ab0a1d..ee22087 100644
--- a/dlls/d3dx9_27/d3dx9_27.spec
+++ b/dlls/d3dx9_27/d3dx9_27.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -230,7 +230,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_28/d3dx9_28.spec b/dlls/d3dx9_28/d3dx9_28.spec
index af5b607..3db5002 100644
--- a/dlls/d3dx9_28/d3dx9_28.spec
+++ b/dlls/d3dx9_28/d3dx9_28.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -230,7 +230,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_29/d3dx9_29.spec b/dlls/d3dx9_29/d3dx9_29.spec
index af5b607..3db5002 100644
--- a/dlls/d3dx9_29/d3dx9_29.spec
+++ b/dlls/d3dx9_29/d3dx9_29.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -230,7 +230,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_30/d3dx9_30.spec b/dlls/d3dx9_30/d3dx9_30.spec
index af5b607..3db5002 100644
--- a/dlls/d3dx9_30/d3dx9_30.spec
+++ b/dlls/d3dx9_30/d3dx9_30.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -230,7 +230,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_31/d3dx9_31.spec b/dlls/d3dx9_31/d3dx9_31.spec
index 8f77dc6..17f380f 100644
--- a/dlls/d3dx9_31/d3dx9_31.spec
+++ b/dlls/d3dx9_31/d3dx9_31.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -227,7 +227,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_32/d3dx9_32.spec b/dlls/d3dx9_32/d3dx9_32.spec
index 2fdd2a0..1de7289 100644
--- a/dlls/d3dx9_32/d3dx9_32.spec
+++ b/dlls/d3dx9_32/d3dx9_32.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -227,7 +227,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_33/d3dx9_33.spec b/dlls/d3dx9_33/d3dx9_33.spec
index 2fdd2a0..1de7289 100644
--- a/dlls/d3dx9_33/d3dx9_33.spec
+++ b/dlls/d3dx9_33/d3dx9_33.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -227,7 +227,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_34/d3dx9_34.spec b/dlls/d3dx9_34/d3dx9_34.spec
index 2fdd2a0..1de7289 100644
--- a/dlls/d3dx9_34/d3dx9_34.spec
+++ b/dlls/d3dx9_34/d3dx9_34.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -227,7 +227,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_35/d3dx9_35.spec b/dlls/d3dx9_35/d3dx9_35.spec
index 2fdd2a0..1de7289 100644
--- a/dlls/d3dx9_35/d3dx9_35.spec
+++ b/dlls/d3dx9_35/d3dx9_35.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -227,7 +227,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_36/d3dx9_36.spec b/dlls/d3dx9_36/d3dx9_36.spec
index 5b70701..5bf7f67 100644
--- a/dlls/d3dx9_36/d3dx9_36.spec
+++ b/dlls/d3dx9_36/d3dx9_36.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -229,7 +229,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_36/d3dx9_private.h b/dlls/d3dx9_36/d3dx9_private.h
index 668fbb2..d87458e 100644
--- a/dlls/d3dx9_36/d3dx9_private.h
+++ b/dlls/d3dx9_36/d3dx9_private.h
@@ -128,6 +128,8 @@ HRESULT lock_surface(IDirect3DSurface9 *surface, const RECT *surface_rect, D3DLO
         IDirect3DSurface9 **temp_surface, BOOL write);
 HRESULT unlock_surface(IDirect3DSurface9 *surface, const RECT *surface_rect,
         IDirect3DSurface9 *temp_surface, BOOL update);
+HRESULT save_dds_texture_to_memory(ID3DXBuffer **dst_buffer, IDirect3DBaseTexture9 *src_texture,
+    const PALETTEENTRY *src_palette);
 
 unsigned short float_32_to_16(const float in);
 float float_16_to_32(const unsigned short in);
diff --git a/dlls/d3dx9_36/mesh.c b/dlls/d3dx9_36/mesh.c
index 4fbb44b..b30a3b4 100644
--- a/dlls/d3dx9_36/mesh.c
+++ b/dlls/d3dx9_36/mesh.c
@@ -4079,7 +4079,8 @@ HRESULT WINAPI D3DXLoadMeshHierarchyFromXInMemory(const void *memory, DWORD memo
     if (anim_controller)
     {
         *anim_controller = NULL;
-        FIXME("Animation controller creation not implemented.\n");
+        /*FIXME("Animation controller creation not implemented.\n");*/
+        D3DXCreateAnimationController(1, 1, 1, 1, anim_controller);
     }
 
 cleanup:
@@ -7288,6 +7289,33 @@ cleanup:
     return hr;
 }
 
+
+/*************************************************************************
+ * D3DXOptimizeVertices    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXOptimizeVertices(const void *indices, UINT num_faces,
+        UINT num_vertices, BOOL indices_are_32bit, DWORD *vertex_remap)
+{
+    UINT i;
+
+    FIXME("indices %p, num_faces %u, num_vertices %u, indices_are_32bit %#x, vertex_remap %p semi-stub.\n",
+            indices, num_faces, num_vertices, indices_are_32bit, vertex_remap);
+
+    if (!vertex_remap)
+    {
+        WARN("vertex remap pointer is NULL.\n");
+        return D3DERR_INVALIDCALL;
+    }
+
+    for (i = 0; i < num_vertices; i++)
+    {
+        vertex_remap[i] = i;
+    }
+
+    return D3D_OK;
+}
+
+
 /*************************************************************************
  * D3DXOptimizeFaces    (D3DX9_36.@)
  *
@@ -7614,6 +7642,24 @@ done:
     return hr;
 }
 
+/*************************************************************************
+ * D3DXComputeTangent    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXComputeTangent(ID3DXMesh *mesh, DWORD stage_idx, DWORD tangent_idx,
+        DWORD binorm_idx, DWORD wrap, const DWORD *adjacency)
+{
+    TRACE("mesh %p, stage_idx %ld, tangent_idx %ld, binorm_idx %ld, wrap %ld, adjacency %p.\n",
+           mesh, stage_idx, tangent_idx, binorm_idx, wrap, adjacency);
+
+    return D3DXComputeTangentFrameEx( mesh, D3DDECLUSAGE_TEXCOORD, stage_idx,
+            ( binorm_idx == D3DX_DEFAULT ) ? D3DX_DEFAULT : D3DDECLUSAGE_BINORMAL,
+            binorm_idx,
+            ( tangent_idx == D3DX_DEFAULT ) ? D3DX_DEFAULT : D3DDECLUSAGE_TANGENT,
+            tangent_idx, D3DX_DEFAULT, 0,
+            ( wrap ? D3DXTANGENT_WRAP_UV : 0 ) | D3DXTANGENT_GENERATE_IN_PLACE | D3DXTANGENT_ORTHOGONALIZE_FROM_U,
+            adjacency, -1.01f, -0.01f, -1.01f, NULL, NULL);
+}
+
 /*************************************************************************
  * D3DXComputeNormals    (D3DX9_36.@)
  */
@@ -7642,6 +7688,8 @@ HRESULT WINAPI D3DXIntersect(ID3DXBaseMesh *mesh, const D3DXVECTOR3 *ray_pos, co
     FIXME("mesh %p, ray_pos %p, ray_dir %p, hit %p, face_index %p, u %p, v %p, distance %p, all_hits %p, "
             "count_of_hits %p stub!\n", mesh, ray_pos, ray_dir, hit, face_index, u, v, distance, all_hits, count_of_hits);
 
+    *hit = FALSE;
+
     return E_NOTIMPL;
 }
 
diff --git a/dlls/d3dx9_36/shader.c b/dlls/d3dx9_36/shader.c
index 88c4916..843a639 100644
--- a/dlls/d3dx9_36/shader.c
+++ b/dlls/d3dx9_36/shader.c
@@ -1,6 +1,7 @@
 /*
  * Copyright 2008 Luis Busquets
  * Copyright 2009 Matteo Bruni
+ * Copyright 2010, 2013, 2016 Christian Costa
  * Copyright 2011 Travis Athougies
  *
  * This library is free software; you can redistribute it and/or
@@ -19,6 +20,7 @@
  */
 
 #include <assert.h>
+#include <stdio.h>
 
 #include "d3dx9_private.h"
 #include "d3dcommon.h"
@@ -458,6 +460,41 @@ HRESULT WINAPI D3DXCompileShader(const char *data, UINT length, const D3DXMACRO
         }
     }
 
+    /* Filter out D3DCompile warning messages that are not present with D3DCompileShader */
+    if (SUCCEEDED(hr) && error_msgs && *error_msgs)
+    {
+        char *messages = ID3DXBuffer_GetBufferPointer(*error_msgs);
+        DWORD size     = ID3DXBuffer_GetBufferSize(*error_msgs);
+
+        /* Ensure messages are null terminated for safe processing */
+        if (size) messages[size - 1] = 0;
+
+        while (size > 1)
+        {
+            char *prev, *next;
+
+            /* Warning has the form "warning X3206: ... implicit truncation of vector type"
+               but we only search for "X3206:" in case d3dcompiler_43 has localization */
+            prev = next = strstr(messages, "X3206:");
+            if (!prev) break;
+
+            /* get pointer to beginning and end of current line */
+            while (prev > messages && *(prev - 1) != '\n') prev--;
+            while (next < messages + size - 1 && *next != '\n') next++;
+            if (next < messages + size - 1 && *next == '\n') next++;
+
+            memmove(prev, next, messages + size - next);
+            size -= (next - prev);
+        }
+
+        /* Only return a buffer if the resulting string is not empty as some apps depend on that */
+        if (size <= 1)
+        {
+            ID3DXBuffer_Release(*error_msgs);
+            *error_msgs = NULL;
+        }
+    }
+
     return hr;
 }
 
@@ -2363,13 +2400,334 @@ HRESULT WINAPI D3DXGetShaderSamplers(const DWORD *byte_code, const char **sample
     return D3D_OK;
 }
 
+static const char *decl_usage[] = { "position", "blendweight", "blendindices", "normal", "psize", "texcoord",
+                                    "tangent", "binormal", "tessfactor", "positiont", "color" };
+
+static const char *tex_type[] = { "", "1d", "2d", "cube", "volume" };
+
+static int add_modifier(char *buffer, DWORD param)
+{
+    char *buf = buffer;
+    DWORD dst_mod = param & D3DSP_DSTMOD_MASK;
+
+    if (dst_mod & D3DSPDM_SATURATE)
+        buf += sprintf(buf, "_sat");
+    if (dst_mod & D3DSPDM_PARTIALPRECISION)
+        buf += sprintf(buf, "_pp");
+    if (dst_mod & D3DSPDM_MSAMPCENTROID)
+        buf += sprintf(buf, "_centroid");
+
+    return buf - buffer;
+}
+
+static int add_register(char *buffer, DWORD param, BOOL dst, BOOL ps)
+{
+    char *buf = buffer;
+    DWORD reg_type = ((param & D3DSP_REGTYPE_MASK2) >> D3DSP_REGTYPE_SHIFT2)
+                   | ((param & D3DSP_REGTYPE_MASK) >> D3DSP_REGTYPE_SHIFT);
+    DWORD reg_num = param & D3DSP_REGNUM_MASK;
+
+    if (reg_type == D3DSPR_INPUT)
+        buf += sprintf(buf, "v%d", reg_num);
+    else if (reg_type == D3DSPR_CONST)
+        buf += sprintf(buf, "c%d", reg_num);
+    else if (reg_type == D3DSPR_TEMP)
+        buf += sprintf(buf, "r%d", reg_num);
+    else if (reg_type == D3DSPR_ADDR)
+        buf += sprintf(buf, "%s%d", ps ? "t" : "a", reg_num);
+    else if (reg_type == D3DSPR_SAMPLER)
+        buf += sprintf(buf, "s%d", reg_num);
+    else if (reg_type == D3DSPR_RASTOUT)
+        buf += sprintf(buf, "oPos");
+    else if (reg_type == D3DSPR_COLOROUT)
+        buf += sprintf(buf, "oC%d", reg_num);
+    else if (reg_type == D3DSPR_TEXCRDOUT)
+        buf += sprintf(buf, "oT%d", reg_num);
+    else if (reg_type == D3DSPR_ATTROUT)
+        buf += sprintf(buf, "oD%d", reg_num);
+    else
+        buf += sprintf(buf, "? (%d)", reg_type);
+
+    if (dst)
+    {
+        if ((param & D3DSP_WRITEMASK_ALL) != D3DSP_WRITEMASK_ALL)
+        {
+            buf += sprintf(buf, ".%s%s%s%s", param & D3DSP_WRITEMASK_0 ? "x" : "",
+                                             param & D3DSP_WRITEMASK_1 ? "y" : "",
+                                             param & D3DSP_WRITEMASK_2 ? "z" : "",
+                                             param & D3DSP_WRITEMASK_3 ? "w" : "");
+        }
+    }
+    else
+    {
+        if ((param & D3DVS_SWIZZLE_MASK) != D3DVS_NOSWIZZLE)
+        {
+            if ( ((param & D3DSP_SWIZZLE_MASK) == (D3DVS_X_X | D3DVS_Y_X | D3DVS_Z_X | D3DVS_W_X)) ||
+                 ((param & D3DSP_SWIZZLE_MASK) == (D3DVS_X_Y | D3DVS_Y_Y | D3DVS_Z_Y | D3DVS_W_Y)) ||
+                 ((param & D3DSP_SWIZZLE_MASK) == (D3DVS_X_Z | D3DVS_Y_Z | D3DVS_Z_Z | D3DVS_W_Z)) ||
+                 ((param & D3DSP_SWIZZLE_MASK) == (D3DVS_X_W | D3DVS_Y_W | D3DVS_Z_W | D3DVS_W_W)) )
+                buf += sprintf(buf, ".%c", 'w' + (((param >> D3DVS_SWIZZLE_SHIFT) + 1) & 0x3));
+            else
+                buf += sprintf(buf, ".%c%c%c%c", 'w' + (((param >> (D3DVS_SWIZZLE_SHIFT+0)) + 1) & 0x3),
+                                                 'w' + (((param >> (D3DVS_SWIZZLE_SHIFT+2)) + 1) & 0x3),
+                                                 'w' + (((param >> (D3DVS_SWIZZLE_SHIFT+4)) + 1) & 0x3),
+                                                 'w' + (((param >> (D3DVS_SWIZZLE_SHIFT+6)) + 1) & 0x3));
+        }
+    }
+
+    return buf - buffer;
+}
+
+struct instr_info
+{
+    DWORD opcode;
+    const char *name;
+    int length;
+    int (*function)(const struct instr_info *info, DWORD **ptr, char *buffer, BOOL ps);
+    WORD min_version;
+    WORD max_version;
+};
+
+static int instr_comment(const struct instr_info *info, DWORD **ptr, char *buffer, BOOL ps)
+{
+    *ptr += 1 + ((**ptr & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT);
+    return 0;
+}
+
+static int instr_def(const struct instr_info *info, DWORD **ptr, char *buffer, BOOL ps)
+{
+    int len = sprintf(buffer, "    def c%d, %g, %g, %g, %g\n", *(*ptr+1) & D3DSP_REGNUM_MASK,
+                      (double)*(float*)(*ptr+2), (double)*(float*)(*ptr+3),
+                      (double)*(float*)(*ptr+4), (double)*(float*)(*ptr+5));
+    *ptr += 6;
+    return len;
+}
+
+static int instr_dcl(const struct instr_info *info, DWORD **ptr, char *buffer, BOOL ps)
+{
+    DWORD param1 = *++*ptr;
+    DWORD param2 = *++*ptr;
+    DWORD usage = (param1 & D3DSP_DCL_USAGE_MASK) >> D3DSP_DCL_USAGE_SHIFT;
+    DWORD usage_index = (param1 & D3DSP_DCL_USAGEINDEX_MASK) >> D3DSP_DCL_USAGEINDEX_SHIFT;
+    char *buf = buffer;
+
+    buf += sprintf(buf, "    dcl");
+    if (ps)
+    {
+        if (param1 & D3DSP_TEXTURETYPE_MASK)
+            buf += sprintf(buf, "_%s", (usage <= D3DSTT_VOLUME) ?
+                tex_type[(param1 & D3DSP_TEXTURETYPE_MASK) >> D3DSP_TEXTURETYPE_SHIFT] : "???");
+    }
+    else
+    {
+        buf += sprintf(buf, "_%s", (usage <= D3DDECLUSAGE_COLOR) ? decl_usage[usage] : "???");
+        if (usage_index)
+            buf += sprintf(buf, "%d", usage_index);
+    }
+
+    buf += add_modifier(buf, param2);
+    buf += sprintf(buf, " ");
+    buf += add_register(buf, param2, TRUE, TRUE);
+    buf += sprintf(buf, "\n");
+    (*ptr)++;
+    return buf - buffer;
+}
+
+static int instr_generic(const struct instr_info *info, DWORD **ptr, char *buffer, BOOL ps)
+{
+    char *buf = buffer;
+    int j;
+
+    buf += sprintf(buf, "    %s", info->name);
+    (*ptr)++;
+
+    if (info->length)
+    {
+        buf += add_modifier(buf, **ptr);
+
+        for (j = 0; j < info->length; j++)
+        {
+            buf += sprintf(buf, "%s ", j ? "," : "");
+
+            if ((j != 0) && ((**ptr & D3DSP_SRCMOD_MASK) != D3DSPSM_NONE))
+            {
+                if ((**ptr & D3DSP_SRCMOD_MASK) == D3DSPSM_NEG)
+                    buf += sprintf(buf, "-");
+                else
+                    buf += sprintf(buf, "*");
+            }
+
+            buf += add_register(buf, **ptr, j == 0, ps);
+
+            if (*(*ptr)++ & D3DVS_ADDRESSMODE_MASK)
+            {
+                buf += sprintf(buf, "[");
+                buf += add_register(buf, **ptr, FALSE, FALSE);
+                buf += sprintf(buf, "]");
+                (*ptr)++;
+            }
+        }
+    }
+    buf += sprintf(buf, "\n");
+    return buf - buffer;
+}
+
+const struct instr_info instructions[] =
+{
+    { D3DSIO_NOP,          "nop",           0, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_MOV,          "mov",           2, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_ADD,          "add",           3, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_SUB,          "sub",           3, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_MAD,          "mad",           4, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_MUL,          "mul",           3, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_RCP,          "rcp",           2, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_RSQ,          "rsq",           2, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_DP3,          "dp3",           3, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_DP4,          "dp4",           3, instr_generic, 0x0100, 0xFFFF }, /* >= 1.2 for PS */
+    { D3DSIO_MIN,          "min",           3, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_MAX,          "max",           3, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_SLT,          "slt",           3, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_SGE,          "sge",           3, instr_generic, 0x0100, 0xFFFF }, /* VS only */
+    { D3DSIO_EXP,          "exp",           2, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_LOG,          "log",           2, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_LIT,          "lit",           2, instr_generic, 0x0100, 0xFFFF }, /* VS only */
+    { D3DSIO_DST,          "dst",           3, instr_generic, 0x0100, 0xFFFF }, /* VS only */
+    { D3DSIO_LRP,          "lrp",           4, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for VS */
+    { D3DSIO_FRC,          "frc",           2, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_M4x4,         "m4x4",          3, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_M4x3,         "m4x3",          3, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_M3x4,         "m3x4",          3, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_M3x3,         "m3x3",          3, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_M3x2,         "m3x2",          3, instr_generic, 0x0100, 0xFFFF }, /* >= 2.0 for PS */
+    { D3DSIO_CALL,         "call",          1, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_CALLNZ,       "callnz",        2, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_LOOP,         "loop",          2, instr_generic, 0x0200, 0xFFFF }, /* >= 3.0 for PS */
+    { D3DSIO_RET,          "ret",           0, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_ENDLOOP,      "endloop",       1, instr_generic, 0x0200, 0xFFFF }, /* >= 3.0 for PS */
+    { D3DSIO_LABEL,        "label",         1, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_DCL,          "dcl",           1, instr_dcl,     0x0100, 0xFFFF },
+    { D3DSIO_POW,          "pow",           3, instr_generic, 0x0200, 0xFFFF },
+    { D3DSIO_CRS,          "crs",           3, instr_generic, 0x0200, 0xFFFF },
+    { D3DSIO_SGN,          "sgn",           4, instr_generic, 0x0200, 0xFFFF }, /* VS only */
+    { D3DSIO_ABS,          "abs",           2, instr_generic, 0x0200, 0xFFFF },
+    { D3DSIO_NRM,          "nrm",           2, instr_generic, 0x0200, 0xFFFF },
+    { D3DSIO_SINCOS,       "sincos",        4, instr_generic, 0x0200, 0x02FF },
+    { D3DSIO_SINCOS,       "sincos",        2, instr_generic, 0x0300, 0xFFFF },
+    { D3DSIO_REP,          "rep",           1, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_ENDREP,       "endrep",        0, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_IF,           "if",            1, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_IFC,          "if_comp",       2, instr_generic, 0x0200, 0xFFFF },
+    { D3DSIO_ELSE,         "else",          0, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_ENDIF,        "endif",         0, instr_generic, 0x0200, 0xFFFF }, /* >= 2.a for PS */
+    { D3DSIO_BREAK,        "break",         0, instr_generic, 0x0201, 0xFFFF },
+    { D3DSIO_BREAKC,       "break_comp",    2, instr_generic, 0x0201, 0xFFFF },
+    { D3DSIO_MOVA,         "mova",          2, instr_generic, 0x0200, 0xFFFF }, /* VS only */
+    { D3DSIO_DEFB,         "defb",          2, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_DEFI,         "defi",          2, instr_generic, 0x0100, 0xFFFF },
+    { D3DSIO_TEXCOORD,     "texcoord",      1, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXCOORD,     "texcrd",        2, instr_generic, 0x0104, 0x0104 }, /* PS only */
+    { D3DSIO_TEXKILL,      "texkill",       1, instr_generic, 0x0100, 0xFFFF }, /* PS only */
+    { D3DSIO_TEX,          "tex",           1, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEX,          "texld",         2, instr_generic, 0x0104, 0x0104 }, /* PS only */
+    { D3DSIO_TEX,          "texld",         3, instr_generic, 0x0200, 0xFFFF }, /* PS only */
+    { D3DSIO_TEXBEM,       "texbem",        2, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXBEML,      "texbeml",       2, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXREG2AR,    "texreg2ar",     2, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXREG2GB,    "texreg2gb",     2, instr_generic, 0x0102, 0x0103 }, /* PS only */
+    { D3DSIO_TEXM3x2PAD,   "texm3x2pad",    2, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXM3x2TEX,   "texm3x2tex",    2, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXM3x3PAD,   "texm3x3pad",    2, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXM3x3TEX,   "texm3x3tex",    2, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXM3x3DIFF,  "texm3x3diff",   2, instr_generic, 0x0100, 0xFFFF }, /* PS only - Not documented */
+    { D3DSIO_TEXM3x3SPEC,  "texm3x3spec",   3, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_TEXM3x3VSPEC, "texm3x3vspec",  2, instr_generic, 0x0100, 0x0103 }, /* PS only */
+    { D3DSIO_EXPP,         "expp",          2, instr_generic, 0x0100, 0xFFFF }, /* VS only */
+    { D3DSIO_LOGP,         "logp",          2, instr_generic, 0x0100, 0xFFFF }, /* VS only */
+    { D3DSIO_CND,          "cnd",           4, instr_generic, 0x0100, 0x0104 }, /* PS only */
+    { D3DSIO_DEF,          "def",           5, instr_def,     0x0100, 0xFFFF },
+    { D3DSIO_TEXREG2RGB,   "texreg2rgb",    2, instr_generic, 0x0102, 0x0103 }, /* PS only */
+    { D3DSIO_TEXDP3TEX,    "texdp3tex",     2, instr_generic, 0x0102, 0x0103 }, /* PS only */
+    { D3DSIO_TEXM3x2DEPTH, "texm3x2depth",  2, instr_generic, 0x0103, 0x0103 }, /* PS only */
+    { D3DSIO_TEXDP3,       "texdp3",        2, instr_generic, 0x0102, 0x0103 }, /* PS only */
+    { D3DSIO_TEXM3x3,      "texm3x3",       2, instr_generic, 0x0102, 0x0103 }, /* PS only */
+    { D3DSIO_TEXDEPTH,     "texdepth",      1, instr_generic, 0x0104, 0x0104 }, /* PS only */
+    { D3DSIO_CMP,          "cmp",           4, instr_generic, 0x0102, 0xFFFF }, /* PS only */
+    { D3DSIO_BEM,          "bem",           3, instr_generic, 0x0104, 0x0104 }, /* PS only */
+    { D3DSIO_DP2ADD,       "dp2add",        4, instr_generic, 0x0200, 0xFFFF }, /* PS only */
+    { D3DSIO_DSX,          "dsx",           2, instr_generic, 0x0201, 0xFFFF }, /* PS only */
+    { D3DSIO_DSY,          "dsy",           2, instr_generic, 0x0201, 0xFFFF }, /* PS only */
+    { D3DSIO_TEXLDD,       "texldd",        5, instr_generic, 0x0201, 0xFFFF }, /* PS only - not existing for 2.b */
+    { D3DSIO_SETP,         "setp_comp",     3, instr_generic, 0x0201, 0xFFFF },
+    { D3DSIO_TEXLDL,       "texldl",        3, instr_generic, 0x0300, 0xFFFF },
+    { D3DSIO_BREAKP,       "breakp",        1, instr_generic, 0x0201, 0xFFFF },
+    { D3DSIO_PHASE,        "phase",         0, instr_generic, 0x0104, 0x0104 },  /* PS only */
+    { D3DSIO_COMMENT,      "",              0, instr_comment, 0x0100, 0xFFFF }
+};
+
 HRESULT WINAPI D3DXDisassembleShader(const DWORD *shader, BOOL colorcode, const char *comments,
-        ID3DXBuffer **buffer)
+        ID3DXBuffer **disassembly)
 {
-    TRACE("shader %p, colorcode %d, comments %s, buffer %p.\n", shader, colorcode, debugstr_a(comments), buffer);
+    DWORD *ptr = (DWORD *)shader;
+    char *buffer, *buf;
+    UINT capacity = 4096;
+    BOOL ps;
+    WORD version;
+    HRESULT hr;
+
+    TRACE("%p %d %s %p\n", shader, colorcode, debugstr_a(comments), disassembly);
+
+    if (!shader || !disassembly)
+        return D3DERR_INVALIDCALL;
+
+    buf = buffer = HeapAlloc(GetProcessHeap(), 0, capacity);
+    if (!buffer)
+        return E_OUTOFMEMORY;
+
+    ps = (*ptr >> 16) & 1;
+    version = *ptr & 0xFFFF;
+    buf += sprintf(buf, "    %s_%d_%d\n", ps ? "ps" : "vs", D3DSHADER_VERSION_MAJOR(*ptr), D3DSHADER_VERSION_MINOR(*ptr));
+    ptr++;
 
-    return D3DDisassemble(shader, D3DXGetShaderSize(shader), colorcode ? D3D_DISASM_ENABLE_COLOR_CODE : 0,
-            comments, (ID3DBlob **)buffer);
+    while (*ptr != D3DSIO_END)
+    {
+        DWORD index;
+
+        if ((buf - buffer + 128) > capacity)
+        {
+            UINT count = buf - buffer;
+           char *new_buffer = HeapReAlloc(GetProcessHeap(), 0, buffer, capacity * 2);
+            if (!new_buffer)
+            {
+                HeapFree(GetProcessHeap(), 0, buffer);
+                return E_OUTOFMEMORY;
+            }
+            capacity *= 2;
+            buffer = new_buffer;
+            buf = buffer + count;
+        }
+
+        for (index = 0; index < sizeof(instructions)/sizeof(instructions[0]); index++)
+            if (((*ptr & D3DSI_OPCODE_MASK) == instructions[index].opcode) &&
+                (version >= instructions[index].min_version) && (version <= instructions[index].max_version))
+                break;
+
+        if (index != sizeof(instructions)/sizeof(instructions[0]))
+        {
+            buf += instructions[index].function(&(instructions[index]), &ptr, buf, ps);
+        }
+        else
+        {
+            buf += sprintf(buf, "    ??? (Unknown opcode %x)\n", *ptr);
+            while (*++ptr & (1u << 31));
+        }
+    }
+
+    hr = D3DXCreateBuffer(buf - buffer + 1 , disassembly);
+    if (SUCCEEDED(hr))
+        strcpy(ID3DXBuffer_GetBufferPointer(*disassembly), buffer);
+    HeapFree(GetProcessHeap(), 0, buffer);
+
+    return hr;
 }
 
 struct d3dx9_texture_shader
diff --git a/dlls/d3dx9_36/skin.c b/dlls/d3dx9_36/skin.c
index 294c652..8129878 100644
--- a/dlls/d3dx9_36/skin.c
+++ b/dlls/d3dx9_36/skin.c
@@ -2,6 +2,7 @@
  * Skin Info operations specific to D3DX9.
  *
  * Copyright (C) 2011 Dylan Smith
+ * Copyright (C) 2013 Christian Costa
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -396,10 +397,89 @@ static HRESULT WINAPI d3dx9_skin_info_GetDeclaration(ID3DXSkinInfo *iface,
 static HRESULT WINAPI d3dx9_skin_info_UpdateSkinnedMesh(ID3DXSkinInfo *iface, const D3DXMATRIX *bone_transforms,
         const D3DXMATRIX *bone_inv_transpose_transforms, const void *src_vertices, void *dst_vertices)
 {
-    FIXME("iface %p, bone_transforms %p, bone_inv_transpose_transforms %p, src_vertices %p, dst_vertices %p stub!\n",
-            iface, bone_transforms, bone_inv_transpose_transforms, src_vertices, dst_vertices);
+    struct d3dx9_skin_info *skin = impl_from_ID3DXSkinInfo(iface);
+    DWORD size = D3DXGetFVFVertexSize(skin->fvf);
+    DWORD i, j;
 
-    return E_NOTIMPL;
+    TRACE("iface %p, bone_transforms %p, bone_inv_transpose_transforms %p, src_vertices %p, dst_vertices %p\n",
+            skin, bone_transforms, bone_inv_transpose_transforms, src_vertices, dst_vertices);
+
+    if (bone_inv_transpose_transforms)
+        FIXME("Skinning vertices with two position elements not supported\n");
+
+    if ((skin->fvf & D3DFVF_POSITION_MASK) != D3DFVF_XYZ) {
+        FIXME("Vertex type %#lx not supported\n", skin->fvf & D3DFVF_POSITION_MASK);
+        return E_FAIL;
+    }
+
+    /* Reset all positions */
+    for (i = 0; i < skin->num_vertices; i++) {
+        D3DXVECTOR3 *position = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * i);
+        position->x = 0.0f;
+        position->y = 0.0f;
+        position->z = 0.0f;
+    }
+
+    /* Update positions that are influenced by bones */
+    for (i = 0; i < skin->num_bones; i++) {
+        D3DXMATRIX bone_inverse, matrix;
+
+        D3DXMatrixInverse(&bone_inverse, NULL, &skin->bones[i].transform);
+        D3DXMatrixMultiply(&matrix, &bone_transforms[i], &bone_inverse);
+        D3DXMatrixMultiply(&matrix, &matrix, &skin->bones[i].transform);
+
+        for (j = 0; j < skin->bones[i].num_influences; j++) {
+            D3DXVECTOR3 position;
+            D3DXVECTOR3 *position_src = (D3DXVECTOR3*)((BYTE*)src_vertices + size * skin->bones[i].vertices[j]);
+            D3DXVECTOR3 *position_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * skin->bones[i].vertices[j]);
+            FLOAT weight = skin->bones[i].weights[j];
+
+            D3DXVec3TransformCoord(&position, position_src, &matrix);
+            position_dest->x += weight * position.x;
+            position_dest->y += weight * position.y;
+            position_dest->z += weight * position.z;
+        }
+    }
+
+    if (skin->fvf & D3DFVF_NORMAL) {
+        /* Reset all normals */
+        for (i = 0; i < skin->num_vertices; i++) {
+            D3DXVECTOR3 *normal = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * i + sizeof(D3DXVECTOR3));
+            normal->x = 0.0f;
+            normal->y = 0.0f;
+            normal->z = 0.0f;
+        }
+
+        /* Update normals that are influenced by bones */
+        for (i = 0; i < skin->num_bones; i++) {
+            D3DXMATRIX bone_inverse, matrix;
+
+            D3DXMatrixInverse(&bone_inverse, NULL, &skin->bones[i].transform);
+            D3DXMatrixMultiply(&matrix, &skin->bones[i].transform, &bone_transforms[i]);
+
+            for (j = 0; j < skin->bones[i].num_influences; j++) {
+                D3DXVECTOR3 normal;
+                D3DXVECTOR3 *normal_src = (D3DXVECTOR3*)((BYTE*)src_vertices + size * skin->bones[i].vertices[j] + sizeof(D3DXVECTOR3));
+                D3DXVECTOR3 *normal_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * skin->bones[i].vertices[j] + sizeof(D3DXVECTOR3));
+                FLOAT weight = skin->bones[i].weights[j];
+
+                D3DXVec3TransformNormal(&normal, normal_src, &bone_inverse);
+                D3DXVec3TransformNormal(&normal, &normal, &matrix);
+                normal_dest->x += weight * normal.x;
+                normal_dest->y += weight * normal.y;
+                normal_dest->z += weight * normal.z;
+            }
+        }
+
+        /* Normalize all normals that are influenced by bones*/
+        for (i = 0; i < skin->num_vertices; i++) {
+            D3DXVECTOR3 *normal_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + (i * size) + sizeof(D3DXVECTOR3));
+            if ((normal_dest->x != 0.0f) && (normal_dest->y != 0.0f) && (normal_dest->z != 0.0f))
+                D3DXVec3Normalize(normal_dest, normal_dest);
+        }
+    }
+
+    return D3D_OK;
 }
 
 static HRESULT WINAPI d3dx9_skin_info_ConvertToBlendedMesh(ID3DXSkinInfo *iface, ID3DXMesh *mesh_in,
diff --git a/dlls/d3dx9_36/sprite.c b/dlls/d3dx9_36/sprite.c
index 2fe822c..d8c6b77 100644
--- a/dlls/d3dx9_36/sprite.c
+++ b/dlls/d3dx9_36/sprite.c
@@ -193,7 +193,7 @@ static HRESULT WINAPI d3dx9_sprite_SetWorldViewLH(ID3DXSprite *iface,
 }
 
 /* Helper function */
-static void set_states(struct d3dx9_sprite *object)
+static void set_states(struct d3dx9_sprite *object, DWORD flags)
 {
     D3DXMATRIX mat;
     D3DVIEWPORT9 vp;
@@ -204,32 +204,35 @@ static void set_states(struct d3dx9_sprite *object)
     IDirect3DDevice9_SetNPatchMode(object->device, 0.0f);
 
     /* Render states */
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHABLENDENABLE, TRUE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHAFUNC, D3DCMP_GREATER);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHAREF, 0x00);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHATESTENABLE, object->alphacmp_caps);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_BLENDOP, D3DBLENDOP_ADD);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_CLIPPING, TRUE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_CLIPPLANEENABLE, 0);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE |
-                                    D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_CULLMODE, D3DCULL_NONE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_ENABLEADAPTIVETESSELLATION, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_FILLMODE, D3DFILL_SOLID);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_FOGENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_LIGHTING, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_RANGEFOGENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SEPARATEALPHABLENDENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SPECULARENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_SRGBWRITEENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_STENCILENABLE, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_VERTEXBLEND, FALSE);
-    IDirect3DDevice9_SetRenderState(object->device, D3DRS_WRAP0, 0);
+    if (!(flags & D3DXSPRITE_DONOTMODIFY_RENDERSTATE))
+    {
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHABLENDENABLE, TRUE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHAFUNC, D3DCMP_GREATER);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHAREF, 0x00);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ALPHATESTENABLE, object->alphacmp_caps);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_BLENDOP, D3DBLENDOP_ADD);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_CLIPPING, TRUE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_CLIPPLANEENABLE, 0);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_ALPHA | D3DCOLORWRITEENABLE_BLUE |
+                                      D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_RED);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_CULLMODE, D3DCULL_NONE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_ENABLEADAPTIVETESSELLATION, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_FILLMODE, D3DFILL_SOLID);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_FOGENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_LIGHTING, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_RANGEFOGENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SEPARATEALPHABLENDENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SPECULARENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_SRGBWRITEENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_STENCILENABLE, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_VERTEXBLEND, FALSE);
+      IDirect3DDevice9_SetRenderState(object->device, D3DRS_WRAP0, 0);
+    }
 
     /* Texture stage states */
     IDirect3DDevice9_SetTextureStageState(object->device, 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
@@ -266,12 +269,15 @@ static void set_states(struct d3dx9_sprite *object)
     IDirect3DDevice9_SetSamplerState(object->device, 0, D3DSAMP_SRGBTEXTURE, 0);
 
     /* Matrices */
-    D3DXMatrixIdentity(&mat);
-    IDirect3DDevice9_SetTransform(object->device, D3DTS_WORLD, &mat);
-    IDirect3DDevice9_SetTransform(object->device, D3DTS_VIEW, &object->view);
-    IDirect3DDevice9_GetViewport(object->device, &vp);
-    D3DXMatrixOrthoOffCenterLH(&mat, vp.X+0.5f, (float)vp.Width+vp.X+0.5f, (float)vp.Height+vp.Y+0.5f, vp.Y+0.5f, vp.MinZ, vp.MaxZ);
-    IDirect3DDevice9_SetTransform(object->device, D3DTS_PROJECTION, &mat);
+    if (!(flags & D3DXSPRITE_OBJECTSPACE))
+    {
+      D3DXMatrixIdentity(&mat);
+      IDirect3DDevice9_SetTransform(object->device, D3DTS_WORLD, &mat);
+      IDirect3DDevice9_SetTransform(object->device, D3DTS_VIEW, &object->view);
+      IDirect3DDevice9_GetViewport(object->device, &vp);
+      D3DXMatrixOrthoOffCenterLH(&mat, vp.X+0.5f, (float)vp.Width+vp.X+0.5f, (float)vp.Height+vp.Y+0.5f, vp.Y+0.5f, vp.MinZ, vp.MaxZ);
+      IDirect3DDevice9_SetTransform(object->device, D3DTS_PROJECTION, &mat);
+    }
 }
 
 static HRESULT WINAPI d3dx9_sprite_Begin(ID3DXSprite *iface, DWORD flags)
@@ -317,7 +323,7 @@ D3DXSPRITE_SORT_TEXTURE: sort by texture (so that it doesn't change too often)
             hr=IDirect3DDevice9_BeginStateBlock(This->device);
             if(hr!=D3D_OK) return hr;
 
-            set_states(This);
+            set_states(This, flags);
 
             IDirect3DDevice9_SetVertexDeclaration(This->device, This->vdecl);
             IDirect3DDevice9_SetStreamSource(This->device, 0, NULL, 0, sizeof(struct sprite_vertex));
@@ -330,7 +336,7 @@ D3DXSPRITE_SORT_TEXTURE: sort by texture (so that it doesn't change too often)
     }
 
     /* Apply device state */
-    set_states(This);
+    set_states(This, flags);
 
     This->flags=flags;
     This->ready=TRUE;
diff --git a/dlls/d3dx9_36/surface.c b/dlls/d3dx9_36/surface.c
index 25a762e..4c2c2c0 100644
--- a/dlls/d3dx9_36/surface.c
+++ b/dlls/d3dx9_36/surface.c
@@ -433,6 +433,14 @@ static HRESULT d3dformat_to_dds_pixel_format(struct dds_pixel_format *pixel_form
         }
     }
 
+    /* Reuse dds_fourcc_to_d3dformat as D3DFORMAT and FOURCC are DWORD with same values */
+    if (dds_fourcc_to_d3dformat(d3dformat) != D3DFMT_UNKNOWN)
+    {
+        pixel_format->flags |= DDS_PF_FOURCC;
+        pixel_format->fourcc = d3dformat;
+        return D3D_OK;
+    }
+
     WARN("Unknown pixel format %#x.\n", d3dformat);
     return E_NOTIMPL;
 }
@@ -642,6 +650,68 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
     return D3D_OK;
 }
 
+static HRESULT get_surface(D3DRESOURCETYPE type, struct IDirect3DBaseTexture9 *tex,
+        int face, UINT level, struct IDirect3DSurface9 **surf)
+{
+    switch (type)
+    {
+        case D3DRTYPE_TEXTURE:
+            return IDirect3DTexture9_GetSurfaceLevel((IDirect3DTexture9*) tex, level, surf);
+        case D3DRTYPE_CUBETEXTURE:
+            return IDirect3DCubeTexture9_GetCubeMapSurface((IDirect3DCubeTexture9*) tex, face, level, surf);
+        default:
+            ERR("Unexpected texture type\n");
+            return E_NOTIMPL;
+    }
+}
+
+HRESULT save_dds_texture_to_memory(ID3DXBuffer **dst_buffer, IDirect3DBaseTexture9 *src_texture, const PALETTEENTRY *src_palette)
+{
+    HRESULT hr;
+    D3DRESOURCETYPE type;
+    UINT mip_levels;
+    IDirect3DSurface9 *surface;
+
+    type = IDirect3DBaseTexture9_GetType(src_texture);
+
+    if ((type !=  D3DRTYPE_TEXTURE) && (type != D3DRTYPE_CUBETEXTURE) && (type != D3DRTYPE_VOLUMETEXTURE))
+        return D3DERR_INVALIDCALL;
+
+    if (type == D3DRTYPE_CUBETEXTURE)
+    {
+        FIXME("Cube texture not supported yet\n");
+        return E_NOTIMPL;
+    }
+    else if (type == D3DRTYPE_VOLUMETEXTURE)
+    {
+        FIXME("Volume texture not supported yet\n");
+        return E_NOTIMPL;
+    }
+
+    mip_levels = IDirect3DTexture9_GetLevelCount(src_texture);
+
+    if (mip_levels > 1)
+    {
+        FIXME("Mipmap not supported yet\n");
+        return E_NOTIMPL;
+    }
+
+    if (src_palette)
+    {
+        FIXME("Saving surfaces with palettized pixel formats not implemented yet\n");
+        return E_NOTIMPL;
+    }
+
+    hr = get_surface(type, src_texture, D3DCUBEMAP_FACE_POSITIVE_X, 0, &surface);
+
+    if (SUCCEEDED(hr))
+    {
+        hr = save_dds_surface_to_memory(dst_buffer, surface, NULL);
+        IDirect3DSurface9_Release(surface);
+    }
+
+    return hr;
+}
 HRESULT load_volume_from_dds(IDirect3DVolume9 *dst_volume, const PALETTEENTRY *dst_palette,
     const D3DBOX *dst_box, const void *src_data, const D3DBOX *src_box, DWORD filter, D3DCOLOR color_key,
     const D3DXIMAGE_INFO *src_info)
diff --git a/dlls/d3dx9_36/tests/mesh.c b/dlls/d3dx9_36/tests/mesh.c
index 1af4532..1de1f19 100644
--- a/dlls/d3dx9_36/tests/mesh.c
+++ b/dlls/d3dx9_36/tests/mesh.c
@@ -5459,6 +5459,88 @@ static void test_create_skin_info(void)
     ok(hr == D3DERR_INVALIDCALL, "Expected D3DERR_INVALIDCALL, got %#lx\n", hr);
 }
 
+static void test_update_skinned_mesh(void)
+{
+    static DWORD bone0_vertices[2] = { 1, 3 };
+    static FLOAT bone0_weights[2] = { 1.0f, 0.5f };
+    static DWORD bone1_vertices[2] = { 2, 3 };
+    static FLOAT bone1_weights[2] = { 1.0f, 0.5f };
+    static D3DMATRIX bones_matrix[2] =
+    { { { {
+               1.0f,  0.0f,  0.0f,  0.0f,
+               0.0f,  1.0f,  0.0f,  0.0f,
+               0.0f,  0.0f,  1.0f,  0.0f,
+               2.0f,  2.0f,  4.0f,  1.0f
+      } } },
+      { { {
+               1.0f,  0.0f,  0.0f,  0.0f,
+               0.0f,  1.0f,  0.0f,  0.0f,
+               0.0f,  0.0f,  1.0f,  0.0f,
+              -4.0f, -4.0f,  4.0f,  1.0f
+      } } } };
+    static D3DVECTOR vertices_src[] = {{  1.0f,  1.0f,  1.0f },
+                                       {  1.0f,  0.0f,  0.0f },
+                                       {  1.0f,  1.0f, -1.0f },
+                                       {  0.0f,  1.0f,  0.0f },
+                                       { -1.0f, -1.0f,  1.0f },
+                                       {  0.0f,  0.0f,  1.0f },
+                                       { -1.0f, -1.0f, -1.0f },
+                                       { -1.0f,  0.0f,  0.0f },
+                                      };
+    static D3DVECTOR vertices_ref[] = {{  0.0f,  0.0f,  0.0f },
+                                       {  0.0f,  0.0f,  0.0f },
+                                       {  3.0f,  3.0f,  3.0f },
+                                       {  0.0f,  1.0f,  0.0f },
+                                       { -5.0f, -5.0f,  5.0f },
+                                       {  0.0f,  0.0f,  1.0f },
+                                       { -2.0f, -2.0f,  3.0f },
+                                       { -1.0f,  0.0f,  0.0f },
+                                      };
+    D3DVECTOR vertices_dest[8];
+    HRESULT hr;
+    ID3DXSkinInfo *skin_info;
+    D3DXMATRIX matrix;
+    int i;
+
+    D3DXMatrixIdentity(&matrix);
+    for (i = 0; i < 8; i++)
+    {
+        vertices_dest[i].x = 10000.0f;
+        vertices_dest[i].y = 10000.0f;
+        vertices_dest[i].z = 10000.0f;
+    }
+
+    hr = D3DXCreateSkinInfoFVF(4, D3DFVF_XYZ | D3DFVF_NORMAL, 2, &skin_info);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+
+    skin_info->lpVtbl->SetBoneInfluence(skin_info, 0, 2, bone0_vertices, bone0_weights);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    skin_info->lpVtbl->SetBoneOffsetMatrix(skin_info, 0, &matrix);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    skin_info->lpVtbl->SetBoneInfluence(skin_info, 1, 2, bone1_vertices, bone1_weights);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    skin_info->lpVtbl->SetBoneOffsetMatrix(skin_info, 1, &matrix);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    skin_info->lpVtbl->UpdateSkinnedMesh(skin_info, bones_matrix, NULL, vertices_src, vertices_dest);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#lx\n", hr);
+    for (i = 0; i < 4; i++)
+    {
+        ok(compare(vertices_dest[i*2].x, vertices_ref[i*2].x), "Vertex[%d].position.x: got %g, expected %g\n",
+           i, vertices_dest[i*2].x, vertices_ref[i*2].x);
+        ok(compare(vertices_dest[i*2].y, vertices_ref[i*2].y), "Vertex[%d].position.y: got %g, expected %g\n",
+           i, vertices_dest[i*2].y, vertices_ref[i*2].y);
+        ok(compare(vertices_dest[i*2].z, vertices_ref[i*2].z), "Vertex[%d].position.z: got %g, expected %g\n",
+           i, vertices_dest[i*2].z, vertices_ref[i*2].z);
+        ok(compare(vertices_dest[i*2+1].x, vertices_ref[i*2+1].x), "Vertex[%d].normal.x: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].x, vertices_ref[i*2+1].x);
+        ok(compare(vertices_dest[i*2+1].y, vertices_ref[i*2+1].y), "Vertex[%d].normal.y: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].y, vertices_ref[i*2+1].y);
+        ok(compare(vertices_dest[i*2+1].z, vertices_ref[i*2+1].z), "Vertex[%d].normal.z: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].z, vertices_ref[i*2+1].z);
+    }
+    skin_info->lpVtbl->Release(skin_info);
+}
+
 static void test_convert_adjacency_to_point_reps(void)
 {
     HRESULT hr;
@@ -10599,6 +10681,27 @@ cleanup:
     free_test_context(test_context);
 }
 
+static void test_optimize_vertices(void)
+{
+    HRESULT hr;
+    DWORD vertex_remap[3];
+    const DWORD indices[] = {0, 1, 2};
+    const UINT num_faces = 1;
+    const UINT num_vertices = 3;
+
+    hr = D3DXOptimizeVertices(indices, num_faces,
+                              num_vertices, FALSE,
+                              vertex_remap);
+    ok(hr == D3D_OK, "D3DXOptimizeVertices failed. Got %lx, expected D3D_OK.\n", hr);
+
+    /* vertex_remap must not be NULL */
+    hr = D3DXOptimizeVertices(indices, num_faces,
+                              num_vertices, FALSE,
+                              NULL);
+    ok(hr == D3DERR_INVALIDCALL, "D3DXOptimizeVertices passed NULL vertex_remap "
+            "pointer. Got %lx, expected D3DERR_INVALIDCALL.\n", hr);
+}
+
 static void test_optimize_faces(void)
 {
     HRESULT hr;
@@ -11822,11 +11925,13 @@ START_TEST(mesh)
     D3DXGenerateAdjacencyTest();
     test_update_semantics();
     test_create_skin_info();
+    test_update_skinned_mesh();
     test_convert_adjacency_to_point_reps();
     test_convert_point_reps_to_adjacency();
     test_weld_vertices();
     test_clone_mesh();
     test_valid_mesh();
+    test_optimize_vertices();
     test_optimize_faces();
     test_compute_normals();
     test_D3DXFrameFind();
diff --git a/dlls/d3dx9_36/tests/shader.c b/dlls/d3dx9_36/tests/shader.c
index 2b40abe..114cd88 100644
--- a/dlls/d3dx9_36/tests/shader.c
+++ b/dlls/d3dx9_36/tests/shader.c
@@ -6644,6 +6644,214 @@ static void test_fragment_linker(void)
     DestroyWindow(window);
 }
 
+static const DWORD ps_tex[] = {
+    0xffff0103,                                                             /* ps_1_3                       */
+    0x00000042, 0xb00f0000,                                                 /* tex t0                       */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static const DWORD ps_texld_1_4[] = {
+    0xffff0104,                                                             /* ps_1_4                       */
+    0x00000042, 0xb00f0000, 0xa0e40000,                                     /* texld t0, c0                 */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static const DWORD ps_texld_2_0[] = {
+    0xffff0200,                                                             /* ps_2_0                       */
+    0x00000042, 0xb00f0000, 0xa0e40000, 0xa0e40001,                         /* texld t0, c0, c1             */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static const DWORD ps_texcoord[] = {
+    0xffff0103,                                                             /* ps_1_4                       */
+    0x00000040, 0xb00f0000,                                                 /* texcoord t0                  */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static const DWORD ps_texcrd[] = {
+    0xffff0104,                                                             /* ps_2_0                       */
+    0x00000040, 0xb00f0000, 0xa0e40000,                                     /* texcrd t0, c0                */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static const DWORD ps_sincos_2_0[] = {
+    0xffff0200,                                                             /* ps_2_0                       */
+    0x00000025, 0xb00f0000, 0xa0e40000, 0xa0e40001, 0xa0e40002,             /* sincos t0, c0, c1, c2        */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static const DWORD ps_sincos_3_0[] = {
+    0xffff0300,                                                             /* ps_3_0                       */
+    0x00000025, 0xb00f0000, 0xa0e40000,                                     /* sincos t0, c0                */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static const DWORD vs_sincos_2_0[] = {
+    0xfffe0200,                                                             /* vs_2_0                       */
+    0x00000025, 0xb00f0000, 0xa0e40000, 0xa0e40001, 0xa0e40002,             /* sincos a0, c0, c1, c2        */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static const DWORD vs_sincos_3_0[] = {
+    0xfffe0300,                                                             /* vs_3_0                       */
+    0x00000025, 0xb00f0000, 0xa0e40000,                                     /* sincos a0, c0                */
+    0x00000000,                                                             /* nop                          */
+    0x0000ffff};
+
+static void test_disassemble_shader(void)
+{
+    static const char disasm_vs[] = "    vs_1_1\n"
+                                    "    dcl_position v0\n"
+                                    "    dp4 oPos.x, v0, c0\n"
+                                    "    dp4 oPos.y, v0, c1\n"
+                                    "    dp4 oPos.z, v0, c2\n"
+                                    "    dp4 oPos.w, v0, c3\n";
+    static const char disasm_ps[] = "    ps_1_1\n"
+                                    "    def c1, 1, 0, 0, 0\n"
+                                    "    tex t0\n"
+                                    "    dp3 r0, c1, c0\n"
+                                    "    mul r0, v0, r0\n"
+                                    "    mul r0, t0, r0\n";
+    static const char disasm_ps_tex[] =        "    ps_1_3\n"
+                                               "    tex t0\n"
+                                               "    nop\n";
+    static const char disasm_ps_texld_1_4[] =  "    ps_1_4\n"
+                                               "    texld t0, c0\n"
+                                               "    nop\n";
+    static const char disasm_ps_texld_2_0[] =  "    ps_2_0\n"
+                                               "    texld t0, c0, c1\n"
+                                               "    nop\n";
+    static const char disasm_ps_texcoord[] =   "    ps_1_3\n"
+                                               "    texcoord t0\n"
+                                               "    nop\n";
+    static const char disasm_ps_texcrd[] =     "    ps_1_4\n"
+                                               "    texcrd t0, c0\n"
+                                               "    nop\n";
+    static const char disasm_ps_sincos_2_0[] = "    ps_2_0\n"
+                                               "    sincos t0, c0, c1, c2\n"
+                                               "    nop\n";
+    static const char disasm_ps_sincos_3_0[] = "    ps_3_0\n"
+                                               "    sincos t0, c0\n"
+                                               "    nop\n";
+    static const char disasm_vs_sincos_2_0[] = "    vs_2_0\n"
+                                               "    sincos a0, c0, c1, c2\n"
+                                               "    nop\n";
+    static const char disasm_vs_sincos_3_0[] = "    vs_3_0\n"
+                                               "    sincos a0, c0\n"
+                                               "    nop\n";
+    ID3DXBuffer *disassembly;
+    HRESULT ret;
+    char *ptr;
+
+    /* Check wrong parameters */
+    ret = D3DXDisassembleShader(NULL, FALSE, NULL, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXDisassembleShader(NULL, FALSE, NULL, &disassembly);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXDisassembleShader(simple_vs, FALSE, NULL, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+
+    /* Test with vertex shader */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(simple_vs, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_vs, sizeof(disasm_vs) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_vs);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test with pixel shader */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(simple_ps, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_ps, sizeof(disasm_ps) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_ps);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test tex instruction with pixel shader 1.3 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(ps_tex, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_ps_tex, sizeof(disasm_ps_tex) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_ps_tex);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test texld instruction with pixel shader 1.4 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(ps_texld_1_4, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_ps_texld_1_4, sizeof(disasm_ps_texld_1_4) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_ps_texld_1_4);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test texld instruction with pixel shader 2.0 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(ps_texld_2_0, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_ps_texld_2_0, sizeof(disasm_ps_texld_2_0) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_ps_texld_2_0);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test texcoord instruction with pixel shader 1.3 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(ps_texcoord, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_ps_texcoord, sizeof(disasm_ps_texcoord) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_ps_texcoord);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test texcrd instruction with pixel shader 1.4 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(ps_texcrd, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_ps_texcrd, sizeof(disasm_ps_texcrd) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_ps_texcrd);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test sincos instruction pixel shader 2.0 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(ps_sincos_2_0, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_ps_sincos_2_0, sizeof(disasm_ps_sincos_2_0) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_ps_sincos_2_0);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test sincos instruction with pixel shader 3.0 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(ps_sincos_3_0, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_ps_sincos_3_0, sizeof(disasm_ps_sincos_3_0) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_ps_sincos_3_0);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test sincos instruction with pixel shader 2.0 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(vs_sincos_2_0, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_vs_sincos_2_0, sizeof(disasm_vs_sincos_2_0) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_vs_sincos_2_0);
+    ID3DXBuffer_Release(disassembly);
+
+    /* Test sincos instruction with pixel shader 3.0 */
+    disassembly = (void *)0xdeadbeef;
+    ret = D3DXDisassembleShader(vs_sincos_3_0, FALSE, NULL, &disassembly);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ptr = ID3DXBuffer_GetBufferPointer(disassembly);
+    ok(!memcmp(ptr, disasm_vs_sincos_3_0, sizeof(disasm_vs_sincos_3_0) - 1), /* compare beginning */
+       "Returned '%s', expected '%s'\n", ptr, disasm_vs_sincos_3_0);
+    ID3DXBuffer_Release(disassembly);
+
+}
+
 START_TEST(shader)
 {
     test_get_shader_size();
@@ -6659,4 +6867,5 @@ START_TEST(shader)
     test_registerset_defaults();
     test_shader_semantics();
     test_fragment_linker();
+    test_disassemble_shader();
 }
diff --git a/dlls/d3dx9_36/texture.c b/dlls/d3dx9_36/texture.c
index 52cfb1e..ccbe1fc 100644
--- a/dlls/d3dx9_36/texture.c
+++ b/dlls/d3dx9_36/texture.c
@@ -1858,10 +1858,7 @@ HRESULT WINAPI D3DXSaveTextureToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE
     if (!dst_buffer || !src_texture) return D3DERR_INVALIDCALL;
 
     if (file_format == D3DXIFF_DDS)
-    {
-        FIXME("DDS file format isn't supported yet\n");
-        return E_NOTIMPL;
-    }
+        return save_dds_texture_to_memory(dst_buffer, src_texture, src_palette);
 
     type = IDirect3DBaseTexture9_GetType(src_texture);
     switch (type)
diff --git a/dlls/d3dx9_36/util.c b/dlls/d3dx9_36/util.c
index 419bd92..527c502 100644
--- a/dlls/d3dx9_36/util.c
+++ b/dlls/d3dx9_36/util.c
@@ -88,6 +88,7 @@ static const struct pixel_format_desc formats[] =
     {D3DFMT_G32R32F,       { 0, 32, 32,  0}, { 0,  0, 32,  0},  8, 1, 1,  8, FORMAT_ARGBF,   NULL,         NULL      },
     {D3DFMT_A32B32G32R32F, {32, 32, 32, 32}, {96,  0, 32, 64}, 16, 1, 1, 16, FORMAT_ARGBF,   NULL,         NULL      },
     {D3DFMT_P8,            { 8,  8,  8,  8}, { 0,  0,  0,  0},  1, 1, 1,  1, FORMAT_INDEX,   NULL,         index_to_rgba},
+    {D3DFMT_X8L8V8U8,      { 0,  8,  8,  8}, { 0,  0,  8, 16},  4, 1, 1,  4, FORMAT_ARGB,    NULL,         NULL      },
     /* marks last element */
     {D3DFMT_UNKNOWN,       { 0,  0,  0,  0}, { 0,  0,  0,  0},  0, 1, 1,  0, FORMAT_UNKNOWN, NULL,         NULL      },
 };
diff --git a/dlls/d3dx9_37/d3dx9_37.spec b/dlls/d3dx9_37/d3dx9_37.spec
index 5b70701..5bf7f67 100644
--- a/dlls/d3dx9_37/d3dx9_37.spec
+++ b/dlls/d3dx9_37/d3dx9_37.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -229,7 +229,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_38/d3dx9_38.spec b/dlls/d3dx9_38/d3dx9_38.spec
index 5b70701..5bf7f67 100644
--- a/dlls/d3dx9_38/d3dx9_38.spec
+++ b/dlls/d3dx9_38/d3dx9_38.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -229,7 +229,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_39/d3dx9_39.spec b/dlls/d3dx9_39/d3dx9_39.spec
index 5b70701..5bf7f67 100644
--- a/dlls/d3dx9_39/d3dx9_39.spec
+++ b/dlls/d3dx9_39/d3dx9_39.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -229,7 +229,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_40/d3dx9_40.spec b/dlls/d3dx9_40/d3dx9_40.spec
index 5b70701..5bf7f67 100644
--- a/dlls/d3dx9_40/d3dx9_40.spec
+++ b/dlls/d3dx9_40/d3dx9_40.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -229,7 +229,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_41/d3dx9_41.spec b/dlls/d3dx9_41/d3dx9_41.spec
index 5b70701..5bf7f67 100644
--- a/dlls/d3dx9_41/d3dx9_41.spec
+++ b/dlls/d3dx9_41/d3dx9_41.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -229,7 +229,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_42/d3dx9_42.spec b/dlls/d3dx9_42/d3dx9_42.spec
index 4a418d1..69558e0 100644
--- a/dlls/d3dx9_42/d3dx9_42.spec
+++ b/dlls/d3dx9_42/d3dx9_42.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -222,7 +222,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_43/d3dx9_43.spec b/dlls/d3dx9_43/d3dx9_43.spec
index 4a418d1..69558e0 100644
--- a/dlls/d3dx9_43/d3dx9_43.spec
+++ b/dlls/d3dx9_43/d3dx9_43.spec
@@ -24,7 +24,7 @@
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
 @ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
-@ stub D3DXComputeTangent(ptr long long long long ptr)
+@ stdcall D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
 @ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
@@ -222,7 +222,7 @@
 @ stdcall D3DXMatrixTranslation(ptr float float float)
 @ stdcall D3DXMatrixTranspose(ptr ptr)
 @ stdcall D3DXOptimizeFaces(ptr long long long ptr)
-@ stub D3DXOptimizeVertices(ptr long long long ptr)
+@ stdcall D3DXOptimizeVertices(ptr long long long ptr)
 @ stdcall D3DXPlaneFromPointNormal(ptr ptr ptr)
 @ stdcall D3DXPlaneFromPoints(ptr ptr ptr ptr)
 @ stdcall D3DXPlaneIntersectLine(ptr ptr ptr ptr)
diff --git a/dlls/dbghelp/Makefile.in b/dlls/dbghelp/Makefile.in
index 152ef80..06ebb65 100644
--- a/dlls/dbghelp/Makefile.in
+++ b/dlls/dbghelp/Makefile.in
@@ -2,7 +2,7 @@ MODULE    = dbghelp.dll
 IMPORTLIB = dbghelp
 IMPORTS   = kernelbase $(ZLIB_PE_LIBS)
 EXTRAINCL = $(ZLIB_PE_CFLAGS)
-EXTRADEFS = -D_IMAGEHLP_SOURCE_
+EXTRADEFS = -D_IMAGEHLP_SOURCE_ -DBINDIR="L\"${bindir}\""
 
 SOURCES = \
 	coff.c \
diff --git a/dlls/dbghelp/elf_module.c b/dlls/dbghelp/elf_module.c
index 00e69d2..f34396c 100644
--- a/dlls/dbghelp/elf_module.c
+++ b/dlls/dbghelp/elf_module.c
@@ -1455,6 +1455,7 @@ static BOOL elf_search_and_load_file(struct process* pcs, const WCHAR* filename,
         load_elf.elf_info    = elf_info;
 
         ret = search_unix_path(filename, process_getenv(pcs, L"LD_LIBRARY_PATH"), elf_load_file_cb, &load_elf)
+            || search_unix_path(filename, BINDIR, elf_load_file_cb, &load_elf)
             || search_dll_path(pcs, filename, IMAGE_FILE_MACHINE_UNKNOWN, elf_load_file_cb, &load_elf);
     }
 
diff --git a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
index 5887854..25b0bd9 100644
--- a/dlls/ddraw/ddraw.c
+++ b/dlls/ddraw/ddraw.c
@@ -44,37 +44,80 @@ static const DDDEVICEIDENTIFIER2 deviceidentifier =
     0
 };
 
+#define D3D_VERSION(x) (1 << (x))
+
 static struct enum_device_entry
 {
-    char interface_name[100];
+    unsigned int version_mask;
+    /* Some games (Motoracer 2 demo) have the bad idea to modify the device
+     * name/description strings. Let's put the strings in sufficiently sized
+     * arrays in static-lifetime writable memory. */
+    char device_desc[100];
     char device_name[100];
     const GUID *device_guid;
     DWORD unsupported_caps;
-} device_list7[] =
+} device_list[] =
 {
-    /* T&L HAL device */
+    /* Ramp Emulation (D3D 1&2 only) */
     {
-        "WINE Direct3D7 Hardware Transform and Lighting acceleration using WineD3D",
-        "Wine D3D7 T&L HAL",
-        &IID_IDirect3DTnLHalDevice,
+        D3D_VERSION(1) | D3D_VERSION(2),
+        "WineD3D Ramp Software Emulation",
+        "Ramp Emulation",
+        &IID_IDirect3DRampDevice,
         0,
     },
 
-    /* HAL device */
+    /* RGB Emulation (D3D 1-7) */
+    {
+        D3D_VERSION(1) | D3D_VERSION(2) | D3D_VERSION(3) | D3D_VERSION(7),
+        "WineD3D RGB Software Emulation",
+        "RGB Emulation",
+        &IID_IDirect3DRGBDevice,
+        D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION,
+    },
+
+    /* Direct3D HAL (D3D 1-7) */
     {
-        "WINE Direct3D7 Hardware acceleration using WineD3D",
+        D3D_VERSION(1) | D3D_VERSION(2) | D3D_VERSION(3) | D3D_VERSION(7),
+        "WineD3D Hardware Acceleration",
         "Direct3D HAL",
         &IID_IDirect3DHALDevice,
         D3DDEVCAPS_HWTRANSFORMANDLIGHT,
     },
 
-    /* RGB device */
+    /* MMX Emulation (D3D2 only) */
     {
-        "WINE Direct3D7 RGB Software Emulation using WineD3D",
-        "Wine D3D7 RGB",
-        &IID_IDirect3DRGBDevice,
-        D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION,
+        D3D_VERSION(2),
+        "WineD3D MMX Software Emulation",
+        "MMX Emulation",
+        &IID_IDirect3DMMXDevice,
+        0,
     },
+
+    /* Direct3D T&L HAL (D3D7 only) */
+    {
+        D3D_VERSION(7),
+        "WineD3D Hardware Transform and Lighting Acceleration",
+        "Direct3D T&L HAL",
+        &IID_IDirect3DTnLHalDevice,
+        0,
+    },
+
+    /* In the future, we may wish to add the "Reference Rasterizer" and
+     * "Null device", which are only available in DX6-8 and must be explicitly
+     * enabled by the registry values:
+     * * EnumReference
+     * * EnumNullDevice,
+     * which are DWORD values which must be created under
+     * HKLM\Software\Microsoft\Direct3D\Drivers and set to any nonzero value.
+     * (Refer to enablerefrast.reg/disablerefrast.reg in the DX6/7 SDKs and
+     * KB249579 for more information.)
+     *
+     * DirectX 9.0 and higher appear to no longer recognize these settings,
+     * so apparently these devices were removed starting with DX9.
+     *
+     * Some games (AvP, Motoracer 2) break if these devices are enumerated.
+     */
 };
 
 static void STDMETHODCALLTYPE ddraw_null_wined3d_object_destroyed(void *parent) {}
@@ -1415,15 +1458,6 @@ HRESULT ddraw_get_d3dcaps(const struct ddraw *ddraw, D3DDEVICEDESC7 *caps)
         D3DPTADDRESSCAPS_WRAP            | D3DPTADDRESSCAPS_MIRROR             | D3DPTADDRESSCAPS_CLAMP              |
         D3DPTADDRESSCAPS_BORDER          | D3DPTADDRESSCAPS_INDEPENDENTUV);
 
-    if (!(caps->dpcLineCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2))
-    {
-        /* DirectX7 always has the np2 flag set, no matter what the card
-         * supports. Some old games (Rollcage) check the caps incorrectly.
-         * If wined3d supports nonpow2 textures it also has np2 conditional
-         * support. */
-        caps->dpcLineCaps.dwTextureCaps |= D3DPTEXTURECAPS_POW2 | D3DPTEXTURECAPS_NONPOW2CONDITIONAL;
-    }
-
     /* Fill the missing members, and do some fixup */
     caps->dpcLineCaps.dwSize = sizeof(caps->dpcLineCaps);
     caps->dpcLineCaps.dwTextureBlendCaps = D3DPTBLENDCAPS_ADD
@@ -1460,6 +1494,28 @@ HRESULT ddraw_get_d3dcaps(const struct ddraw *ddraw, D3DDEVICEDESC7 *caps)
     return DD_OK;
 }
 
+HRESULT CALLBACK enum_zbuffer(DDPIXELFORMAT *format, void *ctx)
+{
+    DDCAPS *caps = ctx;
+
+    switch (format->dwZBufferBitDepth)
+    {
+        case 8:
+            caps->dwZBufferBitDepths |= DDBD_8;
+            break;
+        case 16:
+            caps->dwZBufferBitDepths |= DDBD_16;
+            break;
+        case 24:
+            caps->dwZBufferBitDepths |= DDBD_24;
+            break;
+        case 32:
+            caps->dwZBufferBitDepths |= DDBD_32;
+            break;
+    }
+    return D3DENUMRET_OK;
+}
+
 /*****************************************************************************
  * IDirectDraw7::GetCaps
  *
@@ -1540,6 +1596,8 @@ static HRESULT WINAPI ddraw7_GetCaps(IDirectDraw7 *iface, DDCAPS *DriverCaps, DD
     caps.dwCaps |= DDCAPS_ALIGNSTRIDE;
     caps.dwAlignStrideAlign = DDRAW_STRIDE_ALIGNMENT;
 
+    IDirect3D7_EnumZBufferFormats(&ddraw->IDirect3D7_iface, &IID_IDirect3DHALDevice, enum_zbuffer, &caps);
+
     caps.ddsOldCaps.dwCaps = caps.ddsCaps.dwCaps;
 
     if(DriverCaps)
@@ -3746,8 +3804,7 @@ static HRESULT WINAPI ddraw1_DuplicateSurface(IDirectDraw *iface, IDirectDrawSur
 /*****************************************************************************
  * IDirect3D7::EnumDevices
  *
- * The EnumDevices method for IDirect3D7. It enumerates all supported
- * D3D7 devices. Currently the T&L, HAL and RGB devices are enumerated.
+ * The EnumDevices method for IDirect3D7. It enumerates all D3D7 devices.
  *
  * Params:
  *  callback: Function to call for each enumerated device
@@ -3779,13 +3836,16 @@ static HRESULT WINAPI d3d7_EnumDevices(IDirect3D7 *iface, LPD3DENUMDEVICESCALLBA
     }
     dev_caps = device_desc7.dwDevCaps;
 
-    for (i = 0; i < ARRAY_SIZE(device_list7); i++)
+    for (i = 0; i < ARRAY_SIZE(device_list); i++)
     {
         HRESULT ret;
 
-        device_desc7.deviceGUID = *device_list7[i].device_guid;
-        device_desc7.dwDevCaps = dev_caps & ~device_list7[i].unsupported_caps;
-        ret = callback(device_list7[i].interface_name, device_list7[i].device_name, &device_desc7, context);
+        if (!(device_list[i].version_mask & D3D_VERSION(ddraw->d3dversion)))
+            continue;
+
+        device_desc7.deviceGUID = *device_list[i].device_guid;
+        device_desc7.dwDevCaps = dev_caps & ~device_list[i].unsupported_caps;
+        ret = callback(device_list[i].device_name, device_list[i].device_name, &device_desc7, context);
         if (ret != DDENUMRET_OK)
         {
             TRACE("Application cancelled the enumeration.\n");
@@ -3801,11 +3861,21 @@ static HRESULT WINAPI d3d7_EnumDevices(IDirect3D7 *iface, LPD3DENUMDEVICESCALLBA
     return D3D_OK;
 }
 
+static void clear_device_desc(D3DDEVICEDESC *device_desc)
+{
+    memset(device_desc, 0, sizeof(*device_desc));
+    device_desc->dwSize = sizeof(*device_desc);
+    device_desc->dtcTransformCaps.dwSize = sizeof(device_desc->dtcTransformCaps);
+    device_desc->dlcLightingCaps.dwSize = sizeof(device_desc->dlcLightingCaps);
+    device_desc->dpcLineCaps.dwSize = sizeof(device_desc->dpcLineCaps);
+    device_desc->dpcTriCaps.dwSize = sizeof(device_desc->dpcTriCaps);
+}
+
 /*****************************************************************************
  * IDirect3D3::EnumDevices
  *
- * Enumerates all supported Direct3DDevice interfaces. This is the
- * implementation for Direct3D 1 to Direc3D 3, Version 7 has its own.
+ * Enumerates all Direct3DDevice interfaces. This is the implementation for
+ * Direct3D 1 to Direct3D 3; Version 7 has its own.
  *
  * Versions 1, 2 and 3
  *
@@ -3820,18 +3890,18 @@ static HRESULT WINAPI d3d7_EnumDevices(IDirect3D7 *iface, LPD3DENUMDEVICESCALLBA
  *****************************************************************************/
 static HRESULT WINAPI d3d3_EnumDevices(IDirect3D3 *iface, LPD3DENUMDEVICESCALLBACK callback, void *context)
 {
-    static CHAR wined3d_description[] = "Wine D3DDevice using WineD3D and OpenGL";
-
+/* Size of D3DDEVICEDESC in Direct3D 1-3 */
+enum {
+    D3D1_DESC_SIZE = FIELD_OFFSET(D3DDEVICEDESC, dwMinTextureWidth), /* 172 */
+    D3D2_DESC_SIZE = FIELD_OFFSET(D3DDEVICEDESC, dwMaxTextureRepeat), /* 204 */
+    D3D3_DESC_SIZE = sizeof(D3DDEVICEDESC) /* 252 */
+};
     struct ddraw *ddraw = impl_from_IDirect3D3(iface);
-    D3DDEVICEDESC device_desc1, hal_desc, hel_desc;
+    DWORD desc_size;
+    D3DDEVICEDESC device_desc1, empty_desc1, hal_desc, hel_desc;
     D3DDEVICEDESC7 device_desc7;
     HRESULT hr;
-
-    /* Some games (Motoracer 2 demo) have the bad idea to modify the device
-     * name string. Let's put the string in a sufficiently sized array in
-     * writable memory. */
-    char device_name[50];
-    strcpy(device_name,"Direct3D HEL");
+    size_t i;
 
     TRACE("iface %p, callback %p, context %p.\n", iface, callback, context);
 
@@ -3840,55 +3910,60 @@ static HRESULT WINAPI d3d3_EnumDevices(IDirect3D3 *iface, LPD3DENUMDEVICESCALLBA
 
     wined3d_mutex_lock();
 
+    switch (ddraw->d3dversion)
+    {
+        case 1:  desc_size = D3D1_DESC_SIZE; break;
+        case 2:  desc_size = D3D2_DESC_SIZE; break;
+        default: desc_size = D3D3_DESC_SIZE; break;
+    }
+
     if (FAILED(hr = ddraw_get_d3dcaps(ddraw, &device_desc7)))
     {
         wined3d_mutex_unlock();
         return hr;
     }
+
     ddraw_d3dcaps1_from_7(&device_desc1, &device_desc7);
+    device_desc1.dwSize = desc_size;
 
-    /* Do I have to enumerate the reference id? Note from old d3d7:
-     * "It seems that enumerating the reference IID on Direct3D 1 games
-     * (AvP / Motoracer2) breaks them". So do not enumerate this iid in V1
-     *
-     * There's a registry key HKLM\Software\Microsoft\Direct3D\Drivers,
-     * EnumReference which enables / disables enumerating the reference
-     * rasterizer. It's a DWORD, 0 means disabled, 2 means enabled. The
-     * enablerefrast.reg and disablerefrast.reg files in the DirectX 7.0 sdk
-     * demo directory suggest this.
-     *
-     * Some games(GTA 2) seem to use the second enumerated device, so I have
-     * to enumerate at least 2 devices. So enumerate the reference device to
-     * have 2 devices.
-     *
-     * Other games (Rollcage) tell emulation and hal device apart by certain
-     * flags. Rollcage expects D3DPTEXTURECAPS_POW2 to be set (yeah, it is a
-     * limitation flag), and it refuses all devices that have the perspective
-     * flag set. This way it refuses the emulation device, and HAL devices
-     * never have POW2 unset in d3d7 on windows. */
-    if (ddraw->d3dversion != 1)
-    {
-        static CHAR reference_description[] = "RGB Direct3D emulation";
-
-        TRACE("Enumerating WineD3D D3DDevice interface.\n");
-        hal_desc = device_desc1;
-        hel_desc = device_desc1;
-        /* The rgb device has the pow2 flag set in the hel caps, but not in the hal caps. */
-        hal_desc.dpcLineCaps.dwTextureCaps &= ~(D3DPTEXTURECAPS_POW2
-                | D3DPTEXTURECAPS_NONPOW2CONDITIONAL | D3DPTEXTURECAPS_PERSPECTIVE);
-        hal_desc.dpcTriCaps.dwTextureCaps &= ~(D3DPTEXTURECAPS_POW2
-                | D3DPTEXTURECAPS_NONPOW2CONDITIONAL | D3DPTEXTURECAPS_PERSPECTIVE);
-        /* RGB, RAMP and MMX devices have a HAL dcmColorModel of 0 */
-        hal_desc.dcmColorModel = 0;
-        /* RGB, RAMP and MMX devices cannot report HAL hardware flags */
-        hal_desc.dwFlags = 0;
-        /* RGB, REF, RAMP and MMX devices don't report hardware transform and lighting capability */
-        hal_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION);
-        hel_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION);
-
-        hr = callback((GUID *)&IID_IDirect3DRGBDevice, reference_description,
-                device_name, &hal_desc, &hel_desc, context);
-        if (hr != D3DENUMRET_OK)
+    clear_device_desc(&empty_desc1);
+    empty_desc1.dwSize = desc_size;
+
+    for (i = 0; i < ARRAY_SIZE(device_list); i++)
+    {
+        if (!(device_list[i].version_mask & D3D_VERSION(ddraw->d3dversion)))
+            continue;
+
+        if (IsEqualGUID(&IID_IDirect3DHALDevice, device_list[i].device_guid))
+        {
+            hal_desc = device_desc1;
+
+            /* The HAL device's hel_desc is almost empty -- but not completely */
+            hel_desc = empty_desc1;
+            hel_desc.dwFlags = D3DDD_COLORMODEL | D3DDD_DEVCAPS | D3DDD_TRANSFORMCAPS
+                | D3DDD_LIGHTINGCAPS | D3DDD_BCLIPPING;
+            hel_desc.dcmColorModel = 0;
+            hel_desc.dwDevCaps = D3DDEVCAPS_FLOATTLVERTEX;
+            hel_desc.dtcTransformCaps.dwCaps = hal_desc.dtcTransformCaps.dwCaps;
+            hel_desc.dlcLightingCaps = hal_desc.dlcLightingCaps;
+            hel_desc.bClipping = hal_desc.bClipping;
+            hel_desc.dwMaxVertexCount = hal_desc.dwMaxVertexCount;
+        }
+        else
+        {
+            hal_desc = empty_desc1;
+
+            hel_desc = device_desc1;
+            /* Ramp device supports grayscale only */
+            if (IsEqualGUID(&IID_IDirect3DRampDevice, device_list[i].device_guid))
+                hel_desc.dcmColorModel = D3DCOLOR_MONO;
+            /* RGB, REF, RAMP and MMX devices don't report hardware transform and lighting capability */
+            hel_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWRASTERIZATION);
+        }
+
+        hr = callback((GUID *)device_list[i].device_guid, device_list[i].device_desc,
+                device_list[i].device_name, &hal_desc, &hel_desc, context);
+        if (hr != DDENUMRET_OK)
         {
             TRACE("Application cancelled the enumeration.\n");
             wined3d_mutex_unlock();
@@ -3896,31 +3971,6 @@ static HRESULT WINAPI d3d3_EnumDevices(IDirect3D3 *iface, LPD3DENUMDEVICESCALLBA
         }
     }
 
-    strcpy(device_name,"Direct3D HAL");
-
-    TRACE("Enumerating HAL Direct3D device.\n");
-    hal_desc = device_desc1;
-    hel_desc = device_desc1;
-
-    /* The hal device does not have the pow2 flag set in hel, but in hal. */
-    hel_desc.dpcLineCaps.dwTextureCaps &= ~(D3DPTEXTURECAPS_POW2
-            | D3DPTEXTURECAPS_NONPOW2CONDITIONAL | D3DPTEXTURECAPS_PERSPECTIVE);
-    hel_desc.dpcTriCaps.dwTextureCaps &= ~(D3DPTEXTURECAPS_POW2
-            | D3DPTEXTURECAPS_NONPOW2CONDITIONAL | D3DPTEXTURECAPS_PERSPECTIVE);
-    /* HAL devices have a HEL dcmColorModel of 0 */
-    hel_desc.dcmColorModel = 0;
-    /* HAL devices report hardware transform and lighting capability, but not in hel */
-    hel_desc.dwDevCaps &= ~(D3DDEVCAPS_HWTRANSFORMANDLIGHT | D3DDEVCAPS_DRAWPRIMITIVES2EX);
-
-    hr = callback((GUID *)&IID_IDirect3DHALDevice, wined3d_description,
-            device_name, &hal_desc, &hel_desc, context);
-    if (hr != D3DENUMRET_OK)
-    {
-        TRACE("Application cancelled the enumeration.\n");
-        wined3d_mutex_unlock();
-        return D3D_OK;
-    }
-
     TRACE("End of enumeration.\n");
 
     wined3d_mutex_unlock();
diff --git a/dlls/ddraw/ddraw_private.h b/dlls/ddraw/ddraw_private.h
index 6fc93b9..c90b894 100644
--- a/dlls/ddraw/ddraw_private.h
+++ b/dlls/ddraw/ddraw_private.h
@@ -338,6 +338,11 @@ struct d3d_device
     struct d3d_viewport *current_viewport;
     D3DVIEWPORT7 active_viewport;
 
+    /* Pick data */
+    D3DPICKRECORD *pick_records;
+    DWORD pick_record_count;
+    DWORD pick_record_size;
+
     /* Required to keep track which of two available texture blending modes in d3ddevice3 is used */
     BOOL legacyTextureBlending;
     D3DTEXTUREBLEND texture_map_blend;
@@ -571,7 +576,7 @@ struct d3d_execute_buffer *unsafe_impl_from_IDirect3DExecuteBuffer(IDirect3DExec
 
 /* The execute function */
 HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *execute_buffer,
-        struct d3d_device *device);
+        struct d3d_device *device, D3DRECT *pick_rect);
 
 /*****************************************************************************
  * IDirect3DVertexBuffer
diff --git a/dlls/ddraw/device.c b/dlls/ddraw/device.c
index bc1d91e..82a813f 100644
--- a/dlls/ddraw/device.c
+++ b/dlls/ddraw/device.c
@@ -349,6 +349,9 @@ static ULONG WINAPI d3d_device_inner_Release(IUnknown *iface)
             IDirect3DDevice3_DeleteViewport(&This->IDirect3DDevice3_iface, &vp->IDirect3DViewport3_iface);
         }
 
+        if (This->pick_record_size > 0)
+            free(This->pick_records);
+
         TRACE("Releasing render target %p.\n", This->rt_iface);
         rt_iface = This->rt_iface;
         This->rt_iface = NULL;
@@ -758,7 +761,7 @@ static HRESULT WINAPI d3d_device1_Execute(IDirect3DDevice *iface,
 
     /* Execute... */
     wined3d_mutex_lock();
-    hr = d3d_execute_buffer_execute(buffer, device);
+    hr = d3d_execute_buffer_execute(buffer, device, NULL);
     wined3d_mutex_unlock();
 
     return hr;
@@ -1025,16 +1028,44 @@ static HRESULT WINAPI d3d_device1_NextViewport(IDirect3DDevice *iface,
  *        x2 and y2 are ignored.
  *
  * Returns:
- *  D3D_OK because it's a stub
+ *  D3D_OK on success
+ *  DDERR_INVALIDPARAMS if any of the parameters == NULL
  *
  *****************************************************************************/
 static HRESULT WINAPI d3d_device1_Pick(IDirect3DDevice *iface, IDirect3DExecuteBuffer *buffer,
         IDirect3DViewport *viewport, DWORD flags, D3DRECT *rect)
 {
-    FIXME("iface %p, buffer %p, viewport %p, flags %#lx, rect %s stub!\n",
-            iface, buffer, viewport, flags, wine_dbgstr_rect((RECT *)rect));
+    struct d3d_device *device = impl_from_IDirect3DDevice(iface);
+    struct d3d_execute_buffer *buffer_impl = unsafe_impl_from_IDirect3DExecuteBuffer(buffer);
+    struct d3d_viewport *viewport_impl = unsafe_impl_from_IDirect3DViewport(viewport);
+    HRESULT hr;
 
-    return D3D_OK;
+    TRACE("iface %p, buffer %p, viewport %p, flags %#lx, rect %s.\n",
+             iface, buffer, viewport, flags, wine_dbgstr_rect((RECT *)rect));
+
+    /* Sanity checks */
+    if (!buffer)
+    {
+        WARN("NULL buffer, returning DDERR_INVALIDPARAMS\n");
+        return DDERR_INVALIDPARAMS;
+    }
+
+    if (!viewport)
+    {
+        WARN("NULL viewport, returning DDERR_INVALIDPARAMS\n");
+        return DDERR_INVALIDPARAMS;
+    }
+
+    if (FAILED(hr = IDirect3DDevice3_SetCurrentViewport
+            (&device->IDirect3DDevice3_iface, &viewport_impl->IDirect3DViewport3_iface)))
+        return hr;
+
+    /* Execute the pick */
+    wined3d_mutex_lock();
+    hr = d3d_execute_buffer_execute(buffer_impl, device, rect);
+    wined3d_mutex_unlock();
+
+    return hr;
 }
 
 /*****************************************************************************
@@ -1050,13 +1081,35 @@ static HRESULT WINAPI d3d_device1_Pick(IDirect3DDevice *iface, IDirect3DExecuteB
  *  D3DPickRec: Address to store the resulting D3DPICKRECORD array.
  *
  * Returns:
- *  D3D_OK, because it's a stub
+ *  D3D_OK always
  *
  *****************************************************************************/
 static HRESULT WINAPI d3d_device1_GetPickRecords(IDirect3DDevice *iface,
         DWORD *count, D3DPICKRECORD *records)
 {
-    FIXME("iface %p, count %p, records %p stub!\n", iface, count, records);
+    struct d3d_device *device;
+
+    TRACE("iface %p, count %p, records %p.\n", iface, count, records);
+
+    /* Windows doesn't check if count is non-NULL */
+
+    wined3d_mutex_lock();
+
+    device = impl_from_IDirect3DDevice(iface);
+
+    /* Set count to the number of pick records we have */
+    *count = device->pick_record_count;
+
+    /* It is correct usage according to documentation to call this function with records == NULL
+       to retrieve _just_ the record count, which the caller can then use to allocate an
+       appropriately sized array, then call this function again to fill that array with data. */
+    if (records && count)
+    {
+        /* If we have a destination array and records to copy, copy them now */
+        memcpy(records, device->pick_records, sizeof(*device->pick_records) * device->pick_record_count);
+    }
+
+    wined3d_mutex_unlock();
 
     return D3D_OK;
 }
diff --git a/dlls/ddraw/executebuffer.c b/dlls/ddraw/executebuffer.c
index 320ce66..84366da 100644
--- a/dlls/ddraw/executebuffer.c
+++ b/dlls/ddraw/executebuffer.c
@@ -45,15 +45,106 @@ static void _dump_D3DEXECUTEBUFFERDESC(const D3DEXECUTEBUFFERDESC *lpDesc) {
     TRACE("lpData       : %p\n", lpDesc->lpData);
 }
 
-HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d_device *device)
+#define TRIANGLE_SIZE 3
+/*****************************************************************************
+ * d3d_execute_buffer_pick_test
+ *
+ * Determines whether a "point" is inside a "triangle". Mainly used when
+ * executing a "pick" from an execute buffer to determine whether a pixel
+ * coordinate (often a mouse coordinate) is inside a triangle (and
+ * therefore clicking or hovering over a 3D object in the scene). This
+ * function uses triangle rasterization algorithms to determine if the
+ * pixel falls inside (using the top-left rule, in accordance with
+ * documentation).
+ *
+ * Params:
+ *  x:     The X coordinate of the point to verify.
+ *  y:     The Y coordinate of the point to verify.
+ *  verts: An array of vertices describing the screen coordinates of the
+ *         triangle. This function expects 3 elements in this array.
+ *
+ * Returns:
+ *  TRUE if the pixel coordinate is inside this triangle
+ *  FALSE if not
+ *
+ *****************************************************************************/
+static BOOL d3d_execute_buffer_pick_test(LONG x, LONG y, D3DTLVERTEX* verts)
+{
+    UINT i;
+
+    for (i = 0; i < TRIANGLE_SIZE; i++)
+    {
+        D3DTLVERTEX* v1 = &verts[(i)     % TRIANGLE_SIZE];
+        D3DTLVERTEX* v2 = &verts[(i + 1) % TRIANGLE_SIZE];
+        D3DVALUE bias = 0.0f;
+
+        /* Edge function - determines whether pixel is inside triangle */
+        D3DVALUE w = (v2->sx - v1->sx) * (y - v1->sy) - (v2->sy - v1->sy) * (x - v1->sx);
+
+        /* Force top-left rule */
+        if ((v1->sy == v2->sy && v1->sx > v2->sx) || (v1->sy < v2->sy))
+            bias = 1.0f;
+
+        if (w < bias)
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+/*****************************************************************************
+ * d3d_execute_buffer_z_value_at_coords
+ *
+ * Returns the Z point of a triangle given an X, Y coordinate somewhere inside
+ * the triangle. Used as the `dvZ` parameter of D3DPICKRECORD.
+ *
+ * Params:
+ *  x:     The X coordinate of the point to verify.
+ *  y:     The Y coordinate of the point to verify.
+ *  verts: An array of vertices describing the screen coordinates of the
+ *         triangle. This function expects 3 elements in this array.
+ *
+ * Returns:
+ *  A floating-point Z value that can be used directly as the dvZ member of a
+ *  D3DPICKRECORD.
+ *
+ *****************************************************************************/
+static D3DVALUE d3d_execute_buffer_z_value_at_coords(LONG x, LONG y, D3DTLVERTEX* verts)
+{
+    UINT i;
+
+    D3DVALUE z1 = 0;
+    D3DVALUE z2 = 0;
+
+    for (i = 0; i < TRIANGLE_SIZE; i++)
+    {
+        D3DTLVERTEX* v1 = &verts[i];
+        D3DTLVERTEX* v2 = &verts[(i + 1) % TRIANGLE_SIZE];
+        D3DTLVERTEX* v3 = &verts[(i + 2) % TRIANGLE_SIZE];
+
+        z1 += v3->sz * (x - v1->sx) * (y - v2->sy) - v2->sz * (x - v1->sx) * (y - v3->sy);
+        z2 += (x - v1->sx) * (y - v2->sy) - (x - v1->sx) * (y - v3->sy);
+    }
+
+    return z1 / z2;
+}
+
+HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d_device *device,
+    D3DRECT* pick_rect)
 {
     DWORD is = buffer->data.dwInstructionOffset;
     char *instr = (char *)buffer->desc.lpData + is;
     unsigned int i, primitive_size;
-    struct wined3d_map_desc map_desc;
+    struct wined3d_map_desc map_desc, vert_map_desc;
     struct wined3d_box box = {0};
     HRESULT hr;
 
+    /* Variables used for picking */
+    const unsigned int vertex_size = get_flexible_vertex_size(D3DFVF_TLVERTEX);
+    D3DTLVERTEX verts[TRIANGLE_SIZE];
+
+    device->pick_record_count = 0;
+
     TRACE("ExecuteData :\n");
     if (TRACE_ON(ddraw))
         _dump_executedata(&(buffer->data));
@@ -69,6 +160,26 @@ HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d
         instr += sizeof(*current);
         primitive_size = 0;
 
+        if (pick_rect != NULL)
+        {
+            switch (current->bOpcode)
+            {
+                /* None of these opcodes seem to be necessary for picking */
+                case D3DOP_POINT:
+                case D3DOP_LINE:
+                case D3DOP_STATETRANSFORM:
+                case D3DOP_STATELIGHT:
+                case D3DOP_STATERENDER:
+                case D3DOP_TEXTURELOAD:
+                case D3DOP_SPAN:
+                    FIXME("ignoring opcode %d for picking\n", current->bOpcode);
+                    instr += count * size;
+                    continue;
+                default:
+                    break;
+            }
+        }
+
         switch (current->bOpcode)
         {
             case D3DOP_POINT:
@@ -174,6 +285,66 @@ HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d
                     {
                         case 3:
                             indices[(i * primitive_size) + 2] = ci->v3;
+
+                            if (pick_rect != NULL) {
+                                UINT j;
+
+                                /* Get D3DTLVERTEX objects for each triangle vertex */
+                                for (j = 0; j < TRIANGLE_SIZE; j++) {
+
+                                    /* Get index of vertex from D3DTRIANGLE struct */
+                                    switch (j) {
+                                    case 0: box.left = vertex_size * ci->v1; break;
+                                    case 1: box.left = vertex_size * ci->v2; break;
+                                    case 2: box.left = vertex_size * ci->v3; break;
+                                    }
+
+                                    box.right = box.left + vertex_size;
+                                    if (FAILED(hr = wined3d_resource_map(wined3d_buffer_get_resource(buffer->dst_vertex_buffer),
+                                            0, &vert_map_desc, &box, WINED3D_MAP_WRITE))) {
+                                        return hr;
+                                    } else {
+                                        /* Copy vert data into stack array */
+                                        verts[j] = *((D3DTLVERTEX*)vert_map_desc.data);
+
+                                        wined3d_resource_unmap(wined3d_buffer_get_resource(buffer->dst_vertex_buffer), 0);
+                                    }
+                                }
+
+                                /* Use vertices acquired above to test for clicking */
+                                if (d3d_execute_buffer_pick_test(pick_rect->x1, pick_rect->y1, verts))
+                                {
+                                    D3DPICKRECORD* record;
+
+                                    device->pick_record_count++;
+
+                                    /* Grow the array if necessary */
+                                    if (device->pick_record_count > device->pick_record_size)
+                                    {
+                                        if (device->pick_record_size == 0) device->pick_record_size = 1;
+                                        device->pick_record_size *= 2;
+                                        device->pick_records = realloc(device->pick_records,
+                                            sizeof(*device->pick_records) * device->pick_record_size);
+                                    }
+
+                                    /* Fill record parameters */
+                                    record = &device->pick_records[device->pick_record_count - 1];
+
+                                    record->bOpcode = current->bOpcode;
+                                    record->bPad = 0;
+
+                                    /* Write current instruction offset into file */
+                                    record->dwOffset = (DWORD_PTR)instr - (DWORD_PTR)buffer->desc.lpData - is;
+
+                                    /* Formula for returning the Z value at this X/Y */
+                                    record->dvZ = d3d_execute_buffer_z_value_at_coords(pick_rect->x1, pick_rect->y1, verts);
+
+                                    /* We have a successful pick so we can skip the rest of the triangles */
+                                    instr += size * (count - i - 1);
+                                    count = i;
+                                }
+                            }
+
                             /* Drop through. */
                         case 2:
                             indices[(i * primitive_size) + 1] = ci->v2;
@@ -426,6 +597,7 @@ HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer, struct d3d
 end_of_buffer:
     return D3D_OK;
 }
+#undef TRIANGLE_SIZE
 
 static inline struct d3d_execute_buffer *impl_from_IDirect3DExecuteBuffer(IDirect3DExecuteBuffer *iface)
 {
diff --git a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
index d0c4bf6..cbfa6aa 100644
--- a/dlls/ddraw/surface.c
+++ b/dlls/ddraw/surface.c
@@ -5503,6 +5503,46 @@ static struct ddraw_surface *get_sub_mimaplevel(struct ddraw_surface *surface)
     return impl_from_IDirectDrawSurface7(next_level);
 }
 
+static BOOL compare_format(DDPIXELFORMAT *format1, DDPIXELFORMAT *format2)
+{
+    if ((format1->dwFlags & (DDPF_RGB|DDPF_YUV|DDPF_FOURCC)) !=
+        (format2->dwFlags & (DDPF_RGB|DDPF_YUV|DDPF_FOURCC)))
+        return FALSE;
+
+    if (format1->dwFlags & (DDPF_RGB|DDPF_YUV))
+    {
+        if (!(format1->dwFlags & DDPF_ALPHA))
+        {
+            /* The RGB and YUV bits are stored in the same fields */
+            if (format1->dwRGBBitCount != format2->dwRGBBitCount)
+                return FALSE;
+
+            if (format1->dwRBitMask != format2->dwRBitMask)
+                return FALSE;
+
+            if (format1->dwGBitMask != format2->dwGBitMask)
+                return FALSE;
+
+            if (format1->dwBBitMask != format2->dwBBitMask)
+                return FALSE;
+        }
+
+        if (format1->dwFlags & (DDPF_ALPHAPIXELS | DDPF_ALPHA))
+        {
+            if (format1->dwRGBAlphaBitMask != format2->dwRGBAlphaBitMask)
+                return FALSE;
+        }
+    }
+
+    if (format1->dwFlags & DDPF_FOURCC)
+    {
+        if (format1->dwFourCC != format2->dwFourCC)
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
 /*****************************************************************************
  * IDirect3DTexture2::Load
  *
@@ -5524,7 +5564,7 @@ static HRESULT WINAPI d3d_texture2_Load(IDirect3DTexture2 *iface, IDirect3DTextu
 {
     struct ddraw_surface *dst_surface = impl_from_IDirect3DTexture2(iface);
     struct ddraw_surface *src_surface = unsafe_impl_from_IDirect3DTexture2(src_texture);
-    struct wined3d_resource *dst_resource, *src_resource;
+    RECT src_rect, dst_rect;
     HRESULT hr;
 
     TRACE("iface %p, src_texture %p.\n", iface, src_texture);
@@ -5537,90 +5577,62 @@ static HRESULT WINAPI d3d_texture2_Load(IDirect3DTexture2 *iface, IDirect3DTextu
 
     wined3d_mutex_lock();
 
-    dst_resource = wined3d_texture_get_resource(ddraw_surface_get_default_texture(dst_surface, DDRAW_SURFACE_WRITE));
-    src_resource = wined3d_texture_get_resource(ddraw_surface_get_default_texture(src_surface, DDRAW_SURFACE_READ));
-
-    if (((src_surface->surface_desc.ddsCaps.dwCaps & DDSCAPS_MIPMAP)
-            != (dst_surface->surface_desc.ddsCaps.dwCaps & DDSCAPS_MIPMAP))
-            || (src_surface->surface_desc.dwMipMapCount != dst_surface->surface_desc.dwMipMapCount))
-    {
-        ERR("Trying to load surfaces with different mip-map counts.\n");
-    }
-
     for (;;)
     {
-        struct ddraw_palette *dst_pal, *src_pal;
-        DDSURFACEDESC *src_desc, *dst_desc;
+        DDSURFACEDESC *src_desc = (DDSURFACEDESC *)&src_surface->surface_desc;
 
         TRACE("Copying surface %p to surface %p.\n", src_surface, dst_surface);
 
-        /* Suppress the ALLOCONLOAD flag */
-        dst_surface->surface_desc.ddsCaps.dwCaps &= ~DDSCAPS_ALLOCONLOAD;
-
-        /* Get the palettes */
-        dst_pal = dst_surface->palette;
-        src_pal = src_surface->palette;
-
-        if (src_pal)
+        if (compare_format(&src_surface->surface_desc.ddpfPixelFormat,
+                           &dst_surface->surface_desc.ddpfPixelFormat))
         {
-            PALETTEENTRY palent[256];
+            struct ddraw_palette *dst_pal, *src_pal;
 
-            if (!dst_pal)
-            {
-                wined3d_mutex_unlock();
-                return DDERR_NOPALETTEATTACHED;
-            }
-            IDirectDrawPalette_GetEntries(&src_pal->IDirectDrawPalette_iface, 0, 0, 256, palent);
-            IDirectDrawPalette_SetEntries(&dst_pal->IDirectDrawPalette_iface, 0, 0, 256, palent);
-        }
+            /* Get the palettes */
+            dst_pal = dst_surface->palette;
+            src_pal = src_surface->palette;
 
-        /* Copy one surface on the other */
-        dst_desc = (DDSURFACEDESC *)&(dst_surface->surface_desc);
-        src_desc = (DDSURFACEDESC *)&(src_surface->surface_desc);
+            if (src_pal)
+            {
+                PALETTEENTRY palent[256];
 
-        if ((src_desc->dwWidth != dst_desc->dwWidth) || (src_desc->dwHeight != dst_desc->dwHeight))
-        {
-            /* Should also check for same pixel format, lPitch, ... */
-            ERR("Error in surface sizes.\n");
-            wined3d_mutex_unlock();
-            return D3DERR_TEXTURE_LOAD_FAILED;
-        }
-        else
-        {
-            struct wined3d_map_desc src_map_desc, dst_map_desc;
+                if (!dst_pal)
+                {
+                    wined3d_mutex_unlock();
+                    return DDERR_NOPALETTEATTACHED;
+                }
+                IDirectDrawPalette_GetEntries(&src_pal->IDirectDrawPalette_iface, 0, 0, 256, palent);
+                IDirectDrawPalette_SetEntries(&dst_pal->IDirectDrawPalette_iface, 0, 0, 256, palent);
+            }
 
-            /* Copy the src blit color key if the source has one, don't erase
-             * the destination's ckey if the source has none */
             if (src_desc->dwFlags & DDSD_CKSRCBLT)
             {
                 IDirectDrawSurface7_SetColorKey(&dst_surface->IDirectDrawSurface7_iface,
                         DDCKEY_SRCBLT, &src_desc->ddckCKSrcBlt);
             }
+        }
+        else
+        {
+            if (src_desc->dwFlags & DDSD_CKSRCBLT)
+                return E_FAIL;
+        }
 
-            if (FAILED(hr = wined3d_resource_map(src_resource,
-                    src_surface->sub_resource_idx, &src_map_desc, NULL, WINED3D_MAP_READ)))
-            {
-                ERR("Failed to lock source surface, hr %#lx.\n", hr);
-                wined3d_mutex_unlock();
-                return D3DERR_TEXTURE_LOAD_FAILED;
-            }
-
-            if (FAILED(hr = wined3d_resource_map(dst_resource,
-                    dst_surface->sub_resource_idx, &dst_map_desc, NULL, WINED3D_MAP_WRITE)))
-            {
-                ERR("Failed to lock destination surface, hr %#lx.\n", hr);
-                wined3d_resource_unmap(src_resource, src_surface->sub_resource_idx);
-                wined3d_mutex_unlock();
-                return D3DERR_TEXTURE_LOAD_FAILED;
-            }
+        /* Suppress the ALLOCONLOAD flag */
+        dst_surface->surface_desc.ddsCaps.dwCaps &= ~DDSCAPS_ALLOCONLOAD;
 
-            if (dst_surface->surface_desc.ddpfPixelFormat.dwFlags & DDPF_FOURCC)
-                memcpy(dst_map_desc.data, src_map_desc.data, src_surface->surface_desc.dwLinearSize);
-            else
-                memcpy(dst_map_desc.data, src_map_desc.data, src_map_desc.row_pitch * src_desc->dwHeight);
+        SetRect(&src_rect, 0, 0, src_surface->surface_desc.dwWidth, src_surface->surface_desc.dwHeight);
+        SetRect(&dst_rect, 0, 0, dst_surface->surface_desc.dwWidth, dst_surface->surface_desc.dwHeight);
 
-            wined3d_resource_unmap(dst_resource, dst_surface->sub_resource_idx);
-            wined3d_resource_unmap(src_resource, src_surface->sub_resource_idx);
+        hr = wined3d_device_context_blt(dst_surface->ddraw->immediate_context,
+                ddraw_surface_get_default_texture(dst_surface, DDRAW_SURFACE_WRITE),
+                dst_surface->sub_resource_idx, &dst_rect,
+                ddraw_surface_get_default_texture(src_surface, DDRAW_SURFACE_READ),
+                src_surface->sub_resource_idx, &src_rect, 0, NULL, WINED3D_TEXF_LINEAR);
+        if (FAILED(hr))
+        {
+            ERR("Failed to blit surface, hr %#lx.\n", hr);
+            wined3d_mutex_unlock();
+            return hr;
         }
 
         if (src_surface->surface_desc.ddsCaps.dwCaps & DDSCAPS_MIPMAP)
@@ -5633,12 +5645,11 @@ static HRESULT WINAPI d3d_texture2_Load(IDirect3DTexture2 *iface, IDirect3DTextu
         else
             dst_surface = NULL;
 
+        if (src_surface && !dst_surface)
+            return DDERR_NOTFOUND;
+
         if (!src_surface || !dst_surface)
-        {
-            if (src_surface != dst_surface)
-                ERR("Loading surface with different mipmap structure.\n");
             break;
-        }
     }
 
     wined3d_mutex_unlock();
diff --git a/dlls/ddraw/tests/d3d.c b/dlls/ddraw/tests/d3d.c
index 5958df5..6153ed2 100644
--- a/dlls/ddraw/tests/d3d.c
+++ b/dlls/ddraw/tests/d3d.c
@@ -1057,6 +1057,288 @@ static BOOL colortables_check_equality(PALETTEENTRY table1[256], PALETTEENTRY ta
     return TRUE;
 }
 
+static void fill_surface(IDirectDrawSurface *surface, DWORD fillcolor, int level)
+{
+    DDSCAPS caps = {DDSCAPS_COMPLEX};
+    IDirectDrawSurface *surface2;
+    DDSURFACEDESC ddsd;
+    DWORD x, y;
+    HRESULT hr;
+    int curlevel = -1;
+
+    IDirectDrawSurface_AddRef(surface);
+
+    while (surface)
+    {
+        curlevel++;
+
+        if (level == -1 || curlevel == level)
+        {
+            memset(&ddsd, 0, sizeof(ddsd));
+            ddsd.dwSize = sizeof(ddsd);
+
+            hr = IDirectDrawSurface_Lock(surface, NULL, &ddsd, DDLOCK_WAIT, NULL);
+            ok(hr == DD_OK, "IDirectDrawSurface_Lock returned: %lx\n", hr);
+
+            for (y = 0; y < ddsd.dwHeight; y++)
+            {
+                if (ddsd.ddpfPixelFormat.dwRGBBitCount == 32)
+                {
+                    DWORD *textureRow = (DWORD *)((char *)ddsd.lpSurface + y * ddsd.lPitch);
+                    for (x = 0; x < ddsd.dwWidth;  x++)
+                        *textureRow++ = fillcolor;
+                }
+                else if (ddsd.ddpfPixelFormat.dwRGBBitCount == 16)
+                {
+                    WORD *textureRow = (WORD *)((char *)ddsd.lpSurface + y * ddsd.lPitch);
+                    for (x = 0; x < ddsd.dwWidth;  x++)
+                        *textureRow++ = fillcolor;
+                }
+                else
+                {
+                    ok(0, "Unsupported format!\n");
+                    break;
+                }
+            }
+
+            hr = IDirectDrawSurface_Unlock(surface, NULL);
+            ok(hr == DD_OK, "IDirectDrawSurface_Unlock returned: %lx\n", hr);
+        }
+
+        if (level != -1 && curlevel >= level)
+        {
+            IDirectDrawSurface_Release(surface);
+            break;
+        }
+
+        if (IDirectDrawSurface_GetAttachedSurface(surface, &caps, &surface2) != DD_OK)
+            surface2 = NULL;
+
+        IDirectDrawSurface_Release(surface);
+        surface = surface2;
+    }
+}
+
+static BOOL check_surface(IDirectDrawSurface *surface, DWORD fillcolor, int level)
+{
+    DDSCAPS caps = {DDSCAPS_COMPLEX};
+    IDirectDrawSurface *surface2;
+    DDSURFACEDESC ddsd;
+    int curlevel = -1;
+    BOOL result = TRUE;
+    DWORD x, y;
+    HRESULT hr;
+
+    IDirectDrawSurface_AddRef(surface);
+    fillcolor &= 0x00ffffff;
+
+    while (surface)
+    {
+        curlevel++;
+
+        if (level == -1 || curlevel == level)
+        {
+            memset(&ddsd, 0, sizeof(ddsd));
+            ddsd.dwSize = sizeof(ddsd);
+
+            hr = IDirectDrawSurface_Lock(surface, NULL, &ddsd, DDLOCK_WAIT, NULL);
+            ok(hr == DD_OK, "IDirectDrawSurface_Lock returned: %lx\n", hr);
+
+            for (y = 0; y < ddsd.dwHeight; y++)
+            {
+                if (ddsd.ddpfPixelFormat.dwRGBBitCount == 32)
+                {
+                    DWORD *textureRow = (DWORD *)((char *)ddsd.lpSurface + y * ddsd.lPitch);
+                    for (x = 0; x < ddsd.dwWidth;  x++)
+                    {
+                        if ((*textureRow & 0x00ffffff) != fillcolor)
+                        {
+                            ok(0, "Expected color %lx, got %lx at (%ld, %ld) in level %d\n",
+                               fillcolor, *textureRow, x, y, curlevel);
+                            result = FALSE;
+                            goto end;
+                        }
+                        textureRow++;
+                    }
+                }
+                else if (ddsd.ddpfPixelFormat.dwRGBBitCount == 16)
+                {
+                    WORD *textureRow = (WORD *)((char *)ddsd.lpSurface + y * ddsd.lPitch);
+                    for (x = 0; x < ddsd.dwWidth;  x++)
+                    {
+                        if (*textureRow != fillcolor)
+                        {
+                            ok(0, "Expected color %lx, got %lx at (%ld, %ld) in level %ld\n",
+                               fillcolor, *textureRow, x, y, curlevel);
+                            result = FALSE;
+                            goto end;
+                        }
+                        textureRow++;
+                    }
+                }
+                else
+                {
+                    ok(0, "Unsupported format!\n");
+                    break;
+                }
+            }
+
+        end:
+            hr = IDirectDrawSurface_Unlock(surface, NULL);
+            ok(hr == DD_OK, "IDirectDrawSurface_Unlock returned: %lx\n", hr);
+        }
+
+        if (level != -1 && curlevel >= level)
+        {
+            IDirectDrawSurface_Release(surface);
+            break;
+        }
+
+        if (IDirectDrawSurface_GetAttachedSurface(surface, &caps, &surface2) != DD_OK)
+            surface2 = NULL;
+
+        IDirectDrawSurface_Release(surface);
+        surface = surface2;
+    }
+
+    return result;
+}
+
+struct rgb_format
+{
+    DWORD dwRGBBitCount;
+    DWORD dwRBitMask;
+    DWORD dwGBitMask;
+    DWORD dwBBitMask;
+};
+
+struct mipmap_surface_info
+{
+    struct rgb_format *format;
+    DWORD             width;
+    DWORD             height;
+    int               levels;
+    DWORD             fill[4];
+};
+
+struct rgb_format test_rgb24 = {32, 0x00FF0000, 0x0000FF00, 0x000000FF};
+struct rgb_format test_rgb16 = {16, 0xf800, 0x07e0, 0x001f};
+
+struct
+{
+    struct mipmap_surface_info surfaces[2];
+    HRESULT hres;
+    int     level_check;
+    DWORD   fill_check[4];
+}
+load_tests[] =
+{
+    /* different formats */
+    { {{&test_rgb16, 256, 256, 0, {0x1234}},
+       {&test_rgb24, 256, 256, 0, {0x789ABC}} },
+                        DD_OK, 1, {0x1045A5}},
+    { {{&test_rgb24, 256, 256, 0, {0x123456}},
+       {&test_rgb16, 256, 256, 0, {0x1234}} },
+                        DD_OK, 1, {0x11AA}},
+
+    /* different sizes, but no mipmap */
+    { {{&test_rgb24, 256, 256, 0, {0xff0000}},
+       {&test_rgb24, 256, 256, 0, {0x00ff00}} },
+                        DD_OK, 1, {0xff0000}},
+    { {{&test_rgb24, 512, 512, 0, {0x00ff00}},
+       {&test_rgb24, 256, 256, 0, {0x0000ff}} },
+                        DD_OK, 1, {0x00ff00}},
+    { {{&test_rgb24, 256, 256, 0, {0x0000ff}},
+       {&test_rgb24, 512, 512, 0, {0xff0000}} },
+                        DD_OK, 1, {0x0000ff}},
+
+    /* different sizes, 1 mapmip level */
+    { {{&test_rgb24, 256, 256, 1, {0xff0000}},
+       {&test_rgb24, 256, 256, 1, {0x00ff00}} },
+                        DD_OK, 1, {0xff0000}},
+    { {{&test_rgb24, 512, 512, 1, {0x00ff00}},
+       {&test_rgb24, 256, 256, 1, {0x0000ff}} },
+                        DD_OK, 1, {0x00ff00}},
+    { {{&test_rgb24, 256, 256, 1, {0x0000ff}},
+       {&test_rgb24, 512, 512, 1, {0xff0000}} },
+                        DD_OK, 1, {0x0000ff}},
+
+    /* different sizes, 2 mapmip levels */
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+    { {{&test_rgb24, 512, 512, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 512, 512, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+
+    /* different sizes, source mipmap levels > dest mimap levels */
+    { {{&test_rgb24, 256, 256, 3, {0xff0000, 0x0000ff, 0x808080}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+               DDERR_NOTFOUND, 0, {}},
+    { {{&test_rgb24, 512, 512, 3, {0xff0000, 0x0000ff, 0x808080}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+               DDERR_NOTFOUND, 0, {}},
+    { {{&test_rgb24, 256, 256, 3, {0xff0000, 0x0000ff, 0x808080}},
+       {&test_rgb24, 512, 512, 2, {0x00ff00, 0x00ff00}} },
+               DDERR_NOTFOUND, 0, {}},
+
+    /* different sizes, source mipmap levels < dest mipmap levels  */
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 256, 256, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+    { {{&test_rgb24, 512, 512, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 256, 256, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb24, 512, 512, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+
+    /* different sizes, different formats */
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 256, 256, 2, {0x07e0, 0x07e0}} },
+                        DD_OK, 2, {0xf800, 0x001f}},
+    { {{&test_rgb24, 512, 512, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 256, 256, 2, {0x07e0, 0x07e0}} },
+                        DD_OK, 2, {0xf800, 0x001f}},
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 512, 512, 2, {0x07e0, 0x07e0}} },
+                        DD_OK, 2, {0xf800, 0x001f}},
+
+    { {{&test_rgb16, 256, 256, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+    { {{&test_rgb16, 512, 512, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 256, 256, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+    { {{&test_rgb16, 256, 256, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 512, 512, 2, {0x00ff00, 0x00ff00}} },
+                        DD_OK, 2, {0xff0000, 0x0000ff}},
+
+    /* different sizes, source mipmap levels < destmipmap levels , different format */
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 256, 256, 3, {0x07e0, 0x07e0, 0x1234}} },
+                        DD_OK, 3, {0xf800, 0x001f, 0x1234}},
+    { {{&test_rgb24, 512, 512, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 256, 256, 3, {0x07e0, 0x07e0, 0x1234}} },
+                        DD_OK, 3, {0xf800, 0x001f, 0x1234}},
+    { {{&test_rgb24, 256, 256, 2, {0xff0000, 0x0000ff}},
+       {&test_rgb16, 512, 512, 3, {0x07e0, 0x07e0, 0x1234}} },
+                        DD_OK, 3, {0xf800, 0x001f, 0x1234}},
+
+    { {{&test_rgb16, 256, 256, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 256, 256, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+    { {{&test_rgb16, 512, 512, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 256, 256, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+    { {{&test_rgb16, 256, 256, 2, {0xf800, 0x001f}},
+       {&test_rgb24, 512, 512, 3, {0x00ff00, 0x00ff00, 0x808080}} },
+                        DD_OK, 3, {0xff0000, 0x0000ff, 0x808080}},
+};
+
 /* test palette handling in IDirect3DTexture_Load */
 static void TextureLoadTest(void)
 {
@@ -1120,6 +1402,97 @@ static void TextureLoadTest(void)
     hr = IDirect3DTexture_Load(Texture2, Texture);
     ok(hr == DD_OK, "Got hr %#lx.\n", hr);
 
+    for (i = 0; i < sizeof(load_tests) / sizeof(load_tests[0]); i++)
+    {
+        IDirectDrawSurface *TexSurfaces[2] = {NULL, NULL};
+        IDirect3DTexture *Textures[2] = {NULL, NULL};
+        DDSURFACEDESC ddsd2;
+        int j, k;
+
+        for (j = 0; j < 2; j++)
+        {
+            memset(&ddsd2, 0, sizeof (ddsd2));
+            ddsd2.dwSize = sizeof (ddsd2);
+            ddsd2.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
+            ddsd2.dwHeight = load_tests[i].surfaces[j].height;
+            ddsd2.dwWidth = load_tests[i].surfaces[j].width;
+            ddsd2.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
+            ddsd2.ddpfPixelFormat.dwSize = sizeof(ddsd2.ddpfPixelFormat);
+            ddsd2.ddpfPixelFormat.dwFlags = DDPF_RGB;
+            ddsd2.ddpfPixelFormat.dwRGBBitCount = load_tests[i].surfaces[j].format->dwRGBBitCount;
+            ddsd2.ddpfPixelFormat.dwRBitMask = load_tests[i].surfaces[j].format->dwRBitMask;
+            ddsd2.ddpfPixelFormat.dwGBitMask = load_tests[i].surfaces[j].format->dwGBitMask;
+            ddsd2.ddpfPixelFormat.dwBBitMask = load_tests[i].surfaces[j].format->dwBBitMask;
+
+            if (load_tests[i].surfaces[j].levels)
+            {
+                ddsd2.dwFlags |= DDSD_MIPMAPCOUNT;
+                ddsd2.ddsCaps.dwCaps |= DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;
+                ddsd2.dwMipMapCount = load_tests[i].surfaces[j].levels;
+            }
+
+            hr = IDirectDraw_CreateSurface(DirectDraw1, &ddsd2, &TexSurfaces[j], NULL);
+            ok(hr == D3D_OK, "IDirectDraw_CreateSurface returned %08lx for surface %d in test %d\n", hr, j, i);
+            if (FAILED(hr)) goto next;
+
+            hr = IDirectDrawSurface_QueryInterface(TexSurfaces[j], &IID_IDirect3DTexture, (void *)&Textures[j]);
+            ok(hr == D3D_OK, "IDirectDrawSurface_QueryInterface returned %08lx for surface %d in test %d\n", hr, j, i);
+            if (FAILED(hr)) goto next;
+
+            if (load_tests[i].surfaces[j].levels)
+            {
+                for (k = 0; k < load_tests[i].surfaces[j].levels; k++)
+                    fill_surface(TexSurfaces[j], load_tests[i].surfaces[j].fill[k], k);
+            }
+            else
+                fill_surface(TexSurfaces[j], load_tests[i].surfaces[j].fill[0], -1);
+        }
+
+        hr = IDirect3DTexture_Load(Textures[1], Textures[0]);
+        ok(hr == load_tests[i].hres, "IDirect3DTexture_Load returned %08lx, expected %08x\n", hr, load_tests[i].hres);
+        if (hr != DD_OK) goto next;
+
+        memset(&ddsd2, 0, sizeof (ddsd2));
+        ddsd2.dwSize = sizeof(ddsd2);
+        hr = IDirectDrawSurface_GetSurfaceDesc(TexSurfaces[1], &ddsd2);
+        ok(hr == DD_OK, "IDirectDrawSurface_GetSurfaceDesc returned %08lx\n", hr);
+
+        if (load_tests[i].surfaces[1].levels)
+        {
+            ok(ddsd2.dwMipMapCount == load_tests[i].surfaces[1].levels,
+               "Expected %d mipmap levels, got %d in run %d\n", load_tests[i].surfaces[1].levels,
+               ddsd2.dwMipMapCount, i);
+        }
+
+        for (k = 0; k < load_tests[i].level_check; k++)
+        {
+            if (!check_surface(TexSurfaces[1], load_tests[i].fill_check[k], k))
+                ok(0, "Check surface failed in test %d\n", i);
+        }
+
+        ok(ddsd2.ddpfPixelFormat.dwRGBBitCount == load_tests[i].surfaces[1].format->dwRGBBitCount,
+           "Expected %d rgb bits, got %d in run %d\n", load_tests[i].surfaces[1].format->dwRGBBitCount,
+           ddsd2.ddpfPixelFormat.dwRGBBitCount, i);
+
+        ok(ddsd2.ddpfPixelFormat.dwRBitMask == load_tests[i].surfaces[1].format->dwRBitMask,
+           "Expected %08x red bits, got %08x in run %d\n", load_tests[i].surfaces[1].format->dwRBitMask,
+           ddsd2.ddpfPixelFormat.dwRBitMask, i);
+
+        ok(ddsd2.ddpfPixelFormat.dwGBitMask == load_tests[i].surfaces[1].format->dwGBitMask,
+           "Expected %08x green bits, got %08x in run %d\n", load_tests[i].surfaces[1].format->dwGBitMask,
+           ddsd2.ddpfPixelFormat.dwGBitMask, i);
+
+        ok(ddsd2.ddpfPixelFormat.dwBBitMask == load_tests[i].surfaces[1].format->dwBBitMask,
+           "Expected %08x blue bits, got %08x in run %d\n", load_tests[i].surfaces[1].format->dwBBitMask,
+           ddsd2.ddpfPixelFormat.dwBBitMask, i);
+
+    next:
+        if (Textures[0]) IDirect3DTexture_Release(Textures[0]);
+        if (TexSurfaces[0]) IDirectDrawSurface_Release(TexSurfaces[0]);
+        if (Textures[1]) IDirect3DTexture_Release(Textures[1]);
+        if (TexSurfaces[1]) IDirectDrawSurface_Release(TexSurfaces[1]);
+    }
+
     for (i = 0; i < 256; i++) {
         table1[i].peRed = i;
         table1[i].peGreen = i;
diff --git a/dlls/ddraw/tests/ddraw1.c b/dlls/ddraw/tests/ddraw1.c
index d8fcb18..bacd904 100644
--- a/dlls/ddraw/tests/ddraw1.c
+++ b/dlls/ddraw/tests/ddraw1.c
@@ -15467,6 +15467,137 @@ static void test_enum_devices(void)
     ok(!refcount, "Device has %lu references left.\n", refcount);
 }
 
+static void test_pick(void)
+{
+    static D3DTLVERTEX tquad[] =
+    {
+        {{320.0f}, {480.0f}, { 1.5f}, {1.0f}, {0xff00ff00}, {0x00000000}, {0.0f}, {0.0f}},
+        {{  0.0f}, {480.0f}, {-0.5f}, {1.0f}, {0xff00ff00}, {0x00000000}, {0.0f}, {0.0f}},
+        {{320.0f}, {  0.0f}, { 1.5f}, {1.0f}, {0xff00ff00}, {0x00000000}, {0.0f}, {0.0f}},
+        {{  0.0f}, {  0.0f}, {-0.5f}, {1.0f}, {0xff00ff00}, {0x00000000}, {0.0f}, {0.0f}},
+    };
+    IDirect3DExecuteBuffer *execute_buffer;
+    D3DEXECUTEBUFFERDESC exec_desc;
+    IDirect3DViewport *viewport;
+    IDirect3DDevice *device;
+    IDirectDraw *ddraw;
+    UINT inst_length;
+    HWND window;
+    HRESULT hr;
+    void *ptr;
+    DWORD rec_count;
+    D3DRECT pick_rect;
+    UINT screen_width = 640;
+    UINT screen_height = 480;
+    UINT hits = 0;
+    UINT nohits = 0;
+    int i, j;
+
+    window = create_window();
+    ddraw = create_ddraw();
+    ok(!!ddraw, "Failed to create a ddraw object.\n");
+    if (!(device = create_device(ddraw, window, DDSCL_NORMAL)))
+    {
+        skip("Failed to create a 3D device, skipping test.\n");
+        IDirectDraw_Release(ddraw);
+        DestroyWindow(window);
+        return;
+    }
+
+    viewport = create_viewport(device, 0, 0, screen_width, screen_height);
+
+    memset(&exec_desc, 0, sizeof(exec_desc));
+    exec_desc.dwSize = sizeof(exec_desc);
+    exec_desc.dwFlags = D3DDEB_BUFSIZE | D3DDEB_CAPS;
+    exec_desc.dwBufferSize = 1024;
+    exec_desc.dwCaps = D3DDEBCAPS_SYSTEMMEMORY;
+
+    hr = IDirect3DDevice_CreateExecuteBuffer(device, &exec_desc, &execute_buffer, NULL);
+    ok(SUCCEEDED(hr), "Failed to create execute buffer, hr %#lx.\n", hr);
+    hr = IDirect3DExecuteBuffer_Lock(execute_buffer, &exec_desc);
+    ok(SUCCEEDED(hr), "Failed to lock execute buffer, hr %#lx.\n", hr);
+    memcpy(exec_desc.lpData, tquad, sizeof(tquad));
+    ptr = ((BYTE *)exec_desc.lpData) + sizeof(tquad);
+    emit_process_vertices(&ptr, D3DPROCESSVERTICES_COPY, 0, 4);
+    emit_tquad(&ptr, 0);
+    emit_end(&ptr);
+    inst_length = (BYTE *)ptr - (BYTE *)exec_desc.lpData;
+    inst_length -= sizeof(tquad);
+    hr = IDirect3DExecuteBuffer_Unlock(execute_buffer);
+    ok(SUCCEEDED(hr), "Failed to unlock execute buffer, hr %#lx.\n", hr);
+
+    set_execute_data(execute_buffer, 4, sizeof(tquad), inst_length);
+
+    /* Perform a number of picks, we should have a specific amount by the end */
+    for (i = 0; i < screen_width; i += 80)
+    {
+        for (j = 0; j < screen_height; j += 60)
+        {
+            pick_rect.x1 = i;
+            pick_rect.y1 = j;
+
+            hr = IDirect3DDevice_Pick(device, execute_buffer, viewport, 0, &pick_rect);
+            ok(SUCCEEDED(hr), "Failed to perform pick, hr %#lx.\n", hr);
+            hr = IDirect3DDevice_GetPickRecords(device, &rec_count, NULL);
+            ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+            if (rec_count > 0)
+                hits++;
+            else
+                nohits++;
+        }
+    }
+
+    /*
+        We should have gotten precisely equal numbers of hits and no hits since our quad
+        covers exactly half the screen
+    */
+    ok(hits == nohits, "Got a non-equal amount of pick successes/failures: %i vs %i.\n", hits, nohits);
+
+    /* Try some specific pixel picks */
+    pick_rect.x1 = 480;
+    pick_rect.y1 = 360;
+    hr = IDirect3DDevice_Pick(device, execute_buffer, viewport, 0, &pick_rect);
+    ok(SUCCEEDED(hr), "Failed to perform pick, hr %#lx.\n", hr);
+    hr = IDirect3DDevice_GetPickRecords(device, &rec_count, NULL);
+    ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+    ok(rec_count == 0, "Got incorrect number of pick records (expected 0): %lu.\n", rec_count);
+
+    pick_rect.x1 = 240;
+    pick_rect.y1 = 120;
+    hr = IDirect3DDevice_Pick(device, execute_buffer, viewport, 0, &pick_rect);
+    ok(SUCCEEDED(hr), "Failed to perform pick, hr %#lx.\n", hr);
+    rec_count = 0;
+    hr = IDirect3DDevice_GetPickRecords(device, &rec_count, NULL);
+    ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+    ok(rec_count == 1, "Got incorrect number of pick records (expected 1): %lu.\n", rec_count);
+
+    if (rec_count == 1)
+    {
+        D3DPICKRECORD record;
+
+        hr = IDirect3DDevice_GetPickRecords(device, &rec_count, &record);
+        ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+        ok(rec_count == 1, "Got incorrect number of pick records (expected 1): %lu.\n", rec_count);
+
+        hr = IDirect3DDevice_GetPickRecords(device, &rec_count, &record);
+        ok(SUCCEEDED(hr), "Failed to get pick records, hr %#lx.\n", hr);
+        ok(rec_count == 1, "Got incorrect number of pick records (expected 1): %lu.\n", rec_count);
+
+        /* Tests D3DPICKRECORD for correct information */
+        ok(record.bOpcode == 3, "Got incorrect bOpcode: %i.\n", record.bOpcode);
+        ok(record.bPad == 0, "Got incorrect bPad: %i.\n", record.bPad);
+        ok(record.dwOffset == 24, "Got incorrect dwOffset: %lu.\n", record.dwOffset);
+        ok(compare_float(record.dvZ, 1.0, 0.1), "Got incorrect dvZ: %f.\n", record.dvZ);
+    }
+
+    destroy_viewport(device, viewport);
+    IDirect3DExecuteBuffer_Release(execute_buffer);
+    IDirect3DDevice_Release(device);
+    IDirectDraw_Release(ddraw);
+
+    DestroyWindow(window);
+}
+
 /* Emperor: Rise of the Middle Kingdom locks a sysmem surface and then accesses
  * the pointer after unlocking it. This test roughly replicates the calls that
  * it makes. */
@@ -15527,6 +15658,7 @@ static void test_pinned_sysmem(void)
     IDirectDrawSurface_Release(surface);
     refcount = IDirectDraw_Release(ddraw);
     ok(!refcount, "Device has %lu references left.\n", refcount);
+
     DestroyWindow(window);
 }
 
@@ -15646,6 +15778,7 @@ START_TEST(ddraw1)
     test_vtbl_protection();
     test_window_position();
     test_get_display_mode();
+    test_pick();
     run_for_each_device_type(test_texture_wrong_caps);
     test_filling_convention();
     test_enum_devices();
diff --git a/dlls/ddraw/tests/ddraw2.c b/dlls/ddraw/tests/ddraw2.c
index f4cc5df..407076d 100644
--- a/dlls/ddraw/tests/ddraw2.c
+++ b/dlls/ddraw/tests/ddraw2.c
@@ -1491,8 +1491,10 @@ static void test_texture_load_ckey(void)
     IDirectDraw2 *ddraw = NULL;
     IDirectDrawSurface *src = NULL;
     IDirectDrawSurface *dst = NULL;
+    IDirectDrawSurface *dst2 = NULL;
     IDirect3DTexture *src_tex = NULL;
     IDirect3DTexture *dst_tex = NULL;
+    IDirect3DTexture *dst2_tex = NULL;
     DDSURFACEDESC ddsd;
     HRESULT hr;
     DDCOLORKEY ckey;
@@ -1504,16 +1506,31 @@ static void test_texture_load_ckey(void)
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
-    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
+    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
     ddsd.dwHeight = 128;
     ddsd.dwWidth = 128;
     ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_SYSTEMMEMORY;
+    ddsd.ddpfPixelFormat.dwSize = sizeof(ddsd.ddpfPixelFormat);
+    ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
+    ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
+    ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000;
+    ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00;
+    ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FF;
+
     hr = IDirectDraw2_CreateSurface(ddraw, &ddsd, &src, NULL);
     ok(SUCCEEDED(hr), "Failed to create source texture, hr %#lx.\n", hr);
     ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE;
     hr = IDirectDraw2_CreateSurface(ddraw, &ddsd, &dst, NULL);
     ok(SUCCEEDED(hr), "Failed to create destination texture, hr %#lx.\n", hr);
 
+    ddsd.ddpfPixelFormat.dwRGBBitCount = 16;
+    ddsd.ddpfPixelFormat.dwRBitMask = 0xf800;
+    ddsd.ddpfPixelFormat.dwGBitMask = 0x07e0;
+    ddsd.ddpfPixelFormat.dwBBitMask = 0x001f;
+
+    hr = IDirectDraw2_CreateSurface(ddraw, &ddsd, &dst2, NULL);
+    ok(SUCCEEDED(hr), "Failed to create destination texture, hr %#lx.\n", hr);
+
     hr = IDirectDrawSurface_QueryInterface(src, &IID_IDirect3DTexture, (void **)&src_tex);
     ok(SUCCEEDED(hr) || hr == E_NOINTERFACE, "Failed to get Direct3DTexture interface, hr %#lx.\n", hr);
     if (FAILED(hr))
@@ -1524,6 +1541,8 @@ static void test_texture_load_ckey(void)
     }
     hr = IDirectDrawSurface_QueryInterface(dst, &IID_IDirect3DTexture, (void **)&dst_tex);
     ok(SUCCEEDED(hr), "Failed to get Direct3DTexture interface, hr %#lx.\n", hr);
+    hr = IDirectDrawSurface_QueryInterface(dst2, &IID_IDirect3DTexture, (void **)&dst2_tex);
+    ok(SUCCEEDED(hr), "Failed to get Direct3DTexture interface, hr %#lx.\n", hr);
 
     /* No surface has a color key */
     hr = IDirect3DTexture_Load(dst_tex, src_tex);
@@ -1552,6 +1571,11 @@ static void test_texture_load_ckey(void)
     ok(ckey.dwColorSpaceLowValue == 0x0000ff00, "Got unexpected value 0x%08lx.\n", ckey.dwColorSpaceLowValue);
     ok(ckey.dwColorSpaceHighValue == 0x0000ff00, "Got unexpected value 0x%08lx.\n", ckey.dwColorSpaceHighValue);
 
+    /* Source surface has a color key but destination differs in format */
+    ckey.dwColorSpaceLowValue = ckey.dwColorSpaceHighValue = 0x0;
+    hr = IDirect3DTexture_Load(dst2_tex, src_tex);
+    ok(hr == E_FAIL, "Got unexpected hr %#lx, expected E_FAIL.\n", hr);
+
     /* Both surfaces have a color key: Dest ckey is overwritten */
     ckey.dwColorSpaceLowValue = ckey.dwColorSpaceHighValue = 0x000000ff;
     hr = IDirectDrawSurface_SetColorKey(dst, DDCKEY_SRCBLT, &ckey);
@@ -1576,8 +1600,10 @@ static void test_texture_load_ckey(void)
     ok(ckey.dwColorSpaceHighValue == 0x0000ff00, "Got unexpected value 0x%08lx.\n", ckey.dwColorSpaceHighValue);
 
 done:
+    if (dst2_tex) IDirect3DTexture_Release(dst2_tex);
     if (dst_tex) IDirect3DTexture_Release(dst_tex);
     if (src_tex) IDirect3DTexture_Release(src_tex);
+    if (dst2) IDirectDrawSurface_Release(dst2);
     if (dst) IDirectDrawSurface_Release(dst);
     if (src) IDirectDrawSurface_Release(src);
     if (ddraw) IDirectDraw2_Release(ddraw);
diff --git a/dlls/ddraw/viewport.c b/dlls/ddraw/viewport.c
index 4eda2fe..fa6c85c 100644
--- a/dlls/ddraw/viewport.c
+++ b/dlls/ddraw/viewport.c
@@ -1216,7 +1216,7 @@ struct d3d_viewport *unsafe_impl_from_IDirect3DViewport2(IDirect3DViewport2 *ifa
     /* IDirect3DViewport and IDirect3DViewport3 use the same iface. */
     if (!iface) return NULL;
     assert(iface->lpVtbl == (IDirect3DViewport2Vtbl *)&d3d_viewport_vtbl);
-    return CONTAINING_RECORD(iface, struct d3d_viewport, IDirect3DViewport3_iface);
+    return CONTAINING_RECORD((IDirect3DViewport3 *)iface, struct d3d_viewport, IDirect3DViewport3_iface);
 }
 
 struct d3d_viewport *unsafe_impl_from_IDirect3DViewport(IDirect3DViewport *iface)
@@ -1224,7 +1224,7 @@ struct d3d_viewport *unsafe_impl_from_IDirect3DViewport(IDirect3DViewport *iface
     /* IDirect3DViewport and IDirect3DViewport3 use the same iface. */
     if (!iface) return NULL;
     assert(iface->lpVtbl == (IDirect3DViewportVtbl *)&d3d_viewport_vtbl);
-    return CONTAINING_RECORD(iface, struct d3d_viewport, IDirect3DViewport3_iface);
+    return CONTAINING_RECORD((IDirect3DViewport3 *)iface, struct d3d_viewport, IDirect3DViewport3_iface);
 }
 
 void d3d_viewport_init(struct d3d_viewport *viewport, struct ddraw *ddraw)
diff --git a/dlls/dinput/keyboard.c b/dlls/dinput/keyboard.c
index cbcbf94..1f1db88 100644
--- a/dlls/dinput/keyboard.c
+++ b/dlls/dinput/keyboard.c
@@ -256,6 +256,7 @@ static BOOL try_enum_object( struct dinput_device *impl, const DIPROPHEADER *fil
 static HRESULT keyboard_enum_objects( IDirectInputDevice8W *iface, const DIPROPHEADER *filter,
                                       DWORD flags, enum_object_callback callback, void *context )
 {
+    static const UINT vsc_base[] = {0, 0x100, 0x80, 0x180};
     struct keyboard *impl = impl_from_IDirectInputDevice8W( iface );
     BYTE subtype = GET_DIDEVICE_SUBTYPE( impl->base.instance.dwDevType );
     DIDEVICEOBJECTINSTANCEW instance =
@@ -265,17 +266,22 @@ static HRESULT keyboard_enum_objects( IDirectInputDevice8W *iface, const DIPROPH
         .dwOfs = DIK_ESCAPE,
         .dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( DIK_ESCAPE ),
     };
-    DWORD index, i, dik;
-    BOOL ret;
+    BOOL ret, mapped[0x100] = {0};
+    DWORD index, i, dik, vsc;
 
-    for (i = 0, index = 0; i < 512; ++i)
+    for (i = 0, index = 0; i < ARRAY_SIZE(vsc_base); ++i)
     {
-        if (!GetKeyNameTextW( i << 16, instance.tszName, ARRAY_SIZE(instance.tszName) )) continue;
-        if (!(dik = map_dik_code( i, 0, subtype, impl->base.dinput->dwVersion ))) continue;
-        instance.dwOfs = dik;
-        instance.dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( dik );
-        ret = try_enum_object( &impl->base, filter, flags, callback, index++, &instance, context );
-        if (ret != DIENUM_CONTINUE) return DIENUM_STOP;
+        for (vsc = vsc_base[i]; vsc < vsc_base[i] + 0x80; vsc++)
+        {
+            if (!GetKeyNameTextW( vsc << 16, instance.tszName, ARRAY_SIZE(instance.tszName) )) continue;
+            if (!(dik = map_dik_code( vsc, 0, subtype, impl->base.dinput->dwVersion ))) continue;
+            if (mapped[dik]) continue;
+            mapped[dik] = TRUE;
+            instance.dwOfs = dik;
+            instance.dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE( dik );
+            ret = try_enum_object( &impl->base, filter, flags, callback, index++, &instance, context );
+            if (ret != DIENUM_CONTINUE) return DIENUM_STOP;
+        }
     }
 
     return DIENUM_CONTINUE;
diff --git a/dlls/dsound/Makefile.in b/dlls/dsound/Makefile.in
index 13cb6e8..ee09776 100644
--- a/dlls/dsound/Makefile.in
+++ b/dlls/dsound/Makefile.in
@@ -10,6 +10,7 @@ SOURCES = \
 	dsound_convert.c \
 	dsound_main.c \
 	duplex.c \
+	eax.c \
 	mixer.c \
 	primary.c \
 	propset.c \
diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index 8e261fd..9bb87c5 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -34,6 +34,7 @@
 #include "dsconf.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 /*******************************************************************************
  *		IDirectSoundNotify
@@ -1110,6 +1111,8 @@ HRESULT secondarybuffer_create(DirectSoundDevice *device, const DSBUFFERDESC *ds
 	dsb->sec_mixpos = 0;
 	dsb->state = STATE_STOPPED;
 
+	dsb->eax.reverb_mix = EAX_REVERBMIX_USEDISTANCE;
+
 	if (dsb->dsbd.dwFlags & DSBCAPS_CTRL3D) {
 		dsb->ds3db_ds3db.dwSize = sizeof(DS3DBUFFER);
 		dsb->ds3db_ds3db.vPosition.x = 0.0;
@@ -1146,6 +1149,8 @@ HRESULT secondarybuffer_create(DirectSoundDevice *device, const DSBUFFERDESC *ds
 	}
 
         InitializeSRWLock(&dsb->lock);
+	if (dsb->device->eax.using_eax)
+		init_eax_buffer(dsb);
 
         /* register buffer */
         err = DirectSoundDevice_AddBuffer(device, dsb);
@@ -1187,6 +1192,8 @@ void secondarybuffer_destroy(IDirectSoundBufferImpl *This)
         free(This->filters);
     }
 
+    free_eax_buffer(This);
+
     TRACE("(%p) released\n", This);
 
     free(This);
@@ -1213,7 +1220,7 @@ HRESULT IDirectSoundBufferImpl_Duplicate(
     VOID *committedbuff;
     TRACE("(%p,%p,%p)\n", device, ppdsb, pdsb);
 
-    dsb = malloc(sizeof(*dsb));
+    dsb = calloc(1, sizeof(*dsb));
     if (dsb == NULL) {
         WARN("out of memory\n");
         *ppdsb = NULL;
@@ -1261,6 +1268,8 @@ HRESULT IDirectSoundBufferImpl_Duplicate(
 
     InitializeSRWLock(&dsb->lock);
 
+    init_eax_buffer(dsb); /* FIXME: should we duplicate EAX properties? */
+
     /* register buffer */
     hres = DirectSoundDevice_AddBuffer(device, dsb);
     if (hres != DS_OK) {
@@ -1341,6 +1350,9 @@ static HRESULT WINAPI IKsPropertySetImpl_Get(IKsPropertySet *iface, REFGUID guid
     TRACE("(iface=%p,guidPropSet=%s,dwPropID=%ld,pInstanceData=%p,cbInstanceData=%ld,pPropData=%p,cbPropData=%ld,pcbReturned=%p)\n",
     This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData,pcbReturned);
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet))
+        return EAX_Get(This, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
@@ -1352,6 +1364,10 @@ static HRESULT WINAPI IKsPropertySetImpl_Set(IKsPropertySet *iface, REFGUID guid
 
     TRACE("(%p,%s,%ld,%p,%ld,%p,%ld)\n",This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData);
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet) ||
+        IsEqualGUID(&DSPROPSETID_EAX20_ListenerProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAX20_BufferProperties, guidPropSet))
+        return EAX_Set(This, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
@@ -1362,6 +1378,13 @@ static HRESULT WINAPI IKsPropertySetImpl_QuerySupport(IKsPropertySet *iface, REF
 
     TRACE("(%p,%s,%ld,%p)\n",This,debugstr_guid(guidPropSet),dwPropID,pTypeSupport);
 
+    if (EAX_QuerySupport(guidPropSet, dwPropID, pTypeSupport)) {
+        static int once;
+        if (!once++)
+            FIXME_(winediag)("EAX sound effects are enabled - try to disable it if your app crashes unexpectedly\n");
+        return S_OK;
+    }
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
diff --git a/dlls/dsound/dsound.c b/dlls/dsound/dsound.c
index b35f9c7..b382b51 100644
--- a/dlls/dsound/dsound.c
+++ b/dlls/dsound/dsound.c
@@ -182,6 +182,8 @@ static HRESULT DirectSoundDevice_Create(DirectSoundDevice ** ppDevice)
 
     InitializeSRWLock(&device->buffer_list_lock);
 
+    init_eax_device(device);
+
    *ppDevice = device;
 
     return DS_OK;
@@ -234,6 +236,7 @@ static ULONG DirectSoundDevice_Release(DirectSoundDevice * device)
         if(device->mmdevice)
             IMMDevice_Release(device->mmdevice);
         CloseHandle(device->sleepev);
+        free(device->dsp_buffer);
         free(device->tmp_buffer);
         free(device->cp_buffer);
         free(device->buffer);
diff --git a/dlls/dsound/dsound_main.c b/dlls/dsound/dsound_main.c
index bb373a4..d065558 100644
--- a/dlls/dsound/dsound_main.c
+++ b/dlls/dsound/dsound_main.c
@@ -83,6 +83,11 @@ const WCHAR wine_vxd_drv[] = L"winemm.vxd";
 
 /* All default settings, you most likely don't want to touch these, see wiki on UsefulRegistryKeys */
 int ds_hel_buflen = 32768 * 2;
+int ds_hq_buffers_max = 4;
+BOOL ds_eax_enabled = TRUE;
+
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
 
 /*
  * Get a config key from either the app-specific or the default config
@@ -134,10 +139,18 @@ void setup_dsound_options(void)
     if (!get_config_key( hkey, appkey, "HelBuflen", buffer, MAX_PATH ))
         ds_hel_buflen = atoi(buffer);
 
+    if (!get_config_key( hkey, appkey, "HQBuffersMax", buffer, MAX_PATH ))
+        ds_hq_buffers_max = atoi(buffer);
+
+    if (!get_config_key( hkey, appkey, "EAXEnabled", buffer, MAX_PATH ))
+        ds_eax_enabled = IS_OPTION_TRUE( buffer[0] );
+
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
 
     TRACE("ds_hel_buflen = %d\n", ds_hel_buflen);
+    TRACE("ds_hq_buffers_max = %d\n", ds_hq_buffers_max);
+    TRACE("ds_eax_enabled = %u\n", ds_eax_enabled);
 }
 
 static const char * get_device_id(LPCGUID pGuid)
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 3449812..10c6617 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -29,12 +29,15 @@
 #include "mediaobj.h"
 #include "mmsystem.h"
 #include "uuids.h"
+#include "dsound_eax.h"
 
 #include "wine/list.h"
 
 #define DS_MAX_CHANNELS 6
 
 extern int ds_hel_buflen;
+extern int ds_hq_buffers_max;
+extern BOOL ds_eax_enabled;
 
 /*****************************************************************************
  * Predeclare the interface implementation structures
@@ -88,13 +91,15 @@ struct DirectSoundDevice
     int                         speaker_num[DS_MAX_CHANNELS];
     int                         num_speakers;
     int                         lfe_channel;
-    float *tmp_buffer, *cp_buffer;
-    DWORD                       tmp_buffer_len, cp_buffer_len;
+    float *tmp_buffer, *cp_buffer, *dsp_buffer;
+    DWORD                       tmp_buffer_len, cp_buffer_len, dsp_buffer_len;
 
     DSVOLUMEPAN                 volpan;
 
     normfunc normfunction;
 
+    eax_info                    eax;
+
     /* DirectSound3DListener fields */
     DS3DLISTENER                ds3dl;
     BOOL                        ds3dl_need_recalc;
@@ -173,6 +178,8 @@ struct IDirectSoundBufferImpl
     int                         num_filters;
     DSFilter*                   filters;
 
+    eax_buffer_info             eax;
+
     struct list entry;
 };
 
@@ -227,6 +234,19 @@ LONG capped_refcount_dec(LONG *ref);
 
 HRESULT DSOUND_FullDuplexCreate(REFIID riid, void **ppv);
 
+/* eax.c */
+BOOL WINAPI EAX_QuerySupport(REFGUID guidPropSet, ULONG dwPropID, ULONG *pTypeSupport);
+HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
+        ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
+        ULONG cbPropData, ULONG *pcbReturned);
+HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
+        ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
+        ULONG cbPropData);
+void init_eax_device(DirectSoundDevice *dev);
+void free_eax_buffer(IDirectSoundBufferImpl *dsb);
+void init_eax_buffer(IDirectSoundBufferImpl *dsb);
+void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count);
+
 /* mixer.c */
 void DSOUND_CheckEvent(const IDirectSoundBufferImpl *dsb, DWORD playpos, int len);
 void DSOUND_RecalcVolPan(PDSVOLUMEPAN volpan);
diff --git a/dlls/dsound/mixer.c b/dlls/dsound/mixer.c
index bf05805..33dcd8a 100644
--- a/dlls/dsound/mixer.c
+++ b/dlls/dsound/mixer.c
@@ -286,10 +286,9 @@ static inline float get_current_sample(const IDirectSoundBufferImpl *dsb,
     return dsb->get(dsb, buffer + (mixpos % buflen), channel);
 }
 
-static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, UINT count)
+static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, bitsputfunc put, UINT ostride, UINT count)
 {
     UINT istride = dsb->pwfx->nBlockAlign;
-    UINT ostride = dsb->device->pwfx->nChannels * sizeof(float);
     UINT committed_samples = 0;
     DWORD channel, i;
 
@@ -308,17 +307,56 @@ static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, UINT count)
 
     for (; i < count; i++)
         for (channel = 0; channel < dsb->mix_channels; channel++)
-            dsb->put(dsb, i * ostride, channel, get_current_sample(dsb, dsb->buffer->memory,
+            put(dsb, i * ostride, channel, get_current_sample(dsb, dsb->buffer->memory,
                 dsb->buflen, dsb->sec_mixpos + i * istride, channel));
-
     return count;
 }
 
-static UINT cp_fields_resample(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+static UINT cp_fields_resample_lq(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                                  UINT ostride, UINT count, LONG64 *freqAccNum)
+{
+    UINT i, channel;
+    UINT istride = dsb->pwfx->nBlockAlign;
+    UINT channels = dsb->mix_channels;
+
+    LONG64 freqAcc_start = *freqAccNum;
+    LONG64 freqAcc_end = freqAcc_start + count * dsb->freqAdjustNum;
+    UINT max_ipos = freqAcc_end / dsb->freqAdjustDen;
+
+    for (i = 0; i < count; ++i) {
+        float cur_freqAcc = (freqAcc_start + i * dsb->freqAdjustNum) / (float)dsb->freqAdjustDen;
+        float cur_freqAcc2;
+        UINT ipos = cur_freqAcc;
+        UINT idx = dsb->sec_mixpos + ipos * istride;
+        cur_freqAcc -= (int)cur_freqAcc;
+        cur_freqAcc2 = 1.0f - cur_freqAcc;
+        for (channel = 0; channel < channels; channel++) {
+            /**
+             * Generally we cannot cache the result of get_current_sample().
+             * Consider the case of resampling from 192000 Hz to 44100 Hz -
+             * none of the values will get reused for the next value of i.
+             * OTOH, for resampling from 44100 Hz to 192000 Hz both values
+             * will likely be reused.
+             *
+             * So far, this possibility of saving calls to
+             * get_current_sample() is ignored.
+             */
+            float s1 = get_current_sample(dsb, dsb->buffer->memory, dsb->buflen, idx, channel);
+            float s2 = get_current_sample(dsb, dsb->buffer->memory, dsb->buflen, idx + istride, channel);
+            float result = s1 * cur_freqAcc2 + s2 * cur_freqAcc;
+            put(dsb, i * ostride, channel, result);
+        }
+    }
+
+    *freqAccNum = freqAcc_end % dsb->freqAdjustDen;
+    return max_ipos;
+}
+
+static UINT cp_fields_resample_hq(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                                  UINT ostride, UINT count, LONG64 *freqAccNum)
 {
     UINT i, channel;
     UINT istride = dsb->pwfx->nBlockAlign;
-    UINT ostride = dsb->device->pwfx->nChannels * sizeof(float);
     UINT committed_samples = 0;
 
     LONG64 freqAcc_start = *freqAccNum;
@@ -393,21 +431,24 @@ static UINT cp_fields_resample(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *
             float* cache = &intermediate[channel * required_input + ipos];
             for (j = 0; j < fir_used; j++)
                 sum += fir_copy[j] * cache[j];
-            dsb->put(dsb, i * ostride, channel, sum * dsb->firgain);
+            put(dsb, i * ostride, channel, sum * dsb->firgain);
         }
     }
 
     return max_ipos;
 }
 
-static void cp_fields(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+static void cp_fields(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                      UINT ostride, UINT count, LONG64 *freqAccNum)
 {
     DWORD ipos, adv;
 
     if (dsb->freqAdjustNum == dsb->freqAdjustDen)
-        adv = cp_fields_noresample(dsb, count); /* *freqAccNum is unmodified */
+        adv = cp_fields_noresample(dsb, put, ostride, count); /* *freqAcc is unmodified */
+    else if (dsb->device->nrofbuffers > ds_hq_buffers_max)
+        adv = cp_fields_resample_lq(dsb, put, ostride, count, freqAccNum);
     else
-        adv = cp_fields_resample(dsb, count, freqAccNum);
+        adv = cp_fields_resample_hq(dsb, put, ostride, count, freqAccNum);
 
     ipos = dsb->sec_mixpos + adv * dsb->pwfx->nBlockAlign;
     if (ipos >= dsb->buflen) {
@@ -443,6 +484,21 @@ static inline DWORD DSOUND_BufPtrDiff(DWORD buflen, DWORD ptr1, DWORD ptr2)
 		return buflen + ptr1 - ptr2;
 	}
 }
+
+static float getieee32_dsp(const IDirectSoundBufferImpl *dsb, DWORD pos, DWORD channel)
+{
+    const BYTE *buf = (BYTE *)dsb->device->dsp_buffer;
+    const float *fbuf = (const float*)(buf + pos + sizeof(float) * channel);
+    return *fbuf;
+}
+
+static void putieee32_dsp(const IDirectSoundBufferImpl *dsb, DWORD pos, DWORD channel, float value)
+{
+    BYTE *buf = (BYTE *)dsb->device->dsp_buffer;
+    float *fbuf = (float*)(buf + pos + sizeof(float) * channel);
+    *fbuf = value;
+}
+
 /**
  * Mix at most the given amount of data into the allocated temporary buffer
  * of the given secondary buffer, starting from the dsb's first currently
@@ -458,31 +514,64 @@ static inline DWORD DSOUND_BufPtrDiff(DWORD buflen, DWORD ptr1, DWORD ptr2)
  */
 static void DSOUND_MixToTemporary(IDirectSoundBufferImpl *dsb, DWORD frames)
 {
-	UINT size_bytes = frames * sizeof(float) * dsb->device->pwfx->nChannels;
+    BOOL using_filters = dsb->num_filters > 0 || dsb->device->eax.using_eax;
+    UINT istride, ostride, size_bytes;
+    DWORD channel, i;
+    bitsputfunc put;
 	HRESULT hr;
-	int i;
 
-	if (dsb->device->tmp_buffer_len < size_bytes || !dsb->device->tmp_buffer)
-	{
-		dsb->device->tmp_buffer_len = size_bytes;
-		dsb->device->tmp_buffer = realloc(dsb->device->tmp_buffer, size_bytes);
-	}
-	if(dsb->put_aux == putieee32_sum)
-		memset(dsb->device->tmp_buffer, 0, dsb->device->tmp_buffer_len);
+    put = dsb->put;
+    ostride = dsb->device->pwfx->nChannels * sizeof(float);
+    size_bytes = frames * ostride;
 
-	cp_fields(dsb, frames, &dsb->freqAccNum);
+    if (dsb->device->tmp_buffer_len < size_bytes || !dsb->device->tmp_buffer)
+    {
+        dsb->device->tmp_buffer_len = size_bytes;
+        dsb->device->tmp_buffer = realloc(dsb->device->tmp_buffer, size_bytes);
+    }
+    if(dsb->put_aux == putieee32_sum)
+        memset(dsb->device->tmp_buffer, 0, dsb->device->tmp_buffer_len);
+
+    if (using_filters) {
+        put = putieee32_dsp;
+        ostride = dsb->mix_channels * sizeof(float);
+        size_bytes = frames * ostride;
+
+        if (dsb->device->dsp_buffer_len < size_bytes || !dsb->device->dsp_buffer) {
+            if (dsb->device->dsp_buffer)
+                dsb->device->dsp_buffer = HeapReAlloc(GetProcessHeap(), 0, dsb->device->dsp_buffer, size_bytes);
+            else
+                dsb->device->dsp_buffer = HeapAlloc(GetProcessHeap(), 0, size_bytes);
+            dsb->device->dsp_buffer_len = size_bytes;
+        }
+    }
 
-	if (size_bytes > 0) {
-		for (i = 0; i < dsb->num_filters; i++) {
-			if (dsb->filters[i].inplace) {
-				hr = IMediaObjectInPlace_Process(dsb->filters[i].inplace, size_bytes, (BYTE*)dsb->device->tmp_buffer, 0, DMO_INPLACE_NORMAL);
+    cp_fields(dsb, put, ostride, frames, &dsb->freqAccNum);
+
+    if (using_filters) {
+        if (frames > 0) {
+            for (i = 0; i < dsb->num_filters; i++) {
+                if (dsb->filters[i].inplace) {
+                    hr = IMediaObjectInPlace_Process(dsb->filters[i].inplace, frames * sizeof(float) * dsb->mix_channels,
+                                                     (BYTE *)dsb->device->dsp_buffer, 0, DMO_INPLACE_NORMAL);
+                    if (FAILED(hr))
+                        WARN("IMediaObjectInPlace_Process failed for filter %lu\n", i);
+                } else
+                    WARN("filter %lu has no inplace object - unsupported\n", i);
+            }
+        }
 
-				if (FAILED(hr))
-					WARN("IMediaObjectInPlace_Process failed for filter %u\n", i);
-			} else
-				WARN("filter %u has no inplace object - unsupported\n", i);
-		}
-	}
+        if (dsb->device->eax.using_eax)
+            process_eax_buffer(dsb, dsb->device->dsp_buffer, frames * dsb->mix_channels);
+
+        istride = ostride;
+        ostride = dsb->device->pwfx->nChannels * sizeof(float);
+        for (i = 0; i < frames; i++) {
+            for (channel = 0; channel < dsb->mix_channels; channel++) {
+                dsb->put(dsb, i * ostride, channel, getieee32_dsp(dsb, i * istride, channel));
+            }
+        }
+    }
 }
 
 static void DSOUND_MixerVol(const IDirectSoundBufferImpl *dsb, INT frames)
diff --git a/dlls/dwrite/font.c b/dlls/dwrite/font.c
index 2028440..c473a30 100644
--- a/dlls/dwrite/font.c
+++ b/dlls/dwrite/font.c
@@ -2530,7 +2530,7 @@ static struct dwrite_font *unsafe_impl_from_IDWriteFont(IDWriteFont *iface)
     if (!iface)
         return NULL;
     assert(iface->lpVtbl == (IDWriteFontVtbl*)&dwritefontvtbl);
-    return CONTAINING_RECORD(iface, struct dwrite_font, IDWriteFont3_iface);
+    return CONTAINING_RECORD((IDWriteFont3 *)iface, struct dwrite_font, IDWriteFont3_iface);
 }
 
 struct dwrite_fontface *unsafe_impl_from_IDWriteFontFace(IDWriteFontFace *iface)
@@ -2538,7 +2538,7 @@ struct dwrite_fontface *unsafe_impl_from_IDWriteFontFace(IDWriteFontFace *iface)
     if (!iface)
         return NULL;
     assert(iface->lpVtbl == (IDWriteFontFaceVtbl*)&dwritefontfacevtbl);
-    return CONTAINING_RECORD(iface, struct dwrite_fontface, IDWriteFontFace5_iface);
+    return CONTAINING_RECORD((IDWriteFontFace5 *)iface, struct dwrite_fontface, IDWriteFontFace5_iface);
 }
 
 static struct dwrite_fontfacereference *unsafe_impl_from_IDWriteFontFaceReference(IDWriteFontFaceReference *iface)
diff --git a/dlls/dxgi/output.c b/dlls/dxgi/output.c
index e828ed0..2c212a2 100644
--- a/dlls/dxgi/output.c
+++ b/dlls/dxgi/output.c
@@ -708,7 +708,7 @@ struct dxgi_output *unsafe_impl_from_IDXGIOutput(IDXGIOutput *iface)
     if (!iface)
         return NULL;
     assert(iface->lpVtbl == (IDXGIOutputVtbl *)&dxgi_output_vtbl);
-    return CONTAINING_RECORD(iface, struct dxgi_output, IDXGIOutput6_iface);
+    return CONTAINING_RECORD((IDXGIOutput6*)iface, struct dxgi_output, IDXGIOutput6_iface);
 }
 
 static void dxgi_output_init(struct dxgi_output *output, unsigned int output_idx,
diff --git a/dlls/fltmgr.sys/Makefile.in b/dlls/fltmgr.sys/Makefile.in
index 6ebd48d..ae02da9 100644
--- a/dlls/fltmgr.sys/Makefile.in
+++ b/dlls/fltmgr.sys/Makefile.in
@@ -1,5 +1,7 @@
 MODULE    = fltmgr.sys
+IMPORTLIB = fltmgr
 EXTRADLLFLAGS = -Wl,--subsystem,native
+IMPORTS = ntoskrnl
 
 SOURCES = \
 	fltmgr.sys.spec \
diff --git a/dlls/fltmgr.sys/fltmgr.sys.spec b/dlls/fltmgr.sys/fltmgr.sys.spec
index 39ce679..8943b9f 100644
--- a/dlls/fltmgr.sys/fltmgr.sys.spec
+++ b/dlls/fltmgr.sys/fltmgr.sys.spec
@@ -10,7 +10,7 @@
 @ stub FltAllocatePoolAlignedWithTag
 @ stub FltAttachVolume
 @ stub FltAttachVolumeAtAltitude
-@ stub FltBuildDefaultSecurityDescriptor
+@ stdcall FltBuildDefaultSecurityDescriptor(ptr long)
 @ stub FltCancelFileOpen
 @ stub FltCancelIo
 @ stub FltCbdqDisable
@@ -60,7 +60,7 @@
 @ stub FltFreeFileLock
 @ stub FltFreeGenericWorkItem
 @ stub FltFreePoolAlignedWithTag
-@ stub FltFreeSecurityDescriptor
+@ stdcall FltFreeSecurityDescriptor(ptr)
 @ stub FltFsControlFile
 @ stub FltGetBottomInstance
 @ stub FltGetContexts
diff --git a/dlls/fltmgr.sys/main.c b/dlls/fltmgr.sys/main.c
index e1016a4..9a85f4b 100644
--- a/dlls/fltmgr.sys/main.c
+++ b/dlls/fltmgr.sys/main.c
@@ -23,7 +23,6 @@
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
-#include "winbase.h"
 #include "winternl.h"
 #include "ddk/fltkernel.h"
 
@@ -93,3 +92,77 @@ void* WINAPI FltGetRoutineAddress(LPCSTR name)
 
     return func;
 }
+
+NTSTATUS WINAPI FltBuildDefaultSecurityDescriptor(PSECURITY_DESCRIPTOR *descriptor, ACCESS_MASK access)
+{
+    PACL dacl;
+    NTSTATUS ret = STATUS_INSUFFICIENT_RESOURCES;
+    DWORD sid_len;
+    SID *sid;
+    SID *sid_system = NULL;
+    PSECURITY_DESCRIPTOR sec_desc = NULL;
+    SID_IDENTIFIER_AUTHORITY auth = { SECURITY_NULL_SID_AUTHORITY };
+
+    *descriptor = NULL;
+
+    sid_len = RtlLengthRequiredSid(2);
+    sid = ExAllocatePool(PagedPool, sid_len);
+    if (!sid)
+        goto done;
+    RtlInitializeSid(sid, &auth, 2);
+    sid->SubAuthority[1] = DOMAIN_GROUP_RID_ADMINS;
+    sid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
+
+    sid_len = RtlLengthRequiredSid(1);
+    sid_system = ExAllocatePool(PagedPool, sid_len);
+    if (!sid_system)
+        goto done;
+    RtlInitializeSid(sid_system, &auth, 1);
+    sid_system->SubAuthority[0] = SECURITY_LOCAL_SYSTEM_RID;
+
+    sid_len = SECURITY_DESCRIPTOR_MIN_LENGTH + sizeof(ACL) +
+            sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid) +
+            sizeof(ACCESS_ALLOWED_ACE) + RtlLengthSid(sid_system);
+
+    sec_desc = ExAllocatePool(PagedPool, sid_len);
+    if (!sec_desc)
+    {
+        ret = STATUS_NO_MEMORY;
+        goto done;
+    }
+
+    ret = RtlCreateSecurityDescriptor(sec_desc, SECURITY_DESCRIPTOR_REVISION);
+    if (ret != STATUS_SUCCESS)
+        goto done;
+
+    dacl = (PACL)((char*)sec_desc + SECURITY_DESCRIPTOR_MIN_LENGTH);
+    ret = RtlCreateAcl(dacl, sid_len - SECURITY_DESCRIPTOR_MIN_LENGTH, ACL_REVISION);
+    if (ret != STATUS_SUCCESS)
+        goto done;
+
+    ret = RtlAddAccessAllowedAce(dacl, ACL_REVISION, access, sid);
+    if (ret != STATUS_SUCCESS)
+        goto done;
+
+    ret = RtlAddAccessAllowedAce(dacl, ACL_REVISION, access, sid_system);
+    if (ret != STATUS_SUCCESS)
+        goto done;
+
+    ret = RtlSetDaclSecurityDescriptor(sec_desc, 1, dacl, 0);
+    if (ret == STATUS_SUCCESS)
+        *descriptor = sec_desc;
+
+done:
+    if (ret != STATUS_SUCCESS)
+        ExFreePool(sec_desc);
+
+    ExFreePool(sid);
+    ExFreePool(sid_system);
+
+    return ret;
+}
+
+void WINAPI FltFreeSecurityDescriptor(PSECURITY_DESCRIPTOR descriptor)
+{
+    ExFreePool(descriptor);
+}
diff --git a/dlls/gdiplus/graphics.c b/dlls/gdiplus/graphics.c
index 9fd399e..30092ad 100644
--- a/dlls/gdiplus/graphics.c
+++ b/dlls/gdiplus/graphics.c
@@ -595,12 +595,23 @@ static GpStatus alpha_blend_pixels(GpGraphics *graphics, INT dst_x, INT dst_y,
     return alpha_blend_pixels_hrgn(graphics, dst_x, dst_y, src, src_width, src_height, src_stride, NULL, fmt);
 }
 
+/* NOTE: start and end pixels must be in pre-multiplied ARGB format */
+static FORCEINLINE ARGB blend_colors_premult(ARGB start, ARGB end, REAL position)
+{
+    UINT pos = position * 255.0f + 0.5f;
+    return
+        (((((start >> 24)       ) << 8) + (((end >> 24)       ) - ((start >> 24)       )) * pos) >> 8) << 24 |
+        (((((start >> 16) & 0xff) << 8) + (((end >> 16) & 0xff) - ((start >> 16) & 0xff)) * pos) >> 8) << 16 |
+        (((((start >>  8) & 0xff) << 8) + (((end >>  8) & 0xff) - ((start >>  8) & 0xff)) * pos) >> 8) <<  8 |
+        (((((start      ) & 0xff) << 8) + (((end      ) & 0xff) - ((start      ) & 0xff)) * pos) >> 8);
+}
+
 static ARGB blend_colors(ARGB start, ARGB end, REAL position)
 {
     INT start_a, end_a, final_a;
     INT pos;
 
-    pos = gdip_round(position * 0xff);
+    pos = (INT)(position * 255.0f + 0.5f);
 
     start_a = ((start >> 24) & 0xff) * (pos ^ 0xff);
     end_a = ((end >> 24) & 0xff) * pos;
@@ -1006,6 +1017,11 @@ static ARGB sample_bitmap_pixel(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT wi
     return ((DWORD*)(bits))[(x - src_rect->X) + (y - src_rect->Y) * src_rect->Width];
 }
 
+static FORCEINLINE int positive_ceilf(float f)
+{
+    return f - (int)f > 0.0f ? f + 1.0f : f;
+}
+
 static ARGB resample_bitmap_pixel(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT width,
     UINT height, GpPointF *point, GDIPCONST GpImageAttributes *attributes,
     InterpolationMode interpolation, PixelOffsetMode offset_mode)
@@ -1026,12 +1042,12 @@ static ARGB resample_bitmap_pixel(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT
         ARGB top, bottom;
         float x_offset;
 
-        leftxf = floorf(point->X);
-        leftx = (INT)leftxf;
-        rightx = (INT)ceilf(point->X);
-        topyf = floorf(point->Y);
-        topy = (INT)topyf;
-        bottomy = (INT)ceilf(point->Y);
+        leftx = (INT)point->X;
+        leftxf = (REAL)leftx;
+        rightx = positive_ceilf(point->X);
+        topy = (INT)point->Y;
+        topyf = (REAL)topy;
+        bottomy = positive_ceilf(point->Y);
 
         if (leftx == rightx && topy == bottomy)
             return sample_bitmap_pixel(src_rect, bits, width, height,
@@ -1075,6 +1091,75 @@ static ARGB resample_bitmap_pixel(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT
     }
 }
 
+static ARGB resample_bitmap_pixel_premult(GDIPCONST GpRect *src_rect, LPBYTE bits, UINT width,
+    UINT height, GpPointF *point, GDIPCONST GpImageAttributes *attributes,
+    InterpolationMode interpolation, PixelOffsetMode offset_mode)
+{
+    static int fixme;
+
+    switch (interpolation)
+    {
+    default:
+        if (!fixme++)
+            FIXME("Unimplemented interpolation %i\n", interpolation);
+        /* fall-through */
+    case InterpolationModeBilinear:
+    {
+        REAL leftxf, topyf;
+        INT leftx, rightx, topy, bottomy;
+        ARGB topleft, topright, bottomleft, bottomright;
+        ARGB top, bottom;
+        float x_offset;
+
+        leftx = (INT)point->X;
+        leftxf = (REAL)leftx;
+        rightx = positive_ceilf(point->X);
+        topy = (INT)point->Y;
+        topyf = (REAL)topy;
+        bottomy = positive_ceilf(point->Y);
+
+        if (leftx == rightx && topy == bottomy)
+            return sample_bitmap_pixel(src_rect, bits, width, height,
+                leftx, topy, attributes);
+
+        topleft = sample_bitmap_pixel(src_rect, bits, width, height,
+            leftx, topy, attributes);
+        topright = sample_bitmap_pixel(src_rect, bits, width, height,
+            rightx, topy, attributes);
+        bottomleft = sample_bitmap_pixel(src_rect, bits, width, height,
+            leftx, bottomy, attributes);
+        bottomright = sample_bitmap_pixel(src_rect, bits, width, height,
+            rightx, bottomy, attributes);
+
+        x_offset = point->X - leftxf;
+        top = blend_colors_premult(topleft, topright, x_offset);
+        bottom = blend_colors_premult(bottomleft, bottomright, x_offset);
+
+        return blend_colors_premult(top, bottom, point->Y - topyf);
+    }
+    case InterpolationModeNearestNeighbor:
+    {
+        FLOAT pixel_offset;
+        switch (offset_mode)
+        {
+        default:
+        case PixelOffsetModeNone:
+        case PixelOffsetModeHighSpeed:
+            pixel_offset = 0.5;
+            break;
+
+        case PixelOffsetModeHalf:
+        case PixelOffsetModeHighQuality:
+            pixel_offset = 0.0;
+            break;
+        }
+        return sample_bitmap_pixel(src_rect, bits, width, height,
+            floorf(point->X + pixel_offset), point->Y + pixel_offset, attributes);
+    }
+
+    }
+}
+
 static REAL intersect_line_scanline(const GpPointF *p1, const GpPointF *p2, REAL y)
 {
     return (p1->X - p2->X) * (p2->Y - y) / (p2->Y - p1->Y) + p2->X;
@@ -3235,8 +3320,10 @@ GpStatus WINGDIPAPI GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image
             lockeddata.Scan0 = src_data;
             if (!do_resampling && bitmap->format == PixelFormat32bppPARGB)
                 lockeddata.PixelFormat = apply_image_attributes(imageAttributes, NULL, 0, 0, 0, ColorAdjustTypeBitmap, bitmap->format);
-            else
+            else if (imageAttributes != &defaultImageAttributes)
                 lockeddata.PixelFormat = PixelFormat32bppARGB;
+            else
+                lockeddata.PixelFormat = PixelFormat32bppPARGB;
 
             stat = GdipBitmapLockBits(bitmap, &src_area, ImageLockModeRead|ImageLockModeUserInputBuf,
                 lockeddata.PixelFormat, &lockeddata);
@@ -3304,8 +3391,14 @@ GpStatus WINGDIPAPI GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image
                     {
                         if (src_pointf.X >= srcx && src_pointf.X < srcx + srcwidth &&
                             src_pointf.Y >= srcy && src_pointf.Y < srcy + srcheight)
-                            *dst_color = resample_bitmap_pixel(&src_area, src_data, bitmap->width, bitmap->height, &src_pointf,
-                                                               imageAttributes, interpolation, offset_mode);
+                        {
+                            if (lockeddata.PixelFormat != PixelFormat32bppPARGB)
+                                *dst_color = resample_bitmap_pixel(&src_area, src_data, bitmap->width, bitmap->height, &src_pointf,
+                                                                   imageAttributes, interpolation, offset_mode);
+                            else
+                                *dst_color = resample_bitmap_pixel_premult(&src_area, src_data, bitmap->width, bitmap->height, &src_pointf,
+                                                                           imageAttributes, interpolation, offset_mode);
+                        }
                         dst_color++;
                     }
                 }
diff --git a/dlls/gdiplus/image.c b/dlls/gdiplus/image.c
index 806da0c..9089411 100644
--- a/dlls/gdiplus/image.c
+++ b/dlls/gdiplus/image.c
@@ -60,7 +60,12 @@ static const struct
     { &GUID_WICPixelFormat24bppBGR, PixelFormat24bppRGB, 0 },
     { &GUID_WICPixelFormat32bppBGR, PixelFormat32bppRGB, 0 },
     { &GUID_WICPixelFormat32bppBGRA, PixelFormat32bppARGB, 0 },
+    { &GUID_WICPixelFormat32bppCMYK, PixelFormat32bppCMYK, 0 },
+    { &GUID_WICPixelFormat32bppGrayFloat, PixelFormat32bppARGB, 0 },
     { &GUID_WICPixelFormat32bppPBGRA, PixelFormat32bppPARGB, 0 },
+    { &GUID_WICPixelFormat48bppRGB, PixelFormat48bppRGB, 0 },
+    { &GUID_WICPixelFormat64bppCMYK, PixelFormat48bppRGB, 0 },
+    { &GUID_WICPixelFormat64bppRGBA, PixelFormat48bppRGB, 0 },
     { NULL }
 };
 
diff --git a/dlls/gdiplus/tests/image.c b/dlls/gdiplus/tests/image.c
index 8fc9aa7..58be944 100644
--- a/dlls/gdiplus/tests/image.c
+++ b/dlls/gdiplus/tests/image.c
@@ -6308,6 +6308,186 @@ static void test_graphics_clear(void)
     GdipDisposeImage((GpImage *)bitmap);
 }
 
+#include "pshpack2.h"
+static const struct tiff_1x1_data
+{
+    USHORT byte_order;
+    USHORT version;
+    ULONG  dir_offset;
+    USHORT number_of_entries;
+    struct IFD_entry entry[12];
+    ULONG next_IFD;
+    struct IFD_rational res;
+    short palette_data[3][256];
+    short bps_data[4];
+    BYTE pixel_data[32];
+} tiff_1x1_data =
+{
+#ifdef WORDS_BIGENDIAN
+    'M' | 'M' << 8,
+#else
+    'I' | 'I' << 8,
+#endif
+    42,
+    FIELD_OFFSET(struct tiff_1x1_data, number_of_entries),
+    12,
+    {
+        { 0xff, IFD_SHORT, 1, 0 }, /* SUBFILETYPE */
+        { 0x100, IFD_LONG, 1, 1 }, /* IMAGEWIDTH */
+        { 0x101, IFD_LONG, 1, 1 }, /* IMAGELENGTH */
+        { 0x102, IFD_SHORT, 3, FIELD_OFFSET(struct tiff_1x1_data, bps_data) }, /* BITSPERSAMPLE */
+        { 0x103, IFD_SHORT, 1, 1 }, /* COMPRESSION: XP doesn't accept IFD_LONG here */
+        { 0x106, IFD_SHORT, 1, 2 }, /* PHOTOMETRIC */
+        { 0x111, IFD_LONG, 1, FIELD_OFFSET(struct tiff_1x1_data, pixel_data) }, /* STRIPOFFSETS */
+        { 0x115, IFD_SHORT, 1, 3 }, /* SAMPLESPERPIXEL */
+        { 0x11a, IFD_RATIONAL, 1, FIELD_OFFSET(struct tiff_1x1_data, res) },
+        { 0x11b, IFD_RATIONAL, 1, FIELD_OFFSET(struct tiff_1x1_data, res) },
+        { 0x128, IFD_SHORT, 1, 2 }, /* RESOLUTIONUNIT */
+        { 0x140, IFD_SHORT, 256*3, FIELD_OFFSET(struct tiff_1x1_data, palette_data) } /* COLORMAP */
+    },
+    0,
+    { 96, 1 },
+    { { 0 } },
+    { 8,8,8,0 },
+    { 1,0,2,3,4,5,6,7,8,9,0,1,2,3,4,5 }
+};
+#include "poppack.h"
+
+static void test_tiff_color_formats(void)
+{
+    static const struct
+    {
+        int photometric; /* PhotometricInterpretation */
+        int samples; /* SamplesPerPixel */
+        int bps; /* BitsPerSample */
+        PixelFormat format;
+    } td[] =
+    {
+        /* 2 - RGB */
+        { 2, 3, 1, PixelFormat24bppRGB },
+        { 2, 3, 4, PixelFormat24bppRGB },
+        { 2, 3, 8, PixelFormat24bppRGB },
+        { 2, 3, 16, PixelFormat48bppRGB },
+        { 2, 3, 24, 0 },
+#if 0 /* FIXME */
+        { 2, 3, 32, 0 },
+#endif
+        { 2, 4, 1, PixelFormat32bppARGB },
+        { 2, 4, 4, PixelFormat32bppARGB },
+        { 2, 4, 8, PixelFormat32bppARGB },
+        { 2, 4, 16, PixelFormat48bppRGB },
+        { 2, 4, 24, 0 },
+        { 2, 4, 32, 0 },
+        /* 1 - BlackIsZero (Bilevel) */
+        { 1, 1, 1, PixelFormat1bppIndexed },
+#if 0 /* FIXME: PNG vs TIFF mismatch */
+        { 1, 1, 4, PixelFormat8bppIndexed },
+#endif
+        { 1, 1, 8, PixelFormat8bppIndexed },
+        { 1, 1, 16, PixelFormat32bppARGB },
+        { 1, 1, 24, 0 },
+        { 1, 1, 32, PixelFormat32bppARGB },
+        /* 3 - Palette Color */
+        { 3, 1, 1, PixelFormat1bppIndexed },
+        { 3, 1, 4, PixelFormat4bppIndexed },
+        { 3, 1, 8, PixelFormat8bppIndexed },
+#if 0 /* FIXME: for some reason libtiff replaces photometric 3 by 1 for bps > 8 */
+        { 3, 1, 16, 0 },
+        { 3, 1, 24, 0 },
+        { 3, 1, 32, 0 },
+#endif
+        /* 5 - Separated */
+        { 5, 4, 1, 0 },
+        { 5, 4, 4, 0 },
+        { 5, 4, 8, PixelFormat32bppCMYK },
+        { 5, 4, 16, PixelFormat48bppRGB },
+        { 5, 4, 24, 0 },
+        { 5, 4, 32, 0 },
+    };
+    BYTE buf[sizeof(tiff_1x1_data)];
+    GpStatus status;
+    GpImage *image;
+    UINT count, i;
+    struct IFD_entry *tag, *tag_photo = NULL, *tag_bps = NULL, *tag_samples = NULL, *tag_colormap = NULL;
+    short *bps;
+    ImageType type;
+    PixelFormat format;
+
+    memcpy(buf, &tiff_1x1_data, sizeof(tiff_1x1_data));
+
+    count = *(short *)(buf + tiff_1x1_data.dir_offset);
+    tag = (struct IFD_entry *)(buf + tiff_1x1_data.dir_offset + sizeof(short));
+
+    /* verify the TIFF structure */
+    for (i = 0; i < count; i++)
+    {
+        if (tag[i].id == 0x102) /* BitsPerSample */
+            tag_bps = &tag[i];
+        else if (tag[i].id == 0x106) /* PhotometricInterpretation */
+            tag_photo = &tag[i];
+        else if (tag[i].id == 0x115) /* SamplesPerPixel */
+            tag_samples = &tag[i];
+        else if (tag[i].id == 0x140) /* ColorMap */
+            tag_colormap = &tag[i];
+    }
+
+    ok(tag_bps && tag_photo && tag_samples && tag_colormap, "tag 0x102,0x106,0x115 or 0x140 is missing\n");
+    if (!tag_bps || !tag_photo || !tag_samples || !tag_colormap) return;
+
+    ok(tag_bps->type == IFD_SHORT, "tag 0x102 should have type IFD_SHORT\n");
+    bps = (short *)(buf + tag_bps->value);
+    ok(bps[0] == 8 && bps[1] == 8 && bps[2] == 8 && bps[3] == 0,
+       "expected bps 8,8,8,0 got %d,%d,%d,%d\n", bps[0], bps[1], bps[2], bps[3]);
+
+    for (i = 0; i < sizeof(td)/sizeof(td[0]); i++)
+    {
+        tag_colormap->count = (1 << td[i].bps) * 3;
+        tag_photo->value = td[i].photometric;
+        tag_bps->count = td[i].samples;
+        tag_samples->value = td[i].samples;
+
+        if (td[i].samples == 1)
+            tag_bps->value = td[i].bps;
+        else if (td[i].samples == 2)
+            tag_bps->value = MAKELONG(td[i].bps, td[i].bps);
+        else if (td[i].samples == 3)
+        {
+            tag_bps->value = (BYTE *)bps - buf;
+            bps[0] = bps[1] = bps[2] = td[i].bps;
+        }
+        else if (td[i].samples == 4)
+        {
+            tag_bps->value = (BYTE *)bps - buf;
+            bps[0] = bps[1] = bps[2] = bps[3] = td[i].bps;
+        }
+        else
+        {
+            ok(0, "%u: unsupported samples count %d\n", i, td[i].samples);
+            continue;
+        }
+
+        image = load_image(buf, sizeof(buf), TRUE, FALSE);
+        if (!td[i].format)
+            ok(!image,
+               "%u: (%d,%d,%d) TIFF image loading should have failed\n", i, td[i].photometric, td[i].samples, td[i].bps);
+        else
+            ok(image != NULL || broken(!image) /* XP */, "%u: failed to load TIFF image data (%d,%d,%d)\n",
+               i, td[i].photometric, td[i].samples, td[i].bps);
+        if (!image) continue;
+
+        status = GdipGetImageType(image, &type);
+        ok(status == Ok, "%u: GdipGetImageType error %d\n", i, status);
+        ok(type == ImageTypeBitmap, "%u: wrong image type %d\n", i, type);
+
+        status = GdipGetImagePixelFormat(image, &format);
+        expect(Ok, status);
+        ok(format == td[i].format,
+           "%u: expected %#x, got %#x\n", i, td[i].format, format);
+
+        GdipDisposeImage(image);
+    }
+}
+
 START_TEST(image)
 {
     HMODULE mod = GetModuleHandleA("gdiplus.dll");
@@ -6332,6 +6512,7 @@ START_TEST(image)
     pGdipBitmapGetHistogram = (void*)GetProcAddress(mod, "GdipBitmapGetHistogram");
     pGdipImageSetAbort = (void*)GetProcAddress(mod, "GdipImageSetAbort");
 
+    test_tiff_color_formats();
     test_GdipInitializePalette();
     test_png_color_formats();
     test_png_save_palette();
diff --git a/dlls/inseng/Makefile.in b/dlls/inseng/Makefile.in
index 40eda55..72fa353 100644
--- a/dlls/inseng/Makefile.in
+++ b/dlls/inseng/Makefile.in
@@ -1,8 +1,10 @@
 MODULE    = inseng.dll
-IMPORTS   = uuid ole32 advapi32
+IMPORTS   = uuid ole32 advapi32 urlmon shlwapi
 
 EXTRADLLFLAGS = -Wb,--prefer-native
 
 SOURCES = \
+	icif.c \
+	inf.c \
 	inseng_classes.idl \
 	inseng_main.c
diff --git a/dlls/inseng/inseng.spec b/dlls/inseng/inseng.spec
index 82c0b4d..7ae46fa 100644
--- a/dlls/inseng/inseng.spec
+++ b/dlls/inseng/inseng.spec
@@ -7,6 +7,6 @@
 @ stdcall -private DllRegisterServer()
 @ stdcall -private DllUnregisterServer()
 @ stub DownloadFile
-@ stub GetICifFileFromFile
-@ stub GetICifRWFileFromFile
+@ stdcall GetICifFileFromFile(ptr str)
+@ stdcall GetICifRWFileFromFile(ptr str)
 @ stub PurgeDownloadDirectory
diff --git a/dlls/inseng/inseng_main.c b/dlls/inseng/inseng_main.c
index f7ce3f1..ad6fe6b 100644
--- a/dlls/inseng/inseng_main.c
+++ b/dlls/inseng/inseng_main.c
@@ -2,6 +2,7 @@
  *    INSENG Implementation
  *
  * Copyright 2006 Mike McCormack
+ * Copyright 2016 Michael MÃ¼ller
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -28,16 +29,68 @@
 #include "winuser.h"
 #include "ole2.h"
 #include "rpcproxy.h"
+#include "urlmon.h"
+#include "shlwapi.h"
 #include "initguid.h"
 #include "inseng.h"
 
+#include "inseng_private.h"
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(inseng);
 
+enum thread_operation
+{
+    OP_DOWNLOAD,
+    OP_INSTALL
+};
+
+struct thread_info
+{
+    DWORD operation;
+    DWORD jobflags;
+    IEnumCifComponents *enum_comp;
+
+    DWORD download_size;
+    DWORD install_size;
+
+    DWORD downloaded_kb;
+    ULONGLONG download_start;
+};
+
 struct InstallEngine {
     IInstallEngine2 IInstallEngine2_iface;
+    IInstallEngineTiming IInstallEngineTiming_iface;
     LONG ref;
+
+    IInstallEngineCallback *callback;
+    char *baseurl;
+    char *downloaddir;
+    ICifFile *icif;
+    DWORD status;
+
+    /* used for the installation thread */
+    struct thread_info thread;
+};
+
+struct downloadcb
+{
+    IBindStatusCallback IBindStatusCallback_iface;
+    LONG ref;
+
+    WCHAR *file_name;
+    WCHAR *cache_file;
+
+    char *id;
+    char *display;
+
+    DWORD dl_size;
+    DWORD dl_previous_kb;
+
+    InstallEngine *engine;
+    HANDLE event_done;
+    HRESULT hr;
 };
 
 static inline InstallEngine *impl_from_IInstallEngine2(IInstallEngine2 *iface)
@@ -45,6 +98,250 @@ static inline InstallEngine *impl_from_IInstallEngine2(IInstallEngine2 *iface)
     return CONTAINING_RECORD(iface, InstallEngine, IInstallEngine2_iface);
 }
 
+static inline struct downloadcb *impl_from_IBindStatusCallback(IBindStatusCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct downloadcb, IBindStatusCallback_iface);
+}
+
+static inline InstallEngine *impl_from_IInstallEngineTiming(IInstallEngineTiming *iface)
+{
+    return CONTAINING_RECORD(iface, InstallEngine, IInstallEngineTiming_iface);
+}
+
+static HRESULT WINAPI downloadcb_QueryInterface(IBindStatusCallback *iface, REFIID riid, void **ppv)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->IBindStatusCallback_iface;
+    }
+    else if (IsEqualGUID(&IID_IBindStatusCallback, riid))
+    {
+        TRACE("(%p)->(IID_IBindStatusCallback %p)\n", This, ppv);
+        *ppv = &This->IBindStatusCallback_iface;
+    }
+    else
+    {
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
+        *ppv = NULL;
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI downloadcb_AddRef(IBindStatusCallback *iface)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    LONG ref = InterlockedIncrement(&This->ref);
+
+    TRACE("(%p) ref = %ld\n", This, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI downloadcb_Release(IBindStatusCallback *iface)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    LONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE("(%p) ref = %ld\n", This, ref);
+
+    if (!ref)
+    {
+        heap_free(This->file_name);
+        heap_free(This->cache_file);
+
+        IInstallEngine2_Release(&This->engine->IInstallEngine2_iface);
+        heap_free(This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI downloadcb_OnStartBinding(IBindStatusCallback *iface, DWORD reserved, IBinding *pbind)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%lu %p)\n", This, reserved, pbind);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_GetPriority(IBindStatusCallback *iface, LONG *priority)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%p): stub\n", This, priority);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI downloadcb_OnLowResource(IBindStatusCallback *iface, DWORD reserved)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%lu): stub\n", This, reserved);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI downloadcb_OnProgress(IBindStatusCallback *iface, ULONG progress,
+        ULONG progress_max, ULONG status, const WCHAR *status_text)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+    HRESULT hr = S_OK;
+
+    TRACE("%p)->(%lu %lu %lu %s)\n", This, progress, progress_max, status, debugstr_w(status_text));
+
+    switch(status)
+    {
+        case BINDSTATUS_BEGINDOWNLOADDATA:
+            if (!This->engine->thread.download_start)
+                This->engine->thread.download_start = GetTickCount64();
+            /* fall-through */
+        case BINDSTATUS_DOWNLOADINGDATA:
+        case BINDSTATUS_ENDDOWNLOADDATA:
+            This->engine->thread.downloaded_kb = This->dl_previous_kb + progress / 1024;
+            if (This->engine->callback)
+            {
+                hr = IInstallEngineCallback_OnComponentProgress(This->engine->callback,
+                         This->id, INSTALLSTATUS_DOWNLOADING, This->display, NULL, progress / 1024, This->dl_size);
+            }
+            break;
+
+        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
+            This->cache_file = strdupW(status_text);
+            if (!This->cache_file)
+            {
+                ERR("Failed to allocate memory for cache file\n");
+                hr = E_OUTOFMEMORY;
+            }
+            break;
+
+        case BINDSTATUS_CONNECTING:
+        case BINDSTATUS_SENDINGREQUEST:
+        case BINDSTATUS_MIMETYPEAVAILABLE:
+        case BINDSTATUS_FINDINGRESOURCE:
+            break;
+
+        default:
+            FIXME("Unsupported status %lu\n", status);
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI downloadcb_OnStopBinding(IBindStatusCallback *iface, HRESULT hresult, LPCWSTR szError)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%#lx %s)\n", This, hresult, debugstr_w(szError));
+
+    if (FAILED(hresult))
+    {
+        This->hr = hresult;
+        goto done;
+    }
+
+    if (!This->cache_file)
+    {
+        This->hr = E_FAIL;
+        goto done;
+    }
+
+    if (CopyFileW(This->cache_file, This->file_name, FALSE))
+        This->hr = S_OK;
+    else
+    {
+        ERR("CopyFile failed: %lu\n", GetLastError());
+        This->hr = E_FAIL;
+    }
+
+done:
+    SetEvent(This->event_done);
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_GetBindInfo(IBindStatusCallback *iface,
+        DWORD *grfBINDF, BINDINFO *pbindinfo)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%p %p)\n", This, grfBINDF, pbindinfo);
+
+    *grfBINDF = BINDF_PULLDATA | BINDF_NEEDFILE;
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_OnDataAvailable(IBindStatusCallback *iface,
+        DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    TRACE("(%p)->(%#lx %lu %p %p)\n", This, grfBSCF, dwSize, pformatetc, pstgmed);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI downloadcb_OnObjectAvailable(IBindStatusCallback *iface,
+        REFIID riid, IUnknown *punk)
+{
+    struct downloadcb *This = impl_from_IBindStatusCallback(iface);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_guid(riid), punk);
+
+    return E_NOTIMPL;
+}
+
+static const IBindStatusCallbackVtbl BindStatusCallbackVtbl =
+{
+    downloadcb_QueryInterface,
+    downloadcb_AddRef,
+    downloadcb_Release,
+    downloadcb_OnStartBinding,
+    downloadcb_GetPriority,
+    downloadcb_OnLowResource,
+    downloadcb_OnProgress,
+    downloadcb_OnStopBinding,
+    downloadcb_GetBindInfo,
+    downloadcb_OnDataAvailable,
+    downloadcb_OnObjectAvailable
+};
+
+static HRESULT downloadcb_create(InstallEngine *engine, HANDLE event, char *file_name, char *id,
+                                 char *display, DWORD dl_size, struct downloadcb **callback)
+{
+    struct downloadcb *cb;
+
+    cb = heap_alloc_zero(sizeof(*cb));
+    if (!cb) return E_OUTOFMEMORY;
+
+    cb->IBindStatusCallback_iface.lpVtbl = &BindStatusCallbackVtbl;
+    cb->ref = 1;
+    cb->hr = E_FAIL;
+    cb->id = id;
+    cb->display = display;
+    cb->engine = engine;
+    cb->dl_size = dl_size;
+    cb->dl_previous_kb = engine->thread.downloaded_kb;
+    cb->event_done = event;
+    cb->file_name = strAtoW(file_name);
+    if (!cb->file_name)
+    {
+        heap_free(cb);
+        return E_OUTOFMEMORY;
+    }
+
+    IInstallEngine2_AddRef(&engine->IInstallEngine2_iface);
+
+    *callback = cb;
+    return S_OK;
+}
+
 static HRESULT WINAPI InstallEngine_QueryInterface(IInstallEngine2 *iface, REFIID riid, void **ppv)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
@@ -58,13 +355,16 @@ static HRESULT WINAPI InstallEngine_QueryInterface(IInstallEngine2 *iface, REFII
     }else if(IsEqualGUID(&IID_IInstallEngine2, riid)) {
         TRACE("(%p)->(IID_IInstallEngine2 %p)\n", This, ppv);
         *ppv = &This->IInstallEngine2_iface;
+    }else if(IsEqualGUID(&IID_IInstallEngineTiming, riid)) {
+        TRACE("(%p)->(IID_IInstallEngineTiming %p)\n", This, ppv);
+        *ppv = &This->IInstallEngineTiming_iface;
     }else {
-        TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), ppv);
+        FIXME("(%p)->(%s %p) not found\n", This, debugstr_guid(riid), ppv);
         *ppv = NULL;
         return E_NOINTERFACE;
     }
 
-    IUnknown_AddRef((IUnknown*)*ppv);
+    IUnknown_AddRef((IUnknown *)*ppv);
     return S_OK;
 }
 
@@ -85,181 +385,726 @@ static ULONG WINAPI InstallEngine_Release(IInstallEngine2 *iface)
 
     TRACE("(%p) ref=%ld\n", This, ref);
 
-    if(!ref)
+    if (!ref)
+    {
+        if (This->icif)
+            ICifFile_Release(This->icif);
+
+        free(This->baseurl);
+        free(This->downloaddir);
         free(This);
+    }
 
     return ref;
 }
 
+static void set_status(InstallEngine *This, DWORD status)
+{
+    This->status = status;
+
+    if (This->callback)
+        IInstallEngineCallback_OnEngineStatusChange(This->callback, status, 0);
+}
+
+static HRESULT calc_sizes(IEnumCifComponents *enum_comp, DWORD operation, DWORD *size_download, DWORD *size_install)
+{
+    ICifComponent *comp;
+    DWORD download = 0;
+    DWORD install = 0;
+    HRESULT hr;
+
+    /* FIXME: what about inactive dependencies and how does
+     * INSTALLOPTIONS_FORCEDEPENDENCIES play into this ?*/
+
+    hr = IEnumCifComponents_Reset(enum_comp);
+    if (FAILED(hr)) return hr;
+
+    while (SUCCEEDED(IEnumCifComponents_Next(enum_comp, &comp)))
+    {
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        /* FIXME: handle install options and find out the default options*/
+        if (operation == OP_DOWNLOAD && ICifComponent_IsComponentDownloaded(comp) == S_FALSE)
+            download = ICifComponent_GetDownloadSize(comp);
+        /*
+        if (operation == OP_INSTALL && ICifComponent_IsComponentInstalled(comp) == S_FALSE)
+            install = ICifComponent_GetInstalledSize(comp);
+        */
+    }
+
+    *size_download = download;
+    *size_install = install;
+
+    return S_OK;
+}
+
+static HRESULT get_next_component(IEnumCifComponents *enum_comp, DWORD operation, ICifComponent **ret_comp)
+{
+    ICifComponent *comp;
+    HRESULT hr;
+
+    hr = IEnumCifComponents_Reset(enum_comp);
+    if (FAILED(hr)) return hr;
+
+    while (SUCCEEDED(IEnumCifComponents_Next(enum_comp, &comp)))
+    {
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        /* FIXME: handle install options and find out the default options*/
+        if (operation == OP_DOWNLOAD && ICifComponent_IsComponentDownloaded(comp) != S_FALSE)
+            continue;
+        if (operation == OP_INSTALL && ICifComponent_IsComponentInstalled(comp) != S_FALSE)
+            continue;
+
+        *ret_comp = comp;
+        return S_OK;
+    }
+
+    return S_FALSE;
+}
+
+static HRESULT get_url(ICifComponent *comp, int index, char **url, DWORD *flags)
+{
+    char *url_temp = NULL;
+    int size = MAX_PATH / 2;
+    HRESULT hr;
+
+    /* FIXME: should we add an internal get function to prevent this ugly code ? */
+
+    /* check if there is an url with such an index */
+    hr = ICifComponent_GetUrl(comp, index, NULL, 0, flags);
+    if (FAILED(hr))
+    {
+        *url = NULL;
+        *flags = 0;
+        return S_OK;
+    }
+
+    do
+    {
+        size *= 2;
+        heap_free(url_temp);
+        url_temp = heap_alloc(size);
+        if (!url_temp) return E_OUTOFMEMORY;
+
+        hr = ICifComponent_GetUrl(comp, index, url_temp, size, flags);
+        if (FAILED(hr))
+        {
+            heap_free(url_temp);
+            return hr;
+        }
+    }
+    while (strlen(url_temp) == size-1);
+
+    *url = url_temp;
+    return S_OK;
+}
+
+static char *combine_url(char *baseurl, char *url)
+{
+    int len_base = strlen(baseurl);
+    int len_url = strlen(url);
+    char *combined;
+
+    combined = heap_alloc(len_base + len_url + 2);
+    if (!combined) return NULL;
+
+    strcpy(combined, baseurl);
+    if (len_base && combined[len_base-1] != '/')
+        strcat(combined, "/");
+    strcat(combined, url);
+
+    return combined;
+}
+
+static HRESULT generate_moniker(char *baseurl, char *url, DWORD flags, IMoniker **moniker)
+{
+    WCHAR *urlW;
+    HRESULT hr;
+
+    if (flags & URLF_RELATIVEURL)
+    {
+        char *combined;
+        if (!baseurl)
+            return E_FAIL;
+
+        combined = combine_url(baseurl, url);
+        if (!combined) return E_OUTOFMEMORY;
+
+        urlW = strAtoW(combined);
+        heap_free(combined);
+        if (!urlW) return E_OUTOFMEMORY;
+    }
+    else
+    {
+        urlW = strAtoW(url);
+        if (!urlW) return E_OUTOFMEMORY;
+    }
+
+    hr = CreateURLMoniker(NULL, urlW, moniker);
+    heap_free(urlW);
+    return hr;
+}
+
+static char *merge_path(char *path1, char *path2)
+{
+    int len = strlen(path1) + strlen(path2) + 2;
+    char *combined = heap_alloc(len);
+
+    if (!combined) return NULL;
+    strcpy(combined, path1);
+    strcat(combined, "\\");
+    strcat(combined, path2);
+
+    return combined;
+}
+
+static HRESULT download_url(InstallEngine *This, char *id, char *display, char *url, DWORD flags, DWORD dl_size)
+{
+    struct downloadcb *callback = NULL;
+    char *filename    = NULL;
+    IUnknown *unk     = NULL;
+    IMoniker *mon     = NULL;
+    IBindCtx *bindctx = NULL;
+    HANDLE event      = NULL;
+    HRESULT hr;
+
+    if (!This->downloaddir)
+    {
+        WARN("No download directory set\n");
+        return E_FAIL;
+    }
+
+    hr = generate_moniker(This->baseurl, url, flags, &mon);
+    if (FAILED(hr))
+    {
+        FIXME("Failed to create moniker\n");
+        return hr;
+    }
+
+    event = CreateEventW(NULL, TRUE, FALSE, NULL);
+    if (!event)
+    {
+        IMoniker_Release(mon);
+        return E_FAIL;
+    }
+
+    filename = strrchr(url, '/');
+    if (!filename) filename = url;
+
+    filename = merge_path(This->downloaddir, filename);
+    if (!filename)
+    {
+        hr = E_OUTOFMEMORY;
+        goto error;
+    }
+
+    hr = downloadcb_create(This, event, filename, id, display, dl_size, &callback);
+    if (FAILED(hr)) goto error;
+
+    hr = CreateAsyncBindCtx(0, &callback->IBindStatusCallback_iface, NULL, &bindctx);
+    if(FAILED(hr)) goto error;
+
+    hr = IMoniker_BindToStorage(mon, bindctx, NULL, &IID_IUnknown, (void**)&unk);
+    if (FAILED(hr)) goto error;
+    if (unk) IUnknown_Release(unk);
+
+    heap_free(filename);
+    IMoniker_Release(mon);
+    IBindCtx_Release(bindctx);
+
+    WaitForSingleObject(event, INFINITE);
+    hr = callback->hr;
+
+    CloseHandle(event);
+    IBindStatusCallback_Release(&callback->IBindStatusCallback_iface);
+    return hr;
+
+error:
+    if (mon) IMoniker_Release(mon);
+    if (event) CloseHandle(event);
+    if (callback) IBindStatusCallback_Release(&callback->IBindStatusCallback_iface);
+    if (bindctx) IBindCtx_Release(bindctx);
+    if (filename) heap_free(filename);
+    return hr;
+}
+
+static HRESULT process_component_dependencies(InstallEngine *This, ICifComponent *comp)
+{
+    char id[MAX_ID_LENGTH+1], type;
+    DWORD ver, build;
+    HRESULT hr;
+    int i;
+
+    for (i = 0;; i++)
+    {
+        hr = ICifComponent_GetDependency(comp, i, id, sizeof(id), &type, &ver, &build);
+        if (SUCCEEDED(hr))
+            FIXME("Can't handle dependencies yet: %s\n", debugstr_a(id));
+        else
+            break;
+    }
+
+    return S_OK;
+}
+
+static HRESULT process_component(InstallEngine *This, ICifComponent *comp)
+{
+    DWORD size_dl, size_install, phase;
+    char display[MAX_DISPLAYNAME_LENGTH+1];
+    char id[MAX_ID_LENGTH+1];
+    HRESULT hr;
+    int i;
+
+    hr = ICifComponent_GetID(comp, id, sizeof(id));
+    if (FAILED(hr)) return hr;
+
+    TRACE("processing component %s\n", debugstr_a(id));
+
+    hr = ICifComponent_GetDescription(comp, display, sizeof(display));
+    if (FAILED(hr)) return hr;
+
+    size_dl      = (This->thread.operation == OP_DOWNLOAD) ? ICifComponent_GetDownloadSize(comp) : 0;
+    size_install = 0; /* (This->thread.operation == OP_INSTALL) ? ICifComponent_GetInstalledSize(comp) : 0; */
+
+    if (This->callback)
+    {
+        IInstallEngineCallback_OnStartComponent(This->callback, id, size_dl, size_install, display);
+        IInstallEngineCallback_OnComponentProgress(This->callback, id, INSTALLSTATUS_INITIALIZING, display, NULL, 0, 0);
+        phase = INSTALLSTATUS_INITIALIZING;
+    }
+
+    hr = process_component_dependencies(This, comp);
+    if (FAILED(hr)) return hr;
+
+    if (This->thread.operation == OP_DOWNLOAD)
+    {
+        for (i = 0;; i++)
+        {
+            DWORD flags;
+            char *url;
+
+            phase = INSTALLSTATUS_DOWNLOADING;
+
+            hr = get_url(comp, i, &url, &flags);
+            if (FAILED(hr)) goto done;
+            if (!url) break;
+
+            TRACE("processing url %s\n", debugstr_a(url));
+
+            hr = download_url(This, id, display, url, flags, size_dl);
+            heap_free(url);
+            if (FAILED(hr))
+            {
+                DWORD retry = 0;
+
+                if (This->callback)
+                    IInstallEngineCallback_OnEngineProblem(This->callback, ENGINEPROBLEM_DOWNLOADFAIL, &retry);
+                if (!retry) goto done;
+
+                i--;
+                continue;
+            }
+
+            phase = INSTALLSTATUS_CHECKINGTRUST;
+            /* FIXME: check trust */
+            IInstallEngineCallback_OnComponentProgress(This->callback, id, INSTALLSTATUS_CHECKINGTRUST, display, NULL, 0, 0);
+        }
+
+        component_set_downloaded(comp, TRUE);
+        phase = INSTALLSTATUS_DOWNLOADFINISHED;
+    }
+    else
+        FIXME("Installation not yet implemented\n");
+
+done:
+    IInstallEngineCallback_OnStopComponent(This->callback, id, hr, phase, display, 0);
+    return hr;
+}
+
+DWORD WINAPI thread_installation(LPVOID param)
+{
+    InstallEngine *This = param;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    if (This->callback)
+        IInstallEngineCallback_OnStartInstall(This->callback, This->thread.download_size, This->thread.install_size);
+
+    for (;;)
+    {
+        hr = get_next_component(This->thread.enum_comp, This->thread.operation, &comp);
+        if (FAILED(hr)) break;
+        if (hr == S_FALSE)
+        {
+            hr = S_OK;
+            break;
+        }
+
+        hr = process_component(This, comp);
+        if (FAILED(hr)) break;
+    }
+
+    if (This->callback)
+        IInstallEngineCallback_OnStopInstall(This->callback, hr, NULL, 0);
+
+    IEnumCifComponents_Release(This->thread.enum_comp);
+    IInstallEngine2_Release(&This->IInstallEngine2_iface);
+
+    set_status(This, ENGINESTATUS_READY);
+    return 0;
+}
+
+static HRESULT start_installation(InstallEngine *This, DWORD operation, DWORD jobflags)
+{
+    HANDLE thread;
+    HRESULT hr;
+
+    This->thread.operation = operation;
+    This->thread.jobflags  = jobflags;
+    This->thread.downloaded_kb = 0;
+    This->thread.download_start = 0;
+
+    /* Windows sends the OnStartInstall event from a different thread,
+     * but OnStartInstall already contains the required download and install size.
+     * The only way to signal an error from the thread is to send an OnStopComponent /
+     * OnStopInstall signal which can only occur after OnStartInstall. We need to
+     * precompute the sizes here to be able inform the application about errors while
+     * calculating the required sizes. */
+
+    hr = ICifFile_EnumComponents(This->icif, &This->thread.enum_comp, 0, NULL);
+    if (FAILED(hr)) return hr;
+
+    hr = calc_sizes(This->thread.enum_comp, operation, &This->thread.download_size, &This->thread.install_size);
+    if (FAILED(hr)) goto error;
+
+    IInstallEngine2_AddRef(&This->IInstallEngine2_iface);
+
+    thread = CreateThread(NULL, 0, thread_installation, This, 0, NULL);
+    if (!thread)
+    {
+        IInstallEngine2_Release(&This->IInstallEngine2_iface);
+        hr = E_FAIL;
+        goto error;
+    }
+
+    CloseHandle(thread);
+    return S_OK;
+
+error:
+    IEnumCifComponents_Release(This->thread.enum_comp);
+    return hr;
+}
+
 static HRESULT WINAPI InstallEngine_GetEngineStatus(IInstallEngine2 *iface, DWORD *status)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, status);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, status);
+
+    if (!status)
+        return E_FAIL;
+
+    *status = This->status;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_SetCifFile(IInstallEngine2 *iface, const char *cab_name, const char *cif_name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(cab_name), debugstr_a(cif_name));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(cab_name), debugstr_a(cif_name));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_DownloadComponents(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%#lx)\n", This, flags);
+
+    /* The interface is not really threadsafe on windows, but we can at least prevent multiple installations */
+    if (InterlockedCompareExchange((LONG *)&This->status, ENGINESTATUS_INSTALLING, ENGINESTATUS_READY) != ENGINESTATUS_READY)
+        return E_FAIL;
+
+    if (This->callback)
+        IInstallEngineCallback_OnEngineStatusChange(This->callback, ENGINESTATUS_INSTALLING, 0);
+
+    return start_installation(This, OP_DOWNLOAD, flags);
 }
 
 static HRESULT WINAPI InstallEngine_InstallComponents(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_EnumInstallIDs(IInstallEngine2 *iface, UINT index, char **id)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%d %p)\n", This, index, id);
+
+    FIXME("(%p)->(%u %p): stub\n", This, index, id);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_EnumDownloadIDs(IInstallEngine2 *iface, UINT index, char **id)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%d %p)\n", This, index, id);
-    return E_NOTIMPL;
+    IEnumCifComponents *enum_components;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    TRACE("(%p)->(%u %p)\n", This, index, id);
+
+    if (!This->icif || !id)
+        return E_FAIL;
+
+    hr = ICifFile_EnumComponents(This->icif, &enum_components, 0, NULL);
+    if (FAILED(hr)) return hr;
+
+    for (;;)
+    {
+        hr = IEnumCifComponents_Next(enum_components, &comp);
+        if (FAILED(hr)) goto done;
+
+        if (ICifComponent_GetInstallQueueState(comp) != ActionInstall)
+            continue;
+
+        if (ICifComponent_IsComponentDownloaded(comp) != S_FALSE)
+            continue;
+
+        if (index == 0)
+        {
+            char *id_src = component_get_id(comp);
+            *id = CoTaskMemAlloc(strlen(id_src) + 1);
+
+            if (*id)
+                strcpy(*id, id_src);
+            else
+                hr = E_OUTOFMEMORY;
+            goto done;
+        }
+
+        index--;
+    }
+
+done:
+    IEnumCifComponents_Release(enum_components);
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine_IsComponentInstalled(IInstallEngine2 *iface, const char *id, DWORD *status)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_a(id), status);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_a(id), status);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_RegisterInstallEngineCallback(IInstallEngine2 *iface, IInstallEngineCallback *callback)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, callback);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, callback);
+
+    This->callback = callback;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_UnregisterInstallEngineCallback(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
-    return E_NOTIMPL;
+
+    TRACE("(%p)\n", This);
+
+    This->callback = NULL;
+    return S_OK;
 }
 
 static HRESULT WINAPI InstallEngine_SetAction(IInstallEngine2 *iface, const char *id, DWORD action, DWORD priority)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %ld %ld)\n", This, debugstr_a(id), action, priority);
-    return E_NOTIMPL;
+    ICifComponent *comp;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s %lu %lu)\n", This, debugstr_a(id), action, priority);
+
+    if (!This->icif)
+        return E_FAIL; /* FIXME: check error code */
+
+    hr = ICifFile_FindComponent(This->icif, id, &comp);
+    if (FAILED(hr)) return hr;
+
+    hr = ICifComponent_SetInstallQueueState(comp, action);
+    if (FAILED(hr)) return hr;
+
+    hr = ICifComponent_SetCurrentPriority(comp, priority);
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine_GetSizes(IInstallEngine2 *iface, const char *id, COMPONENT_SIZES *sizes)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_a(id), sizes);
+
+    FIXME("(%p)->(%s %p): stub\n", This, debugstr_a(id), sizes);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_LaunchExtraCommand(IInstallEngine2 *iface, const char *inf_name, const char *section)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(inf_name), debugstr_a(section));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(inf_name), debugstr_a(section));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_GetDisplayName(IInstallEngine2 *iface, const char *id, const char *name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s %s)\n", This, debugstr_a(id), debugstr_a(name));
+
+    FIXME("(%p)->(%s %s): stub\n", This, debugstr_a(id), debugstr_a(name));
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetBaseUrl(IInstallEngine2 *iface, const char *base_name)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(base_name));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(base_name));
+
+    if (This->baseurl)
+        heap_free(This->baseurl);
+
+    This->baseurl = strdupA(base_name);
+    return This->baseurl ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI InstallEngine_SetDownloadDir(IInstallEngine2 *iface, const char *download_dir)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(download_dir));
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(download_dir));
+
+    if (This->downloaddir)
+        heap_free(This->downloaddir);
+
+    This->downloaddir = strdupA(download_dir);
+    return This->downloaddir ? S_OK : E_OUTOFMEMORY;
 }
 
 static HRESULT WINAPI InstallEngine_SetInstallDrive(IInstallEngine2 *iface, char drive)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%c)\n", This, drive);
+
+    FIXME("(%p)->(%c): stub\n", This, drive);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetInstallOptions(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetHWND(IInstallEngine2 *iface, HWND hwnd)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, hwnd);
+
+    FIXME("(%p)->(%p): stub\n", This, hwnd);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_SetIStream(IInstallEngine2 *iface, IStream *stream)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, stream);
+
+    FIXME("(%p)->(%p): stub\n", This, stream);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Abort(IInstallEngine2 *iface, DWORD flags)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%lx)\n", This, flags);
+
+    FIXME("(%p)->(%#lx): stub\n", This, flags);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Suspend(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
+
+    FIXME("(%p): stub\n", This);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine_Resume(IInstallEngine2 *iface)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)\n", This);
+
+    FIXME("(%p): stub\n", This);
+
     return E_NOTIMPL;
 }
 
 static HRESULT WINAPI InstallEngine2_SetLocalCif(IInstallEngine2 *iface, const char *cif)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_a(cif));
-    return E_NOTIMPL;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_a(cif));
+
+    if (This->icif)
+        ICifFile_Release(This->icif);
+
+    set_status(This, ENGINESTATUS_LOADING);
+
+    hr = GetICifFileFromFile(&This->icif, cif);
+    if (SUCCEEDED(hr))
+        set_status(This, ENGINESTATUS_READY);
+    else
+    {
+        This->icif = NULL;
+        set_status(This, ENGINESTATUS_NOTREADY);
+    }
+    return hr;
 }
 
 static HRESULT WINAPI InstallEngine2_GetICifFile(IInstallEngine2 *iface, ICifFile **cif_file)
 {
     InstallEngine *This = impl_from_IInstallEngine2(iface);
-    FIXME("(%p)->(%p)\n", This, cif_file);
-    return E_NOTIMPL;
+
+    TRACE("(%p)->(%p)\n", This, cif_file);
+
+    if (!This->icif || !cif_file)
+        return E_FAIL;
+
+    ICifFile_AddRef(This->icif);
+    *cif_file = This->icif;
+    return S_OK;
 }
 
-static const IInstallEngine2Vtbl InstallEngine2Vtbl = {
+static const IInstallEngine2Vtbl InstallEngine2Vtbl =
+{
     InstallEngine_QueryInterface,
     InstallEngine_AddRef,
     InstallEngine_Release,
@@ -289,6 +1134,70 @@ static const IInstallEngine2Vtbl InstallEngine2Vtbl = {
     InstallEngine2_GetICifFile
 };
 
+static HRESULT WINAPI InstallEngineTiming_QueryInterface(IInstallEngineTiming *iface, REFIID riid, void **ppv)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_QueryInterface(&This->IInstallEngine2_iface, riid, ppv);
+}
+
+static ULONG WINAPI InstallEngineTiming_AddRef(IInstallEngineTiming *iface)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_AddRef(&This->IInstallEngine2_iface);
+}
+
+static ULONG WINAPI InstallEngineTiming_Release(IInstallEngineTiming *iface)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    return IInstallEngine2_Release(&This->IInstallEngine2_iface);
+}
+
+static HRESULT WINAPI InstallEngineTiming_GetRates(IInstallEngineTiming *iface, DWORD *download, DWORD *install)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+
+    FIXME("(%p)->(%p, %p): stub\n", This, download, install);
+
+    *download = 0;
+    *install = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI InstallEngineTiming_GetInstallProgress(IInstallEngineTiming *iface, INSTALLPROGRESS *progress)
+{
+    InstallEngine *This = impl_from_IInstallEngineTiming(iface);
+    ULONGLONG elapsed;
+    static int once;
+
+    if (!once)
+        FIXME("(%p)->(%p): semi-stub\n", This, progress);
+    else
+        TRACE("(%p)->(%p): semi-stub\n", This, progress);
+
+    progress->dwDownloadKBRemaining = max(This->thread.download_size, This->thread.downloaded_kb) - This->thread.downloaded_kb;
+
+    elapsed = GetTickCount64() - This->thread.download_start;
+    if (This->thread.download_start && This->thread.downloaded_kb && elapsed > 100)
+        progress->dwDownloadSecsRemaining = (progress->dwDownloadKBRemaining * elapsed) / (This->thread.downloaded_kb * 1000);
+    else
+        progress->dwDownloadSecsRemaining = -1;
+
+    progress->dwInstallKBRemaining = 0;
+    progress->dwInstallSecsRemaining = -1;
+
+    return S_OK;
+}
+
+static const IInstallEngineTimingVtbl InstallEngineTimingVtbl =
+{
+    InstallEngineTiming_QueryInterface,
+    InstallEngineTiming_AddRef,
+    InstallEngineTiming_Release,
+    InstallEngineTiming_GetRates,
+    InstallEngineTiming_GetInstallProgress,
+};
+
 static HRESULT WINAPI ClassFactory_QueryInterface(IClassFactory *iface, REFIID riid, void **ppv)
 {
     *ppv = NULL;
@@ -333,12 +1242,14 @@ static HRESULT WINAPI InstallEngineCF_CreateInstance(IClassFactory *iface, IUnkn
 
     TRACE("(%p %s %p)\n", outer, debugstr_guid(riid), ppv);
 
-    engine = malloc(sizeof(*engine));
+    engine = calloc(1, sizeof(*engine));
     if(!engine)
         return E_OUTOFMEMORY;
 
     engine->IInstallEngine2_iface.lpVtbl = &InstallEngine2Vtbl;
+    engine->IInstallEngineTiming_iface.lpVtbl = &InstallEngineTimingVtbl;
     engine->ref = 1;
+    engine->status = ENGINESTATUS_NOTREADY;
 
     hres = IInstallEngine2_QueryInterface(&engine->IInstallEngine2_iface, riid, ppv);
     IInstallEngine2_Release(&engine->IInstallEngine2_iface);
diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
index f4bdc08..49c4c64 100644
--- a/dlls/kernel32/path.c
+++ b/dlls/kernel32/path.c
@@ -463,8 +463,16 @@ WCHAR * CDECL wine_get_dos_file_name( LPCSTR str )
  */
 BOOLEAN WINAPI CreateSymbolicLinkA(LPCSTR link, LPCSTR target, DWORD flags)
 {
-    FIXME("(%s %s %ld): stub\n", debugstr_a(link), debugstr_a(target), flags);
-    return TRUE;
+    WCHAR *linkW, *targetW;
+    BOOL ret;
+
+    if (!(linkW = FILE_name_AtoW( link, FALSE ))) return FALSE;
+    if (!(targetW = FILE_name_AtoW( target, TRUE ))) return FALSE;
+
+    ret = CreateSymbolicLinkW( linkW, targetW, flags );
+
+    HeapFree( GetProcessHeap(), 0, targetW );
+    return ret;
 }
 
 /*************************************************************************
diff --git a/dlls/kernel32/tests/file.c b/dlls/kernel32/tests/file.c
index 17cfe24..a4d2db9 100644
--- a/dlls/kernel32/tests/file.c
+++ b/dlls/kernel32/tests/file.c
@@ -1161,23 +1161,17 @@ static void test_CopyFileEx(void)
     ok(hfile != INVALID_HANDLE_VALUE, "failed to open destination file, error %ld\n", GetLastError());
     SetLastError(0xdeadbeef);
     retok = CopyFileExA(source, dest, copy_progress_cb, hfile, NULL, 0);
-    todo_wine
     ok(!retok, "CopyFileExA unexpectedly succeeded\n");
-    todo_wine
     ok(GetLastError() == ERROR_REQUEST_ABORTED, "expected ERROR_REQUEST_ABORTED, got %ld\n", GetLastError());
     ok(GetFileAttributesA(dest) != INVALID_FILE_ATTRIBUTES, "file was deleted\n");
 
     hfile = CreateFileA(dest, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                         NULL, OPEN_EXISTING, 0, 0);
-    todo_wine
     ok(hfile != INVALID_HANDLE_VALUE, "failed to open destination file, error %ld\n", GetLastError());
     SetLastError(0xdeadbeef);
     retok = CopyFileExA(source, dest, copy_progress_cb, hfile, NULL, 0);
-    todo_wine
     ok(!retok, "CopyFileExA unexpectedly succeeded\n");
-    todo_wine
     ok(GetLastError() == ERROR_REQUEST_ABORTED, "expected ERROR_REQUEST_ABORTED, got %ld\n", GetLastError());
-    todo_wine
     ok(GetFileAttributesA(dest) == INVALID_FILE_ATTRIBUTES, "file was not deleted\n");
 
     retok = CopyFileExA(source, NULL, copy_progress_cb, hfile, NULL, 0);
diff --git a/dlls/kernel32/tests/loader.c b/dlls/kernel32/tests/loader.c
index 8f418ef..30f089b 100644
--- a/dlls/kernel32/tests/loader.c
+++ b/dlls/kernel32/tests/loader.c
@@ -28,6 +28,7 @@
 #include "winbase.h"
 #include "winternl.h"
 #include "winnls.h"
+#include "winuser.h"
 #include "wine/test.h"
 #include "delayloadhandler.h"
 
@@ -4205,6 +4206,79 @@ static void test_Wow64Transition(void)
             debugstr_wn(name->SectionFileName.Buffer, name->SectionFileName.Length / sizeof(WCHAR)));
 }
 
+static inline WCHAR toupperW(WCHAR c)
+{
+    WCHAR tmp = c;
+    CharUpperBuffW(&tmp, 1);
+    return tmp;
+}
+
+static ULONG hash_basename(const WCHAR *basename)
+{
+    WORD version = MAKEWORD(NtCurrentTeb()->Peb->OSMinorVersion,
+                            NtCurrentTeb()->Peb->OSMajorVersion);
+    ULONG hash = 0;
+
+    if (version >= 0x0602)
+    {
+        for (; *basename; basename++)
+            hash = hash * 65599 + toupperW(*basename);
+    }
+    else if (version == 0x0601)
+    {
+        for (; *basename; basename++)
+            hash = hash + 65599 * toupperW(*basename);
+    }
+    else
+        hash = toupperW(basename[0]) - 'A';
+
+    return hash & 31;
+}
+
+static void test_HashLinks(void)
+{
+    static WCHAR ntdllW[] = {'n','t','d','l','l','.','d','l','l',0};
+    static WCHAR kernel32W[] = {'k','e','r','n','e','l','3','2','.','d','l','l',0};
+
+    LIST_ENTRY *hash_map, *entry, *mark;
+    LDR_DATA_TABLE_ENTRY *module;
+    BOOL found;
+
+    entry = &NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList;
+    entry = entry->Flink;
+
+    module = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
+    entry = module->HashLinks.Blink;
+
+    hash_map = entry - hash_basename(module->BaseDllName.Buffer);
+
+    mark = &hash_map[hash_basename(ntdllW)];
+    found = FALSE;
+    for (entry = mark->Flink; entry != mark; entry = entry->Flink)
+    {
+        module = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, HashLinks);
+        if (!lstrcmpiW(module->BaseDllName.Buffer, ntdllW))
+        {
+            found = TRUE;
+            break;
+        }
+    }
+    ok(found, "Could not find ntdll\n");
+
+    mark = &hash_map[hash_basename(kernel32W)];
+    found = FALSE;
+    for (entry = mark->Flink; entry != mark; entry = entry->Flink)
+    {
+        module = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, HashLinks);
+        if (!lstrcmpiW(module->BaseDllName.Buffer, kernel32W))
+        {
+            found = TRUE;
+            break;
+        }
+    }
+    ok(found, "Could not find kernel32\n");
+}
+
 START_TEST(loader)
 {
     int argc;
@@ -4286,6 +4360,7 @@ START_TEST(loader)
     test_InMemoryOrderModuleList();
     test_LoadPackagedLibrary();
     test_wow64_redirection();
+    test_HashLinks();
     test_dll_file( "ntdll.dll" );
     test_dll_file( "kernel32.dll" );
     test_dll_file( "advapi32.dll" );
diff --git a/dlls/kernel32/tests/path.c b/dlls/kernel32/tests/path.c
index 7e12278..d6f0a71 100644
--- a/dlls/kernel32/tests/path.c
+++ b/dlls/kernel32/tests/path.c
@@ -83,6 +83,9 @@ static NTSTATUS (WINAPI *pLdrGetDllPath)(LPCWSTR,ULONG,LPWSTR*,LPWSTR*);
 static BOOL (WINAPI *pCheckNameLegalDOS8Dot3W)(const WCHAR *, char *, DWORD, BOOL *, BOOL *);
 static BOOL (WINAPI *pCheckNameLegalDOS8Dot3A)(const char *, char *, DWORD, BOOL *, BOOL *);
 
+/* Present in Vista+ */
+static BOOL (WINAPI *pCreateSymbolicLinkW)(LPCWSTR, LPCWSTR, DWORD);
+
 /* a structure to deal with wine todos somewhat cleanly */
 typedef struct {
   DWORD shortlen;
@@ -2106,6 +2109,7 @@ static void init_pointers(void)
     MAKEFUNC(SetDefaultDllDirectories);
     MAKEFUNC(CheckNameLegalDOS8Dot3W);
     MAKEFUNC(CheckNameLegalDOS8Dot3A);
+    MAKEFUNC(CreateSymbolicLinkW);
     mod = GetModuleHandleA("ntdll.dll");
     MAKEFUNC(LdrGetDllPath);
     MAKEFUNC(RtlGetExePath);
@@ -2691,6 +2695,95 @@ static void test_LdrGetDllPath(void)
     SetEnvironmentVariableW( pathW, old_path );
 }
 
+static void test_CreateSymbolicLink(void)
+{
+    static const WCHAR target_fileW[] = {'t','a','r','g','e','t','_','f','i','l','e',0};
+    static const WCHAR target_dirW[] = {'t','a','r','g','e','t','_','d','i','r',0};
+    static const WCHAR linkW[] = {'l','i','n','k',0};
+    static const WCHAR fooW[] = {'f','o','o',0};
+    static WCHAR volW[] = {'c',':','\\',0};
+    static const WCHAR dotW[] = {'.',0};
+    WCHAR path[MAX_PATH], old_path[MAX_PATH], tmp[MAX_PATH];
+    DWORD dwLen, dwFlags;
+    TOKEN_PRIVILEGES tp;
+    HANDLE token;
+    LUID luid;
+    BOOL bret;
+    HANDLE h;
+
+    if (!pCreateSymbolicLinkW)
+    {
+        win_skip( "CreateSymbolicLink isn't available\n" );
+        return;
+    }
+
+    /* Create a temporary folder for the symlink tests */
+    GetTempFileNameW( dotW, fooW, 0, path );
+    DeleteFileW( path );
+    if (!CreateDirectoryW( path, NULL ))
+    {
+        win_skip("Unable to create a temporary reparse point directory.\n");
+        return;
+    }
+    GetCurrentDirectoryW( sizeof(old_path)/sizeof(WCHAR), old_path );
+    SetCurrentDirectoryW( path );
+
+    /* Check that the volume this folder is located on supports reparse points */
+    GetFullPathNameW( path, sizeof(tmp)/sizeof(WCHAR), tmp, NULL );
+    volW[0] = tmp[0];
+    GetVolumeInformationW( volW, 0, 0, 0, &dwLen, &dwFlags, 0, 0 );
+    if (!(dwFlags & FILE_SUPPORTS_REPARSE_POINTS))
+    {
+        skip("File system does not support reparse points.\n");
+        goto cleanup;
+    }
+
+    /* Establish permissions for symlink creation */
+    bret = OpenProcessToken( GetCurrentProcess(), TOKEN_ALL_ACCESS, &token );
+    ok(bret, "OpenProcessToken failed: %ld\n", GetLastError());
+    bret = LookupPrivilegeValueA( NULL, "SeCreateSymbolicLinkPrivilege", &luid );
+    todo_wine ok(bret || broken(!bret && GetLastError() == ERROR_NO_SUCH_PRIVILEGE) /* winxp */,
+                 "LookupPrivilegeValue failed: %lu\n", GetLastError());
+    if (bret)
+    {
+        tp.PrivilegeCount = 1;
+        tp.Privileges[0].Luid = luid;
+        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+        bret = AdjustTokenPrivileges( token, FALSE, &tp, 0, NULL, NULL );
+        ok(bret, "AdjustTokenPrivileges failed: %ld\n", GetLastError());
+    }
+    if ((!bret && GetLastError() != ERROR_NO_SUCH_PRIVILEGE) || GetLastError() == ERROR_NOT_ALL_ASSIGNED)
+    {
+        win_skip("Insufficient permissions to perform symlink tests.\n");
+        goto cleanup;
+    }
+
+    /* Create a destination folder and file for symlinks to target */
+    bret = CreateDirectoryW( target_dirW, NULL );
+    ok(bret, "Failed to create symlink target directory.\n");
+    h = CreateFileW( target_fileW, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL );
+    ok(h != INVALID_HANDLE_VALUE, "Failed to create symlink target file.\n");
+    CloseHandle( h );
+
+    /* Create a directory symbolic link */
+    bret = CreateSymbolicLinkW( linkW, target_dirW, SYMBOLIC_LINK_FLAG_DIRECTORY );
+    ok(bret, "Failed to create directory symbolic link! (0x%lx)\n", GetLastError());
+    bret = RemoveDirectoryW( linkW );
+    ok(bret, "Failed to remove directory symbolic link! (0x%lx)\n", GetLastError());
+
+    /* Create a file symbolic link */
+    bret = CreateSymbolicLinkW( linkW, target_fileW, 0x0 );
+    ok(bret, "Failed to create file symbolic link! (0x%lx)\n", GetLastError());
+    bret = DeleteFileW( linkW );
+    ok(bret, "Failed to remove file symbolic link! (0x%lx)\n", GetLastError());
+
+cleanup:
+    DeleteFileW( target_fileW );
+    RemoveDirectoryW( target_dirW );
+    SetCurrentDirectoryW( old_path );
+    RemoveDirectoryW( path );
+}
+
 START_TEST(path)
 {
     CHAR origdir[MAX_PATH],curdir[MAX_PATH], curDrive, otherDrive;
@@ -2720,4 +2813,5 @@ START_TEST(path)
     test_RtlGetSearchPath();
     test_RtlGetExePath();
     test_LdrGetDllPath();
+    test_CreateSymbolicLink();
 }
diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index 0e5bf82..dac4057 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -2577,6 +2577,69 @@ static void _create_process(int line, const char *command, LPPROCESS_INFORMATION
     ok_(__FILE__, line)(ret, "CreateProcess error %lu\n", GetLastError());
 }
 
+#define test_assigned_proc(job, ...) _test_assigned_proc(__LINE__, job, __VA_ARGS__)
+static void _test_assigned_proc(int line, HANDLE job, int expected_count, ...)
+{
+    char buf[sizeof(JOBOBJECT_BASIC_PROCESS_ID_LIST) + sizeof(ULONG_PTR) * 20];
+    PJOBOBJECT_BASIC_PROCESS_ID_LIST pid_list = (JOBOBJECT_BASIC_PROCESS_ID_LIST *)buf;
+    DWORD ret_len, pid;
+    va_list valist;
+    int n;
+    BOOL ret;
+
+    memset(buf, 0, sizeof(buf));
+    ret = pQueryInformationJobObject(job, JobObjectBasicProcessIdList, pid_list, sizeof(buf), &ret_len);
+    ok_(__FILE__, line)(ret, "QueryInformationJobObject error %lu\n", GetLastError());
+    if (ret)
+    {
+        todo_wine_if(expected_count)
+        ok_(__FILE__, line)(expected_count == pid_list->NumberOfAssignedProcesses,
+                            "Expected NumberOfAssignedProcesses to be %d (expected_count) is %ld\n",
+                            expected_count, pid_list->NumberOfAssignedProcesses);
+        todo_wine_if(expected_count)
+        ok_(__FILE__, line)(expected_count == pid_list->NumberOfProcessIdsInList,
+                            "Expected NumberOfProcessIdsInList to be %d (expected_count) is %ld\n",
+                            expected_count, pid_list->NumberOfProcessIdsInList);
+
+        va_start(valist, expected_count);
+        for (n = 0; n < min(expected_count, pid_list->NumberOfProcessIdsInList); ++n)
+        {
+            pid = va_arg(valist, DWORD);
+            ok_(__FILE__, line)(pid == pid_list->ProcessIdList[n],
+                                "Expected pid_list->ProcessIdList[%d] to be %lx is %Ix\n",
+                                n, pid, pid_list->ProcessIdList[n]);
+        }
+        va_end(valist);
+    }
+}
+
+#define test_accounting(job, total_proc, active_proc, terminated_proc) _test_accounting(__LINE__, job, total_proc, active_proc, terminated_proc)
+static void _test_accounting(int line, HANDLE job, int total_proc, int active_proc, int terminated_proc)
+{
+    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION basic_accounting;
+    DWORD ret_len;
+    BOOL ret;
+
+    memset(&basic_accounting, 0, sizeof(basic_accounting));
+    ret = pQueryInformationJobObject(job, JobObjectBasicAccountingInformation, &basic_accounting, sizeof(basic_accounting), &ret_len);
+    ok_(__FILE__, line)(ret, "QueryInformationJobObject error %lu\n", GetLastError());
+    if (ret)
+    {
+        /* Not going to check process times or page faults */
+
+        todo_wine_if(total_proc)
+        ok_(__FILE__, line)(total_proc == basic_accounting.TotalProcesses,
+                            "Expected basic_accounting.TotalProcesses to be %d (total_proc) is %ld\n",
+                            total_proc, basic_accounting.TotalProcesses);
+        todo_wine_if(active_proc)
+        ok_(__FILE__, line)(active_proc == basic_accounting.ActiveProcesses,
+                            "Expected basic_accounting.ActiveProcesses to be %d (active_proc) is %ld\n",
+                            active_proc, basic_accounting.ActiveProcesses);
+        ok_(__FILE__, line)(terminated_proc == basic_accounting.TotalTerminatedProcesses,
+                            "Expected basic_accounting.TotalTerminatedProcesses to be %d (terminated_proc) is %ld\n",
+                            terminated_proc, basic_accounting.TotalTerminatedProcesses);
+    }
+}
 
 static void test_IsProcessInJob(void)
 {
@@ -2602,11 +2665,15 @@ static void test_IsProcessInJob(void)
     ret = pIsProcessInJob(pi.hProcess, job, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
     ok(!out, "IsProcessInJob returned out=%u\n", out);
+    test_assigned_proc(job, 0);
+    test_accounting(job, 0, 0, 0);
 
     out = TRUE;
     ret = pIsProcessInJob(pi.hProcess, job2, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
     ok(!out, "IsProcessInJob returned out=%u\n", out);
+    test_assigned_proc(job2, 0);
+    test_accounting(job2, 0, 0, 0);
 
     ret = pAssignProcessToJobObject(job, pi.hProcess);
     ok(ret, "AssignProcessToJobObject error %lu\n", GetLastError());
@@ -2615,11 +2682,15 @@ static void test_IsProcessInJob(void)
     ret = pIsProcessInJob(pi.hProcess, job, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
     ok(out, "IsProcessInJob returned out=%u\n", out);
+    test_assigned_proc(job, 1, pi.dwProcessId);
+    test_accounting(job, 1, 1, 0);
 
     out = TRUE;
     ret = pIsProcessInJob(pi.hProcess, job2, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
     ok(!out, "IsProcessInJob returned out=%u\n", out);
+    test_assigned_proc(job2, 0);
+    test_accounting(job2, 0, 0, 0);
 
     out = FALSE;
     ret = pIsProcessInJob(pi.hProcess, NULL, &out);
@@ -2633,6 +2704,8 @@ static void test_IsProcessInJob(void)
     ret = pIsProcessInJob(pi.hProcess, job, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
     ok(out, "IsProcessInJob returned out=%u\n", out);
+    test_assigned_proc(job, 0);
+    test_accounting(job, 1, 0, 0);
 
     CloseHandle(pi.hProcess);
     CloseHandle(pi.hThread);
@@ -2649,11 +2722,15 @@ static void test_TerminateJobObject(void)
 
     job = pCreateJobObjectW(NULL, NULL);
     ok(job != NULL, "CreateJobObject error %lu\n", GetLastError());
+    test_assigned_proc(job, 0);
+    test_accounting(job, 0, 0, 0);
 
     create_process("wait", &pi);
 
     ret = pAssignProcessToJobObject(job, pi.hProcess);
     ok(ret, "AssignProcessToJobObject error %lu\n", GetLastError());
+    test_assigned_proc(job, 1, pi.dwProcessId);
+    test_accounting(job, 1, 1, 0);
 
     ret = pTerminateJobObject(job, 123);
     ok(ret, "TerminateJobObject error %lu\n", GetLastError());
@@ -2662,6 +2739,8 @@ static void test_TerminateJobObject(void)
     dwret = WaitForSingleObject(pi.hProcess, 1000);
     ok(dwret == WAIT_OBJECT_0, "WaitForSingleObject returned %lu\n", dwret);
     if (dwret == WAIT_TIMEOUT) TerminateProcess(pi.hProcess, 0);
+    test_assigned_proc(job, 0);
+    test_accounting(job, 1, 0, 0);
 
     ret = GetExitCodeProcess(pi.hProcess, &dwret);
     ok(ret, "GetExitCodeProcess error %lu\n", GetLastError());
@@ -2679,6 +2758,8 @@ static void test_TerminateJobObject(void)
     ret = pAssignProcessToJobObject(job, pi.hProcess);
     ok(!ret, "AssignProcessToJobObject unexpectedly succeeded\n");
     expect_eq_d(ERROR_ACCESS_DENIED, GetLastError());
+    test_assigned_proc(job, 0);
+    test_accounting(job, 1, 0, 0);
 
     CloseHandle(pi.hProcess);
     CloseHandle(pi.hThread);
@@ -2877,11 +2958,15 @@ static void test_KillOnJobClose(void)
         return;
     }
     ok(ret, "SetInformationJobObject error %lu\n", GetLastError());
+    test_assigned_proc(job, 0);
+    test_accounting(job, 0, 0, 0);
 
     create_process("wait", &pi);
 
     ret = pAssignProcessToJobObject(job, pi.hProcess);
     ok(ret, "AssignProcessToJobObject error %lu\n", GetLastError());
+    test_assigned_proc(job, 1, pi.dwProcessId);
+    test_accounting(job, 1, 1, 0);
 
     CloseHandle(job);
 
@@ -2991,6 +3076,8 @@ static HANDLE test_AddSelfToJob(void)
 
     ret = pAssignProcessToJobObject(job, GetCurrentProcess());
     ok(ret, "AssignProcessToJobObject error %lu\n", GetLastError());
+    test_assigned_proc(job, 1, GetCurrentProcessId());
+    test_accounting(job, 1, 1, 0);
 
     return job;
 }
@@ -3012,6 +3099,8 @@ static void test_jobInheritance(HANDLE job)
     ret = pIsProcessInJob(pi.hProcess, job, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
     ok(out, "IsProcessInJob returned out=%u\n", out);
+    test_assigned_proc(job, 2, GetCurrentProcessId(), pi.dwProcessId);
+    test_accounting(job, 2, 2, 0);
 
     wait_and_close_child_process(&pi);
 }
@@ -3045,6 +3134,8 @@ static void test_BreakawayOk(HANDLE parent_job)
     ret = CreateProcessA(NULL, buffer, NULL, NULL, FALSE, CREATE_BREAKAWAY_FROM_JOB, NULL, NULL, &si, &pi);
     ok(!ret, "CreateProcessA expected failure\n");
     expect_eq_d(ERROR_ACCESS_DENIED, GetLastError());
+    test_assigned_proc(job, 1, GetCurrentProcessId());
+    test_accounting(job, 2, 1, 0);
 
     if (ret)
     {
@@ -3084,6 +3175,8 @@ static void test_BreakawayOk(HANDLE parent_job)
     ret = pIsProcessInJob(pi.hProcess, job, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
     ok(!out, "IsProcessInJob returned out=%u\n", out);
+    test_assigned_proc(job, 1, GetCurrentProcessId());
+    test_accounting(job, 2, 1, 0);
 
     ret = pIsProcessInJob(pi.hProcess, parent_job, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
@@ -3101,6 +3194,8 @@ static void test_BreakawayOk(HANDLE parent_job)
     ret = pIsProcessInJob(pi.hProcess, job, &out);
     ok(ret, "IsProcessInJob error %lu\n", GetLastError());
     ok(!out, "IsProcessInJob returned out=%u\n", out);
+    test_assigned_proc(job, 1, GetCurrentProcessId());
+    test_accounting(job, 2, 1, 0);
 
     wait_and_close_child_process(&pi);
 
diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index 56a9d6e..f1d0dfc 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -57,6 +57,7 @@ static BOOLEAN (WINAPI *pTryAcquireSRWLockShared)(PSRWLOCK);
 
 static NTSTATUS (WINAPI *pNtAllocateVirtualMemory)(HANDLE, PVOID *, ULONG_PTR, SIZE_T *, ULONG, ULONG);
 static NTSTATUS (WINAPI *pNtFreeVirtualMemory)(HANDLE, PVOID *, SIZE_T *, ULONG);
+static NTSTATUS (WINAPI *pNtQuerySystemTime)(LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pNtWaitForSingleObject)(HANDLE, BOOLEAN, const LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
 static PSLIST_ENTRY (__fastcall *pRtlInterlockedPushListSList)(PSLIST_HEADER list, PSLIST_ENTRY first,
@@ -227,8 +228,23 @@ static void test_temporary_objects(void)
     ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
 }
 
+static HANDLE mutex, mutex2, mutices[2];
+
+static DWORD WINAPI mutex_thread( void *param )
+{
+    DWORD expect = (DWORD)(DWORD_PTR)param;
+    DWORD ret;
+
+    ret = WaitForSingleObject( mutex, 0 );
+    ok(ret == expect, "expected %lu, got %lu\n", expect, ret);
+
+    if (!ret) ReleaseMutex( mutex );
+    return 0;
+}
+
 static void test_mutex(void)
 {
+    HANDLE thread;
     DWORD wait_ret;
     BOOL ret;
     HANDLE hCreated;
@@ -268,7 +284,8 @@ static void test_mutex(void)
     SetLastError(0xdeadbeef);
     hOpened = OpenMutexA(GENERIC_READ | GENERIC_WRITE, FALSE, "WineTestMutex");
     ok(hOpened != NULL, "OpenMutex failed with error %ld\n", GetLastError());
-    wait_ret = WaitForSingleObject(hOpened, INFINITE);
+    wait_ret = WaitForSingleObject(hOpened, 0);
+todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: validation is not implemented */
     ok(wait_ret == WAIT_FAILED, "WaitForSingleObject succeeded\n");
     CloseHandle(hOpened);
 
@@ -299,6 +316,7 @@ static void test_mutex(void)
 
     SetLastError(0xdeadbeef);
     ret = ReleaseMutex(hCreated);
+todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: due to the above */
     ok(!ret && (GetLastError() == ERROR_NOT_OWNER),
         "ReleaseMutex should have failed with ERROR_NOT_OWNER instead of %ld\n", GetLastError());
 
@@ -337,6 +355,85 @@ static void test_mutex(void)
     CloseHandle(hOpened);
 
     CloseHandle(hCreated);
+
+    mutex = CreateMutexA( NULL, FALSE, NULL );
+    ok(!!mutex, "got error %lu\n", GetLastError());
+
+    ret = ReleaseMutex( mutex );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
+
+    for (i = 0; i < 100; i++)
+    {
+        ret = WaitForSingleObject( mutex, 0 );
+        ok(ret == 0, "got %u\n", ret);
+    }
+
+    for (i = 0; i < 100; i++)
+    {
+        ret = ReleaseMutex( mutex );
+        ok(ret, "got error %lu\n", GetLastError());
+    }
+
+    ret = ReleaseMutex( mutex );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
+
+    thread = CreateThread( NULL, 0, mutex_thread, (void *)0, 0, NULL );
+    ret = WaitForSingleObject( thread, 2000 );
+    ok(ret == 0, "wait failed: %u\n", ret);
+
+    WaitForSingleObject( mutex, 0 );
+
+    thread = CreateThread( NULL, 0, mutex_thread, (void *)WAIT_TIMEOUT, 0, NULL );
+    ret = WaitForSingleObject( thread, 2000 );
+    ok(ret == 0, "wait failed: %u\n", ret);
+
+    ret = ReleaseMutex( mutex );
+        ok(ret, "got error %lu\n", GetLastError());
+
+    thread = CreateThread( NULL, 0, mutex_thread, (void *)0, 0, NULL );
+    ret = WaitForSingleObject( thread, 2000 );
+    ok(ret == 0, "wait failed: %u\n", ret);
+
+    mutex2 = CreateMutexA( NULL, TRUE, NULL );
+    ok(!!mutex2, "got error %lu\n", GetLastError());
+
+    ret = ReleaseMutex( mutex2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ReleaseMutex( mutex2 );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
+
+    mutices[0] = mutex;
+    mutices[1] = mutex2;
+
+    ret = WaitForMultipleObjects( 2, mutices, FALSE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = ReleaseMutex( mutex );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ReleaseMutex( mutex2 );
+    ok(!ret, "got %d\n", ret);
+    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
+
+    ret = WaitForMultipleObjects( 2, mutices, TRUE, 0 );
+    ok(ret == 0, "got %u\n", ret);
+
+    ret = ReleaseMutex( mutex );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ReleaseMutex( mutex2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = CloseHandle( mutex );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = CloseHandle( mutex2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
 }
 
 static void test_slist(void)
@@ -512,12 +609,13 @@ static void test_slist(void)
 
 static void test_event(void)
 {
-    HANDLE handle, handle2;
+    HANDLE handle, handle2, handles[2];
     SECURITY_ATTRIBUTES sa;
     SECURITY_DESCRIPTOR sd;
     ACL acl;
     DWORD ret;
     BOOL val;
+    int i;
 
     /* no sd */
     handle = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
@@ -621,11 +719,130 @@ static void test_event(void)
     ok( ret, "QueryMemoryResourceNotification failed err %lu\n", GetLastError() );
     ok( val == FALSE || val == TRUE, "wrong value %u\n", val );
     CloseHandle( handle );
+
+    handle = CreateEventA( NULL, TRUE, FALSE, NULL );
+    ok(!!handle, "got error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = SetEvent( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = SetEvent( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    for (i = 0; i < 100; i++)
+    {
+        ret = WaitForSingleObject( handle, 0 );
+        ok(ret == 0, "got %lu\n", ret);
+    }
+
+    ret = ResetEvent( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ResetEvent( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    handle2 = CreateEventA( NULL, FALSE, TRUE, NULL );
+    ok(!!handle2, "got error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = SetEvent( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = SetEvent( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ResetEvent( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = ResetEvent( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    handles[0] = handle;
+    handles[1] = handle2;
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ResetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    SetEvent( handle2 );
+    ResetEvent( handle );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    handles[0] = handle2;
+    handles[1] = handle;
+    SetEvent( handle );
+    SetEvent( handle2 );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %lu\n", ret);
+
+    ret = CloseHandle( handle );
+    ok(ret, "got error %lu\n", GetLastError());
+
+    ret = CloseHandle( handle2 );
+    ok(ret, "got error %lu\n", GetLastError());
 }
 
 static void test_semaphore(void)
 {
-    HANDLE handle, handle2;
+    HANDLE handle, handle2, handles[2];
+    DWORD ret;
+    LONG prev;
+    int i;
 
     /* test case sensitivity */
 
@@ -667,6 +884,99 @@ static void test_semaphore(void)
     ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
 
     CloseHandle( handle );
+
+    handle = CreateSemaphoreA( NULL, 0, 5, NULL );
+    ok(!!handle, "CreateSemaphore failed: %lu\n", GetLastError());
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 0, "got prev %ld\n", prev);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 1, "got prev %ld\n", prev);
+
+    ret = ReleaseSemaphore( handle, 5, &prev );
+    ok(!ret, "got %ld\n", ret);
+    ok(GetLastError() == ERROR_TOO_MANY_POSTS, "got error %lu\n", GetLastError());
+    ok(prev == 1, "got prev %ld\n", prev);
+
+    ret = ReleaseSemaphore( handle, 2, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 2, "got prev %ld\n", prev);
+
+    ret = ReleaseSemaphore( handle, 1, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 4, "got prev %ld\n", prev);
+
+    for (i = 0; i < 5; i++)
+    {
+        ret = WaitForSingleObject( handle, 0 );
+        ok(ret == 0, "got %lu\n", ret);
+    }
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    handle2 = CreateSemaphoreA( NULL, 3, 5, NULL );
+    ok(!!handle2, "CreateSemaphore failed: %lu\n", GetLastError());
+
+    ret = ReleaseSemaphore( handle2, 1, &prev );
+    ok(ret, "got error %lu\n", GetLastError());
+    ok(prev == 3, "got prev %ld\n", prev);
+
+    for (i = 0; i < 4; i++)
+    {
+        ret = WaitForSingleObject( handle2, 0 );
+        ok(ret == 0, "got %lu\n", ret);
+    }
+
+    ret = WaitForSingleObject( handle2, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    handles[0] = handle;
+    handles[1] = handle2;
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+    ReleaseSemaphore( handle2, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == 1, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+    ReleaseSemaphore( handle2, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ReleaseSemaphore( handle, 1, NULL );
+
+    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( handle, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = CloseHandle( handle );
+    ok(ret, "got error %lu\n", ret);
+
+    ret = CloseHandle( handle2 );
+    ok(ret, "got error %lu\n", ret);
 }
 
 static void test_waitable_timer(void)
@@ -1221,11 +1531,15 @@ static HANDLE modify_handle(HANDLE handle, DWORD modify)
     return ULongToHandle(tmp);
 }
 
+#define TIMEOUT_INFINITE (((LONGLONG)0x7fffffff) << 32 | 0xffffffff)
+
 static void test_WaitForSingleObject(void)
 {
     HANDLE signaled, nonsignaled, invalid;
+    LARGE_INTEGER ntnow, ntthen;
     LARGE_INTEGER timeout;
     NTSTATUS status;
+    DWORD now, then;
     DWORD ret;
 
     signaled = CreateEventW(NULL, TRUE, TRUE, NULL);
@@ -1310,6 +1624,68 @@ static void test_WaitForSingleObject(void)
     status = pNtWaitForSingleObject(GetCurrentThread(), FALSE, &timeout);
     ok(status == STATUS_TIMEOUT, "expected STATUS_TIMEOUT, got %08lx\n", status);
 
+    ret = WaitForSingleObject( signaled, 0 );
+    ok(ret == 0, "got %lu\n", ret);
+
+    ret = WaitForSingleObject( nonsignaled, 0 );
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+
+    /* test that a timed wait actually does wait */
+    now = GetTickCount();
+    ret = WaitForSingleObject( nonsignaled, 100 );
+    then = GetTickCount();
+    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
+    ok(abs((then - now) - 100) < 5, "got %lu ms\n", then - now);
+
+    now = GetTickCount();
+    ret = WaitForSingleObject( signaled, 100 );
+    then = GetTickCount();
+    ok(ret == 0, "got %lu\n", ret);
+    ok(abs(then - now) < 5, "got %lu ms\n", then - now);
+
+    ret = WaitForSingleObject( signaled, INFINITE );
+    ok(ret == 0, "got %lu\n", ret);
+
+    /* test NT timeouts */
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart + 100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
+    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = -100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
+    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    status = pNtWaitForSingleObject( signaled, FALSE, NULL );
+    ok(status == 0, "got %#lx\n", status);
+
+    timeout.QuadPart = TIMEOUT_INFINITE;
+    status = pNtWaitForSingleObject( signaled, FALSE, &timeout );
+    ok(status == 0, "got %#lx\n", status);
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
+    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
+    pNtQuerySystemTime( &ntnow );
+    timeout.QuadPart = ntnow.QuadPart - 100 * 10000;
+    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
+    pNtQuerySystemTime( &ntthen );
+    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
+    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
+        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
+
     CloseHandle(signaled);
     CloseHandle(nonsignaled);
 }
@@ -2841,6 +3217,84 @@ static void test_QueueUserAPC(void)
     ok(apc_count == 1, "APC count %u\n", apc_count);
 }
 
+static int zigzag_state, zigzag_count[2], zigzag_stop;
+
+static DWORD CALLBACK zigzag_event0(void *arg)
+{
+    HANDLE *events = arg;
+
+    while (!zigzag_stop)
+    {
+        WaitForSingleObject(events[0], INFINITE);
+        ResetEvent(events[0]);
+        ok(zigzag_state == 0, "got wrong state %d\n", zigzag_state);
+        zigzag_state++;
+        SetEvent(events[1]);
+        zigzag_count[0]++;
+    }
+    trace("thread 0 got done\n");
+    return 0;
+}
+
+static DWORD CALLBACK zigzag_event1(void *arg)
+{
+    HANDLE *events = arg;
+
+    while (!zigzag_stop)
+    {
+        WaitForSingleObject(events[1], INFINITE);
+        ResetEvent(events[1]);
+        ok(zigzag_state == 1, "got wrong state %d\n", zigzag_state);
+        zigzag_state--;
+        SetEvent(events[0]);
+        zigzag_count[1]++;
+    }
+    trace("thread 1 got done\n");
+    return 0;
+}
+
+static void test_zigzag_event(void)
+{
+    /* The basic idea is to test SetEvent/Wait back and forth between two
+     * threads. Each thread clears their own event, sets some common data,
+     * signals the other's, then waits on their own. We make sure the common
+     * data is always in the right state. We also print performance data. */
+
+    HANDLE threads[2], events[2];
+    BOOL ret;
+
+    events[0] = CreateEventA(NULL, FALSE, FALSE, NULL);
+    events[1] = CreateEventA(NULL, FALSE, FALSE, NULL);
+
+    threads[0] = CreateThread(NULL, 0, zigzag_event0, events, 0, NULL);
+    threads[1] = CreateThread(NULL, 0, zigzag_event1, events, 0, NULL);
+
+    zigzag_state = 0;
+    zigzag_count[0] = zigzag_count[1] = 0;
+    zigzag_stop = 0;
+
+    trace("starting zigzag test (events)\n");
+    SetEvent(events[0]);
+    Sleep(2000);
+    zigzag_stop = 1;
+    ret = WaitForMultipleObjects(2, threads, FALSE, INFINITE);
+    trace("%d\n", ret);
+    ok(ret == 0 || ret == 1, "wait failed: %u\n", ret);
+
+    ok(zigzag_count[0] == zigzag_count[1] || zigzag_count[0] == zigzag_count[1] + 1,
+        "count did not match: %d != %d\n", zigzag_count[0], zigzag_count[1]);
+
+    /* signal the other thread to finish, if it didn't already
+     * (in theory they both would at the same time, but there's a slight race on teardown if we get
+     * thread 1 SetEvent -> thread 0 ResetEvent -> thread 0 Wait -> thread 1 exits */
+    zigzag_state = 1-ret;
+    SetEvent(events[1-ret]);
+    ret = WaitForSingleObject(threads[1-ret], 1000);
+    ok(!ret, "wait failed: %u\n", ret);
+
+    trace("count: %d\n", zigzag_count[0]);
+}
+
 START_TEST(sync)
 {
     char **argv;
@@ -2867,6 +3321,7 @@ START_TEST(sync)
     pTryAcquireSRWLockShared = (void *)GetProcAddress(hdll, "TryAcquireSRWLockShared");
     pNtAllocateVirtualMemory = (void *)GetProcAddress(hntdll, "NtAllocateVirtualMemory");
     pNtFreeVirtualMemory = (void *)GetProcAddress(hntdll, "NtFreeVirtualMemory");
+    pNtQuerySystemTime = (void *)GetProcAddress(hntdll, "NtQuerySystemTime");
     pNtWaitForSingleObject = (void *)GetProcAddress(hntdll, "NtWaitForSingleObject");
     pNtWaitForMultipleObjects = (void *)GetProcAddress(hntdll, "NtWaitForMultipleObjects");
     pRtlInterlockedPushListSList = (void *)GetProcAddress(hntdll, "RtlInterlockedPushListSList");
@@ -2911,5 +3366,6 @@ START_TEST(sync)
     test_srwlock_example();
     test_alertable_wait();
     test_apc_deadlock();
+    test_zigzag_event();
     test_crit_section();
 }
diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index 9925da3..32e1ced 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -101,6 +101,7 @@ static HRESULT (WINAPI *pSetThreadDescription)(HANDLE,const WCHAR *);
 static HRESULT (WINAPI *pGetThreadDescription)(HANDLE,WCHAR **);
 static PVOID (WINAPI *pRtlAddVectoredExceptionHandler)(ULONG,PVECTORED_EXCEPTION_HANDLER);
 static ULONG (WINAPI *pRtlRemoveVectoredExceptionHandler)(PVOID);
+static NTSTATUS (WINAPI *pNtSetLdtEntries)(ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
 
 static HANDLE create_target_process(const char *arg)
 {
@@ -1298,6 +1299,78 @@ static void test_GetThreadSelectorEntry(void)
     ok(entry.HighWord.Bits.Granularity == 1,  "expected 1, got %u\n", entry.HighWord.Bits.Granularity);
 }
 
+static void test_NtSetLdtEntries(void)
+{
+    THREAD_DESCRIPTOR_INFORMATION tdi;
+    LDT_ENTRY ds_entry;
+    CONTEXT ctx;
+    DWORD ret;
+    union
+    {
+        LDT_ENTRY entry;
+        DWORD dw[2];
+    } sel;
+
+    if (!pNtSetLdtEntries)
+    {
+        win_skip("NtSetLdtEntries is not available on this platform\n");
+        return;
+    }
+
+    if (pNtSetLdtEntries(0, 0, 0, 0, 0, 0) == STATUS_NOT_IMPLEMENTED) /* WoW64 */
+    {
+        win_skip("NtSetLdtEntries is not implemented on this platform\n");
+        return;
+    }
+
+    ret = pNtSetLdtEntries(0, 0, 0, 0, 0, 0);
+    ok(!ret, "NtSetLdtEntries failed: %08x\n", ret);
+
+    ctx.ContextFlags = CONTEXT_SEGMENTS;
+    ret = GetThreadContext(GetCurrentThread(), &ctx);
+    ok(ret, "GetThreadContext failed\n");
+
+    tdi.Selector = ctx.SegDs;
+    ret = pNtQueryInformationThread(GetCurrentThread(), ThreadDescriptorTableEntry, &tdi, sizeof(tdi), &ret);
+    ok(!ret, "NtQueryInformationThread failed: %08x\n", ret);
+    ds_entry = tdi.Entry;
+
+    tdi.Selector = 0x000f;
+    ret = pNtQueryInformationThread(GetCurrentThread(), ThreadDescriptorTableEntry, &tdi, sizeof(tdi), &ret);
+    ok(ret == STATUS_ACCESS_VIOLATION, "got %08x\n", ret);
+
+    tdi.Selector = 0x001f;
+    ret = pNtQueryInformationThread(GetCurrentThread(), ThreadDescriptorTableEntry, &tdi, sizeof(tdi), &ret);
+    ok(ret == STATUS_ACCESS_VIOLATION, "NtQueryInformationThread returned %08x\n", ret);
+
+    ret = GetThreadSelectorEntry(GetCurrentThread(), 0x000f, &sel.entry);
+    ok(!ret, "GetThreadSelectorEntry should fail\n");
+
+    ret = GetThreadSelectorEntry(GetCurrentThread(), 0x001f, &sel.entry);
+    ok(!ret, "GetThreadSelectorEntry should fail\n");
+
+    memset(&sel.entry, 0x9a, sizeof(sel.entry));
+    ret = GetThreadSelectorEntry(GetCurrentThread(), ctx.SegDs, &sel.entry);
+    ok(ret, "GetThreadSelectorEntry failed\n");
+    ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
+
+    ret = pNtSetLdtEntries(0x000f, sel.dw[0], sel.dw[1], 0x001f, sel.dw[0], sel.dw[1]);
+    ok(!ret || broken(ret == STATUS_INVALID_LDT_DESCRIPTOR) /*XP*/, "NtSetLdtEntries failed: %08x\n", ret);
+
+    if (!ret)
+    {
+        memset(&sel.entry, 0x9a, sizeof(sel.entry));
+        ret = GetThreadSelectorEntry(GetCurrentThread(), 0x000f, &sel.entry);
+        ok(ret, "GetThreadSelectorEntry failed\n");
+        ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
+
+        memset(&sel.entry, 0x9a, sizeof(sel.entry));
+        ret = GetThreadSelectorEntry(GetCurrentThread(), 0x001f, &sel.entry);
+        ok(ret, "GetThreadSelectorEntry failed\n");
+        ok(!memcmp(&ds_entry, &sel.entry, sizeof(ds_entry)), "entries do not match\n");
+    }
+}
+
 #endif  /* __i386__ */
 
 static HANDLE finish_event;
@@ -2613,6 +2686,7 @@ static void init_funcs(void)
        X(NtSetInformationThread);
        X(RtlAddVectoredExceptionHandler);
        X(RtlRemoveVectoredExceptionHandler);
+       X(NtSetLdtEntries);
    }
 #undef X
 }
@@ -2669,6 +2743,7 @@ START_TEST(thread)
    test_SetThreadContext();
    test_GetThreadSelectorEntry();
    test_GetThreadContext();
+   test_NtSetLdtEntries();
 #endif
    test_QueueUserWorkItem();
    test_RegisterWaitForSingleObject();
diff --git a/dlls/kernel32/tests/virtual.c b/dlls/kernel32/tests/virtual.c
index c54fb16..03ed185 100644
--- a/dlls/kernel32/tests/virtual.c
+++ b/dlls/kernel32/tests/virtual.c
@@ -55,6 +55,23 @@ static BOOL  (WINAPI *pPrefetchVirtualMemory)(HANDLE, ULONG_PTR, PWIN32_MEMORY_R
 
 /* ############################### */
 
+static UINT_PTR page_mask = 0xfff;
+#define ROUND_SIZE(addr,size) \
+   (((SIZE_T)(size) + ((UINT_PTR)(addr) & page_mask) + page_mask) & ~page_mask)
+
+static PIMAGE_NT_HEADERS image_nt_header(HMODULE module)
+{
+    IMAGE_NT_HEADERS *ret = NULL;
+    IMAGE_DOS_HEADER *dos = (IMAGE_DOS_HEADER *)module;
+
+    if (dos->e_magic == IMAGE_DOS_SIGNATURE)
+    {
+        ret = (IMAGE_NT_HEADERS *)((char *)dos + dos->e_lfanew);
+        if (ret->Signature != IMAGE_NT_SIGNATURE) ret = NULL;
+    }
+    return ret;
+}
+
 static HANDLE create_target_process(const char *arg)
 {
     char **argv;
@@ -3582,9 +3599,7 @@ static void test_CreateFileMapping_protection(void)
                 SetLastError(0xdeadbeef);
                 ret = VirtualQuery(base, &info, sizeof(info));
                 ok(ret, "VirtualQuery failed %ld\n", GetLastError());
-                /* FIXME: remove the condition below once Wine is fixed */
-                todo_wine_if (td[i].prot == PAGE_WRITECOPY || td[i].prot == PAGE_EXECUTE_WRITECOPY)
-                    ok(info.Protect == td[i].prot_after_write, "%ld: got %#lx != expected %#lx\n", i, info.Protect, td[i].prot_after_write);
+                ok(info.Protect == td[i].prot_after_write, "%ld: got %#lx != expected %#lx\n", i, info.Protect, td[i].prot_after_write);
             }
         }
         else
@@ -3598,9 +3613,7 @@ static void test_CreateFileMapping_protection(void)
         SetLastError(0xdeadbeef);
         ret = VirtualProtect(base, si.dwPageSize, PAGE_NOACCESS, &old_prot);
         ok(ret, "%ld: VirtualProtect error %ld\n", i, GetLastError());
-        /* FIXME: remove the condition below once Wine is fixed */
-        todo_wine_if (td[i].prot == PAGE_WRITECOPY || td[i].prot == PAGE_EXECUTE_WRITECOPY)
-            ok(old_prot == td[i].prot_after_write, "%ld: got %#lx != expected %#lx\n", i, old_prot, td[i].prot_after_write);
+        ok(old_prot == td[i].prot_after_write, "%ld: got %#lx != expected %#lx\n", i, old_prot, td[i].prot_after_write);
 
         UnmapViewOfFile(base);
     }
@@ -3953,15 +3966,12 @@ static void test_mapping( HANDLE hfile, DWORD sec_flags, BOOL readonly )
                         continue;
                     }
 
-                    todo_wine_if(readonly && page_prot[k] == PAGE_WRITECOPY && view[j].prot != PAGE_WRITECOPY)
                     ok(ret, "VirtualProtect error %ld, map %#lx, view %#lx, requested prot %#lx\n", GetLastError(), page_prot[i], view[j].prot, page_prot[k]);
-                    todo_wine_if(readonly && page_prot[k] == PAGE_WRITECOPY && view[j].prot != PAGE_WRITECOPY)
                     ok(old_prot == prev_prot, "got %#lx, expected %#lx\n", old_prot, prev_prot);
                     prev_prot = actual_prot;
 
                     ret = VirtualQuery(base, &info, sizeof(info));
                     ok(ret, "%ld: VirtualQuery failed %ld\n", j, GetLastError());
-                    todo_wine_if(readonly && page_prot[k] == PAGE_WRITECOPY && view[j].prot != PAGE_WRITECOPY)
                     ok(info.Protect == actual_prot,
                        "VirtualProtect wrong prot, map %#lx, view %#lx, requested prot %#lx got %#lx\n",
                        page_prot[i], view[j].prot, page_prot[k], info.Protect );
@@ -4016,15 +4026,12 @@ static void test_mapping( HANDLE hfile, DWORD sec_flags, BOOL readonly )
             if (!anon_mapping && is_compatible_protection(alloc_prot, PAGE_WRITECOPY))
             {
                 ret = VirtualProtect(base, sec_flags & SEC_IMAGE ? si.dwPageSize : 2*si.dwPageSize, PAGE_WRITECOPY, &old_prot);
-                todo_wine_if(readonly && view[j].prot != PAGE_WRITECOPY)
                 ok(ret, "VirtualProtect error %ld, map %#lx, view %#lx\n", GetLastError(), page_prot[i], view[j].prot);
                 if (ret) *(DWORD*)base = 0xdeadbeef;
                 ret = VirtualQuery(base, &info, sizeof(info));
                 ok(ret, "%ld: VirtualQuery failed %ld\n", j, GetLastError());
-                todo_wine
                 ok(info.Protect == PAGE_READWRITE, "VirtualProtect wrong prot, map %#lx, view %#lx got %#lx\n",
                    page_prot[i], view[j].prot, info.Protect );
-                todo_wine_if (!(sec_flags & SEC_IMAGE))
                 ok(info.RegionSize == si.dwPageSize, "wrong region size %#Ix after write, map %#lx, view %#lx got %#lx\n",
                    info.RegionSize, page_prot[i], view[j].prot, info.Protect );
 
@@ -4035,7 +4042,6 @@ static void test_mapping( HANDLE hfile, DWORD sec_flags, BOOL readonly )
                 {
                     ret = VirtualQuery((char*)base + si.dwPageSize, &info, sizeof(info));
                     ok(ret, "%ld: VirtualQuery failed %ld\n", j, GetLastError());
-                    todo_wine_if(readonly && view[j].prot != PAGE_WRITECOPY)
                     ok(info.Protect == PAGE_WRITECOPY, "wrong prot, map %#lx, view %#lx got %#lx\n",
                        page_prot[i], view[j].prot, info.Protect);
                 }
@@ -4055,14 +4061,11 @@ static void test_mapping( HANDLE hfile, DWORD sec_flags, BOOL readonly )
                             continue;
                         }
 
-                        todo_wine_if(readonly && page_prot[k] == PAGE_WRITECOPY && view[j].prot != PAGE_WRITECOPY)
                         ok(ret, "VirtualProtect error %ld, map %#lx, view %#lx, requested prot %#lx\n", GetLastError(), page_prot[i], view[j].prot, page_prot[k]);
-                        todo_wine_if(readonly && page_prot[k] == PAGE_WRITECOPY && view[j].prot != PAGE_WRITECOPY)
                         ok(old_prot == prev_prot, "got %#lx, expected %#lx\n", old_prot, prev_prot);
 
                         ret = VirtualQuery(base, &info, sizeof(info));
                         ok(ret, "%ld: VirtualQuery failed %ld\n", j, GetLastError());
-                        todo_wine_if( map_prot_written( page_prot[k] ) != actual_prot )
                         ok(info.Protect == map_prot_written( page_prot[k] ),
                            "VirtualProtect wrong prot, map %#lx, view %#lx, requested prot %#lx got %#lx\n",
                            page_prot[i], view[j].prot, page_prot[k], info.Protect );
@@ -4103,7 +4106,6 @@ static void test_mappings(void)
     SetFilePointer(hfile, 0, NULL, FILE_BEGIN);
     ok(ReadFile(hfile, &data, sizeof(data), &num_bytes, NULL), "ReadFile failed\n");
     ok(num_bytes == sizeof(data), "num_bytes = %ld\n", num_bytes);
-    todo_wine
     ok(!data, "data = %lx\n", data);
 
     CloseHandle( hfile );
@@ -4262,6 +4264,233 @@ static void test_PrefetchVirtualMemory(void)
         "PrefetchVirtualMemory unexpected status on 2 page-aligned entries: %ld\n", GetLastError() );
 }
 
+static void test_NtQuerySection(void)
+{
+    char path[MAX_PATH];
+    HANDLE file, mapping;
+    void *p;
+    NTSTATUS status;
+    union
+    {
+        SECTION_BASIC_INFORMATION basic;
+        SECTION_IMAGE_INFORMATION image;
+        char buf[1024];
+    } info;
+    IMAGE_NT_HEADERS *nt;
+    SIZE_T ret;
+    SIZE_T fsize, image_size;
+    SYSTEM_INFO si;
+
+    if (!pNtQuerySection)
+    {
+        win_skip("NtQuerySection is not available\n");
+        return;
+    }
+
+    GetSystemInfo(&si);
+    page_mask = si.dwPageSize - 1;
+
+    GetSystemDirectoryA(path, sizeof(path));
+    strcat(path, "\\kernel32.dll");
+
+    SetLastError(0xdeadbef);
+    file = CreateFileA(path, GENERIC_READ|GENERIC_EXECUTE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile error %lu\n", GetLastError());
+
+    fsize = GetFileSize(file, NULL);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(file, NULL, PAGE_EXECUTE_READ, 0, 0, NULL);
+    /* NT4 and win2k don't support EXEC on file mappings */
+    if (!mapping)
+        mapping = CreateFileMappingA(file, NULL, PAGE_READONLY, 0, 0, NULL);
+    ok(mapping != 0, "CreateFileMapping error %lu\n", GetLastError());
+
+    status = pNtQuerySection(mapping, SectionBasicInformation, NULL, sizeof(info), &ret);
+    ok(status == STATUS_ACCESS_VIOLATION, "expected STATUS_ACCESS_VIOLATION, got %#lx\n", status);
+
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, 0, NULL);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#lx\n", status);
+
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, 0, &ret);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#lx\n", status);
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_FILE, "expected SEC_FILE, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == fsize, "expected %#Ix, got %#lx/%08lx\n", fsize, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, sizeof(info.basic), &ret);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#lx\n", status);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SECTION_NOT_IMAGE, "expected STATUS_SECTION_NOT_IMAGE, got %#lx\n", status);
+
+    SetLastError(0xdeadbef);
+    p = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
+    ok(p != NULL, "MapViewOfFile error %lu\n", GetLastError());
+
+    nt = image_nt_header(p);
+    image_size = ROUND_SIZE(p, nt->OptionalHeader.SizeOfImage);
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_FILE, "expected SEC_FILE, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == fsize, "expected %#Ix, got %#lx/%08lx\n", fsize, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    UnmapViewOfFile(p);
+    CloseHandle(mapping);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(file, NULL, PAGE_EXECUTE_READ|SEC_IMAGE, 0, 0, NULL);
+    /* NT4 and win2k don't support EXEC on file mappings */
+    if (!mapping)
+        mapping = CreateFileMappingA(file, NULL, PAGE_READONLY|SEC_IMAGE, 0, 0, NULL);
+    ok(mapping != 0, "CreateFileMapping error %lu\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == (SEC_FILE|SEC_IMAGE), "expected SEC_FILE|SEC_IMAGE, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == image_size, "expected %#Ix, got %#lx/%08lx\n", image_size, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, NULL, sizeof(info), &ret);
+    ok(status == STATUS_ACCESS_VIOLATION, "expected STATUS_ACCESS_VIOLATION, got %#lx\n", status);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, 0, NULL);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#lx\n", status);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, 0, &ret);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#lx\n", status);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, sizeof(info.basic), &ret);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#lx\n", status);
+
+    SetLastError(0xdeadbef);
+    p = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
+    ok(p != NULL, "MapViewOfFile error %lu\n", GetLastError());
+
+    nt = image_nt_header(p);
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.image), "wrong returned size %Iu\n", ret);
+    ok((ULONG_PTR)info.image.TransferAddress == nt->OptionalHeader.ImageBase + nt->OptionalHeader.AddressOfEntryPoint,
+       "expected %#Ix, got %p\n", (SIZE_T)(nt->OptionalHeader.ImageBase + nt->OptionalHeader.AddressOfEntryPoint), info.image.TransferAddress);
+    ok(info.image.ZeroBits == 0, "expected 0, got %#lx\n", info.image.ZeroBits);
+    ok(info.image.MaximumStackSize == nt->OptionalHeader.SizeOfStackReserve, "expected %#Ix, got %#Ix\n", (SIZE_T)nt->OptionalHeader.SizeOfStackReserve, info.image.MaximumStackSize);
+    ok(info.image.CommittedStackSize == nt->OptionalHeader.SizeOfStackCommit, "expected %#Ix, got %#Ix\n", (SIZE_T)nt->OptionalHeader.SizeOfStackCommit, info.image.CommittedStackSize);
+    ok(info.image.SubSystemType == nt->OptionalHeader.Subsystem, "expected %#x, got %#lx\n", nt->OptionalHeader.Subsystem, info.image.SubSystemType);
+    ok(info.image.MinorSubsystemVersion == nt->OptionalHeader.MinorSubsystemVersion, "expected %#x, got %#x\n", nt->OptionalHeader.MinorSubsystemVersion, info.image.MinorSubsystemVersion);
+    ok(info.image.MajorSubsystemVersion == nt->OptionalHeader.MajorSubsystemVersion, "expected %#x, got %#x\n", nt->OptionalHeader.MajorSubsystemVersion, info.image.MajorSubsystemVersion);
+    ok(info.image.ImageCharacteristics == nt->FileHeader.Characteristics, "expected %#x, got %#x\n", nt->FileHeader.Characteristics, info.image.ImageCharacteristics);
+    ok(info.image.DllCharacteristics == nt->OptionalHeader.DllCharacteristics, "expected %#x, got %#x\n", nt->OptionalHeader.DllCharacteristics, info.image.DllCharacteristics);
+    ok(info.image.Machine == nt->FileHeader.Machine, "expected %#x, got %#x\n", nt->FileHeader.Machine, info.image.Machine);
+todo_wine
+    ok(info.image.ImageContainsCode == TRUE, "expected 1, got %#x\n", info.image.ImageContainsCode);
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == (SEC_FILE|SEC_IMAGE), "expected SEC_FILE|SEC_IMAGE, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == image_size, "expected %#Ix, got %#lx/%08lx\n", image_size, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    UnmapViewOfFile(p);
+    CloseHandle(mapping);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(file, NULL, PAGE_READONLY|SEC_COMMIT|SEC_NOCACHE, 0, 0, NULL);
+    ok(mapping != 0, "CreateFileMapping error %lu\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+todo_wine
+    ok(info.basic.Attributes == SEC_FILE, "expected SEC_FILE, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == fsize, "expected %#Ix, got %#lx/%08lx\n", fsize, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    CloseHandle(mapping);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(file, NULL, PAGE_READONLY|SEC_RESERVE, 0, 0, NULL);
+    ok(mapping != 0, "CreateFileMapping error %lu\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_FILE, "expected SEC_FILE, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == fsize, "expected %#Ix, got %#lx/%08lx\n", fsize, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    CloseHandle(mapping);
+    CloseHandle(file);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE|SEC_COMMIT, 0, 4096, NULL);
+    ok(mapping != 0, "CreateFileMapping error %lu\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_COMMIT, "expected SEC_COMMIT, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == 4096, "expected 4096, got %#lx/%08lx\n", info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    SetLastError(0xdeadbef);
+    p = MapViewOfFile(mapping, FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, 0);
+    ok(p != NULL, "MapViewOfFile error %lu\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_COMMIT, "expected SEC_COMMIT, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == 4096, "expected 4096, got %#lx/%08lx\n", info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    UnmapViewOfFile(p);
+    CloseHandle(mapping);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READONLY|SEC_RESERVE, 0, 4096, NULL);
+    ok(mapping != 0, "CreateFileMapping error %lu\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#lx\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %Iu\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_RESERVE, "expected SEC_RESERVE, got %#lx\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == 4096, "expected 4096, got %#lx/%08lx\n", info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    CloseHandle(mapping);
+}
+
 START_TEST(virtual)
 {
     int argc;
@@ -4328,6 +4557,7 @@ START_TEST(virtual)
     test_shared_memory_ro(FALSE, FILE_MAP_COPY);
     test_shared_memory_ro(FALSE, FILE_MAP_COPY|FILE_MAP_WRITE);
     test_mappings();
+    test_NtQuerySection();
     test_CreateFileMapping_protection();
     test_VirtualAlloc_protection();
     test_VirtualProtect();
diff --git a/dlls/kernelbase/debug.c b/dlls/kernelbase/debug.c
index 43714c3..c5f8825 100644
--- a/dlls/kernelbase/debug.c
+++ b/dlls/kernelbase/debug.c
@@ -203,6 +203,23 @@ void WINAPI DECLSPEC_HOTPATCH OutputDebugStringA( LPCSTR str )
     __ENDTRY
     if (caught_by_dbg) return;
 
+    /* for some unknown reason Windows sends the exception a second time, if a
+     * debugger is attached, and the event wasn't handled in the first attempt */
+    if (NtCurrentTeb()->Peb->BeingDebugged)
+    {
+        __TRY
+        {
+            ULONG_PTR args[2];
+            args[0] = strlen(str) + 1;
+            args[1] = (ULONG_PTR)str;
+            RaiseException( DBG_PRINTEXCEPTION_C, 0, 2, args );
+        }
+        __EXCEPT(debug_exception_handler)
+        {
+        }
+        __ENDTRY
+    }
+
     /* send string to a system-wide monitor */
     if (!mutex_inited)
     {
@@ -598,6 +615,7 @@ static BOOL start_debugger( EXCEPTION_POINTERS *epointers, HANDLE event )
     TRACE( "Starting debugger %s\n", debugstr_w(cmdline) );
     memset( &startup, 0, sizeof(startup) );
     startup.cb = sizeof(startup);
+    startup.lpDesktop = (WCHAR*)L"WinSta0";
     startup.dwFlags = STARTF_USESHOWWINDOW;
     startup.wShowWindow = SW_SHOWNORMAL;
     ret = CreateProcessW( NULL, cmdline, NULL, NULL, TRUE, 0, env, NULL, &startup, &info );
diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index e1ba92a..dc29f5d 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -37,6 +37,7 @@
 #include "ddk/ntddk.h"
 #include "ddk/ntddser.h"
 #include "ioringapi.h"
+#include "ntifs.h"
 
 #include "kernelbase.h"
 #include "wine/exception.h"
@@ -496,11 +497,16 @@ BOOL WINAPI CopyFileExW( const WCHAR *source, const WCHAR *dest, LPPROGRESS_ROUT
 {
     static const int buffer_size = 65536;
     HANDLE h1, h2;
-    FILE_BASIC_INFORMATION info;
+    FILE_NETWORK_OPEN_INFORMATION info;
+    FILE_BASIC_INFORMATION basic_info;
     IO_STATUS_BLOCK io;
     DWORD count;
     BOOL ret = FALSE;
     char *buffer;
+    LARGE_INTEGER size;
+    LARGE_INTEGER transferred;
+    DWORD cbret;
+    DWORD source_access = GENERIC_READ;
 
     if (!source || !dest)
     {
@@ -522,7 +528,10 @@ BOOL WINAPI CopyFileExW( const WCHAR *source, const WCHAR *dest, LPPROGRESS_ROUT
     if (flags & COPY_FILE_OPEN_SOURCE_FOR_WRITE)
         FIXME("COPY_FILE_OPEN_SOURCE_FOR_WRITE is not supported\n");
 
-    if ((h1 = CreateFileW( source, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+    if (flags & COPY_FILE_OPEN_SOURCE_FOR_WRITE)
+        source_access |= GENERIC_WRITE;
+
+    if ((h1 = CreateFileW( source, source_access, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            NULL, OPEN_EXISTING, 0, 0 )) == INVALID_HANDLE_VALUE)
     {
         WARN("Unable to open source %s\n", debugstr_w(source));
@@ -530,7 +539,7 @@ BOOL WINAPI CopyFileExW( const WCHAR *source, const WCHAR *dest, LPPROGRESS_ROUT
         return FALSE;
     }
 
-    if (!set_ntstatus( NtQueryInformationFile( h1, &io, &info, sizeof(info), FileBasicInformation )))
+    if (!set_ntstatus( NtQueryInformationFile( h1, &io, &info, sizeof(info), FileNetworkOpenInformation )))
     {
         WARN("GetFileInformationByHandle returned error for %s\n", debugstr_w(source));
         HeapFree( GetProcessHeap(), 0, buffer );
@@ -556,7 +565,11 @@ BOOL WINAPI CopyFileExW( const WCHAR *source, const WCHAR *dest, LPPROGRESS_ROUT
         }
     }
 
-    if ((h2 = CreateFileW( dest, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+    if ((h2 = CreateFileW( dest, GENERIC_WRITE | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+                           (flags & COPY_FILE_FAIL_IF_EXISTS) ? CREATE_NEW : CREATE_ALWAYS,
+                           info.FileAttributes, h1 )) == INVALID_HANDLE_VALUE &&
+        /* retry without DELETE if we got a sharing violation */
+        (h2 = CreateFileW( dest, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                            (flags & COPY_FILE_FAIL_IF_EXISTS) ? CREATE_NEW : CREATE_ALWAYS,
                            info.FileAttributes, h1 )) == INVALID_HANDLE_VALUE)
     {
@@ -566,6 +579,29 @@ BOOL WINAPI CopyFileExW( const WCHAR *source, const WCHAR *dest, LPPROGRESS_ROUT
         return FALSE;
     }
 
+    size = info.EndOfFile;
+    transferred.QuadPart = 0;
+
+    if (progress)
+    {
+        cbret = progress( size, transferred, size, transferred, 1,
+                          CALLBACK_STREAM_SWITCH, h1, h2, param );
+        if (cbret == PROGRESS_QUIET)
+            progress = NULL;
+        else if (cbret == PROGRESS_STOP)
+        {
+            SetLastError( ERROR_REQUEST_ABORTED );
+            goto done;
+        }
+        else if (cbret == PROGRESS_CANCEL)
+        {
+            BOOLEAN disp = TRUE;
+            SetFileInformationByHandle( h2, FileDispositionInfo, &disp, sizeof(disp) );
+            SetLastError( ERROR_REQUEST_ABORTED );
+            goto done;
+        }
+    }
+
     while (ReadFile( h1, buffer, buffer_size, &count, NULL ) && count)
     {
         char *p = buffer;
@@ -575,13 +611,38 @@ BOOL WINAPI CopyFileExW( const WCHAR *source, const WCHAR *dest, LPPROGRESS_ROUT
             if (!WriteFile( h2, p, count, &res, NULL ) || !res) goto done;
             p += res;
             count -= res;
+
+            if (progress)
+            {
+                transferred.QuadPart += res;
+                cbret = progress( size, transferred, size, transferred, 1,
+                                  CALLBACK_CHUNK_FINISHED, h1, h2, param );
+                if (cbret == PROGRESS_QUIET)
+                    progress = NULL;
+                else if (cbret == PROGRESS_STOP)
+                {
+                    SetLastError( ERROR_REQUEST_ABORTED );
+                    goto done;
+                }
+                else if (cbret == PROGRESS_CANCEL)
+                {
+                    BOOLEAN disp = TRUE;
+                    SetFileInformationByHandle( h2, FileDispositionInfo, &disp, sizeof(disp) );
+                    SetLastError( ERROR_REQUEST_ABORTED );
+                    goto done;
+                }
+            }
         }
     }
     ret =  TRUE;
 done:
     /* Maintain the timestamp of source file to destination file */
-    info.FileAttributes = 0;
-    NtSetInformationFile( h2, &io, &info, sizeof(info), FileBasicInformation );
+    basic_info.CreationTime = info.CreationTime;
+    basic_info.LastAccessTime = info.LastAccessTime;
+    basic_info.LastWriteTime = info.LastWriteTime;
+    basic_info.ChangeTime = info.ChangeTime;
+    basic_info.FileAttributes = 0;
+    NtSetInformationFile( h2, &io, &basic_info, sizeof(basic_info), FileBasicInformation );
     HeapFree( GetProcessHeap(), 0, buffer );
     CloseHandle( h1 );
     CloseHandle( h2 );
@@ -732,6 +793,8 @@ static UINT get_nt_file_options( DWORD attributes )
         options |= FILE_SEQUENTIAL_ONLY;
     if (attributes & FILE_FLAG_WRITE_THROUGH)
         options |= FILE_WRITE_THROUGH;
+    if (attributes & FILE_FLAG_OPEN_REPARSE_POINT)
+        options |= FILE_OPEN_REPARSE_POINT;
     return options;
 }
 
@@ -943,8 +1006,106 @@ done:
  */
 BOOLEAN WINAPI /* DECLSPEC_HOTPATCH */ CreateSymbolicLinkW( LPCWSTR link, LPCWSTR target, DWORD flags )
 {
-    FIXME( "(%s %s %ld): stub\n", debugstr_w(link), debugstr_w(target), flags );
-    return TRUE;
+    static INT struct_size = offsetof(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0]);
+    static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
+    INT buffer_size, data_size, string_len, prefix_len;
+    WCHAR *subst_dest, *print_dest, *string;
+    REPARSE_DATA_BUFFER *buffer;
+    LPWSTR target_path = NULL;
+    BOOL is_relative, is_dir;
+    int target_path_len = 0;
+    UNICODE_STRING nt_name;
+    BOOLEAN bret = FALSE;
+    NTSTATUS status;
+    HANDLE hlink;
+    DWORD dwret;
+
+    TRACE( "(%s %s %ld): stub\n", debugstr_w(link), debugstr_w(target), flags );
+
+    is_relative = (RtlDetermineDosPathNameType_U( target ) == RELATIVE_PATH);
+    is_dir = (flags & SYMBOLIC_LINK_FLAG_DIRECTORY);
+    if (is_dir && !CreateDirectoryW( link, NULL ))
+        return FALSE;
+    hlink = CreateFileW( link, GENERIC_READ | GENERIC_WRITE, 0, 0,
+                         is_dir ? OPEN_EXISTING : CREATE_NEW,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0 );
+    if (hlink == INVALID_HANDLE_VALUE)
+        goto cleanup;
+    if (is_relative)
+    {
+        UNICODE_STRING nt_path;
+        int len;
+
+        status = RtlDosPathNameToNtPathName_U_WithStatus( link, &nt_path, NULL, NULL );
+        if (status != STATUS_SUCCESS)
+        {
+            SetLastError( RtlNtStatusToDosError(status) );
+            goto cleanup;
+        }
+        /* obtain the path of the link */
+        for (; nt_path.Length > 0; nt_path.Length -= sizeof(WCHAR))
+        {
+            WCHAR c = nt_path.Buffer[nt_path.Length/sizeof(WCHAR)];
+            if (c == '/' || c == '\\')
+            {
+                nt_path.Length += sizeof(WCHAR);
+                break;
+            }
+        }
+        /* append the target to the link path */
+        target_path_len = nt_path.Length / sizeof(WCHAR);
+        len = target_path_len + (lstrlenW( target ) + 1);
+        target_path = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, len*sizeof(WCHAR) );
+        lstrcpynW( target_path, nt_path.Buffer, target_path_len+1 );
+        target_path[target_path_len+1] = 0;
+        lstrcatW( target_path, target );
+        RtlFreeUnicodeString( &nt_path );
+    }
+    else
+        target_path = (LPWSTR)target;
+    status = RtlDosPathNameToNtPathName_U_WithStatus( target_path, &nt_name, NULL, NULL );
+    if (status != STATUS_SUCCESS)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        goto cleanup;
+    }
+    if (is_relative && _wcsnicmp( target_path, nt_name.Buffer, target_path_len ) != 0)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        goto cleanup;
+    }
+    prefix_len = is_relative ? 0 : strlen("\\??\\");
+    string = &nt_name.Buffer[target_path_len];
+    string_len = lstrlenW( &string[prefix_len] );
+    data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
+    buffer_size = struct_size + data_size;
+    buffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_size );
+    buffer->ReparseTag = IO_REPARSE_TAG_SYMLINK;
+    buffer->ReparseDataLength = struct_size - header_size + data_size;
+    buffer->SymbolicLinkReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
+    buffer->SymbolicLinkReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
+    buffer->SymbolicLinkReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
+    buffer->SymbolicLinkReparseBuffer.Flags = is_relative ? SYMLINK_FLAG_RELATIVE : 0;
+    subst_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[0];
+    print_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[prefix_len + string_len + 1];
+    lstrcpyW( subst_dest, string );
+    lstrcpyW( print_dest, &string[prefix_len] );
+    RtlFreeUnicodeString( &nt_name );
+    bret = DeviceIoControl( hlink, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_size, NULL, 0,
+                            &dwret, 0 );
+    HeapFree( GetProcessHeap(), 0, buffer );
+
+cleanup:
+    CloseHandle( hlink );
+    if (!bret)
+    {
+        if (is_dir)
+            RemoveDirectoryW( link );
+        else
+            DeleteFileW( link );
+    }
+    if (is_relative) HeapFree( GetProcessHeap(), 0, target_path );
+    return bret;
 }
 
 
@@ -988,7 +1149,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH DeleteFileW( LPCWSTR path )
 
     status = NtCreateFile(&hFile, SYNCHRONIZE | DELETE, &attr, &io, NULL, 0,
 			  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
-			  FILE_OPEN, FILE_DELETE_ON_CLOSE | FILE_NON_DIRECTORY_FILE, NULL, 0);
+			  FILE_OPEN, FILE_DELETE_ON_CLOSE | FILE_NON_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT,
+			  NULL, 0);
     if (status == STATUS_SUCCESS) status = NtClose(hFile);
 
     RtlFreeUnicodeString( &nameW );
@@ -1514,6 +1676,30 @@ BOOL WINAPI DECLSPEC_HOTPATCH FindNextFileW( HANDLE handle, WIN32_FIND_DATAW *da
         memcpy( data->cFileName, dir_info->FileName, dir_info->FileNameLength );
         data->cFileName[dir_info->FileNameLength/sizeof(WCHAR)] = 0;
 
+        /* get reparse tag */
+        if (dir_info->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
+        {
+            INT path_len = info->path.Length + dir_info->FileNameLength + sizeof(WCHAR);
+            WCHAR *path = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, path_len );
+            FILE_ATTRIBUTE_TAG_INFORMATION taginfo;
+            IO_STATUS_BLOCK iosb;
+            NTSTATUS status;
+            HANDLE hlink;
+
+            if (!path) break;
+
+            lstrcpynW( path, info->path.Buffer, info->path.Length/sizeof(WCHAR) + 1 );
+            lstrcatW( path, data->cFileName );
+
+            hlink = CreateFileW( path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                                 FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0 );
+            HeapFree( GetProcessHeap(), 0, path );
+            status = NtQueryInformationFile( hlink, &iosb, &taginfo, sizeof(taginfo),
+                                             FileAttributeTagInformation );
+            if (status == STATUS_SUCCESS) data->dwReserved0 = taginfo.ReparseTag;
+            CloseHandle( hlink );
+        }
+
         if (info->level != FindExInfoBasic)
         {
             memcpy( data->cAlternateFileName, dir_info->ShortName, dir_info->ShortNameLength );
@@ -2576,7 +2762,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH MoveFileWithProgressW( const WCHAR *source, const
 
     status = NtOpenFile( &source_handle, DELETE | SYNCHRONIZE, &attr, &io,
                          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
-                         FILE_SYNCHRONOUS_IO_NONALERT );
+                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT );
     RtlFreeUnicodeString( &nt_name );
     if (!set_ntstatus( status )) goto error;
 
@@ -3637,7 +3823,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RemoveDirectoryW( LPCWSTR path )
     InitializeObjectAttributes( &attr, &nt_name, OBJ_CASE_INSENSITIVE, 0, NULL );
     status = NtOpenFile( &handle, DELETE | SYNCHRONIZE, &attr, &io,
                          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
-                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
+                         FILE_OPEN_REPARSE_POINT | FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
     RtlFreeUnicodeString( &nt_name );
 
     if (!status)
diff --git a/dlls/kernelbase/path.c b/dlls/kernelbase/path.c
index 40ddf84..5b67a02 100644
--- a/dlls/kernelbase/path.c
+++ b/dlls/kernelbase/path.c
@@ -3623,6 +3623,7 @@ HRESULT WINAPI UrlCanonicalizeW(const WCHAR *src_url, WCHAR *canonicalized, DWOR
      *         4   have //  5,3
      *         5   have 1[+] alnum  6,3
      *         6   have location (found /) save root location
+     *         7   have ./
      */
 
     wk1 = url;
@@ -3649,6 +3650,11 @@ HRESULT WINAPI UrlCanonicalizeW(const WCHAR *src_url, WCHAR *canonicalized, DWOR
         state = 5;
         is_file_url = TRUE;
     }
+    else if (url[0] == '.' && url[1] == '/')
+    {
+        state = 7;
+        is_file_url = TRUE;
+    }
 
     while (*wk1)
     {
@@ -3853,6 +3859,15 @@ HRESULT WINAPI UrlCanonicalizeW(const WCHAR *src_url, WCHAR *canonicalized, DWOR
             }
             *wk2 = '\0';
             break;
+        case 7:
+            if (flags & URL_DONT_SIMPLIFY)
+            {
+                state = 3;
+                break;
+            }
+            wk1 += 2;
+            state = 6;
+            break;
         default:
             FIXME("how did we get here - state=%d\n", state);
             heap_free(url_copy);
@@ -4910,7 +4925,10 @@ HRESULT WINAPI UrlCombineW(const WCHAR *baseW, const WCHAR *relativeW, WCHAR *co
         work = preliminary + base.cchProtocol + 1 + base.cchSuffix - 1;
         if (*work++ != '/')
             *(work++) = '/';
-        lstrcpyW(work, relative.pszSuffix);
+        if (relative.pszSuffix[0] == '.' && relative.pszSuffix[1] == 0)
+            *work = 0;
+        else
+            lstrcpyW(work, relative.pszSuffix);
         break;
 
     default:
diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index 1aeb8f5..543e2e7 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -28,6 +28,7 @@
 #include "winnls.h"
 #include "wincontypes.h"
 #include "winternl.h"
+#include "winuser.h"
 
 #include "kernelbase.h"
 #include "wine/debug.h"
@@ -433,6 +434,54 @@ BOOL WINAPI DECLSPEC_HOTPATCH CloseHandle( HANDLE handle )
 }
 
 
+static BOOL image_needs_elevation( const WCHAR *path )
+{
+    ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION run_level;
+    BOOL ret = FALSE;
+    HANDLE handle;
+    ACTCTXW ctx;
+
+    ctx.cbSize = sizeof(ctx);
+    ctx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
+    ctx.lpSource = path;
+    ctx.lpResourceName = (const WCHAR *)CREATEPROCESS_MANIFEST_RESOURCE_ID;
+
+    if (RtlCreateActivationContext( &handle, &ctx )) return FALSE;
+
+    if (!RtlQueryInformationActivationContext( 0, handle, NULL, RunlevelInformationInActivationContext,
+                                               &run_level, sizeof(run_level), NULL ))
+    {
+        TRACE( "image requested run level %#x\n", run_level.RunLevel );
+        if (run_level.RunLevel == ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE
+                || run_level.RunLevel == ACTCTX_RUN_LEVEL_REQUIRE_ADMIN)
+            ret = TRUE;
+    }
+    RtlReleaseActivationContext( handle );
+
+    return ret;
+}
+
+
+static HANDLE get_elevated_token(void)
+{
+    TOKEN_ELEVATION_TYPE type;
+    TOKEN_LINKED_TOKEN linked;
+    NTSTATUS status;
+
+    if ((status = NtQueryInformationToken( GetCurrentThreadEffectiveToken(),
+                                           TokenElevationType, &type, sizeof(type), NULL )))
+        return NULL;
+
+    if (type == TokenElevationTypeFull) return NULL;
+
+    if ((status = NtQueryInformationToken( GetCurrentThreadEffectiveToken(),
+                                           TokenLinkedToken, &linked, sizeof(linked), NULL )))
+        return NULL;
+
+    return linked.LinkedToken;
+}
+
+
 /**********************************************************************
  *           CreateProcessAsUserA   (kernelbase.@)
  */
@@ -519,7 +568,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
     WCHAR *p, *tidy_cmdline = cmd_line;
     RTL_USER_PROCESS_PARAMETERS *params = NULL;
     RTL_USER_PROCESS_INFORMATION rtl_info;
-    HANDLE parent = 0, debug = 0;
+    HANDLE parent = 0, debug = 0, elevated_token = NULL;
     ULONG nt_flags = 0;
     USHORT machine = 0;
     NTSTATUS status;
@@ -631,6 +680,9 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
     if (flags & CREATE_BREAKAWAY_FROM_JOB) nt_flags |= PROCESS_CREATE_FLAGS_BREAKAWAY;
     if (flags & CREATE_SUSPENDED) nt_flags |= PROCESS_CREATE_FLAGS_SUSPENDED;
 
+    if (!token && image_needs_elevation( params->ImagePathName.Buffer ))
+        token = elevated_token = get_elevated_token();
+
     status = create_nt_process( token, debug, process_attr, thread_attr,
                                 nt_flags, params, &rtl_info, parent, machine, handle_list, job_list );
     switch (status)
@@ -672,7 +724,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
         TRACE( "started process pid %04lx tid %04lx\n", info->dwProcessId, info->dwThreadId );
     }
 
- done:
+done:
+    if (elevated_token) NtClose( elevated_token );
     RtlDestroyProcessParameters( params );
     if (tidy_cmdline != cmd_line) HeapFree( GetProcessHeap(), 0, tidy_cmdline );
     return set_ntstatus( status );
diff --git a/dlls/kernelbase/thread.c b/dlls/kernelbase/thread.c
index 8867029..ecb4f09 100644
--- a/dlls/kernelbase/thread.c
+++ b/dlls/kernelbase/thread.c
@@ -521,12 +521,25 @@ DWORD WINAPI DECLSPEC_HOTPATCH SetThreadIdealProcessor( HANDLE thread, DWORD pro
 /***********************************************************************
  *           SetThreadIdealProcessorEx   (kernelbase.@)
  */
-BOOL WINAPI DECLSPEC_HOTPATCH SetThreadIdealProcessorEx( HANDLE thread, PROCESSOR_NUMBER *ideal,
+BOOL WINAPI DECLSPEC_HOTPATCH SetThreadIdealProcessorEx( HANDLE thread, PROCESSOR_NUMBER *processor,
                                                          PROCESSOR_NUMBER *previous )
 {
-    FIXME( "(%p %p %p): stub\n", thread, ideal, previous );
-    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
-    return FALSE;
+    FIXME("(%p, %p, %p): stub\n", thread, processor, previous);
+
+    if (!processor || processor->Group > 0 || processor->Number > MAXIMUM_PROCESSORS)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    if (previous)
+    {
+        previous->Group = 0;
+        previous->Number = 0;
+        previous->Reserved = 0;
+    }
+
+    return TRUE;
 }
 
 
diff --git a/dlls/krnl386.exe16/file.c b/dlls/krnl386.exe16/file.c
index 5eab055..0d9a2e8 100644
--- a/dlls/krnl386.exe16/file.c
+++ b/dlls/krnl386.exe16/file.c
@@ -42,6 +42,17 @@ WINE_DEFAULT_DEBUG_CHANNEL(file);
 
 static HANDLE dos_handles[DOS_TABLE_SIZE];
 
+static void set_standard_handle(HANDLE *out, HANDLE null, HANDLE in)
+{
+    if (!in || in == INVALID_HANDLE_VALUE ||
+        !DuplicateHandle(GetCurrentProcess(), in, GetCurrentProcess(),
+                         out, 0, TRUE, DUPLICATE_SAME_ACCESS))
+    {
+        DuplicateHandle(GetCurrentProcess(), null, GetCurrentProcess(),
+                        out, 0, TRUE, DUPLICATE_SAME_ACCESS);
+    }
+}
+
 /***********************************************************************
  *           FILE_InitProcessDosHandles
  *
@@ -50,25 +61,21 @@ static HANDLE dos_handles[DOS_TABLE_SIZE];
  */
 static void FILE_InitProcessDosHandles( void )
 {
-    HANDLE hStdInput, hStdOutput, hStdError, hNull;
+    HANDLE hNull;
     static BOOL init_done /* = FALSE */;
-    HANDLE cp = GetCurrentProcess();
 
     if (init_done) return;
     init_done = TRUE;
-    hStdInput = GetStdHandle(STD_INPUT_HANDLE);
-    hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
-    hStdError = GetStdHandle(STD_ERROR_HANDLE);
+
     hNull = CreateFileA("NUL", GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+
     /* Invalid console handles need to translate to real DOS handles in a new process */
-    if (!hStdInput) hStdInput = hNull;
-    if (!hStdOutput) hStdOutput = hNull;
-    if (!hStdError) hStdError = hNull;
-    DuplicateHandle(cp, hStdInput, cp, &dos_handles[0], 0, TRUE, DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(cp, hStdOutput, cp, &dos_handles[1], 0, TRUE, DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(cp, hStdError, cp, &dos_handles[2], 0, TRUE, DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(cp, hStdError, cp, &dos_handles[3], 0, TRUE, DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(cp, hStdError, cp, &dos_handles[4], 0, TRUE, DUPLICATE_SAME_ACCESS);
+    set_standard_handle(&dos_handles[0], hNull, GetStdHandle(STD_INPUT_HANDLE));
+    set_standard_handle(&dos_handles[1], hNull, GetStdHandle(STD_OUTPUT_HANDLE));
+    set_standard_handle(&dos_handles[2], hNull, GetStdHandle(STD_ERROR_HANDLE));
+    set_standard_handle(&dos_handles[3], hNull, GetStdHandle(STD_ERROR_HANDLE));
+    set_standard_handle(&dos_handles[4], hNull, GetStdHandle(STD_ERROR_HANDLE));
+
     CloseHandle(hNull);
 }
 
diff --git a/dlls/krnl386.exe16/instr.c b/dlls/krnl386.exe16/instr.c
index b21a00d..0954fd8 100644
--- a/dlls/krnl386.exe16/instr.c
+++ b/dlls/krnl386.exe16/instr.c
@@ -60,7 +60,7 @@ static inline void *get_stack( CONTEXT *context )
 }
 
 #include "pshpack1.h"
-struct idtr
+struct dtr
 {
     WORD  limit;
     BYTE *base;
@@ -68,19 +68,41 @@ struct idtr
 #include "poppack.h"
 
 static LDT_ENTRY idt[256];
+static LDT_ENTRY gdt[8192];
+static LDT_ENTRY ldt[8192];
 
-static inline struct idtr get_idtr(void)
+static BOOL emulate_idtr( BYTE *data, unsigned int data_size, unsigned int *offset )
 {
-    struct idtr ret;
 #if defined(__i386__) && defined(__GNUC__)
+    struct dtr ret;
     __asm__( "sidtl %0" : "=m" (ret) );
+    *offset = data - ret.base;
+    return (*offset <= ret.limit + 1 - data_size);
 #else
-    ret.base = (BYTE *)idt;
-    ret.limit = sizeof(idt) - 1;
+    return FALSE;
 #endif
-    return ret;
 }
 
+static BOOL emulate_gdtr( BYTE *data, unsigned int data_size, unsigned int *offset )
+{
+#if defined(__i386__) && defined(__GNUC__)
+    struct dtr ret;
+    __asm__( "sgdtl %0" : "=m" (ret) );
+    *offset = data - ret.base;
+    return (*offset <= ret.limit + 1 - data_size);
+#else
+    return FALSE;
+#endif
+}
+
+static inline WORD get_ldt(void)
+{
+    WORD seg = 1;
+#if defined(__i386__) && defined(__GNUC__)
+    __asm__( "sldt %0" : "=m" (seg) );
+#endif
+    return seg;
+}
 
 /***********************************************************************
  *           INSTR_ReplaceSelector
@@ -705,10 +727,9 @@ DWORD __wine_emulate_instruction( EXCEPTION_RECORD *rec, CONTEXT *context )
                 BYTE *data = INSTR_GetOperandAddr(context, instr + 1, long_addr,
                                                   segprefix, &len);
                 unsigned int data_size = (*instr == 0x8b) ? (long_op ? 4 : 2) : 1;
-                struct idtr idtr = get_idtr();
-                unsigned int offset = data - idtr.base;
+                unsigned int offset;
 
-                if (offset <= idtr.limit + 1 - data_size)
+                if (emulate_idtr( data, data_size, &offset ))
                 {
                     idt[1].LimitLow = 0x100; /* FIXME */
                     idt[2].LimitLow = 0x11E; /* FIXME */
@@ -722,6 +743,31 @@ DWORD __wine_emulate_instruction( EXCEPTION_RECORD *rec, CONTEXT *context )
                     context->Eip += prefixlen + len + 1;
                     return ExceptionContinueExecution;
                 }
+
+                if (emulate_gdtr( data, data_size, &offset ))
+                {
+                    static BOOL initialized;
+
+                    if (!initialized)
+                    {
+                        WORD index = get_ldt() >> 3;
+                        gdt[index].BaseLow                = ((DWORD_PTR)ldt & 0x0000FFFF);
+                        gdt[index].HighWord.Bytes.BaseMid = ((DWORD_PTR)ldt & 0x00FF0000) >> 16;
+                        gdt[index].HighWord.Bytes.BaseHi  = ((DWORD_PTR)ldt & 0xFF000000) >> 24;
+                        gdt[index].LimitLow               = 0xFFFF;
+                        gdt[index].HighWord.Bits.Pres     = 1;
+
+                        initialized = TRUE;
+                    }
+
+                    switch (*instr)
+                    {
+                    case 0x8a: store_reg_byte( context, instr[1], (BYTE *)gdt + offset ); break;
+                    case 0x8b: store_reg_word( context, instr[1], (BYTE *)gdt + offset, long_op ); break;
+                    }
+                    context->Eip += prefixlen + len + 1;
+                    return ExceptionContinueExecution;
+                }
             }
             break;  /* Unable to emulate it */
 
diff --git a/dlls/mmsystem.dll16/message16.c b/dlls/mmsystem.dll16/message16.c
index b12b9b9..64382ae 100644
--- a/dlls/mmsystem.dll16/message16.c
+++ b/dlls/mmsystem.dll16/message16.c
@@ -33,6 +33,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(winmm);
 
+struct mihdrWrap
+{
+    int ref;
+    SEGPTR mh16;
+    MIDIHDR hdr;
+};
+
 /* =================================
  *       A U X    M A P P E R S
  * ================================= */
@@ -88,7 +95,78 @@ static  void	                MMSYSTDRV_Mixer_MapCB(DWORD uMsg, DWORD_PTR* dwUser
  */
 static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_Map16To32W  (DWORD wMsg, DWORD_PTR* lpParam1, DWORD_PTR* lpParam2)
 {
-    return MMSYSTEM_MAP_MSGERROR;
+    MMSYSTEM_MapType ret = MMSYSTEM_MAP_MSGERROR;
+
+    switch (wMsg)
+    {
+        case MIDM_GETNUMDEVS:
+        case MIDM_RESET:
+            ret = MMSYSTEM_MAP_OK;
+            break;
+
+        case MIDM_GETDEVCAPS:
+            {
+                LPMIDIINCAPSW  mic32 = HeapAlloc(GetProcessHeap(), 0, sizeof(LPMIDIINCAPS16) + sizeof(MIDIINCAPSW));
+                LPMIDIINCAPS16 mic16 = MapSL(*lpParam1);
+
+                if (mic32)
+                {
+                    *(LPMIDIINCAPS16 *)mic32 = mic16;
+                    mic32 = (LPMIDIINCAPSW)((LPSTR)mic32 + sizeof(LPMIDIINCAPS16));
+                    *lpParam1 = (DWORD)mic32;
+                    *lpParam2 = sizeof(LPMIDIINCAPSW);
+
+                    ret = MMSYSTEM_MAP_OKMEM;
+                }
+                else
+                    ret = MMSYSTEM_MAP_NOMEM;
+            }
+            break;
+
+        case MIDM_ADDBUFFER:
+        case MIDM_PREPARE:
+            {
+                struct mihdrWrap   *mh32 = HeapAlloc(GetProcessHeap(), 0, sizeof(struct mihdrWrap));
+                LPMIDIHDR16         mh16 = MapSL(*lpParam1);
+
+                if (mh32)
+                {
+                    mh32->ref = 2;
+                    mh32->mh16 = (SEGPTR)*lpParam1;
+                    mh32->hdr.lpData = MapSL((SEGPTR)mh16->lpData);
+                    mh32->hdr.dwBufferLength = mh16->dwBufferLength;
+                    mh32->hdr.dwBytesRecorded = mh16->dwBytesRecorded;
+                    mh32->hdr.dwUser = mh16->dwUser;
+                    mh32->hdr.dwFlags = mh16->dwFlags;
+                    mh16->lpNext = (MIDIHDR16*)mh32;
+                    *lpParam1 = (DWORD)&mh32->hdr;
+                    *lpParam2 = offsetof(MIDIHDR,dwOffset);
+
+                    ret = MMSYSTEM_MAP_OKMEM;
+                }
+                else
+                    ret = MMSYSTEM_MAP_NOMEM;
+            }
+            break;
+
+        case MIDM_UNPREPARE:
+            {
+                LPMIDIHDR16         mh16 = MapSL(*lpParam1);
+                struct mihdrWrap   *mh32 = (struct mihdrWrap *)mh16->lpNext;
+
+                mh32->ref++;
+
+                *lpParam1 = (DWORD)&mh32->hdr;
+                *lpParam2 = offsetof(MIDIHDR,dwOffset);
+
+                mh32->hdr.dwBufferLength = mh16->dwBufferLength;
+
+                ret = MMSYSTEM_MAP_OKMEM;
+            }
+            break;
+    }
+
+    return ret;
 }
 
 /**************************************************************************
@@ -96,7 +174,60 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
  */
 static  MMSYSTEM_MapType	MMSYSTDRV_MidiIn_UnMap16To32W(DWORD wMsg, DWORD_PTR* lpParam1, DWORD_PTR* lpParam2, MMRESULT fn_ret)
 {
-    return MMSYSTEM_MAP_MSGERROR;
+    MMSYSTEM_MapType    ret = MMSYSTEM_MAP_MSGERROR;
+
+    switch (wMsg)
+    {
+        case MIDM_GETNUMDEVS:
+        case MIDM_RESET:
+            ret = MMSYSTEM_MAP_OK;
+            break;
+
+        case MIDM_GETDEVCAPS:
+            {
+                LPMIDIINCAPSW   mic32 = (LPMIDIINCAPSW)(*lpParam1);
+                LPMIDIINCAPS16  mic16 = *(LPMIDIINCAPS16*)((LPSTR)mic32 - sizeof(LPMIDIINCAPS16));
+
+                mic16->wMid             = mic32->wMid;
+                mic16->wPid             = mic32->wPid;
+                mic16->vDriverVersion   = mic32->vDriverVersion;
+                WideCharToMultiByte( CP_ACP, 0, mic32->szPname, -1, mic16->szPname,
+                                     sizeof(mic16->szPname), NULL, NULL );
+                mic16->dwSupport        = mic32->dwSupport;
+                HeapFree(GetProcessHeap(), 0, (LPSTR)mic32 - sizeof(LPMIDIINCAPS16));
+                ret = MMSYSTEM_MAP_OK;
+            }
+            break;
+
+        case MIDM_PREPARE:
+        case MIDM_UNPREPARE:
+            {
+                struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*lpParam1, struct mihdrWrap, hdr);
+                LPMIDIHDR16         mh16;
+
+                if (mh32->mh16)
+                {
+                    mh16 = MapSL(mh32->mh16);
+                    assert((struct mihdrWrap *)mh16->lpNext == mh32);
+                    mh16->dwFlags = mh32->hdr.dwFlags;
+
+                    if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR)
+                    {
+                        mh32->mh16 = 0;
+                        mh32->ref--;
+                        mh16->lpNext = 0;
+                    }
+                }
+
+                if (!--mh32->ref)
+                    HeapFree(GetProcessHeap(), 0, mh32);
+
+                ret = MMSYSTEM_MAP_OK;
+            }
+            break;
+
+    }
+    return ret;
 }
 
 /**************************************************************************
@@ -117,13 +248,13 @@ static  void            	MMSYSTDRV_MidiIn_MapCB(DWORD uMsg, DWORD_PTR* dwUser, D
     case MIM_LONGDATA:
     case MIM_LONGERROR:
         {
-	    LPMIDIHDR		mh32 = (LPMIDIHDR)(*dwParam1);
-	    SEGPTR		segmh16 = *(SEGPTR*)((LPSTR)mh32 - sizeof(LPMIDIHDR));
-	    LPMIDIHDR16		mh16 = MapSL(segmh16);
+	        struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*dwParam1, struct mihdrWrap, hdr);
+	        SEGPTR              segmh16 = mh32->mh16;
+	        LPMIDIHDR16         mh16 = MapSL(segmh16);
 
-	    *dwParam1 = (DWORD)segmh16;
-	    mh16->dwFlags = mh32->dwFlags;
-	    mh16->dwBytesRecorded = mh32->dwBytesRecorded;
+	        *dwParam1 = (DWORD)segmh16;
+	        mh16->dwFlags = mh32->hdr.dwFlags;
+	        mh16->dwBytesRecorded = mh32->hdr.dwBytesRecorded;
 	}
 	break;
     default:
@@ -175,42 +306,49 @@ static MMSYSTEM_MapType	MMSYSTDRV_MidiOut_Map16To32W  (DWORD wMsg, DWORD_PTR* lp
 	break;
     case MODM_PREPARE:
 	{
-	    LPMIDIHDR		mh32 = HeapAlloc(GetProcessHeap(), 0, sizeof(LPMIDIHDR) + sizeof(MIDIHDR));
-	    LPMIDIHDR16		mh16 = MapSL(*lpParam1);
-
-	    if (mh32) {
-		*(LPMIDIHDR*)mh32 = (LPMIDIHDR)*lpParam1;
-		mh32 = (LPMIDIHDR)((LPSTR)mh32 + sizeof(LPMIDIHDR));
-		mh32->lpData = MapSL((SEGPTR)mh16->lpData);
-		mh32->dwBufferLength = mh16->dwBufferLength;
-		mh32->dwBytesRecorded = mh16->dwBytesRecorded;
-		mh32->dwUser = mh16->dwUser;
-		mh32->dwFlags = mh16->dwFlags;
-		mh16->lpNext = (MIDIHDR16*)mh32; /* for reuse in unprepare and write */
-		*lpParam1 = (DWORD)mh32;
-		*lpParam2 = offsetof(MIDIHDR,dwOffset); /* old size, without dwOffset */
+        struct mihdrWrap   *mh32 = HeapAlloc(GetProcessHeap(), 0, sizeof(struct mihdrWrap));
+        LPMIDIHDR16         mh16 = MapSL(*lpParam1);
 
-		ret = MMSYSTEM_MAP_OKMEM;
-	    } else {
-		ret = MMSYSTEM_MAP_NOMEM;
-	    }
+        if (mh32)
+        {
+            mh32->ref = 2;
+            mh32->mh16 = (SEGPTR)*lpParam1;
+            mh32->hdr.lpData = MapSL((SEGPTR)mh16->lpData);
+            mh32->hdr.dwBufferLength = mh16->dwBufferLength;
+            mh32->hdr.dwBytesRecorded = mh16->dwBytesRecorded;
+            mh32->hdr.dwUser = mh16->dwUser;
+            mh32->hdr.dwFlags = mh16->dwFlags;
+            mh16->lpNext = (MIDIHDR16*)mh32; /* for reuse in unprepare and write */
+            *lpParam1 = (DWORD)&mh32->hdr;
+            *lpParam2 = offsetof(MIDIHDR,dwOffset); /* old size, without dwOffset */
+
+            ret = MMSYSTEM_MAP_OKMEM;
+        }
+        else
+            ret = MMSYSTEM_MAP_NOMEM;
 	}
 	break;
     case MODM_UNPREPARE:
     case MODM_LONGDATA:
 	{
-	    LPMIDIHDR16		mh16 = MapSL(*lpParam1);
-	    LPMIDIHDR		mh32 = (MIDIHDR*)mh16->lpNext;
+        LPMIDIHDR16         mh16 = MapSL(*lpParam1);
+        struct mihdrWrap   *mh32 = (struct mihdrWrap*)mh16->lpNext;
 
-	    *lpParam1 = (DWORD)mh32;
-	    *lpParam2 = offsetof(MIDIHDR,dwOffset);
-	    /* dwBufferLength can be reduced between prepare & write */
-	    if (wMsg == MODM_LONGDATA && mh32->dwBufferLength < mh16->dwBufferLength) {
-		ERR("Size of buffer has been increased from %ld to %ld, keeping initial value\n",
-		    mh32->dwBufferLength, mh16->dwBufferLength);
-	    } else
-                mh32->dwBufferLength = mh16->dwBufferLength;
-	    ret = MMSYSTEM_MAP_OKMEM;
+        mh32->ref++;
+
+        *lpParam1 = (DWORD)&mh32->hdr;
+        *lpParam2 = offsetof(MIDIHDR,dwOffset);
+
+        /* dwBufferLength can be reduced between prepare & write */
+        if (wMsg == MODM_LONGDATA && mh32->hdr.dwBufferLength < mh16->dwBufferLength)
+        {
+            ERR("Size of buffer has been increased from %d to %d, keeping initial value\n",
+                mh32->hdr.dwBufferLength, mh16->dwBufferLength);
+        }
+        else
+            mh32->hdr.dwBufferLength = mh16->dwBufferLength;
+
+        ret = MMSYSTEM_MAP_OKMEM;
 	}
 	break;
 
@@ -267,17 +405,28 @@ static  MMSYSTEM_MapType	MMSYSTDRV_MidiOut_UnMap16To32W(DWORD wMsg, DWORD_PTR* l
     case MODM_UNPREPARE:
     case MODM_LONGDATA:
 	{
-	    LPMIDIHDR		mh32 = (LPMIDIHDR)(*lpParam1);
-	    LPMIDIHDR16		mh16 = MapSL(*(SEGPTR*)((LPSTR)mh32 - sizeof(LPMIDIHDR)));
+        struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*lpParam1, struct mihdrWrap, hdr);
+        LPMIDIHDR16         mh16;
 
-	    assert((MIDIHDR*)mh16->lpNext == mh32);
-	    mh16->dwFlags = mh32->dwFlags;
+        /* Prosound unprepares the buffer during a callback */
+        if (mh32->mh16)
+        {
+            mh16 = MapSL(mh32->mh16);
+            assert((struct mihdrWrap *)mh16->lpNext == mh32);
+            mh16->dwFlags = mh32->hdr.dwFlags;
 
-	    if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR) {
-		HeapFree(GetProcessHeap(), 0, (LPSTR)mh32 - sizeof(LPMIDIHDR));
-		mh16->lpNext = 0;
-	    }
-	    ret = MMSYSTEM_MAP_OK;
+            if (wMsg == MODM_UNPREPARE && fn_ret == MMSYSERR_NOERROR)
+            {
+                mh32->mh16 = 0;
+                mh32->ref--;
+                mh16->lpNext = 0;
+            }
+        }
+
+        if (!--mh32->ref)
+            HeapFree(GetProcessHeap(), 0, mh32);
+
+        ret = MMSYSTEM_MAP_OK;
 	}
 	break;
 
@@ -307,12 +456,12 @@ static  void MMSYSTDRV_MidiOut_MapCB(DWORD uMsg, DWORD_PTR* dwUser, DWORD_PTR* d
     case MOM_DONE:
         {
 	    /* initial map is: 16 => 32 */
-	    LPMIDIHDR		mh32 = (LPMIDIHDR)(*dwParam1);
-	    SEGPTR		segmh16 = *(SEGPTR*)((LPSTR)mh32 - sizeof(LPMIDIHDR));
-	    LPMIDIHDR16		mh16 = MapSL(segmh16);
+        struct mihdrWrap   *mh32 = CONTAINING_RECORD((MIDIHDR *)*dwParam1, struct mihdrWrap, hdr);
+        SEGPTR              segmh16 = mh32->mh16;
+        LPMIDIHDR16         mh16 = MapSL(segmh16);
 
-	    *dwParam1 = (DWORD)segmh16;
-	    mh16->dwFlags = mh32->dwFlags;
+        *dwParam1 = (DWORD)segmh16;
+        mh16->dwFlags = mh32->hdr.dwFlags;
 	}
 	break;
     default:
diff --git a/dlls/mountmgr.sys/device.c b/dlls/mountmgr.sys/device.c
index 48ee8d9..58db928 100644
--- a/dlls/mountmgr.sys/device.c
+++ b/dlls/mountmgr.sys/device.c
@@ -177,6 +177,36 @@ static void get_filesystem_serial( struct volume *volume )
     volume->serial = strtoul( buffer, NULL, 16 );
 }
 
+/* get the flags for the volume by looking at the type of underlying filesystem */
+static DWORD get_filesystem_flags( struct volume *volume )
+{
+    char fstypename[256];
+    ULONG size = sizeof(fstypename);
+    struct get_volume_filesystem_params params = { volume->device->unix_mount, fstypename, &size };
+
+    if (!volume->device->unix_mount) return 0;
+    if (MOUNTMGR_CALL( get_volume_filesystem, &params )) return 0;
+
+    if (!strcmp("apfs", fstypename) ||
+        !strcmp("nfs", fstypename) ||
+        !strcmp("cifs", fstypename) ||
+        !strcmp("ncpfs", fstypename) ||
+        !strcmp("tmpfs", fstypename) ||
+        !strcmp("cramfs", fstypename) ||
+        !strcmp("devfs", fstypename) ||
+        !strcmp("procfs", fstypename) ||
+        !strcmp("ext2", fstypename) ||
+        !strcmp("ext3", fstypename) ||
+        !strcmp("ext4", fstypename) ||
+        !strcmp("hfs", fstypename) ||
+        !strcmp("hpfs", fstypename) ||
+        !strcmp("ntfs", fstypename))
+    {
+        return FILE_SUPPORTS_REPARSE_POINTS;
+    }
+    return 0;
+}
+
 
 /******************************************************************
  *		VOLUME_FindCdRomDataBestVoldesc
@@ -1021,8 +1051,8 @@ static NTSTATUS set_volume_info( struct volume *volume, struct dos_drive *drive,
         id = disk_device->unix_mount;
         id_len = strlen( disk_device->unix_mount ) + 1;
     }
-    if (volume->mount) set_mount_point_id( volume->mount, id, id_len );
-    if (drive && drive->mount) set_mount_point_id( drive->mount, id, id_len );
+    if (volume->mount) set_mount_point_id( volume->mount, id, id_len, -1 );
+    if (drive && drive->mount) set_mount_point_id( drive->mount, id, id_len, drive->drive );
 
     return STATUS_SUCCESS;
 }
@@ -1704,7 +1734,8 @@ static NTSTATUS WINAPI harddisk_query_volume( DEVICE_OBJECT *device, IRP *irp )
             break;
         default:
             fsname = L"NTFS";
-            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
+            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS
+                                         | get_filesystem_flags( volume );
             info->MaximumComponentNameLength = 255;
             break;
         }
@@ -1872,7 +1903,7 @@ static BOOL create_port_device( DRIVER_OBJECT *driver, int n, const char *unix_p
     UNICODE_STRING nt_name, symlink_name, default_name;
     DEVICE_OBJECT *dev_obj;
     NTSTATUS status;
-    struct set_dosdev_symlink_params params = { dosdevices_path, unix_path };
+    struct set_dosdev_symlink_params params = { dosdevices_path, unix_path, driver == serial_driver };
 
     /* create DOS device */
     if (MOUNTMGR_CALL( set_dosdev_symlink, &params )) return FALSE;
diff --git a/dlls/mountmgr.sys/mountmgr.c b/dlls/mountmgr.sys/mountmgr.c
index ad3c034..fecac94 100644
--- a/dlls/mountmgr.sys/mountmgr.c
+++ b/dlls/mountmgr.sys/mountmgr.c
@@ -44,14 +44,21 @@ struct mount_point
 static struct list mount_points_list = LIST_INIT(mount_points_list);
 static HKEY mount_key;
 
-void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len )
+void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len, int drive )
 {
+    WCHAR logicalW[] = {'\\','\\','.','\\','a',':',0};
     free( mount->id );
     mount->id_len = max( MIN_ID_LEN, id_len );
     if ((mount->id = calloc( mount->id_len, 1 )))
     {
         memcpy( mount->id, id, id_len );
-        RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, mount->id, mount->id_len );
+        if (drive < 0)
+            RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, mount->id, mount->id_len );
+        else
+        {
+            logicalW[4] = 'a' + drive;
+            RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, (BYTE*)logicalW, sizeof(logicalW) );
+        }
     }
     else mount->id_len = 0;
 }
@@ -609,6 +616,27 @@ static DWORD WINAPI run_loop_thread( void *arg )
     return MOUNTMGR_CALL( run_loop, &params );
 }
 
+static DWORD WINAPI registry_flush_thread( void *arg )
+{
+    UNICODE_STRING name = RTL_CONSTANT_STRING( L"\\Registry" );
+    OBJECT_ATTRIBUTES attr;
+    HANDLE root;
+
+    InitializeObjectAttributes( &attr, &name, 0, 0, NULL );
+    if (NtOpenKeyEx( &root, MAXIMUM_ALLOWED, &attr, 0 ))
+    {
+        ERR( "Failed opening root registry key.\n" );
+        return 0;
+    }
+
+    for (;;)
+    {
+        Sleep( 30000 );
+        if (NtFlushKey( root )) ERR( "Failed flushing registry.\n" );
+    }
+
+    return 0;
+}
 
 /* main entry point for the mount point manager driver */
 NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
@@ -652,6 +680,7 @@ NTSTATUS WINAPI DriverEntry( DRIVER_OBJECT *driver, UNICODE_STRING *path )
 
     thread = CreateThread( NULL, 0, device_op_thread, NULL, 0, NULL );
     CloseHandle( CreateThread( NULL, 0, run_loop_thread, thread, 0, NULL ));
+    CloseHandle( CreateThread( NULL, 0, registry_flush_thread, thread, 0, NULL ));
 
 #ifdef _WIN64
     /* create a symlink so that the Wine port overrides key can be edited with 32-bit reg or regedit */
diff --git a/dlls/mountmgr.sys/mountmgr.h b/dlls/mountmgr.sys/mountmgr.h
index b1de312..d7b7fad 100644
--- a/dlls/mountmgr.sys/mountmgr.h
+++ b/dlls/mountmgr.sys/mountmgr.h
@@ -108,6 +108,6 @@ extern struct mount_point *add_dosdev_mount_point( DEVICE_OBJECT *device, UNICOD
 extern struct mount_point *add_volume_mount_point( DEVICE_OBJECT *device, UNICODE_STRING *device_name,
                                                    const GUID *guid );
 extern void delete_mount_point( struct mount_point *mount );
-extern void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len );
+extern void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len, int drive );
 
 #endif /* __WINE_MOUNTMGR_H */
diff --git a/dlls/mountmgr.sys/unixlib.c b/dlls/mountmgr.sys/unixlib.c
index b74b233..55489d9 100644
--- a/dlls/mountmgr.sys/unixlib.c
+++ b/dlls/mountmgr.sys/unixlib.c
@@ -36,7 +36,23 @@
 #ifdef HAVE_SYS_STATVFS_H
 # include <sys/statvfs.h>
 #endif
+#include <termios.h>
 #include <unistd.h>
+#ifdef HAVE_SYS_STATFS_H
+# include <sys/statfs.h>
+#endif
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
+#ifdef HAVE_SYS_VFS_H
+# include <sys/vfs.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif
+#ifdef HAVE_SYS_MOUNT_H
+#include <sys/mount.h>
+#endif
 
 #include "unixlib.h"
 #include "wine/debug.h"
@@ -304,6 +320,27 @@ static NTSTATUS set_dosdev_symlink( void *args )
     char *path;
     NTSTATUS status = STATUS_SUCCESS;
 
+#ifdef linux
+    /* Serial port device files almost always exist on Linux even if the corresponding serial
+     * ports don't exist. Do a basic functionality check before advertising a serial port. */
+    if (params->serial)
+    {
+        struct termios tios;
+        int fd;
+
+        if ((fd = open( params->dest, O_RDONLY )) == -1)
+            return FALSE;
+
+        if (tcgetattr( fd, &tios ) == -1)
+        {
+            close( fd );
+            return FALSE;
+        }
+
+        close( fd );
+    }
+#endif
+
     if (!(path = get_dosdevices_path( params->dev ))) return STATUS_NO_MEMORY;
 
     if (params->dest && params->dest[0])
@@ -441,6 +478,87 @@ static NTSTATUS read_volume_file( void *args )
     return STATUS_SUCCESS;
 }
 
+static NTSTATUS get_volume_filesystem( void *args )
+{
+#if defined(__NR_renameat2) || defined(RENAME_SWAP)
+    const struct get_volume_filesystem_params *params = args;
+#if defined(HAVE_FSTATFS)
+    struct statfs stfs;
+#elif defined(HAVE_FSTATVFS)
+    struct statvfs stfs;
+#endif
+    const char *fstypename = "unknown";
+    int fd = -1;
+
+    if (params->volume[0] != '/')
+    {
+        char *path = get_dosdevices_path( params->volume );
+        if (path) fd = open( path, O_RDONLY );
+        free( path );
+    }
+    else fd = open( params->volume, O_RDONLY );
+    if (fd == -1) return STATUS_NO_SUCH_FILE;
+
+#if defined(HAVE_FSTATFS)
+    if (fstatfs(fd, &stfs))
+        return STATUS_NO_SUCH_FILE;
+#elif defined(HAVE_FSTATVFS)
+    if (fstatvfs(fd, &stfs))
+        return STATUS_NO_SUCH_FILE;
+#endif
+    close( fd );
+#if defined(HAVE_FSTATFS) && defined(linux)
+    switch (stfs.f_type)
+    {
+    case 0x6969:      /* nfs */
+        fstypename = "nfs";
+        break;
+    case 0xff534d42:  /* cifs */
+        fstypename = "cifs";
+        break;
+    case 0x564c:      /* ncpfs */
+        fstypename = "ncpfs";
+        break;
+    case 0x01021994:  /* tmpfs */
+        fstypename = "tmpfs";
+        break;
+    case 0x28cd3d45:  /* cramfs */
+        fstypename = "cramfs";
+        break;
+    case 0x1373:      /* devfs */
+        fstypename = "devfs";
+        break;
+    case 0x9fa0:      /* procfs */
+        fstypename = "procfs";
+        break;
+    case 0xef51:      /* old ext2 */
+        fstypename = "ext2";
+        break;
+    case 0xef53:      /* ext2/3/4 */
+        fstypename = "ext2";
+        break;
+    case 0x4244:      /* hfs */
+        fstypename = "hfs";
+        break;
+    case 0xf995e849:  /* hpfs */
+        fstypename = "hpfs";
+        break;
+    case 0x5346544e:  /* ntfs */
+        fstypename = "ntfs";
+        break;
+    default:
+        break;
+    }
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__) || defined(__NetBSD__)
+    fstypename = stfs.f_fstypename;
+#endif
+    lstrcpynA( params->fstypename, fstypename, *params->size );
+    return STATUS_SUCCESS;
+#else
+    return STATUS_NOT_IMPLEMENTED;
+#endif
+}
+
 static NTSTATUS match_unixdev( void *args )
 {
     const struct match_unixdev_params *params = args;
@@ -585,6 +703,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
     write_credential,
     delete_credential,
     enumerate_credentials,
+    get_volume_filesystem,
 };
 
 C_ASSERT( ARRAYSIZE(__wine_unix_call_funcs) == unix_funcs_count );
diff --git a/dlls/mountmgr.sys/unixlib.h b/dlls/mountmgr.sys/unixlib.h
index 41f6425..e836d35 100644
--- a/dlls/mountmgr.sys/unixlib.h
+++ b/dlls/mountmgr.sys/unixlib.h
@@ -90,6 +90,7 @@ struct set_dosdev_symlink_params
 {
     const char *dev;
     const char *dest;
+    BOOL serial;
 };
 
 struct get_volume_dos_devices_params
@@ -106,6 +107,13 @@ struct read_volume_file_params
     ULONG *size;
 };
 
+struct get_volume_filesystem_params
+{
+    const char *volume;
+    void *fstypename;
+    ULONG *size;
+};
+
 struct match_unixdev_params
 {
     const char *device;
@@ -172,6 +180,7 @@ enum mountmgr_funcs
     unix_write_credential,
     unix_delete_credential,
     unix_enumerate_credentials,
+    unix_get_volume_filesystem,
     unix_funcs_count
 };
 
diff --git a/dlls/mscoree/mscoree_main.c b/dlls/mscoree/mscoree_main.c
index a1bc888..643c1ee 100644
--- a/dlls/mscoree/mscoree_main.c
+++ b/dlls/mscoree/mscoree_main.c
@@ -21,9 +21,12 @@
 
 #include <stdarg.h>
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #define COBJMACROS
 #include "windef.h"
 #include "winbase.h"
+#include "winternl.h"
 #include "winuser.h"
 #include "winnls.h"
 #include "winreg.h"
@@ -315,8 +318,76 @@ VOID WINAPI _CorImageUnloading(PVOID imageBase)
 
 HRESULT WINAPI _CorValidateImage(PVOID* imageBase, LPCWSTR imageName)
 {
-    TRACE("(%p, %s): stub\n", imageBase, debugstr_w(imageName));
-    return E_FAIL;
+    IMAGE_COR20_HEADER *cliheader;
+    IMAGE_NT_HEADERS *nt;
+    ULONG size;
+
+    TRACE("(%p, %s)\n", imageBase, debugstr_w(imageName));
+
+    if (!imageBase)
+        return E_INVALIDARG;
+
+    nt = RtlImageNtHeader(*imageBase);
+    if (!nt)
+        return STATUS_INVALID_IMAGE_FORMAT;
+
+    cliheader = RtlImageDirectoryEntryToData(*imageBase, TRUE, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR, &size);
+    if (!cliheader || size < sizeof(*cliheader))
+        return STATUS_INVALID_IMAGE_FORMAT;
+
+#ifdef _WIN64
+    if (cliheader->Flags & COMIMAGE_FLAGS_32BITREQUIRED)
+        return STATUS_INVALID_IMAGE_FORMAT;
+
+    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+    {
+        if (cliheader->Flags & COMIMAGE_FLAGS_ILONLY)
+        {
+            DWORD *entry = &nt->OptionalHeader.AddressOfEntryPoint;
+            DWORD old_protect;
+
+            if (!VirtualProtect(entry, sizeof(*entry), PAGE_READWRITE, &old_protect))
+                return E_UNEXPECTED;
+            *entry = 0;
+            if (!VirtualProtect(entry, sizeof(*entry), old_protect, &old_protect))
+                return E_UNEXPECTED;
+        }
+
+        return STATUS_SUCCESS;
+    }
+
+    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
+    {
+        if (!(cliheader->Flags & COMIMAGE_FLAGS_ILONLY))
+            return STATUS_INVALID_IMAGE_FORMAT;
+
+        FIXME("conversion of IMAGE_NT_HEADERS32 -> IMAGE_NT_HEADERS64 not implemented\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+#else
+    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
+    {
+        if (cliheader->Flags & COMIMAGE_FLAGS_ILONLY)
+        {
+            DWORD *entry = &nt->OptionalHeader.AddressOfEntryPoint;
+            DWORD old_protect;
+
+            if (!VirtualProtect(entry, sizeof(*entry), PAGE_READWRITE, &old_protect))
+                return E_UNEXPECTED;
+            *entry = (nt->FileHeader.Characteristics & IMAGE_FILE_DLL) ?
+                ((DWORD_PTR)&_CorDllMain - (DWORD_PTR)*imageBase) :
+                ((DWORD_PTR)&_CorExeMain - (DWORD_PTR)*imageBase);
+            if (!VirtualProtect(entry, sizeof(*entry), old_protect, &old_protect))
+                return E_UNEXPECTED;
+        }
+
+        return STATUS_SUCCESS;
+    }
+
+#endif
+
+    return STATUS_INVALID_IMAGE_FORMAT;
 }
 
 HRESULT WINAPI GetCORSystemDirectory(LPWSTR pbuffer, DWORD cchBuffer, DWORD *dwLength)
diff --git a/dlls/msctf/range.c b/dlls/msctf/range.c
index 413cf91..f2ed2bf 100644
--- a/dlls/msctf/range.c
+++ b/dlls/msctf/range.c
@@ -54,7 +54,7 @@ static inline Range *impl_from_ITfRangeACP(ITfRangeACP *iface)
 
 static Range *unsafe_impl_from_ITfRange(ITfRange *iface)
 {
-    return CONTAINING_RECORD(iface, Range, ITfRangeACP_iface);
+    return CONTAINING_RECORD((ITfRangeACP*)iface, Range, ITfRangeACP_iface);
 }
 
 static void Range_Destructor(Range *This)
diff --git a/dlls/mshtml/oleobj.c b/dlls/mshtml/oleobj.c
index 36ff993..65bd37b 100644
--- a/dlls/mshtml/oleobj.c
+++ b/dlls/mshtml/oleobj.c
@@ -1392,8 +1392,28 @@ static HRESULT WINAPI DocObjOleInPlaceActiveObject_ContextSensitiveHelp(IOleInPl
 static HRESULT WINAPI DocObjOleInPlaceActiveObject_TranslateAccelerator(IOleInPlaceActiveObject *iface, LPMSG lpmsg)
 {
     HTMLDocumentObj *This = HTMLDocumentObj_from_IOleInPlaceActiveObject(iface);
-    FIXME("(%p)->(%p)\n", This, lpmsg);
-    return E_NOTIMPL;
+    HRESULT hres = S_FALSE;
+
+    TRACE("(%p)->(%p)\n", This, lpmsg);
+
+    switch(lpmsg->message)
+    {
+        case WM_KEYDOWN:
+            break;
+        case WM_KEYUP:
+        {
+            TRACE("Processing key %Ix\n", lpmsg->wParam);
+            if (lpmsg->wParam == VK_F5)
+                hres = IOleCommandTarget_Exec(&This->IOleCommandTarget_iface, NULL, OLECMDID_REFRESH, 0, NULL, NULL);
+
+            break;
+        }
+        default:
+            FIXME("Unsupported message %04x\n", lpmsg->message);
+    }
+
+    TRACE("result 0x%08lx\n", hres);
+    return hres;
 }
 
 static HRESULT WINAPI DocObjOleInPlaceActiveObject_OnFrameWindowActivate(IOleInPlaceActiveObject *iface,
diff --git a/dlls/msi/custom.c b/dlls/msi/custom.c
index d1e064f..12a7c3c 100644
--- a/dlls/msi/custom.c
+++ b/dlls/msi/custom.c
@@ -573,12 +573,28 @@ UINT CDECL __wine_msi_call_dll_function(DWORD client_pid, const GUID *guid)
     return r;
 }
 
+static HANDLE get_admin_token(void)
+{
+    TOKEN_ELEVATION_TYPE type;
+    TOKEN_LINKED_TOKEN linked;
+    DWORD size;
+
+    if (!GetTokenInformation(GetCurrentThreadEffectiveToken(), TokenElevationType, &type, sizeof(type), &size)
+            || type == TokenElevationTypeFull)
+        return NULL;
+
+    if (!GetTokenInformation(GetCurrentThreadEffectiveToken(), TokenLinkedToken, &linked, sizeof(linked), &size))
+        return NULL;
+    return linked.LinkedToken;
+}
+
 static DWORD custom_start_server(MSIPACKAGE *package, DWORD arch)
 {
     WCHAR path[MAX_PATH], cmdline[MAX_PATH + 23];
     PROCESS_INFORMATION pi = {0};
     STARTUPINFOW si = {0};
     WCHAR buffer[24];
+    HANDLE token;
     void *cookie;
     HANDLE pipe;
 
@@ -600,14 +616,18 @@ static DWORD custom_start_server(MSIPACKAGE *package, DWORD arch)
     lstrcatW(path, L"\\msiexec.exe");
     swprintf(cmdline, ARRAY_SIZE(cmdline), L"%s -Embedding %d", path, GetCurrentProcessId());
 
+    token = get_admin_token();
+
     if (is_wow64 && arch == SCS_64BIT_BINARY)
     {
         Wow64DisableWow64FsRedirection(&cookie);
-        CreateProcessW(path, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+        CreateProcessAsUserW(token, path, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
         Wow64RevertWow64FsRedirection(cookie);
     }
     else
-        CreateProcessW(path, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+        CreateProcessAsUserW(token, path, cmdline, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
+
+    if (token) CloseHandle(token);
 
     CloseHandle(pi.hThread);
 
diff --git a/dlls/msi/dialog.c b/dlls/msi/dialog.c
index ba8ca52..fbd5a1c 100644
--- a/dlls/msi/dialog.c
+++ b/dlls/msi/dialog.c
@@ -3105,13 +3105,13 @@ static LONGLONG vcl_get_cost( msi_dialog *dialog )
                 MSICOSTTREE_SELFONLY, INSTALLSTATE_LOCAL, &each_cost)))
         {
             /* each_cost is in 512-byte units */
-            total_cost += each_cost * 512;
+            total_cost += ((LONGLONG)each_cost) * 512;
         }
         if (ERROR_SUCCESS == (MSI_GetFeatureCost(dialog->package, feature,
                 MSICOSTTREE_SELFONLY, INSTALLSTATE_ABSENT, &each_cost)))
         {
             /* each_cost is in 512-byte units */
-            total_cost -= each_cost * 512;
+            total_cost -= ((LONGLONG)each_cost) * 512;
         }
     }
     return total_cost;
diff --git a/dlls/msi/files.c b/dlls/msi/files.c
index 96c6c5e..c85c66a 100644
--- a/dlls/msi/files.c
+++ b/dlls/msi/files.c
@@ -819,7 +819,7 @@ UINT ACTION_PatchFiles( MSIPACKAGE *package )
             data.cb      = patchfiles_cb;
             data.user    = &cursor;
 
-            if (!msi_cabextract( package, mi, &data ))
+            if (mi->cabinet && !msi_cabextract( package, mi, &data ))
             {
                 ERR("Failed to extract cabinet: %s\n", debugstr_w(mi->cabinet));
                 rc = ERROR_INSTALL_FAILURE;
diff --git a/dlls/msvcp120/tests/msvcp120.c b/dlls/msvcp120/tests/msvcp120.c
index f3cce63..4cc1ee2 100644
--- a/dlls/msvcp120/tests/msvcp120.c
+++ b/dlls/msvcp120/tests/msvcp120.c
@@ -1617,15 +1617,14 @@ static void test_tr2_sys__Stat(void)
         char const *path;
         enum file_type ret;
         int err_code;
-        int is_todo;
     } tests[] = {
-        { NULL, status_unknown, ERROR_INVALID_PARAMETER, FALSE },
-        { "tr2_test_dir",    directory_file, ERROR_SUCCESS, FALSE },
-        { "tr2_test_dir\\f1",  regular_file, ERROR_SUCCESS, FALSE },
-        { "tr2_test_dir\\not_exist_file  ", file_not_found, ERROR_SUCCESS, FALSE },
-        { "tr2_test_dir\\??invalid_name>>", file_not_found, ERROR_SUCCESS, FALSE },
-        { "tr2_test_dir\\f1_link" ,   regular_file, ERROR_SUCCESS, TRUE },
-        { "tr2_test_dir\\dir_link", directory_file, ERROR_SUCCESS, TRUE },
+        { NULL, status_unknown, ERROR_INVALID_PARAMETER },
+        { "tr2_test_dir",    directory_file, ERROR_SUCCESS },
+        { "tr2_test_dir\\f1",  regular_file, ERROR_SUCCESS },
+        { "tr2_test_dir\\not_exist_file  ", file_not_found, ERROR_SUCCESS },
+        { "tr2_test_dir\\??invalid_name>>", file_not_found, ERROR_SUCCESS },
+        { "tr2_test_dir\\f1_link" ,   regular_file, ERROR_SUCCESS },
+        { "tr2_test_dir\\dir_link", directory_file, ERROR_SUCCESS },
     };
 
     CreateDirectoryA("tr2_test_dir", NULL);
@@ -1668,16 +1667,14 @@ static void test_tr2_sys__Stat(void)
     for(i=0; i<ARRAY_SIZE(tests); i++) {
         err_code = 0xdeadbeef;
         val = p_tr2_sys__Stat(tests[i].path, &err_code);
-        todo_wine_if(tests[i].is_todo)
-            ok(tests[i].ret == val, "tr2_sys__Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+        ok(tests[i].ret == val, "tr2_sys__Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
         ok(tests[i].err_code == err_code, "tr2_sys__Stat(): test %d err_code expect: %d, got %d\n",
                 i+1, tests[i].err_code, err_code);
 
         /* test tr2_sys__Lstat */
         err_code = 0xdeadbeef;
         val = p_tr2_sys__Lstat(tests[i].path, &err_code);
-        todo_wine_if(tests[i].is_todo)
-            ok(tests[i].ret == val, "tr2_sys__Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+        ok(tests[i].ret == val, "tr2_sys__Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
         ok(tests[i].err_code == err_code, "tr2_sys__Lstat(): test %d err_code expect: %d, got %d\n",
                 i+1, tests[i].err_code, err_code);
     }
@@ -1692,8 +1689,8 @@ static void test_tr2_sys__Stat(void)
     ok(ERROR_SUCCESS == err_code, "tr2_sys__Lstat_wchar(): err_code expect ERROR_SUCCESS, got %d\n", err_code);
 
     if(ret) {
-        todo_wine ok(DeleteFileA("tr2_test_dir/f1_link"), "expect tr2_test_dir/f1_link to exist\n");
-        todo_wine ok(RemoveDirectoryA("tr2_test_dir/dir_link"), "expect tr2_test_dir/dir_link to exist\n");
+        ok(DeleteFileA("tr2_test_dir/f1_link"), "expect tr2_test_dir/f1_link to exist\n");
+        ok(RemoveDirectoryA("tr2_test_dir/dir_link"), "expect tr2_test_dir/dir_link to exist\n");
     }
     ok(DeleteFileA("tr2_test_dir/f1"), "expect tr2_test_dir/f1 to exist\n");
     ok(RemoveDirectoryA("tr2_test_dir"), "expect tr2_test_dir to exist\n");
@@ -1922,16 +1919,15 @@ static void test_tr2_sys__Symlink(void)
         char const *existing_path;
         char const *new_path;
         int last_error;
-        MSVCP_bool is_todo;
     } tests[] = {
-        { "f1", "f1_link", ERROR_SUCCESS, FALSE },
-        { "f1", "tr2_test_dir\\f1_link", ERROR_SUCCESS, FALSE },
-        { "tr2_test_dir\\f1_link", "tr2_test_dir\\f1_link_link", ERROR_SUCCESS, FALSE },
-        { "tr2_test_dir", "dir_link", ERROR_SUCCESS, FALSE },
-        { NULL, "NULL_link", ERROR_INVALID_PARAMETER, FALSE },
-        { "f1", NULL, ERROR_INVALID_PARAMETER, FALSE },
-        { "not_exist",  "not_exist_link", ERROR_SUCCESS, FALSE },
-        { "f1", "not_exist_dir\\f1_link", ERROR_PATH_NOT_FOUND, TRUE }
+        { "f1", "f1_link", ERROR_SUCCESS },
+        { "f1", "tr2_test_dir\\f1_link", ERROR_SUCCESS },
+        { "tr2_test_dir\\f1_link", "tr2_test_dir\\f1_link_link", ERROR_SUCCESS },
+        { "tr2_test_dir", "dir_link", ERROR_SUCCESS },
+        { NULL, "NULL_link", ERROR_INVALID_PARAMETER },
+        { "f1", NULL, ERROR_INVALID_PARAMETER },
+        { "not_exist",  "not_exist_link", ERROR_SUCCESS },
+        { "f1", "not_exist_dir\\f1_link", ERROR_PATH_NOT_FOUND }
     };
 
     ret = p_tr2_sys__Make_dir("tr2_test_dir");
@@ -1956,18 +1952,17 @@ static void test_tr2_sys__Symlink(void)
         }
 
         ok(errno == 0xdeadbeef, "tr2_sys__Symlink(): test %d errno expect 0xdeadbeef, got %d\n", i+1, errno);
-        todo_wine_if(tests[i].is_todo)
-            ok(ret == tests[i].last_error, "tr2_sys__Symlink(): test %d expect: %d, got %d\n", i+1, tests[i].last_error, ret);
+        ok(ret == tests[i].last_error, "tr2_sys__Symlink(): test %d expect: %d, got %d\n", i+1, tests[i].last_error, ret);
         if(ret == ERROR_SUCCESS)
             ok(p_tr2_sys__File_size(tests[i].new_path) == 0, "tr2_sys__Symlink(): expect 0, got %s\n", wine_dbgstr_longlong(p_tr2_sys__File_size(tests[i].new_path)));
     }
 
     ok(DeleteFileA("f1"), "expect f1 to exist\n");
-    todo_wine ok(DeleteFileA("f1_link"), "expect f1_link to exist\n");
-    todo_wine ok(DeleteFileA("tr2_test_dir/f1_link"), "expect tr2_test_dir/f1_link to exist\n");
-    todo_wine ok(DeleteFileA("tr2_test_dir/f1_link_link"), "expect tr2_test_dir/f1_link_link to exist\n");
-    todo_wine ok(DeleteFileA("not_exist_link"), "expect not_exist_link to exist\n");
-    todo_wine ok(DeleteFileA("dir_link"), "expect dir_link to exist\n");
+    ok(DeleteFileA("f1_link"), "expect f1_link to exist\n");
+    ok(DeleteFileA("tr2_test_dir/f1_link"), "expect tr2_test_dir/f1_link to exist\n");
+    ok(DeleteFileA("tr2_test_dir/f1_link_link"), "expect tr2_test_dir/f1_link_link to exist\n");
+    ok(DeleteFileA("not_exist_link"), "expect not_exist_link to exist\n");
+    ok(DeleteFileA("dir_link"), "expect dir_link to exist\n");
     ret = p_tr2_sys__Remove_dir("tr2_test_dir");
     ok(ret == 1, "tr2_sys__Remove_dir(): expect 1 got %d\n", ret);
 }
@@ -1981,15 +1976,14 @@ static void test_tr2_sys__Unlink(void)
     struct {
         char const *path;
         int last_error;
-        MSVCP_bool is_todo;
     } tests[] = {
-        { "tr2_test_dir\\f1_symlink", ERROR_SUCCESS, TRUE },
-        { "tr2_test_dir\\f1_link", ERROR_SUCCESS, FALSE },
-        { "tr2_test_dir\\f1", ERROR_SUCCESS, FALSE },
-        { "tr2_test_dir", ERROR_ACCESS_DENIED, FALSE },
-        { "not_exist", ERROR_FILE_NOT_FOUND, FALSE },
-        { "not_exist_dir\\not_exist_file", ERROR_PATH_NOT_FOUND, FALSE },
-        { NULL, ERROR_PATH_NOT_FOUND, FALSE }
+        { "tr2_test_dir\\f1_symlink", ERROR_SUCCESS },
+        { "tr2_test_dir\\f1_link", ERROR_SUCCESS },
+        { "tr2_test_dir\\f1", ERROR_SUCCESS },
+        { "tr2_test_dir", ERROR_ACCESS_DENIED },
+        { "not_exist", ERROR_FILE_NOT_FOUND },
+        { "not_exist_dir\\not_exist_file", ERROR_PATH_NOT_FOUND },
+        { NULL, ERROR_PATH_NOT_FOUND }
     };
 
     GetCurrentDirectoryA(MAX_PATH, current_path);
@@ -2018,9 +2012,8 @@ static void test_tr2_sys__Unlink(void)
     for(i=0; i<ARRAY_SIZE(tests); i++) {
         errno = 0xdeadbeef;
         ret = p_tr2_sys__Unlink(tests[i].path);
-        todo_wine_if(tests[i].is_todo)
-            ok(ret == tests[i].last_error, "tr2_sys__Unlink(): test %d expect: %d, got %d\n",
-                    i+1, tests[i].last_error, ret);
+        ok(ret == tests[i].last_error, "tr2_sys__Unlink(): test %d expect: %d, got %d\n",
+           i+1, tests[i].last_error, ret);
         ok(errno == 0xdeadbeef, "tr2_sys__Unlink(): test %d errno expect: 0xdeadbeef, got %d\n", i+1, ret);
     }
 
diff --git a/dlls/msvcp140/tests/msvcp140.c b/dlls/msvcp140/tests/msvcp140.c
index 8966820..4b440ac 100644
--- a/dlls/msvcp140/tests/msvcp140.c
+++ b/dlls/msvcp140/tests/msvcp140.c
@@ -858,16 +858,15 @@ static void test_Stat(void)
         WCHAR const *path;
         enum file_type ret;
         int perms;
-        int is_todo;
     } tests[] = {
-        { NULL, file_not_found, 0xdeadbeef, FALSE },
-        { L"wine_test_dir", directory_file, 0777, FALSE },
-        { L"wine_test_dir/f1", regular_file, 0777, FALSE },
-        { L"wine_test_dir/f2", regular_file, 0555, FALSE },
-        { L"wine_test_dir/ne", file_not_found, 0xdeadbeef, FALSE },
-        { L"wine_test_dir\\??invalid_name>>", file_not_found, 0xdeadbeef, FALSE },
-        { L"wine_test_dir\\f1_link", regular_file, 0777, TRUE },
-        { L"wine_test_dir\\dir_link", directory_file, 0777, TRUE },
+        { NULL, file_not_found, 0xdeadbeef },
+        { L"wine_test_dir", directory_file, 0777 },
+        { L"wine_test_dir/f1", regular_file, 0777 },
+        { L"wine_test_dir/f2", regular_file, 0555 },
+        { L"wine_test_dir/ne", file_not_found, 0xdeadbeef },
+        { L"wine_test_dir\\??invalid_name>>", file_not_found, 0xdeadbeef },
+        { L"wine_test_dir\\f1_link", regular_file, 0777 },
+        { L"wine_test_dir\\dir_link", directory_file, 0777 },
     };
 
     GetCurrentDirectoryW(MAX_PATH, origin_path);
@@ -925,26 +924,20 @@ static void test_Stat(void)
     for(i=0; i<ARRAY_SIZE(tests); i++) {
         perms = 0xdeadbeef;
         val = p_Stat(tests[i].path, &perms);
-        todo_wine_if(tests[i].is_todo) {
-            ok(tests[i].ret == val, "_Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
-            ok(tests[i].perms == perms, "_Stat(): test %d perms expect: 0%o, got 0%o\n",
-                    i+1, tests[i].perms, perms);
-        }
+        ok(tests[i].ret == val, "_Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+        ok(tests[i].perms == perms, "_Stat(): test %d perms expect: 0%o, got 0%o\n",
+                i+1, tests[i].perms, perms);
         val = p_Stat(tests[i].path, NULL);
-        todo_wine_if(tests[i].is_todo)
-            ok(tests[i].ret == val, "_Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+        ok(tests[i].ret == val, "_Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
 
         /* test _Lstat */
         perms = 0xdeadbeef;
         val = p_Lstat(tests[i].path, &perms);
-        todo_wine_if(tests[i].is_todo) {
-            ok(tests[i].ret == val, "_Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
-            ok(tests[i].perms == perms, "_Lstat(): test %d perms expect: 0%o, got 0%o\n",
-                    i+1, tests[i].perms, perms);
-        }
+        ok(tests[i].ret == val, "_Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+        ok(tests[i].perms == perms, "_Lstat(): test %d perms expect: 0%o, got 0%o\n",
+                i+1, tests[i].perms, perms);
         val = p_Lstat(tests[i].path, NULL);
-        todo_wine_if(tests[i].is_todo)
-            ok(tests[i].ret == val, "_Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+        ok(tests[i].ret == val, "_Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
     }
 
     GetSystemDirectoryW(sys_path, MAX_PATH);
@@ -956,9 +949,9 @@ static void test_Stat(void)
     ok(perms == expected_perms, "_Stat(): perms expect: 0%o, got 0%o\n", expected_perms, perms);
 
     if(ret) {
-        todo_wine ok(DeleteFileW(L"wine_test_dir\\f1_link"),
+        ok(DeleteFileW(L"wine_test_dir\\f1_link"),
                 "expect wine_test_dir/f1_link to exist\n");
-        todo_wine ok(RemoveDirectoryW(L"wine_test_dir\\dir_link"),
+        ok(RemoveDirectoryW(L"wine_test_dir\\dir_link"),
                 "expect wine_test_dir/dir_link to exist\n");
     }
     ok(DeleteFileW(L"wine_test_dir/f1"), "expect wine_test_dir/f1 to exist\n");
@@ -1077,15 +1070,14 @@ static void test_Unlink(void)
     struct {
         WCHAR const *path;
         int last_error;
-        MSVCP_bool is_todo;
     } tests[] = {
-        { L"wine_test_dir\\f1_symlink", ERROR_SUCCESS, TRUE },
-        { L"wine_test_dir\\f1_link", ERROR_SUCCESS, FALSE },
-        { L"wine_test_dir\\f1", ERROR_SUCCESS, FALSE },
-        { L"wine_test_dir", ERROR_ACCESS_DENIED, FALSE },
-        { L"not_exist", ERROR_FILE_NOT_FOUND, FALSE },
-        { L"not_exist_dir\\not_exist_file", ERROR_PATH_NOT_FOUND, FALSE },
-        { NULL, ERROR_PATH_NOT_FOUND, FALSE }
+        { L"wine_test_dir\\f1_symlink", ERROR_SUCCESS },
+        { L"wine_test_dir\\f1_link", ERROR_SUCCESS },
+        { L"wine_test_dir\\f1", ERROR_SUCCESS },
+        { L"wine_test_dir", ERROR_ACCESS_DENIED },
+        { L"not_exist", ERROR_FILE_NOT_FOUND },
+        { L"not_exist_dir\\not_exist_file", ERROR_PATH_NOT_FOUND },
+        { NULL, ERROR_PATH_NOT_FOUND }
     };
 
     GetCurrentDirectoryW(MAX_PATH, current_path);
@@ -1114,9 +1106,8 @@ static void test_Unlink(void)
     for(i=0; i<ARRAY_SIZE(tests); i++) {
         errno = 0xdeadbeef;
         ret = p_Unlink(tests[i].path);
-        todo_wine_if(tests[i].is_todo)
-            ok(ret == tests[i].last_error, "_Unlink(): test %d expect: %d, got %d\n",
-                    i+1, tests[i].last_error, ret);
+        ok(ret == tests[i].last_error, "_Unlink(): test %d expect: %d, got %d\n",
+           i+1, tests[i].last_error, ret);
         ok(errno == 0xdeadbeef, "_Unlink(): test %d errno expect: 0xdeadbeef, got %d\n", i+1, ret);
     }
 
diff --git a/dlls/msxml3/Makefile.in b/dlls/msxml3/Makefile.in
index 7e59a22..5044c4e 100644
--- a/dlls/msxml3/Makefile.in
+++ b/dlls/msxml3/Makefile.in
@@ -1,5 +1,5 @@
 MODULE    = msxml3.dll
-IMPORTS   = $(XSLT_PE_LIBS) $(XML2_PE_LIBS) uuid urlmon shlwapi oleaut32 ole32 user32 advapi32
+IMPORTS   = $(XSLT_PE_LIBS) $(XML2_PE_LIBS) uuid urlmon shlwapi oleaut32 ole32 user32 advapi32 rtworkq
 EXTRAINCL = $(XSLT_PE_CFLAGS) $(XML2_PE_CFLAGS)
 
 SOURCES = \
diff --git a/dlls/msxml3/factory.c b/dlls/msxml3/factory.c
index c2d3cd3..323c7b4 100644
--- a/dlls/msxml3/factory.c
+++ b/dlls/msxml3/factory.c
@@ -31,6 +31,7 @@
 #include "ole2.h"
 #include "msxml.h"
 #include "msxml2.h"
+#include "msxml6.h"
 #include "xmlparser.h"
 
 /* undef the #define in msxml2 so that we can access the v.2 version
@@ -278,6 +279,7 @@ static HRESULT DOMClassFactory_Create(const GUID *clsid, REFIID riid, void **ppv
 
 static ClassFactory xmldoccf = { { &ClassFactoryVtbl }, XMLDocument_create };
 static ClassFactory httpreqcf = { { &ClassFactoryVtbl }, XMLHTTPRequest_create };
+static ClassFactory httpreqcf2 = { { &ClassFactoryVtbl }, XMLHTTPRequest2_create };
 static ClassFactory serverhttp = { { &ClassFactoryVtbl }, ServerXMLHTTP_create };
 static ClassFactory xsltemplatecf = { { &ClassFactoryVtbl }, XSLTemplate_create };
 static ClassFactory mxnsmanagercf = { {&ClassFactoryVtbl }, MXNamespaceManager_create };
@@ -339,6 +341,10 @@ HRESULT WINAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, void **ppv )
     {
         cf = &httpreqcf.IClassFactory_iface;
     }
+    else if( IsEqualCLSID( rclsid, &CLSID_FreeThreadedXMLHTTP60 ))
+    {
+        cf = &httpreqcf2.IClassFactory_iface;
+    }
     else if( IsEqualCLSID( rclsid, &CLSID_ServerXMLHTTP ) ||
              IsEqualCLSID( rclsid, &CLSID_ServerXMLHTTP30 ) ||
              IsEqualCLSID( rclsid, &CLSID_ServerXMLHTTP40 ) ||
diff --git a/dlls/msxml3/httprequest.c b/dlls/msxml3/httprequest.c
index e21ece7..f63284e 100644
--- a/dlls/msxml3/httprequest.c
+++ b/dlls/msxml3/httprequest.c
@@ -37,10 +37,12 @@
 #include "shlwapi.h"
 
 #include "msxml_dispex.h"
+#include "initguid.h"
+#include "rtworkq.h"
 
 #include "wine/debug.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(msxml);
+WINE_DEFAULT_DEBUG_CHANNEL(xmlhttp);
 
 static const WCHAR colspaceW[] = {':',' ',0};
 static const WCHAR crlfW[] = {'\r','\n',0};
@@ -99,6 +101,21 @@ typedef struct
 
     /* IObjectSafety */
     DWORD safeopt;
+
+    /* Properties */
+    DWORD no_prompt;
+    DWORD no_auth;
+    DWORD timeout;
+    BOOL no_headeres;
+    BOOL redirect;
+    BOOL cache;
+    BOOL extended;
+    BOOL query_utf8;
+    BOOL ignore_errors;
+    BOOL threshold;
+    DWORD enterrprised_id;
+    DWORD max_connections;
+
 } httprequest;
 
 typedef struct
@@ -2054,6 +2071,553 @@ static const struct IServerXMLHTTPRequestVtbl ServerXMLHTTPRequestVtbl =
     ServerXMLHTTPRequest_setOption
 };
 
+static DWORD xhr2_work_queue;
+
+struct xml_http_request_2
+{
+    httprequest req;
+    IXMLHTTPRequest3 IXMLHTTPRequest3_iface;
+    IRtwqAsyncCallback IRtwqAsyncCallback_iface;
+    IDispatch IDispatch_iface;
+
+    IXMLHTTPRequest2Callback *callback;
+    IXMLHTTPRequest3Callback *callback3;
+    ISequentialStream *response_body;
+    ISequentialStream *request_body;
+    ULONGLONG request_body_size;
+};
+
+static inline struct xml_http_request_2 *impl_from_IXMLHTTPRequest3(IXMLHTTPRequest3 *iface)
+{
+    return CONTAINING_RECORD(iface, struct xml_http_request_2, IXMLHTTPRequest3_iface);
+}
+
+static inline struct xml_http_request_2 *xml_http_request_2_from_IRtwqAsyncCallback(IRtwqAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct xml_http_request_2, IRtwqAsyncCallback_iface);
+}
+
+static inline struct xml_http_request_2 *xml_http_request_2_from_IDispatch(IDispatch *iface)
+{
+    return CONTAINING_RECORD(iface, struct xml_http_request_2, IDispatch_iface);
+}
+
+static HRESULT WINAPI xml_http_request_2_QueryInterface(IXMLHTTPRequest3 *iface, REFIID riid, void **obj)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IXMLHTTPRequest3) || IsEqualGUID(riid, &IID_IXMLHTTPRequest2)
+        || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IUnknown_AddRef((IUnknown*)*obj);
+        return S_OK;
+    }
+
+    FIXME("Unsupported interface %s\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xml_http_request_2_AddRef(IXMLHTTPRequest3 *iface)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    ULONG ref = InterlockedIncrement(&This->req.ref);
+    TRACE("(%p)->(%lu)\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI xml_http_request_2_Release(IXMLHTTPRequest3 *iface)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    ULONG ref = InterlockedDecrement(&This->req.ref);
+
+    TRACE("(%p)->(%lu)\n", This, ref);
+
+    if (ref == 0)
+    {
+        /* do not call httprequest_put_onreadystatechange to avoid ref cycle */
+        This->req.sink = NULL;
+        if (This->response_body) ISequentialStream_Release(This->response_body);
+        if (This->request_body) ISequentialStream_Release(This->request_body);
+        if (This->callback3) IXMLHTTPRequest3Callback_Release(This->callback3);
+        if (This->callback) IXMLHTTPRequest2Callback_Release(This->callback);
+        heap_free(This);
+        RtwqShutdown();
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI xml_http_request_2_Open(IXMLHTTPRequest3 *iface, const WCHAR *method,
+                                              const WCHAR *url, IXMLHTTPRequest2Callback *callback,
+                                              const WCHAR *username, const WCHAR *password,
+                                              const WCHAR *proxy_username, const WCHAR *proxy_password)
+{
+    static const WCHAR accept_encoding[] = {'A','c','c','e','p','t','-','E','n','c','o','d','i','n','g',0};
+    static const WCHAR empty = 0;
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    VARIANT async_v, username_v, password_v;
+    HRESULT hr;
+
+    TRACE("(%p)->(%s %s %p %s %s %s %s)\n", This, debugstr_w(method), debugstr_w(url), callback,
+          debugstr_w(username), debugstr_w(password), debugstr_w(proxy_username), debugstr_w(proxy_password));
+
+    if (This->callback) IXMLHTTPRequest2Callback_Release(This->callback);
+    if (This->callback3) IXMLHTTPRequest3Callback_Release(This->callback3);
+    IXMLHTTPRequest2Callback_AddRef(callback);
+    This->callback = callback;
+    if (FAILED(IXMLHTTPRequest2Callback_QueryInterface(callback, &IID_IXMLHTTPRequest3Callback, (void **)&This->callback3)))
+        This->callback3 = NULL;
+
+    if (proxy_username || proxy_password) FIXME("proxy credentials not implemented\n");
+
+    VariantInit(&async_v);
+    V_VT(&async_v) = VT_BOOL;
+    V_BOOL(&async_v) = FALSE; /* FIXME: TRUE needs a RTWQ_WINDOW_WORKQUEUE */
+
+    VariantInit(&username_v);
+    V_VT(&username_v) = VT_BSTR;
+    if (username) V_BSTR(&username_v) = SysAllocString(username);
+    else V_BSTR(&username_v) = SysAllocString(&empty);
+
+    VariantInit(&password_v);
+    V_VT(&password_v) = VT_BSTR;
+    if (password) V_BSTR(&password_v) = SysAllocString(password);
+    else V_BSTR(&password_v) = SysAllocString(&empty);
+
+    if (FAILED(hr = httprequest_open(&This->req, (BSTR)method, (BSTR)url, async_v, username_v, password_v)))
+        return hr;
+    return httprequest_setRequestHeader(&This->req, (BSTR)accept_encoding, (BSTR)&empty);
+}
+
+static HRESULT WINAPI xml_http_request_2_Send(IXMLHTTPRequest3 *iface, ISequentialStream *body, ULONGLONG body_size)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    IRtwqAsyncResult *result;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p %s)\n", This, body, wine_dbgstr_longlong( body_size ));
+
+    if (body_size)
+    {
+        ISequentialStream_AddRef(body);
+        This->request_body = body;
+        This->request_body_size = body_size;
+    }
+
+    if (FAILED(hr = RtwqCreateAsyncResult(NULL, &This->IRtwqAsyncCallback_iface, NULL, &result)))
+        return hr;
+    // IRtwqAsyncCallback_Invoke(&This->IRtwqAsyncCallback_iface, result);
+    hr = RtwqPutWorkItem(xhr2_work_queue, 0, result);
+    if (result) IRtwqAsyncResult_Release(result);
+
+    return hr;
+}
+
+static HRESULT WINAPI xml_http_request_2_Abort(IXMLHTTPRequest3 *iface)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    TRACE("(%p) stub!\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_SetCookie(IXMLHTTPRequest3 *iface, const XHR_COOKIE *cookie, DWORD *state)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%p %p) stub!\n", This, cookie, state);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_SetCustomResponseStream(IXMLHTTPRequest3 *iface, ISequentialStream *stream)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%p) stub!\n", This, stream);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_SetProperty(IXMLHTTPRequest3 *iface, XHR_PROPERTY property, ULONGLONG value)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+
+    TRACE("(%p)->(%#x %s) stub!\n", This, property, wine_dbgstr_longlong( value ));
+
+    switch (property)
+    {
+        case XHR_PROP_NO_CRED_PROMPT:
+            This->req.no_prompt = value;
+            break;
+        case XHR_PROP_NO_AUTH:
+            This->req.no_auth = value;
+            break;
+        case XHR_PROP_TIMEOUT:
+            This->req.timeout = value;
+            break;
+        case XHR_PROP_NO_DEFAULT_HEADERS:
+            This->req.no_headeres = value != 0;
+            break;
+        case XHR_PROP_REPORT_REDIRECT_STATUS:
+            This->req.redirect = value != 0;
+            break;
+        case XHR_PROP_NO_CACHE:
+            This->req.cache = value != 0;
+            break;
+        case XHR_PROP_EXTENDED_ERROR:
+            This->req.extended = value != 0;
+            break;
+        case XHR_PROP_QUERY_STRING_UTF8:
+            This->req.query_utf8 = value != 0;
+            break;
+        case XHR_PROP_IGNORE_CERT_ERRORS:
+            This->req.ignore_errors = value != 0;
+            break;
+        case XHR_PROP_ONDATA_THRESHOLD:
+            This->req.threshold = value;
+            break;
+        case XHR_PROP_SET_ENTERPRISEID:
+            This->req.enterrprised_id = value;
+            break;
+        case XHR_PROP_MAX_CONNECTIONS:
+            This->req.max_connections = value;
+            break;
+        default:
+            WARN("Invalid property %#x\n", property);
+            return E_INVALIDARG;
+    }
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_SetRequestHeader(IXMLHTTPRequest3 *iface,
+                                                          const WCHAR *header, const WCHAR *value)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    TRACE("(%p)->(%s %s)\n", This, debugstr_w(header), debugstr_w(value));
+    return httprequest_setRequestHeader(&This->req, (BSTR)header, (BSTR)value);
+}
+
+static HRESULT WINAPI xml_http_request_2_GetAllResponseHeaders(IXMLHTTPRequest3 *iface, WCHAR **headers)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%p) stub!\n", This, headers);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_GetCookie(IXMLHTTPRequest3 *iface, const WCHAR *url,
+                                                   const WCHAR *name, DWORD flags,
+                                                   ULONG *cookies_count, XHR_COOKIE **cookies)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%s %s %ld %p %p) stub!\n", This, debugstr_w(url), debugstr_w(name), flags, cookies_count, cookies);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI xml_http_request_2_GetResponseHeader(IXMLHTTPRequest3 *iface,
+                                                           const WCHAR *header, WCHAR **value)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_w(header), value);
+
+    hr = httprequest_getResponseHeader(&This->req, (BSTR)header, value);
+
+#define E_FILE_NOT_FOUND                                   _HRESULT_TYPEDEF_(0x80070002)
+
+    if (hr == S_FALSE)
+    {
+        *value = NULL;
+        return E_FILE_NOT_FOUND;
+    }
+
+    return hr;
+}
+
+static HRESULT WINAPI xml_http_request_3_SetClientCertificate(IXMLHTTPRequest3 *iface, DWORD count, const BYTE *hashes, const WCHAR *pin)
+{
+    struct xml_http_request_2 *This = impl_from_IXMLHTTPRequest3(iface);
+    FIXME("(%p)->(%ld %p %s) stub!\n", This, count, hashes, debugstr_w(pin));
+    return E_NOTIMPL;
+}
+
+static const struct IXMLHTTPRequest3Vtbl XMLHTTPRequest3Vtbl = {
+    /* IUnknown methods */
+    xml_http_request_2_QueryInterface,
+    xml_http_request_2_AddRef,
+    xml_http_request_2_Release,
+    /* IXMLHTTPRequest2 methods */
+    xml_http_request_2_Open,
+    xml_http_request_2_Send,
+    xml_http_request_2_Abort,
+    xml_http_request_2_SetCookie,
+    xml_http_request_2_SetCustomResponseStream,
+    xml_http_request_2_SetProperty,
+    xml_http_request_2_SetRequestHeader,
+    xml_http_request_2_GetAllResponseHeaders,
+    xml_http_request_2_GetCookie,
+    xml_http_request_2_GetResponseHeader,
+    /* IXMLHTTPRequest3 methods */
+    xml_http_request_3_SetClientCertificate,
+};
+
+static HRESULT WINAPI xml_http_request_2_IRtwqAsyncCallback_QueryInterface(IRtwqAsyncCallback *iface, REFIID riid, void **obj)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IRtwqAsyncCallback) || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IRtwqAsyncCallback_AddRef(iface);
+        *obj = iface;
+        return S_OK;
+    }
+
+    FIXME("Unsupported interface %s\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xml_http_request_2_IRtwqAsyncCallback_AddRef(IRtwqAsyncCallback *iface)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+    TRACE("(%p)\n", This);
+    return xml_http_request_2_AddRef(&This->IXMLHTTPRequest3_iface);
+}
+
+static ULONG WINAPI xml_http_request_2_IRtwqAsyncCallback_Release(IRtwqAsyncCallback *iface)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+    TRACE("(%p)\n", This);
+    return xml_http_request_2_Release(&This->IXMLHTTPRequest3_iface);
+}
+
+static HRESULT WINAPI xml_http_request_2_IRtwqAsyncCallback_GetParameters(IRtwqAsyncCallback *iface,
+        DWORD *flags, DWORD *queue)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+
+    TRACE("(%p)->(%p %p)\n", This, flags, queue);
+
+    *flags = 0;
+    *queue = xhr2_work_queue;
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_IRtwqAsyncCallback_Invoke(IRtwqAsyncCallback *iface,
+        IRtwqAsyncResult *result)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IRtwqAsyncCallback(iface);
+    IStream *stream = NULL;
+    SAFEARRAY *sa = NULL;
+    VARIANT body_v;
+    HRESULT hr;
+    ULONG read;
+
+    TRACE("(%p)->(%p)\n", This, result);
+
+    VariantInit(&body_v);
+
+    if (This->request_body)
+    {
+        SAFEARRAYBOUND bound;
+        ULONGLONG body_size;
+        STATSTG stream_stat;
+        LARGE_INTEGER li;
+        void *ptr;
+
+        if (SUCCEEDED(ISequentialStream_QueryInterface(This->request_body, &IID_IStream, (void **)&stream))
+                && SUCCEEDED(IStream_Stat(stream, &stream_stat, 0)))
+        {
+            body_size = stream_stat.cbSize.QuadPart;
+            li.QuadPart = 0;
+            IStream_Seek(stream, li, STREAM_SEEK_SET, NULL);
+        }
+        else
+        {
+            body_size = This->request_body_size;
+        }
+
+        TRACE("body_size %I64u.\n", body_size);
+
+        bound.lLbound = 0;
+        bound.cElements = body_size;
+        if (!(sa = SafeArrayCreate(VT_UI1, 1, &bound)))
+        {
+            ERR("No memory.\n");
+            hr = E_OUTOFMEMORY;
+            goto done;
+        }
+        V_ARRAY(&body_v) = sa;
+        V_VT(&body_v) = VT_ARRAY | VT_UI1;
+        SafeArrayAccessData(sa, &ptr);
+
+        if (stream)
+            hr = IStream_Read(stream, ptr, body_size, &read);
+        else
+            hr = ISequentialStream_Read(This->request_body, ptr, body_size, &read);
+        SafeArrayUnaccessData(sa);
+        if (FAILED(hr) || read < body_size)
+        {
+            /* Windows doesn't send the body in this case but still sends request with Content-Length
+             * set to requested body size. */
+            ERR("Failed to read from stream, hr %#lx, read %lu\n", hr, read);
+            SafeArrayDestroy(sa);
+            sa = NULL;
+            V_VT(&body_v) = VT_NULL;
+        }
+
+        ISequentialStream_Release(This->request_body);
+        This->request_body = NULL;
+    }
+
+    hr = httprequest_send(&This->req, body_v);
+
+done:
+    if (sa)
+        SafeArrayDestroy(sa);
+    if (stream)
+        IStream_Release(stream);
+    return IRtwqAsyncResult_SetStatus(result, hr);
+}
+
+static const struct IRtwqAsyncCallbackVtbl xml_http_request_2_IRtwqAsyncCallbackVtbl = {
+    /* IUnknown methods */
+    xml_http_request_2_IRtwqAsyncCallback_QueryInterface,
+    xml_http_request_2_IRtwqAsyncCallback_AddRef,
+    xml_http_request_2_IRtwqAsyncCallback_Release,
+    /* IRtwqAsyncCallback methods */
+    xml_http_request_2_IRtwqAsyncCallback_GetParameters,
+    xml_http_request_2_IRtwqAsyncCallback_Invoke,
+};
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_QueryInterface(IDispatch *iface, REFIID riid, void **obj)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IDispatch) || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IDispatch_AddRef(iface);
+        *obj = iface;
+        return S_OK;
+    }
+
+    FIXME("Unsupported interface %s\n", debugstr_guid(riid));
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xml_http_request_2_IDispatch_AddRef(IDispatch *iface)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    TRACE("(%p)\n", This);
+    return xml_http_request_2_AddRef(&This->IXMLHTTPRequest3_iface);
+}
+
+static ULONG WINAPI xml_http_request_2_IDispatch_Release(IDispatch *iface)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    TRACE("(%p)\n", This);
+    return xml_http_request_2_Release(&This->IXMLHTTPRequest3_iface);
+}
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_GetTypeInfoCount(IDispatch *iface, UINT *value)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    FIXME("(%p)->(%p) stub!\n", This, value);
+    *value = 0;
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_GetTypeInfo(IDispatch *iface, UINT index,
+                                                               LCID lcid, ITypeInfo **value)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    FIXME("(%p)->(%d %lu %p) stub!\n", This, index, lcid, value);
+    *value = NULL;
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_GetIDsOfNames(IDispatch *iface, REFIID riid,
+                                                                 OLECHAR **names, UINT names_count,
+                                                                 LCID lcid, DISPID *disp_ids)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    FIXME("(%p)->(%s %p %d %lu %p) stub!\n", This, debugstr_guid(riid), names, names_count, lcid, disp_ids);
+    return S_OK;
+}
+
+static HRESULT WINAPI xml_http_request_2_IDispatch_Invoke(IDispatch *iface, DISPID id, REFIID riid,
+                                                          LCID lcid, WORD flags, DISPPARAMS *params,
+                                                          VARIANT *result, EXCEPINFO *exception, UINT *arg_err)
+{
+    struct xml_http_request_2 *This = xml_http_request_2_from_IDispatch(iface);
+    IXMLHTTPRequest2 *xhr2_iface = (IXMLHTTPRequest2*)&This->IXMLHTTPRequest3_iface;
+    HRESULT hr;
+    LONG status;
+    BSTR status_str = NULL;
+
+    TRACE("(%p)->(%ld %s %lu %d %p %p %p %p) stub!\n", This, id, debugstr_guid(riid), lcid, flags,
+          params, result, exception, arg_err);
+
+    if (This->req.state == READYSTATE_COMPLETE)
+    {
+        VARIANT body_v;
+        VariantInit(&body_v);
+
+        IXMLHTTPRequest2Callback_AddRef(This->callback);
+        if (This->callback3)
+        {
+            IXMLHTTPRequest3Callback_AddRef(This->callback3);
+            IXMLHTTPRequest3Callback_OnServerCertificateReceived(This->callback3, (IXMLHTTPRequest3 *)xhr2_iface, 0, 1, NULL);
+            IXMLHTTPRequest3Callback_Release(This->callback3);
+        }
+
+        if (FAILED(hr = httprequest_get_status(&This->req, &status)) ||
+            FAILED(hr = httprequest_get_statusText(&This->req, &status_str)))
+        {
+            WARN("failed to get response status, error %#lx\n", hr);
+            IXMLHTTPRequest2Callback_OnError(This->callback, xhr2_iface, hr);
+            IXMLHTTPRequest2Callback_Release(This->callback);
+            return S_OK;
+        }
+
+        IXMLHTTPRequest2Callback_OnHeadersAvailable(This->callback, xhr2_iface, status, status_str);
+        SysFreeString(status_str);
+
+        if (This->response_body) ISequentialStream_Release(This->response_body);
+        This->response_body = NULL;
+
+        if (FAILED(hr = httprequest_get_responseStream(&This->req, &body_v)) ||
+            FAILED(hr = IUnknown_QueryInterface(V_UNKNOWN(&body_v), &IID_ISequentialStream, (void **)&This->response_body)))
+        {
+            WARN("failed to get response stream, error %#lx\n", hr);
+            IXMLHTTPRequest2Callback_OnError(This->callback, xhr2_iface, hr);
+            IXMLHTTPRequest2Callback_Release(This->callback);
+            return S_OK;
+        }
+
+        IXMLHTTPRequest2Callback_OnDataAvailable(This->callback, xhr2_iface, This->response_body);
+        IXMLHTTPRequest2Callback_OnResponseReceived(This->callback, xhr2_iface, This->response_body);
+        IXMLHTTPRequest2Callback_Release(This->callback);
+    }
+
+    return S_OK;
+}
+
+static const struct IDispatchVtbl xml_http_request_2_IDispatchVtbl = {
+    /* IUnknown methods */
+    xml_http_request_2_IDispatch_QueryInterface,
+    xml_http_request_2_IDispatch_AddRef,
+    xml_http_request_2_IDispatch_Release,
+    /* IDispatch methods */
+    xml_http_request_2_IDispatch_GetTypeInfoCount,
+    xml_http_request_2_IDispatch_GetTypeInfo,
+    xml_http_request_2_IDispatch_GetIDsOfNames,
+    xml_http_request_2_IDispatch_Invoke,
+};
+
 static void init_httprequest(httprequest *req)
 {
     req->IXMLHTTPRequest_iface.lpVtbl = &XMLHTTPRequestVtbl;
@@ -2083,6 +2647,20 @@ static void init_httprequest(httprequest *req)
 
     req->site = NULL;
     req->safeopt = 0;
+
+    /* Properties */
+    req->no_prompt = XHR_CRED_PROMPT_ALL;
+    req->no_auth = XHR_AUTH_ALL;
+    req->timeout = 0xFFFFFFFF;
+    req->no_headeres = FALSE;
+    req->redirect = FALSE;
+    req->cache = FALSE;
+    req->extended = FALSE;
+    req->query_utf8 = FALSE;;
+    req->ignore_errors = FALSE;;
+    req->threshold = 0x100;
+    req->enterrprised_id = 0;
+    req->max_connections = 10;
 }
 
 HRESULT XMLHTTPRequest_create(void **obj)
@@ -2103,6 +2681,35 @@ HRESULT XMLHTTPRequest_create(void **obj)
     return S_OK;
 }
 
+HRESULT XMLHTTPRequest2_create(void **obj)
+{
+    struct xml_http_request_2 *xhr2;
+    TRACE("(%p)\n", obj);
+
+    if (!(xhr2 = heap_alloc(sizeof(*xhr2)))) return E_OUTOFMEMORY;
+
+    init_httprequest(&xhr2->req);
+    xhr2->IXMLHTTPRequest3_iface.lpVtbl = &XMLHTTPRequest3Vtbl;
+    xhr2->IRtwqAsyncCallback_iface.lpVtbl = &xml_http_request_2_IRtwqAsyncCallbackVtbl;
+    xhr2->IDispatch_iface.lpVtbl = &xml_http_request_2_IDispatchVtbl;
+
+    /* do not call httprequest_put_onreadystatechange to avoid ref cycle */
+    xhr2->req.sink = &xhr2->IDispatch_iface;
+
+    xhr2->callback = NULL;
+    xhr2->callback3 = NULL;
+    xhr2->request_body = NULL;
+    xhr2->response_body = NULL;
+
+    /* for async http requests we need window message queue */
+    RtwqStartup();
+    if (!xhr2_work_queue) RtwqAllocateWorkQueue(RTWQ_MULTITHREADED_WORKQUEUE, &xhr2_work_queue);
+
+    *obj = &xhr2->IXMLHTTPRequest3_iface;
+    TRACE("returning iface %p\n", *obj);
+    return S_OK;
+}
+
 HRESULT ServerXMLHTTP_create(void **obj)
 {
     serverhttp *req;
diff --git a/dlls/msxml3/msxml_private.h b/dlls/msxml3/msxml_private.h
index 449a86d..3e5181f 100644
--- a/dlls/msxml3/msxml_private.h
+++ b/dlls/msxml3/msxml_private.h
@@ -344,6 +344,7 @@ extern HRESULT XMLDocument_create(void**);
 extern HRESULT SAXXMLReader_create(MSXML_VERSION, void**);
 extern HRESULT SAXAttributes_create(MSXML_VERSION, void**);
 extern HRESULT XMLHTTPRequest_create(void **);
+extern HRESULT XMLHTTPRequest2_create(void **);
 extern HRESULT ServerXMLHTTP_create(void **);
 extern HRESULT XSLTemplate_create(void**);
 extern HRESULT MXWriter_create(MSXML_VERSION, void**);
diff --git a/dlls/msxml3/mxwriter.c b/dlls/msxml3/mxwriter.c
index 4a2844b..8caf897 100644
--- a/dlls/msxml3/mxwriter.c
+++ b/dlls/msxml3/mxwriter.c
@@ -189,6 +189,7 @@ typedef struct
     BSTR element;
 
     IStream *dest;
+    IXMLDOMDocument *dest_doc;
 
     output_buffer buffer;
 } mxwriter;
@@ -850,6 +851,7 @@ static ULONG WINAPI mxwriter_Release(IMXWriter *iface)
         free_output_buffer(&This->buffer);
 
         if (This->dest) IStream_Release(This->dest);
+        if (This->dest_doc) IXMLDOMDocument_Release(This->dest_doc);
         SysFreeString(This->version);
         SysFreeString(This->encoding);
 
@@ -914,6 +916,8 @@ static HRESULT WINAPI mxwriter_put_output(IMXWriter *iface, VARIANT dest)
     {
         if (This->dest) IStream_Release(This->dest);
         This->dest = NULL;
+        if (This->dest_doc) IXMLDOMDocument_Release(This->dest_doc);
+        This->dest_doc = NULL;
         close_output_buffer(This);
         break;
     }
@@ -929,12 +933,33 @@ static HRESULT WINAPI mxwriter_put_output(IMXWriter *iface, VARIANT dest)
 
             if (This->dest) IStream_Release(This->dest);
             This->dest = stream;
+            if (This->dest_doc) IXMLDOMDocument_Release(This->dest_doc);
+            This->dest_doc = NULL;
             break;
         }
 
         FIXME("unhandled interface type for VT_UNKNOWN destination\n");
         return E_NOTIMPL;
     }
+    case VT_DISPATCH:
+    {
+        IXMLDOMDocument *doc;
+
+        hr = IDispatch_QueryInterface(V_DISPATCH(&dest), &IID_IXMLDOMDocument, (void**)&doc);
+        if (hr == S_OK)
+        {
+            close_output_buffer(This);
+
+            if (This->dest) IStream_Release(This->dest);
+            This->dest = NULL;
+            if (This->dest_doc) IXMLDOMDocument_Release(This->dest_doc);
+            This->dest_doc = doc;
+            break;
+        }
+
+        FIXME("unhandled interface type for VT_DISPATCH destination\n");
+        return E_NOTIMPL;
+    }
     default:
         FIXME("unhandled destination type %s\n", debugstr_variant(&dest));
         return E_NOTIMPL;
@@ -1201,7 +1226,7 @@ static HRESULT WINAPI SAXContentHandler_putDocumentLocator(
 {
     mxwriter *This = impl_from_ISAXContentHandler( iface );
     FIXME("(%p)->(%p)\n", This, locator);
-    return E_NOTIMPL;
+    return S_OK;
 }
 
 static HRESULT WINAPI SAXContentHandler_startDocument(ISAXContentHandler *iface)
@@ -1239,10 +1264,21 @@ static HRESULT WINAPI SAXContentHandler_startDocument(ISAXContentHandler *iface)
 
 static HRESULT WINAPI SAXContentHandler_endDocument(ISAXContentHandler *iface)
 {
+    HRESULT hr;
+    VARIANT dest;
+    VARIANT_BOOL success;
     mxwriter *This = impl_from_ISAXContentHandler( iface );
     TRACE("(%p)\n", This);
     This->prop_changed = FALSE;
-    return flush_output_buffer(This);
+
+    hr = flush_output_buffer(This);
+    if (FAILED(hr)) return hr;
+
+    if (This->dest_doc) {
+        mxwriter_get_output(&This->IMXWriter_iface, &dest);
+        return IXMLDOMDocument_loadXML(This->dest_doc, V_BSTR(&dest), &success);
+    }
+    return S_OK;
 }
 
 static HRESULT WINAPI SAXContentHandler_startPrefixMapping(
@@ -2630,6 +2666,7 @@ HRESULT MXWriter_create(MSXML_VERSION version, void **ppObj)
     This->newline = FALSE;
 
     This->dest = NULL;
+    This->dest_doc = NULL;
 
     hr = init_output_buffer(This->xml_enc, &This->buffer);
     if (hr != S_OK) {
diff --git a/dlls/msxml3/schema.c b/dlls/msxml3/schema.c
index 3760019..89959d4 100644
--- a/dlls/msxml3/schema.c
+++ b/dlls/msxml3/schema.c
@@ -794,7 +794,7 @@ static inline schema_cache* impl_from_IXMLDOMSchemaCollection2(IXMLDOMSchemaColl
 
 static inline schema_cache* impl_from_IXMLDOMSchemaCollection(IXMLDOMSchemaCollection* iface)
 {
-    return CONTAINING_RECORD(iface, schema_cache, IXMLDOMSchemaCollection2_iface);
+    return CONTAINING_RECORD((IXMLDOMSchemaCollection2 *)iface, schema_cache, IXMLDOMSchemaCollection2_iface);
 }
 
 static inline schema_cache* unsafe_impl_from_IXMLDOMSchemaCollection(IXMLDOMSchemaCollection *iface)
diff --git a/dlls/msxml3/tests/httpreq.c b/dlls/msxml3/tests/httpreq.c
index bccfbaf..23d7680 100644
--- a/dlls/msxml3/tests/httpreq.c
+++ b/dlls/msxml3/tests/httpreq.c
@@ -26,9 +26,9 @@
 #include <assert.h>
 
 #include "windows.h"
-
 #include "msxml2.h"
-#include "msxml2did.h"
+#include "msxml6.h"
+#include "msxml6did.h"
 #include "dispex.h"
 
 #include "initguid.h"
@@ -1344,6 +1344,17 @@ static IXMLHttpRequest *create_xhr(void)
     return SUCCEEDED(hr) ? ret : NULL;
 }
 
+static IXMLHTTPRequest2 *create_xhr2(void)
+{
+    IXMLHTTPRequest2 *ret;
+    HRESULT hr;
+
+    hr = CoCreateInstance(&CLSID_FreeThreadedXMLHTTP60, NULL, CLSCTX_INPROC_SERVER,
+        &IID_IXMLHTTPRequest2, (void**)&ret);
+
+    return SUCCEEDED(hr) ? ret : NULL;
+}
+
 static IServerXMLHTTPRequest *create_server_xhr(void)
 {
     IServerXMLHTTPRequest *ret;
@@ -1904,11 +1915,388 @@ static void test_supporterrorinfo(void)
     IServerXMLHTTPRequest_Release(server_xhr);
 }
 
+struct xhr3_callback
+{
+    IXMLHTTPRequest3Callback IXMLHTTPRequest3Callback_iface;
+    LONG ref;
+    HANDLE event;
+};
+
+static inline struct xhr3_callback *xhr3_callback_from_IXMLHTTPRequest3Callback(IXMLHTTPRequest3Callback *iface)
+{
+    return CONTAINING_RECORD(iface, struct xhr3_callback, IXMLHTTPRequest3Callback_iface);
+}
+
+static HRESULT WINAPI xhr3_callback_QueryInterface(IXMLHTTPRequest3Callback *iface, REFIID riid, void **obj)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IXMLHTTPRequest3Callback) || IsEqualGUID(riid, &IID_IXMLHTTPRequest2Callback) || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IXMLHTTPRequest3Callback_AddRef(iface);
+        *obj = iface;
+        return S_OK;
+    }
+
+    ok(0, "unexpected interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xhr3_callback_AddRef(IXMLHTTPRequest3Callback *iface)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    trace("(%p)->(%lu)\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI xhr3_callback_Release(IXMLHTTPRequest3Callback *iface)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    trace("(%p)->(%lu)\n", This, ref);
+    if (ref == 0) HeapFree(GetProcessHeap(), 0, This);
+    return ref;
+}
+
+static HRESULT WINAPI xhr3_callback_OnRedirect(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, const WCHAR* redirect_url)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %s)\n", This, request, debugstr_w(redirect_url));
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnHeadersAvailable(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, DWORD status, const WCHAR *status_str)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    WCHAR *header = NULL;
+    HRESULT hr;
+
+    trace("(%p)->(%p %lu %s)\n", This, request, status, debugstr_w(status_str));
+
+    header = (void *)0xdeadbeef;
+    hr = IXMLHTTPRequest2_GetResponseHeader(request, L"Content-Length", &header);
+    trace("Content-Length: %p (%s), hr %#lx\n", header, debugstr_w(header), hr);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnDataAvailable(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, ISequentialStream *response)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %p)\n", This, request, response);
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnResponseReceived(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, ISequentialStream *response)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    WCHAR *header = NULL;
+    char *buffer = HeapAlloc( GetProcessHeap(), 0, 256 );
+    ULONG read_size = 0;
+    HRESULT hr;
+
+    memset(buffer, '?', 256);
+    buffer[255] = 0;
+
+    trace("(%p)->(%p %p)\n", This, request, response);
+
+    header = (void *)0xdeadbeef;
+    hr = IXMLHTTPRequest2_GetResponseHeader(request, L"Cache-Control", &header);
+    trace("Cache-Control: %p (%s), hr %#lx\n", header, debugstr_w(header), hr);
+
+    header = (void *)0xdeadbeef;
+    hr = IXMLHTTPRequest2_GetResponseHeader(request, L"Expires", &header);
+    trace("Expires: %p (%s), hr %#lx\n", header, debugstr_w(header), hr);
+
+    header = (void *)0xdeadbeef;
+    hr = IXMLHTTPRequest2_GetResponseHeader(request, L"Content-Type", &header);
+    trace("Content-Type: %p (%s), hr %#lx\n", header, debugstr_w(header), hr);
+
+    read_size = 0xdeadbeef;
+    hr = ISequentialStream_Read(response, buffer, 214, &read_size);
+    trace("Response: (%ld) %s, hr %#lx\n", read_size, debugstr_a(buffer), hr);
+
+    read_size = 0xdeadbeef;
+    hr = ISequentialStream_Read(response, buffer, 1, &read_size);
+    trace("Response: (%ld) %s, hr %#lx\n", read_size, debugstr_a(buffer), hr);
+
+    HeapFree( GetProcessHeap(), 0, buffer );
+    SetEvent(This->event);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnError(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest2 *request, HRESULT error)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %#lx)\n", This, request, error);
+    SetEvent(This->event);
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnServerCertificateReceived(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest3 *request, DWORD errors, DWORD chain_size, const XHR_CERT *chain)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %lu %lu %p)\n", This, request, errors, chain_size, chain);
+    return S_OK;
+}
+
+static HRESULT WINAPI xhr3_callback_OnClientCertificateRequested(IXMLHTTPRequest3Callback *iface,
+        IXMLHTTPRequest3 *request, DWORD issuers_size, const WCHAR **issuers)
+{
+    struct xhr3_callback *This = xhr3_callback_from_IXMLHTTPRequest3Callback(iface);
+    trace("(%p)->(%p %lu %p)\n", This, request, issuers_size, issuers);
+    return S_OK;
+}
+
+static const IXMLHTTPRequest3CallbackVtbl xhr3_callback_vtbl =
+{
+    xhr3_callback_QueryInterface,
+    xhr3_callback_AddRef,
+    xhr3_callback_Release,
+    /* IXMLHTTPRequest2Callback methods */
+    xhr3_callback_OnRedirect,
+    xhr3_callback_OnHeadersAvailable,
+    xhr3_callback_OnDataAvailable,
+    xhr3_callback_OnResponseReceived,
+    xhr3_callback_OnError,
+    /* IXMLHTTPRequest3Callback methods */
+    xhr3_callback_OnServerCertificateReceived,
+    xhr3_callback_OnClientCertificateRequested,
+};
+
+static IXMLHTTPRequest2Callback* xhr3_callback_create(HANDLE event)
+{
+    struct xhr3_callback *This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
+    ok(This != NULL, "failed to allocate object\n");
+    if (!This) return NULL;
+
+    This->IXMLHTTPRequest3Callback_iface.lpVtbl = &xhr3_callback_vtbl;
+    This->ref = 1;
+    This->event = event;
+
+    return (IXMLHTTPRequest2Callback*)&This->IXMLHTTPRequest3Callback_iface;
+}
+
+struct xhr2_stream
+{
+    IStream IStream_iface;
+    LONG ref;
+    IStream *stream;
+};
+
+static inline struct xhr2_stream *xhr2_stream_from_IStream(IStream *iface)
+{
+    return CONTAINING_RECORD(iface, struct xhr2_stream, IStream_iface);
+}
+
+static HRESULT WINAPI xhr2_stream_QueryInterface(IStream *iface, REFIID riid, void **obj)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
+
+    if (IsEqualGUID(riid, &IID_IStream) || IsEqualGUID(riid, &IID_ISequentialStream) || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IStream_AddRef(iface);
+        *obj = iface;
+        return S_OK;
+    }
+
+    ok(0, "unexpected interface %s\n", debugstr_guid(riid));
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI xhr2_stream_AddRef(IStream *iface)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    trace("(%p)->(%lu)\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI xhr2_stream_Release(IStream *iface)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    trace("(%p)->(%lu)\n", This, ref);
+    if (ref == 0)
+    {
+        IStream_Release(This->stream);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI xhr2_stream_Read(IStream *iface, void *pv, ULONG cb,
+        ULONG *pcbRead)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p %lu %p)\n", This, pv, cb, pcbRead);
+    return IStream_Read(This->stream, pv, cb, pcbRead);
+}
+
+static HRESULT WINAPI xhr2_stream_Write(IStream *iface, const void *pv,
+        ULONG cb, ULONG *pcbWritten)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p %lu %p)\n", This, pv, cb, pcbWritten);
+    return IStream_Write(This->stream, pv, cb, pcbWritten);
+}
+
+static HRESULT WINAPI xhr2_stream_Seek(IStream *iface, LARGE_INTEGER dlibMove,
+        DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%I64u, %lu %p)\n", This, dlibMove.QuadPart, dwOrigin, plibNewPosition);
+    return IStream_Seek(This->stream, dlibMove, dwOrigin, plibNewPosition);
+}
+
+static HRESULT WINAPI xhr2_stream_SetSize(IStream *iface, ULARGE_INTEGER libNewSize)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%I64u)\n", This, libNewSize.QuadPart);
+    return IStream_SetSize(This->stream, libNewSize);
+}
+
+static HRESULT WINAPI xhr2_stream_CopyTo(IStream *iface, IStream *pstm,
+        ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p %I64u %p %p)\n", This, pstm, cb.QuadPart, pcbRead, pcbWritten);
+    return IStream_CopyTo(This->stream, pstm, cb, pcbRead, pcbWritten);
+}
+
+static HRESULT WINAPI xhr2_stream_Commit(IStream *iface, DWORD grfCommitFlags)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%#lx)\n", This, grfCommitFlags);
+    return IStream_Commit(This->stream, grfCommitFlags);
+}
+
+static HRESULT WINAPI xhr2_stream_Revert(IStream *iface)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->()\n", This);
+    return IStream_Revert(This->stream);
+}
+
+static HRESULT WINAPI xhr2_stream_LockRegion(IStream *iface, ULARGE_INTEGER libOffset,
+        ULARGE_INTEGER cb, DWORD dwLockType)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%I64u %I64u %lu)\n", This, libOffset.QuadPart, cb.QuadPart, dwLockType);
+    return IStream_LockRegion(This->stream, libOffset, cb, dwLockType);
+}
+
+static HRESULT WINAPI xhr2_stream_UnlockRegion(IStream *iface, ULARGE_INTEGER libOffset,
+        ULARGE_INTEGER cb, DWORD dwLockType)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%I64u %I64u %lu)\n", This, libOffset.QuadPart, cb.QuadPart, dwLockType);
+    return IStream_UnlockRegion(This->stream, libOffset, cb, dwLockType);
+}
+
+static HRESULT WINAPI xhr2_stream_Stat(IStream *iface, STATSTG *pstatstg, DWORD grfStatFlag)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p %#lx)\n", This, pstatstg, grfStatFlag);
+    return IStream_Stat(This->stream, pstatstg, grfStatFlag);
+}
+
+static HRESULT WINAPI xhr2_stream_Clone(IStream *iface, IStream **ppstm)
+{
+    struct xhr2_stream *This = xhr2_stream_from_IStream(iface);
+    trace("(%p)->(%p)\n", This, ppstm);
+    return IStream_Clone(This->stream, ppstm);
+}
+
+static const IStreamVtbl xhr2_stream_vtbl =
+{
+    xhr2_stream_QueryInterface,
+    xhr2_stream_AddRef,
+    xhr2_stream_Release,
+    /* IStream methods */
+    xhr2_stream_Read,
+    xhr2_stream_Write,
+    xhr2_stream_Seek,
+    xhr2_stream_SetSize,
+    xhr2_stream_CopyTo,
+    xhr2_stream_Commit,
+    xhr2_stream_Revert,
+    xhr2_stream_LockRegion,
+    xhr2_stream_UnlockRegion,
+    xhr2_stream_Stat,
+    xhr2_stream_Clone
+};
+
+static ISequentialStream *xhr2_stream_create(void)
+{
+    struct xhr2_stream *This = HeapAlloc(GetProcessHeap(), 0, sizeof(*This));
+    ok(This != NULL, "failed to allocate object\n");
+    if (!This) return NULL;
+
+    This->IStream_iface.lpVtbl = &xhr2_stream_vtbl;
+    This->ref = 1;
+    CreateStreamOnHGlobal(NULL, TRUE, &This->stream);
+
+    return (ISequentialStream*)&This->IStream_iface;
+}
+
+static void test_IXMLHTTPRequest2(void)
+{
+    IXMLHTTPRequest2 *xhr2[16];
+    IXMLHTTPRequest2Callback *xhr3_callback;
+    ISequentialStream *stream;
+    HANDLE events[16];
+    HRESULT hr;
+    int i = 0;
+
+    if (!(xhr2[i] = create_xhr2()))
+    {
+        win_skip("IXMLHTTPRequest2 is not available\n");
+        return;
+    }
+
+    events[i] = CreateEventW(NULL, FALSE, FALSE, NULL);
+    if (!(xhr3_callback = xhr3_callback_create(events[i])))
+        return;
+
+    trace("%lu: IXMLHTTPRequest2_Open (%p)->(L\"GET\", L\"http://test.winehq.org/\", xhr3_callback, NULL, NULL, NULL, NULL)\n", GetCurrentThreadId(), xhr2[i]);
+    hr = IXMLHTTPRequest2_Open(xhr2[i], L"GET", L"http://test.winehq.org/", xhr3_callback, NULL, NULL, NULL, NULL);
+    ok(SUCCEEDED(hr), "IXMLHTTPRequest2_Send failed %#lx\n", hr);
+
+    if ((stream = xhr2_stream_create()))
+    {
+        trace("%lu: IXMLHTTPRequest2_Send (%p)->(%p 0)\n", GetCurrentThreadId(), xhr2[i], stream);
+        hr = IXMLHTTPRequest2_Send(xhr2[i], stream, 0);
+        ok(SUCCEEDED(hr), "IXMLHTTPRequest2_Send failed %#lx\n", hr);
+
+        ISequentialStream_Release(stream);
+    }
+
+    IXMLHTTPRequest2Callback_Release(xhr3_callback);
+    i++;
+
+    while (i--)
+    {
+        WaitForSingleObject(events[i], INFINITE);
+        IXMLHTTPRequest2_Release(xhr2[i]);
+    }
+}
+
 START_TEST(httpreq)
 {
     IXMLHttpRequest *xhr;
 
-    CoInitialize(NULL);
+    CoInitializeEx(NULL, COINIT_MULTITHREADED);
 
     if (!(xhr = create_xhr()))
     {
@@ -1923,6 +2311,7 @@ START_TEST(httpreq)
     test_server_xhr();
     test_safe_httpreq();
     test_supporterrorinfo();
+    test_IXMLHTTPRequest2();
 
     CoUninitialize();
 }
diff --git a/dlls/msxml3/tests/saxreader.c b/dlls/msxml3/tests/saxreader.c
index e123d4e..b43c31d 100644
--- a/dlls/msxml3/tests/saxreader.c
+++ b/dlls/msxml3/tests/saxreader.c
@@ -29,6 +29,7 @@
 #include "windows.h"
 #include "ole2.h"
 #include "msxml2.h"
+#include "msxml6.h"
 #include "msxml2did.h"
 #include "ocidl.h"
 #include "dispex.h"
@@ -4563,6 +4564,7 @@ static void test_mxwriter_domdoc(void)
     todo_wine
     ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
 
+    if (!node) return;
     hr = IXMLDOMNode_get_nodeName(node, &str);
 todo_wine {
     ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
diff --git a/dlls/msxml3/tests/schema.c b/dlls/msxml3/tests/schema.c
index efc3a8e..fd244ee 100644
--- a/dlls/msxml3/tests/schema.c
+++ b/dlls/msxml3/tests/schema.c
@@ -32,6 +32,17 @@
 #include "dispex.h"
 #include "cguid.h"
 
+DEFINE_GUID(CLSID_FreeThreadedDOMDocument60, 0x88d96a06, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_FreeThreadedXMLHTTP60, 0x88d96a09, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_MXXMLWriter60, 0x88d96a0f, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_SAXAttributes60, 0x88d96a0e, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_SAXXMLReader60, 0x88d96a0c, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_XMLSchemaCache60, 0x88d96a07, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(IID_IXMLHTTPRequest2, 0xe5d37dc0, 0x552a, 0x4d52, 0x9c,0xc0, 0xa1,0x4d,0x54,0x6f,0xbd,0x04);
+DEFINE_GUID(IID_IXMLHTTPRequest3, 0xa1c9feee, 0x0617, 0x4f23, 0x9d,0x58, 0x89,0x61,0xea,0x43,0x56,0x7c);
+DEFINE_GUID(IID_IXMLHTTPRequest2Callback, 0xa44a9299, 0xe321, 0x40de, 0x88,0x66, 0x34,0x1b,0x41,0x66,0x91,0x62);
+DEFINE_GUID(IID_IXMLHTTPRequest3Callback, 0xb9e57830, 0x8c6c, 0x4a6f, 0x9c,0x13, 0x47,0x77,0x2b,0xb0,0x47,0xbb);
+
 #include "wine/test.h"
 
 #define check_interface(a, b, c) check_interface_(__LINE__, a, b, c)
diff --git a/dlls/msxml3/uuid.c b/dlls/msxml3/uuid.c
index 4abbe5e..1b4f045 100644
--- a/dlls/msxml3/uuid.c
+++ b/dlls/msxml3/uuid.c
@@ -41,6 +41,22 @@
 #include "initguid.h"
 #include "msxml2.h"
 
+/* Cannot include msxml6 here since we will get a duplicate LIBID_MSXML2 error.  */
+DEFINE_GUID(CLSID_FreeThreadedDOMDocument60, 0x88d96a06, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_FreeThreadedXMLHTTP60, 0x88d96a09, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_MXNamespaceManager60, 0x88d96a11, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_MXXMLWriter60, 0x88d96a0f, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_SAXAttributes60, 0x88d96a0e, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_SAXXMLReader60, 0x88d96a0c, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_ServerXMLHTTP60, 0x88d96a0b, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_XMLHTTP60, 0x88d96a0a, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_XMLSchemaCache60, 0x88d96a07, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(CLSID_XSLTemplate60, 0x88d96a08, 0xf192, 0x11d4, 0xa6,0x5f, 0x00,0x40,0x96,0x32,0x51,0xe5);
+DEFINE_GUID(IID_IXMLHTTPRequest2, 0xe5d37dc0, 0x552a, 0x4d52, 0x9c,0xc0, 0xa1,0x4d,0x54,0x6f,0xbd,0x04);
+DEFINE_GUID(IID_IXMLHTTPRequest3, 0xa1c9feee, 0x0617, 0x4f23, 0x9d,0x58, 0x89,0x61,0xea,0x43,0x56,0x7c);
+DEFINE_GUID(IID_IXMLHTTPRequest2Callback, 0xa44a9299, 0xe321, 0x40de, 0x88,0x66, 0x34,0x1b,0x41,0x66,0x91,0x62);
+DEFINE_GUID(IID_IXMLHTTPRequest3Callback, 0xb9e57830, 0x8c6c, 0x4a6f, 0x9c,0x13, 0x47,0x77,0x2b,0xb0,0x47,0xbb);
+
 /*
  * Note that because of a #define in msxml2.h, we end up initializing
  * CLSID_DOMDocument2 to be the v.3 version independent DOMDocument
diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
index d3f2a0e..a2b4987 100644
--- a/dlls/ntdll/Makefile.in
+++ b/dlls/ntdll/Makefile.in
@@ -4,7 +4,7 @@ UNIXLIB   = ntdll.so
 IMPORTLIB = ntdll
 IMPORTS   = $(MUSL_PE_LIBS) winecrt0
 UNIX_CFLAGS  = $(UNWIND_CFLAGS)
-UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS)
+UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS) -lm
 
 EXTRADLLFLAGS = -nodefaultlibs
 i386_EXTRADLLFLAGS = -Wl,--image-base,0x7bc00000
@@ -48,6 +48,7 @@ SOURCES = \
 	unix/cdrom.c \
 	unix/debug.c \
 	unix/env.c \
+	unix/esync.c \
 	unix/file.c \
 	unix/loader.c \
 	unix/loadorder.c \
diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index ec4e376..042074a 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -583,13 +583,13 @@ static inline ULONG heap_get_flags( const struct heap *heap, ULONG flags )
 static inline void heap_lock( struct heap *heap, ULONG flags )
 {
     if (flags & HEAP_NO_SERIALIZE) return;
-    RtlEnterCriticalSection( &heap->cs );
+    enter_critical_section( &heap->cs );
 }
 
 static inline void heap_unlock( struct heap *heap, ULONG flags )
 {
     if (flags & HEAP_NO_SERIALIZE) return;
-    RtlLeaveCriticalSection( &heap->cs );
+    leave_critical_section( &heap->cs );
 }
 
 static void heap_set_status( const struct heap *heap, ULONG flags, NTSTATUS status )
@@ -1580,9 +1580,9 @@ HANDLE WINAPI RtlCreateHeap( ULONG flags, void *addr, SIZE_T total_size, SIZE_T
     /* link it into the per-process heap list */
     if (process_heap)
     {
-        RtlEnterCriticalSection( &process_heap->cs );
+        enter_critical_section( &process_heap->cs );
         list_add_head( &process_heap->entry, &heap->entry );
-        RtlLeaveCriticalSection( &process_heap->cs );
+        leave_critical_section( &process_heap->cs );
     }
     else if (!addr)
     {
@@ -1641,9 +1641,9 @@ HANDLE WINAPI RtlDestroyHeap( HANDLE handle )
     if (heap == process_heap) return handle; /* cannot delete the main process heap */
 
     /* remove it from the per-process list */
-    RtlEnterCriticalSection( &process_heap->cs );
+    enter_critical_section( &process_heap->cs );
     list_remove( &heap->entry );
-    RtlLeaveCriticalSection( &process_heap->cs );
+    leave_critical_section( &process_heap->cs );
 
     heap->cs.DebugInfo->Spare[0] = 0;
     RtlDeleteCriticalSection( &heap->cs );
@@ -2534,7 +2534,7 @@ ULONG WINAPI RtlGetProcessHeaps( ULONG count, HANDLE *heaps )
     ULONG total = 1;  /* main heap */
     struct list *ptr;
 
-    RtlEnterCriticalSection( &process_heap->cs );
+    enter_critical_section( &process_heap->cs );
     LIST_FOR_EACH( ptr, &process_heap->entry ) total++;
     if (total <= count)
     {
@@ -2542,7 +2542,7 @@ ULONG WINAPI RtlGetProcessHeaps( ULONG count, HANDLE *heaps )
         LIST_FOR_EACH( ptr, &process_heap->entry )
             *heaps++ = LIST_ENTRY( ptr, struct heap, entry );
     }
-    RtlLeaveCriticalSection( &process_heap->cs );
+    leave_critical_section( &process_heap->cs );
     return total;
 }
 
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 4fc8af2..19bdd1b 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -42,6 +42,7 @@ WINE_DECLARE_DEBUG_CHANNEL(relay);
 WINE_DECLARE_DEBUG_CHANNEL(snoop);
 WINE_DECLARE_DEBUG_CHANNEL(loaddll);
 WINE_DECLARE_DEBUG_CHANNEL(imports);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #ifdef _WIN64
 #define DEFAULT_SECURITY_COOKIE_64  (((ULONGLONG)0x00002b99 << 32) | 0x2ddfa232)
@@ -91,6 +92,9 @@ const WCHAR system_dir[] = L"C:\\windows\\system32\\";
 /* system search path */
 static const WCHAR system_path[] = L"C:\\windows\\system32;C:\\windows\\system;C:\\windows";
 
+#define IS_OPTION_TRUE(ch) ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+
 static BOOL is_prefix_bootstrap;  /* are we bootstrapping the prefix? */
 static BOOL imports_fixup_done = FALSE;  /* set once the imports have been fixed up, before attaching them */
 static BOOL process_detaching = FALSE;  /* set on process detach to avoid deadlocks with thread detach */
@@ -110,6 +114,8 @@ struct dll_dir_entry
 
 static struct list dll_dir_list = LIST_INIT( dll_dir_list );  /* extra dirs from LdrAddDllDirectory */
 
+static BOOL hide_wine_exports = FALSE;  /* try to hide ntdll wine exports from applications */
+
 struct ldr_notification
 {
     struct list                    entry;
@@ -132,6 +138,9 @@ struct file_id
     BYTE ObjectId[16];
 };
 
+#define HASH_MAP_SIZE 32
+static LIST_ENTRY hash_table[HASH_MAP_SIZE];
+
 /* internal representation of loaded modules */
 typedef struct _wine_modref
 {
@@ -547,6 +556,33 @@ static void call_ldr_notifications( ULONG reason, LDR_DATA_TABLE_ENTRY *module )
     }
 }
 
+/*************************************************************************
+ *      hash_basename
+ *
+ * Calculates the bucket index of a dll using the basename.
+ */
+static ULONG hash_basename(const WCHAR *basename)
+{
+    WORD version = MAKEWORD(NtCurrentTeb()->Peb->OSMinorVersion,
+                            NtCurrentTeb()->Peb->OSMajorVersion);
+    ULONG hash = 0;
+
+    if (version >= 0x0602)
+    {
+        for (; *basename; basename++)
+            hash = hash * 65599 + towupper(*basename);
+    }
+    else if (version == 0x0601)
+    {
+        for (; *basename; basename++)
+            hash = hash + 65599 * towupper(*basename);
+    }
+    else
+        hash = towupper(basename[0]) - 'A';
+
+    return hash & (HASH_MAP_SIZE-1);
+}
+
 /*************************************************************************
  *		get_modref
  *
@@ -587,13 +623,13 @@ static WINE_MODREF *find_basename_module( LPCWSTR name )
     if (cached_modref && RtlEqualUnicodeString( &name_str, &cached_modref->ldr.BaseDllName, TRUE ))
         return cached_modref;
 
-    mark = &NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList;
+    mark = &hash_table[hash_basename(name)];
     for (entry = mark->Flink; entry != mark; entry = entry->Flink)
     {
-        WINE_MODREF *mod = CONTAINING_RECORD(entry, WINE_MODREF, ldr.InLoadOrderLinks);
+        WINE_MODREF *mod = CONTAINING_RECORD(entry, WINE_MODREF, ldr.HashLinks);
         if (RtlEqualUnicodeString( &name_str, &mod->ldr.BaseDllName, TRUE ) && !mod->system)
         {
-            cached_modref = CONTAINING_RECORD(mod, WINE_MODREF, ldr);
+            cached_modref = CONTAINING_RECORD(&mod->ldr, WINE_MODREF, ldr);
             return cached_modref;
         }
     }
@@ -1527,7 +1563,12 @@ static WINE_MODREF *alloc_module( HMODULE hModule, const UNICODE_STRING *nt_name
                    &wm->ldr.InLoadOrderLinks);
     InsertTailList(&NtCurrentTeb()->Peb->LdrData->InMemoryOrderModuleList,
                    &wm->ldr.InMemoryOrderLinks);
+    InsertTailList(&hash_table[hash_basename(wm->ldr.BaseDllName.Buffer)],
+                   &wm->ldr.HashLinks);
+
     /* wait until init is called for inserting into InInitializationOrderModuleList */
+    wm->ldr.InInitializationOrderLinks.Flink = NULL;
+    wm->ldr.InInitializationOrderLinks.Blink = NULL;
 
     if (!(nt->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT))
     {
@@ -1999,6 +2040,96 @@ NTSTATUS WINAPI LdrUnlockLoaderLock( ULONG flags, ULONG_PTR magic )
 }
 
 
+/***********************************************************************
+ *           hidden_exports_init
+ *
+ * Initializes the hide_wine_exports options.
+ */
+static void hidden_exports_init( const WCHAR *appname )
+{
+    static const WCHAR configW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e',0};
+    static const WCHAR appdefaultsW[] = {'A','p','p','D','e','f','a','u','l','t','s','\\',0};
+    static const WCHAR hideWineExports[] = {'H','i','d','e','W','i','n','e','E','x','p','o','r','t','s',0};
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING nameW;
+    HANDLE root, config_key, hkey;
+    BOOL got_hide_wine_exports = FALSE;
+    char tmp[80];
+    DWORD dummy;
+
+    RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+    RtlInitUnicodeString( &nameW, configW );
+
+    /* @@ Wine registry key: HKCU\Software\Wine */
+    if (NtOpenKey( &config_key, KEY_QUERY_VALUE, &attr )) config_key = 0;
+    NtClose( root );
+    if (!config_key) return;
+
+    if (appname && *appname)
+    {
+        const WCHAR *p;
+        WCHAR appversion[MAX_PATH+20];
+
+        if ((p = wcsrchr( appname, '/' ))) appname = p + 1;
+        if ((p = wcsrchr( appname, '\\' ))) appname = p + 1;
+
+        wcscpy( appversion, appdefaultsW );
+        wcscat( appversion, appname );
+        RtlInitUnicodeString( &nameW, appversion );
+        attr.RootDirectory = config_key;
+
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe */
+        if (!NtOpenKey( &hkey, KEY_QUERY_VALUE, &attr ))
+        {
+            TRACE( "getting HideWineExports from %s\n", debugstr_w(appversion) );
+
+            RtlInitUnicodeString( &nameW, hideWineExports );
+            if (!NtQueryValueKey( hkey, &nameW, KeyValuePartialInformation, tmp, sizeof(tmp), &dummy ))
+            {
+                WCHAR *str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)tmp)->Data;
+                hide_wine_exports = IS_OPTION_TRUE( str[0] );
+                got_hide_wine_exports = TRUE;
+            }
+
+            NtClose( hkey );
+        }
+    }
+
+    if (!got_hide_wine_exports)
+    {
+        TRACE( "getting default HideWineExports\n" );
+
+        RtlInitUnicodeString( &nameW, hideWineExports );
+        if (!NtQueryValueKey( config_key, &nameW, KeyValuePartialInformation, tmp, sizeof(tmp), &dummy ))
+        {
+            WCHAR *str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)tmp)->Data;
+            hide_wine_exports = IS_OPTION_TRUE( str[0] );
+        }
+    }
+
+    NtClose( config_key );
+}
+
+
+/***********************************************************************
+ *           is_hidden_export
+ *
+ * Checks if a specific export should be hidden.
+ */
+static BOOL is_hidden_export( void *proc )
+{
+    return hide_wine_exports && (proc == &wine_get_version ||
+                                 proc == &wine_get_build_id ||
+                                 proc == &wine_get_host_version);
+}
+
+
 /******************************************************************
  *		LdrGetProcedureAddress  (NTDLL.@)
  */
@@ -2019,7 +2150,7 @@ NTSTATUS WINAPI LdrGetProcedureAddress(HMODULE module, const ANSI_STRING *name,
     {
         void *proc = name ? find_named_export( module, exports, exp_size, name->Buffer, -1, NULL )
                           : find_ordinal_export( module, exports, exp_size, ord - exports->Base, NULL );
-        if (proc)
+        if (proc && !is_hidden_export( proc ))
         {
             *address = proc;
             ret = STATUS_SUCCESS;
@@ -2225,6 +2356,7 @@ static NTSTATUS build_module( LPCWSTR load_path, const UNICODE_STRING *nt_name,
             /* the module has only be inserted in the load & memory order lists */
             RemoveEntryList(&wm->ldr.InLoadOrderLinks);
             RemoveEntryList(&wm->ldr.InMemoryOrderLinks);
+            RemoveEntryList(&wm->ldr.HashLinks);
 
             /* FIXME: there are several more dangling references
              * left. Including dlls loaded by this dll before the
@@ -2279,6 +2411,8 @@ static void build_ntdll_module(void)
     wm->ldr.Flags &= ~LDR_DONT_RESOLVE_REFS;
     node_ntdll = wm->ldr.DdagNode;
     if (TRACE_ON(relay)) RELAY_SetupDLL( module );
+
+    hidden_exports_init( wm->ldr.FullDllName.Buffer );
 }
 
 
@@ -3822,6 +3956,7 @@ void WINAPI LdrShutdownProcess(void)
     process_detach();
 }
 
+extern const char * CDECL wine_get_version(void);
 
 /******************************************************************
  *		RtlExitUserProcess (NTDLL.@)
@@ -3906,6 +4041,7 @@ static void free_modref( WINE_MODREF *wm )
 
     RemoveEntryList(&wm->ldr.InLoadOrderLinks);
     RemoveEntryList(&wm->ldr.InMemoryOrderLinks);
+    RemoveEntryList(&wm->ldr.HashLinks);
     if (wm->ldr.InInitializationOrderLinks.Flink)
         RemoveEntryList(&wm->ldr.InInitializationOrderLinks);
 
@@ -4244,6 +4380,9 @@ static void release_address_space(void)
  */
 void loader_init( CONTEXT *context, void **entry )
 {
+    OBJECT_ATTRIBUTES staging_event_attr;
+    UNICODE_STRING staging_event_string;
+    HANDLE staging_event;
     static int attach_done;
     NTSTATUS status;
     ULONG_PTR cookie, port = 0;
@@ -4258,6 +4397,7 @@ void loader_init( CONTEXT *context, void **entry )
         ANSI_STRING ctrl_routine = RTL_CONSTANT_STRING( "CtrlRoutine" );
         WINE_MODREF *kernel32;
         PEB *peb = NtCurrentTeb()->Peb;
+        unsigned int i;
 
         peb->LdrData            = &ldr;
         peb->FastPebLock        = &peb_lock;
@@ -4273,6 +4413,10 @@ void loader_init( CONTEXT *context, void **entry )
         RtlSetBits( peb->TlsBitmap, 0, NtCurrentTeb()->WowTebOffset ? WOW64_TLS_MAX_NUMBER : 1 );
         RtlSetBits( peb->TlsBitmap, NTDLL_TLS_ERRNO, 1 );
 
+        /* initialize hash table */
+        for (i = 0; i < HASH_MAP_SIZE; i++)
+            InitializeListHead( &hash_table[i] );
+
         init_user_process_params();
         load_global_options();
         version_init();
@@ -4313,6 +4457,16 @@ void loader_init( CONTEXT *context, void **entry )
     if (NtCurrentTeb()->WowTebOffset) init_wow64( context );
 #endif
 
+    RtlInitUnicodeString( &staging_event_string, L"\\__wine_staging_warn_event" );
+    InitializeObjectAttributes( &staging_event_attr, &staging_event_string, OBJ_OPENIF, NULL, NULL );
+    if (NtCreateEvent( &staging_event, EVENT_ALL_ACCESS, &staging_event_attr, NotificationEvent, FALSE ) == STATUS_SUCCESS)
+    {
+        FIXME_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
+        FIXME_(winediag)("Please mention your exact version when filing bug reports on winehq.org.\n");
+    }
+    else
+        WARN_(winediag)("wine-staging %s is a testing version containing experimental patches.\n", wine_get_version());
+
     RtlAcquirePebLock();
     InsertHeadList( &tls_links, &NtCurrentTeb()->TlsLinks );
     RtlReleasePebLock();
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 756b19a..15c035f 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -28,6 +28,7 @@
 #include "winnt.h"
 #include "winternl.h"
 #include "unixlib.h"
+#include "wine/debug.h"
 #include "wine/asm.h"
 
 #define DECLARE_CRITICAL_SECTION(cs) \
@@ -101,6 +102,39 @@ extern struct _KUSER_SHARED_DATA *user_shared_data;
 extern int CDECL NTDLL__vsnprintf( char *str, SIZE_T len, const char *format, va_list args );
 extern int CDECL NTDLL__vsnwprintf( WCHAR *str, SIZE_T len, const WCHAR *format, va_list args );
 
+/* inline version of RtlEnterCriticalSection */
+static inline void enter_critical_section( RTL_CRITICAL_SECTION *crit )
+{
+    if (InterlockedIncrement( &crit->LockCount ))
+    {
+        if (crit->OwningThread == ULongToHandle(GetCurrentThreadId()))
+        {
+            crit->RecursionCount++;
+            return;
+        }
+        RtlpWaitForCriticalSection( crit );
+    }
+    crit->OwningThread   = ULongToHandle(GetCurrentThreadId());
+    crit->RecursionCount = 1;
+}
+
+/* inline version of RtlLeaveCriticalSection */
+static inline void leave_critical_section( RTL_CRITICAL_SECTION *crit )
+{
+    WINE_DECLARE_DEBUG_CHANNEL(ntdll);
+    if (--crit->RecursionCount)
+    {
+        if (crit->RecursionCount > 0) InterlockedDecrement( &crit->LockCount );
+        else ERR_(ntdll)( "section %p is not acquired\n", crit );
+    }
+    else
+    {
+        crit->OwningThread = 0;
+        if (InterlockedDecrement( &crit->LockCount ) >= 0)
+            RtlpUnWaitCriticalSection( crit );
+    }
+}
+
 struct dllredirect_data
 {
     ULONG size;
@@ -128,6 +162,11 @@ static inline TEB64 *NtCurrentTeb64(void) { return (TEB64 *)NtCurrentTeb()->GdiB
 
 NTSTATUS WINAPI RtlHashUnicodeString(PCUNICODE_STRING,BOOLEAN,ULONG,ULONG*);
 
+/* version */
+extern const char * CDECL wine_get_version(void);
+extern const char * CDECL wine_get_build_id(void);
+extern void CDECL wine_get_host_version( const char **sysname, const char **release );
+
 /* convert from straight ASCII to Unicode without depending on the current codepage */
 static inline void ascii_to_unicode( WCHAR *dst, const char *src, size_t len )
 {
diff --git a/dlls/ntdll/process.c b/dlls/ntdll/process.c
index 8709078..e4df897 100644
--- a/dlls/ntdll/process.c
+++ b/dlls/ntdll/process.c
@@ -39,6 +39,9 @@
 WINE_DEFAULT_DEBUG_CHANNEL(process);
 
 
+/* we don't want to include winuser.h */
+#define CREATEPROCESS_MANIFEST_RESOURCE_ID ((ULONG_PTR)1)
+
 /******************************************************************************
  *  RtlGetCurrentPeb  [NTDLL.@]
  *
@@ -91,6 +94,63 @@ NTSTATUS WINAPI RtlWow64EnableFsRedirectionEx( ULONG disable, ULONG *old_value )
 }
 
 
+static BOOL image_needs_elevation( const UNICODE_STRING *path )
+{
+    ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION run_level;
+    UNICODE_STRING path0;
+    BOOL ret = FALSE;
+    HANDLE handle;
+    ACTCTXW ctx;
+
+    if (RtlDuplicateUnicodeString( 1, path, &path0 ))
+        return FALSE;
+
+    ctx.cbSize = sizeof(ctx);
+    ctx.dwFlags = ACTCTX_FLAG_RESOURCE_NAME_VALID;
+    ctx.lpSource = path0.Buffer;
+    ctx.lpResourceName = (const WCHAR *)CREATEPROCESS_MANIFEST_RESOURCE_ID;
+
+    if (RtlCreateActivationContext( &handle, &ctx ))
+    {
+        RtlFreeUnicodeString( &path0 );
+        return FALSE;
+    }
+
+    if (!RtlQueryInformationActivationContext( 0, handle, NULL, RunlevelInformationInActivationContext,
+                                               &run_level, sizeof(run_level), NULL ))
+    {
+        TRACE( "image requested run level %#x\n", run_level.RunLevel );
+        if (run_level.RunLevel == ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE
+                || run_level.RunLevel == ACTCTX_RUN_LEVEL_REQUIRE_ADMIN)
+            ret = TRUE;
+    }
+    RtlReleaseActivationContext( handle );
+    RtlFreeUnicodeString( &path0 );
+    return ret;
+}
+
+
+static HANDLE get_elevated_token(void)
+{
+    TOKEN_ELEVATION_TYPE type;
+    TOKEN_LINKED_TOKEN linked;
+    NTSTATUS status;
+
+    if ((status = NtQueryInformationToken( GetCurrentThreadEffectiveToken(),
+                                           TokenElevationType, &type, sizeof(type), NULL )))
+        return NULL;
+
+    if (type == TokenElevationTypeFull) return NULL;
+
+
+    if ((status = NtQueryInformationToken( GetCurrentThreadEffectiveToken(),
+                                           TokenLinkedToken, &linked, sizeof(linked), NULL )))
+        return NULL;
+
+    return linked.LinkedToken;
+}
+
+
 /**********************************************************************
  *           RtlWow64GetCurrentMachine  (NTDLL.@)
  */
@@ -463,8 +523,15 @@ NTSTATUS WINAPI RtlCreateUserProcess( UNICODE_STRING *path, ULONG attributes,
     PS_CREATE_INFO create_info;
     ULONG_PTR buffer[offsetof( PS_ATTRIBUTE_LIST, Attributes[6] ) / sizeof(ULONG_PTR)];
     PS_ATTRIBUTE_LIST *attr = (PS_ATTRIBUTE_LIST *)buffer;
+    HANDLE elevated_token = NULL;
+    NTSTATUS status;
     UINT pos = 0;
 
+    /* It's not clear whether we should use path or &params->ImagePathName here,
+     * but Roblox Player tries to pass an empty string for the latter. */
+    if (!token && image_needs_elevation( path ))
+        token = elevated_token = get_elevated_token();
+
     RtlNormalizeProcessParams( params );
 
     attr->Attributes[pos].Attribute    = PS_ATTRIBUTE_IMAGE_NAME;
@@ -511,11 +578,13 @@ NTSTATUS WINAPI RtlCreateUserProcess( UNICODE_STRING *path, ULONG attributes,
     InitializeObjectAttributes( &process_attr, NULL, 0, NULL, process_descr );
     InitializeObjectAttributes( &thread_attr, NULL, 0, NULL, thread_descr );
 
-    return NtCreateUserProcess( &info->Process, &info->Thread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS,
-                                &process_attr, &thread_attr,
-                                inherit ? PROCESS_CREATE_FLAGS_INHERIT_HANDLES : 0,
-                                THREAD_CREATE_FLAGS_CREATE_SUSPENDED, params,
-                                &create_info, attr );
+    status = NtCreateUserProcess( &info->Process, &info->Thread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS,
+                                  &process_attr, &thread_attr,
+                                  inherit ? PROCESS_CREATE_FLAGS_INHERIT_HANDLES : 0,
+                                  THREAD_CREATE_FLAGS_CREATE_SUSPENDED, params, &create_info, attr );
+
+    if (elevated_token) NtClose( elevated_token );
+    return status;
 }
 
 /***********************************************************************
diff --git a/dlls/ntdll/tests/Makefile.in b/dlls/ntdll/tests/Makefile.in
index 3ca77a0..7508e1a 100644
--- a/dlls/ntdll/tests/Makefile.in
+++ b/dlls/ntdll/tests/Makefile.in
@@ -1,5 +1,5 @@
 TESTDLL   = ntdll.dll
-IMPORTS   = user32 advapi32
+IMPORTS   = user32 ole32 advapi32
 
 SOURCES = \
 	atom.c \
diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
index da3611f..517eb26 100644
--- a/dlls/ntdll/tests/file.c
+++ b/dlls/ntdll/tests/file.c
@@ -38,6 +38,7 @@
 #include "winuser.h"
 #include "winioctl.h"
 #include "winnls.h"
+#include "ntifs.h"
 
 #ifndef IO_COMPLETION_ALL_ACCESS
 #define IO_COMPLETION_ALL_ACCESS 0x001F0003
@@ -136,18 +137,22 @@ static void WINAPI apc( void *arg, IO_STATUS_BLOCK *iosb, ULONG reserved )
 
 static void create_file_test(void)
 {
+    static const WCHAR notepadW[] = {'n','o','t','e','p','a','d','.','e','x','e',0};
     static const WCHAR systemrootW[] = {'\\','S','y','s','t','e','m','R','o','o','t',
                                         '\\','f','a','i','l','i','n','g',0};
+    static const WCHAR systemrootExplorerW[] = {'\\','S','y','s','t','e','m','R','o','o','t',
+                                               '\\','e','x','p','l','o','r','e','r','.','e','x','e',0};
     static const WCHAR questionmarkInvalidNameW[] = {'a','f','i','l','e','?',0};
     static const WCHAR pipeInvalidNameW[]  = {'a','|','b',0};
     static const WCHAR pathInvalidNtW[] = {'\\','\\','?','\\',0};
     static const WCHAR pathInvalidNt2W[] = {'\\','?','?','\\',0};
     static const WCHAR pathInvalidDosW[] = {'\\','D','o','s','D','e','v','i','c','e','s','\\',0};
     static const char testdata[] = "Hello World";
+    static const WCHAR sepW[] = {'\\',0};
     FILE_NETWORK_OPEN_INFORMATION info;
     NTSTATUS status;
     HANDLE dir, file;
-    WCHAR path[MAX_PATH];
+    WCHAR path[MAX_PATH], temp[MAX_PATH];
     OBJECT_ATTRIBUTES attr;
     IO_STATUS_BLOCK io;
     UNICODE_STRING nameW;
@@ -327,6 +332,25 @@ static void create_file_test(void)
     status = pNtQueryFullAttributesFile( &attr, &info );
     ok( status == STATUS_OBJECT_NAME_INVALID,
         "query %s failed %lx\n", wine_dbgstr_w(nameW.Buffer), status );
+
+    GetWindowsDirectoryW( path, MAX_PATH );
+    path[2] = 0;
+    ok( QueryDosDeviceW( path, temp, MAX_PATH ),
+        "QueryDosDeviceW failed with error %lx\n", GetLastError() );
+    lstrcatW( temp, sepW );
+    lstrcatW( temp, path+3 );
+    lstrcatW( temp, sepW );
+    lstrcatW( temp, notepadW );
+
+    pRtlInitUnicodeString( &nameW, temp );
+    status = pNtQueryFullAttributesFile( &attr, &info );
+    ok( status == STATUS_SUCCESS,
+        "query %s failed %lx\n", wine_dbgstr_w(nameW.Buffer), status );
+
+    pRtlInitUnicodeString( &nameW, systemrootExplorerW );
+    status = pNtQueryFullAttributesFile( &attr, &info );
+    ok( status == STATUS_SUCCESS,
+        "query %s failed %lx\n", wine_dbgstr_w(nameW.Buffer), status );
 }
 
 static void open_file_test(void)
@@ -4735,6 +4759,83 @@ static void test_NtCreateFile(void)
     RemoveDirectoryW( path );
 }
 
+static void test_readonly(void)
+{
+    static const WCHAR fooW[] = {'f','o','o',0};
+    NTSTATUS status;
+    HANDLE handle;
+    WCHAR path[MAX_PATH];
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK io;
+    UNICODE_STRING nameW;
+
+    GetTempPathW(MAX_PATH, path);
+    GetTempFileNameW(path, fooW, 0, path);
+    DeleteFileW(path);
+    pRtlDosPathNameToNtPathName_U(path, &nameW, NULL, NULL);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = NULL;
+    attr.ObjectName = &nameW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    status = pNtCreateFile(&handle, GENERIC_READ, &attr, &io, NULL, FILE_ATTRIBUTE_READONLY,
+                           FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_CREATE, 0, NULL, 0);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, GENERIC_WRITE,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_ACCESS_DENIED, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, GENERIC_READ,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, FILE_READ_ATTRIBUTES,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, FILE_WRITE_ATTRIBUTES,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, DELETE,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, READ_CONTROL,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, WRITE_DAC,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, WRITE_OWNER,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle(handle);
+
+    status = pNtOpenFile(&handle, SYNCHRONIZE,  &attr, &io,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, FILE_OPEN_FOR_BACKUP_INTENT);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    CloseHandle( handle );
+
+    pRtlFreeUnicodeString(&nameW);
+    SetFileAttributesW(path, FILE_ATTRIBUTE_ARCHIVE);
+    DeleteFileW(path);
+}
+
 static void test_read_write(void)
 {
     static const char contents[14] = "1234567890abcd";
@@ -5803,32 +5904,557 @@ static void test_mailslot_name(void)
     CloseHandle( device );
 }
 
+static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, ULONG flags,
+                                REPARSE_DATA_BUFFER **pbuffer)
+{
+    static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
+    INT buffer_size, struct_size, data_size, string_len, prefix_len;
+    WCHAR *subst_dest, *print_dest;
+    REPARSE_DATA_BUFFER *buffer;
+
+    switch(tag)
+    {
+    case IO_REPARSE_TAG_MOUNT_POINT:
+        struct_size = offsetof(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]);
+        break;
+    case IO_REPARSE_TAG_SYMLINK:
+        struct_size = offsetof(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0]);
+        break;
+    default:
+        return 0;
+    }
+    prefix_len = (flags == SYMLINK_FLAG_RELATIVE) ? 0 : strlen("\\??\\");
+    string_len = lstrlenW(&filename[prefix_len]);
+    data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
+    buffer_size = struct_size + data_size;
+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_size);
+    buffer->ReparseTag = tag;
+    buffer->ReparseDataLength = struct_size - header_size + data_size;
+    switch(tag)
+    {
+    case IO_REPARSE_TAG_MOUNT_POINT:
+        buffer->MountPointReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
+        buffer->MountPointReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
+        buffer->MountPointReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
+        subst_dest = &buffer->MountPointReparseBuffer.PathBuffer[0];
+        print_dest = &buffer->MountPointReparseBuffer.PathBuffer[prefix_len + string_len + 1];
+        break;
+    case IO_REPARSE_TAG_SYMLINK:
+        buffer->SymbolicLinkReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
+        buffer->SymbolicLinkReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
+        buffer->SymbolicLinkReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
+        buffer->SymbolicLinkReparseBuffer.Flags = flags;
+        subst_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[0];
+        print_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[prefix_len + string_len + 1];
+        break;
+    default:
+        return 0;
+    }
+    lstrcpyW(subst_dest, filename);
+    lstrcpyW(print_dest, &filename[prefix_len]);
+    *pbuffer = buffer;
+    return buffer_size;
+}
+
 static void test_reparse_points(void)
 {
-    OBJECT_ATTRIBUTES attr;
-    HANDLE handle;
-    IO_STATUS_BLOCK io;
-    NTSTATUS status;
+    WCHAR path[MAX_PATH], reparse_path[MAX_PATH], target_path[MAX_PATH], volnameW[MAX_PATH], new_path[MAX_PATH], thru_path[MAX_PATH];
+    static const WCHAR new_reparseW[] = {'\\','n','e','w','_','r','e','p','a','r','s','e',0};
+    static const WCHAR reparseW[] = {'\\','r','e','p','a','r','s','e',0};
+    static const WCHAR targetW[] = {'\\','t','a','r','g','e','t',0};
+    static const WCHAR parentW[] = {'\\','.','.','\\',0};
+    INT buffer_len, string_len, path_len, total_len;
+    FILE_BASIC_INFORMATION old_attrib, new_attrib;
+    static const WCHAR fooW[] = {'f','o','o',0};
+    static WCHAR volW[] = {'c',':','\\',0};
+    const WCHAR *rel_target = &targetW[1];
+    WCHAR *dest, *long_path, *abs_target;
+    REPARSE_GUID_DATA_BUFFER guid_buffer;
+    static const WCHAR dotW[] = {'.',0};
+    FILE_ATTRIBUTE_TAG_INFORMATION info;
+    REPARSE_DATA_BUFFER *buffer = NULL;
+    DWORD dwret, dwLen, dwFlags, err;
+    WIN32_FILE_ATTRIBUTE_DATA fad;
+    char unix_target[] = "target";
+    UCHAR *unix_dest;
+    WCHAR buf[] = {0,0,0,0};
+    HANDLE handle, token;
+    IO_STATUS_BLOCK iosb;
     UNICODE_STRING nameW;
-    unsigned char reparse_data[1];
+    TOKEN_PRIVILEGES tp;
+    NTSTATUS status;
+    LUID luid;
+    BOOL bret;
 
-    pRtlInitUnicodeString( &nameW, L"\\??\\C:\\" );
-    InitializeObjectAttributes( &attr, &nameW, 0, NULL, NULL );
+    /* Create a temporary folder for the junction point tests */
+    GetTempFileNameW(dotW, fooW, 0, path);
+    DeleteFileW(path);
+    if (!CreateDirectoryW(path, NULL))
+    {
+        win_skip("Unable to create a temporary junction point directory.\n");
+        return;
+    }
 
-    status = pNtOpenFile( &handle, READ_CONTROL, &attr, &io, 0, 0 );
-    ok( !status, "open %s failed %#lx\n", wine_dbgstr_w(nameW.Buffer), status );
+    /* Check that the volume this folder is located on supports junction points */
+    pRtlDosPathNameToNtPathName_U(path, &nameW, NULL, NULL);
+    volW[0] = nameW.Buffer[4];
+    pRtlFreeUnicodeString( &nameW );
+    if (!GetVolumeNameForVolumeMountPointW(volW, volnameW, MAX_PATH))
+    {
+        win_skip("Failed to obtain volume name for current volume.\n");
+        return;
+    }
+    GetVolumeInformationW(volnameW, 0, 0, 0, &dwLen, &dwFlags, 0, 0);
+    if (!(dwFlags & FILE_SUPPORTS_REPARSE_POINTS))
+    {
+        skip("File system does not support reparse points.\n");
+        RemoveDirectoryW(path);
+        return;
+    }
 
-    status = pNtFsControlFile( handle, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT, NULL, 0, NULL, 0 );
-    ok( status == STATUS_INVALID_USER_BUFFER, "expected %#lx, got %#lx\n", STATUS_INVALID_USER_BUFFER, status );
+    /* Create the folder to be replaced by a junction point */
+    lstrcpyW(reparse_path, path);
+    lstrcatW(reparse_path, reparseW);
+    bret = CreateDirectoryW(reparse_path, NULL);
+    ok(bret, "Failed to create junction point directory.\n");
 
-    status = pNtFsControlFile( handle, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse_data, 0 );
-    ok( status == STATUS_INVALID_USER_BUFFER, "expected %#lx, got %#lx\n", STATUS_INVALID_USER_BUFFER, status );
+    /* Create a destination folder for the junction point to target */
+    lstrcpyW(target_path, path);
+    for (int i=0; i<1; i++)
+    {
+        lstrcatW(target_path, parentW);
+        lstrcatW(target_path, path);
+    }
+    lstrcatW(target_path, targetW);
+    bret = CreateDirectoryW(target_path, NULL);
+    ok(bret, "Failed to create junction point target directory.\n");
+    pRtlDosPathNameToNtPathName_U(path, &nameW, NULL, NULL);
 
-    /* a volume cannot be a reparse point by definition */
-    status = pNtFsControlFile( handle, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse_data, 1 );
-    ok( status == STATUS_NOT_A_REPARSE_POINT, "expected %#lx, got %#lx\n", STATUS_NOT_A_REPARSE_POINT, status );
+    /* construct a too long pathname (resulting reparse buffer over 16 kiB limit) */
+    long_path = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 32767);
+    lstrcpyW(long_path, nameW.Buffer);
+    for (int i=0; i<250; i++)
+    {
+        lstrcatW(long_path, parentW);
+        lstrcatW(long_path, path);
+    }
+    lstrcatW(long_path, targetW);
 
-    CloseHandle( handle );
+    /* Create the junction point */
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+    {
+        win_skip("Failed to open junction point directory handle (0x%lx).\n", GetLastError());
+        goto cleanup;
+    }
+    buffer_len = build_reparse_buffer(long_path, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(!bret && GetLastError()==ERROR_INVALID_REPARSE_DATA, "Unexpected error (0x%lx)\n", GetLastError());
+    HeapFree(GetProcessHeap(), 0, buffer);
+    CloseHandle(handle);
+
+    /* construct a long pathname to demonstrate correct behavior with very large reparse points */
+    pRtlDosPathNameToNtPathName_U(path, &nameW, NULL, NULL);
+    lstrcpyW(long_path, nameW.Buffer);
+    for (int i=0; i<200; i++)
+    {
+        lstrcatW(long_path, parentW);
+        lstrcatW(long_path, path);
+    }
+    lstrcatW(long_path, targetW);
+
+    /* use a sane (not obscenely long) target for the rest of testing */
+    pRtlFreeUnicodeString(&nameW);
+    pRtlDosPathNameToNtPathName_U(target_path, &nameW, NULL, NULL);
+    abs_target = nameW.Buffer;
+
+    /* Create the junction point */
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+    {
+        win_skip("Failed to open junction point directory handle (0x%lx).\n", GetLastError());
+        goto cleanup;
+    }
+    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%lx).\n", dwret);
+    buffer_len = build_reparse_buffer(long_path, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create junction point! (0x%lx)\n", GetLastError());
+
+    /* Check the file attributes of the junction point */
+    dwret = GetFileAttributesW(reparse_path);
+    ok(dwret != (DWORD)~0, "Reparse point doesn't exist (attributes: 0x%lx)!\n", dwret);
+    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a reparse point! (attributes: 0x%lx)\n", dwret);
+
+    /* Read back the junction point */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    buffer_len = sizeof(*buffer) + 2*32767;
+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
+    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
+    ok(bret, "Failed to read junction point! (last error=0x%lx)\n", GetLastError());
+    string_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
+    dest = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
+    ok((memcmp(dest, long_path, string_len) == 0), "Junction point destination does not match ('%s' != '%s')!\n",
+                                                   wine_dbgstr_w(dest), wine_dbgstr_w(long_path));
+    path_len = buffer->MountPointReparseBuffer.PrintNameOffset/sizeof(WCHAR);
+    path_len += buffer->MountPointReparseBuffer.PrintNameLength/sizeof(WCHAR);
+    total_len = FIELD_OFFSET(typeof(*buffer), MountPointReparseBuffer.PathBuffer[path_len+1])
+                - FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
+    ok(buffer->ReparseDataLength == total_len, "ReparseDataLength has unexpected value (%d != %d)\n",
+                                               buffer->ReparseDataLength, total_len);
+
+    /* Delete the junction point */
+    memset(&old_attrib, 0x00, sizeof(old_attrib));
+    old_attrib.LastAccessTime.QuadPart = 0x200deadcafebeef;
+    dwret = NtSetInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to set junction point folder's attributes (0x%lx).\n", dwret);
+    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
+    guid_buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+    bret = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
+                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to delete junction point! (0x%lx)\n", GetLastError());
+    memset(&new_attrib, 0x00, sizeof(new_attrib));
+    dwret = NtQueryInformationFile(handle, &iosb, &new_attrib, sizeof(new_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%lx).\n", dwret);
+    ok(old_attrib.LastAccessTime.QuadPart == new_attrib.LastAccessTime.QuadPart,
+       "Junction point folder's access time does not match.\n");
+    CloseHandle(handle);
+
+    /* Check deleting a junction point as if it were a directory */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    buffer_len = build_reparse_buffer(abs_target, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create junction point! (0x%lx)\n", GetLastError());
+    CloseHandle(handle);
+    bret = RemoveDirectoryW(reparse_path);
+    ok(bret, "Failed to delete junction point as directory!\n");
+    dwret = GetFileAttributesW(reparse_path);
+    ok(dwret == (DWORD)~0, "Junction point still exists (attributes: 0x%lx)!\n", dwret);
+
+    /* Check deleting a junction point as if it were a file */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    bret = CreateDirectoryW(reparse_path, NULL);
+    ok(bret, "Failed to create junction point target directory.\n");
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    buffer_len = build_reparse_buffer(abs_target, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create junction point! (0x%lx)\n", GetLastError());
+    CloseHandle(handle);
+    bret = DeleteFileW(reparse_path);
+    ok(!bret, "Succeeded in deleting junction point as file!\n");
+    err = GetLastError();
+    ok(err == ERROR_ACCESS_DENIED, "Expected last error 0x%x for DeleteFile on junction point (actually 0x%lx)!\n",
+                                   ERROR_ACCESS_DENIED, err);
+    dwret = GetFileAttributesW(reparse_path);
+    ok(dwret != (DWORD)~0, "Junction point doesn't exist (attributes: 0x%lx)!\n", dwret);
+    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a junction point! (attributes: 0x%lx)\n", dwret);
+
+    /* Test deleting a junction point's target */
+    dwret = GetFileAttributesW(reparse_path);
+    ok(dwret == 0x410 || broken(dwret == 0x430) /* win2k */ || broken(dwret == 0xc10) /* vista */,
+       "Unexpected junction point attributes (0x%lx != 0x410)!\n", dwret);
+    bret = RemoveDirectoryW(target_path);
+    ok(bret, "Failed to delete junction point target!\n");
+    bret = CreateDirectoryW(target_path, NULL);
+    ok(bret, "Failed to create junction point target directory.\n");
+
+    /* Establish permissions for symlink creation */
+    bret = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &token);
+    ok(bret, "OpenProcessToken failed: %lx\n", GetLastError());
+    bret = LookupPrivilegeValueA(NULL, "SeCreateSymbolicLinkPrivilege", &luid);
+    todo_wine ok(bret || broken(!bret && GetLastError() == ERROR_NO_SUCH_PRIVILEGE) /* winxp */,
+                 "LookupPrivilegeValue failed: %lx\n", GetLastError());
+    if (bret)
+    {
+        tp.PrivilegeCount = 1;
+        tp.Privileges[0].Luid = luid;
+        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+        bret = AdjustTokenPrivileges(token, FALSE, &tp, 0, NULL, NULL);
+        ok(bret, "AdjustTokenPrivileges failed: %lx\n", GetLastError());
+        if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
+        {
+            win_skip("Insufficient permissions to perform symlink tests.\n");
+            goto cleanup;
+        }
+    }
+
+    /* Delete the junction point directory and create a blank slate for symlink tests */
+    bret = RemoveDirectoryW(reparse_path);
+    ok(bret, "Failed to delete junction point!\n");
+    bret = RemoveDirectoryW(target_path);
+    ok(bret, "Failed to delete junction point target!\n");
+    handle = CreateFileW(target_path, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW, 0, 0);
+    ok(handle != INVALID_HANDLE_VALUE, "Failed to create symlink target file.\n");
+    bret = WriteFile(handle, fooW, sizeof(fooW), &dwLen, NULL);
+    ok(bret, "Failed to write data to the symlink target file.\n");
+    ok(GetFileSize(handle, NULL) == sizeof(fooW), "target size is incorrect (%ld vs %d)\n",
+       GetFileSize(handle, NULL), (int)sizeof(fooW));
+    CloseHandle(handle);
+
+    /* Create the file symlink */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    ok(handle != INVALID_HANDLE_VALUE, "Failed to create symlink file.\n");
+    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get symlink file's attributes (0x%lx).\n", dwret);
+    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, 0, &buffer);
+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create symlink! (0x%lx)\n", GetLastError());
+    CloseHandle(handle);
+
+    /* Check the size of the symlink */
+    bret = GetFileAttributesExW(reparse_path, GetFileExInfoStandard, &fad);
+    ok(bret, "Failed to read file attributes from the symlink target.\n");
+    ok(fad.nFileSizeLow == 0 && fad.nFileSizeHigh == 0, "Size of symlink is not zero.\n");
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    ok(handle != INVALID_HANDLE_VALUE, "Failed to open symlink file.\n");
+    ok(GetFileSize(handle, NULL) == 0, "symlink size is not zero\n");
+    bret = ReadFile(handle, &buf, sizeof(buf), &dwLen, NULL);
+    ok(bret, "Failed to read data from the symlink.\n");
+    ok(dwLen == 0, "Length of symlink data is not zero.\n");
+    memset(&info, 0x0, sizeof(info));
+    status = pNtQueryInformationFile(handle, &iosb, &info, sizeof(info), FileAttributeTagInformation);
+    ok( status == STATUS_SUCCESS, "got %#lx\n", status );
+    ok( info.ReparseTag == IO_REPARSE_TAG_SYMLINK, "got reparse tag %#lx\n", info.ReparseTag );
+    CloseHandle(handle);
+
+    /* Check the size/data of the symlink target */
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+    {
+        win_skip("Failed to open symlink file handle (0x%lx).\n", GetLastError());
+        goto cleanup;
+    }
+    ok(GetFileSize(handle, NULL) == sizeof(fooW), "symlink target size does not match (%ld != %d)\n",
+       GetFileSize(handle, NULL), (int)sizeof(fooW));
+    bret = ReadFile(handle, &buf, sizeof(buf), &dwLen, NULL);
+    ok(bret, "Failed to read data from the symlink.\n");
+    ok(dwLen == sizeof(fooW), "Length of symlink target data does not match (%ld != %d).\n",
+       dwLen, (int)sizeof(fooW));
+    ok(!memcmp(fooW, &buf, sizeof(fooW)), "Symlink target data does not match (%s != %s).\n",
+       wine_dbgstr_wn(buf, dwLen), wine_dbgstr_w(fooW));
+    CloseHandle(handle);
+
+    /* Check the size/data of the symlink target when opened with FILE_FLAG_OPEN_REPARSE_POINT */
+    handle = CreateFileW(target_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+    {
+        win_skip("Failed to open symlink file handle (0x%lx).\n", GetLastError());
+        goto cleanup;
+    }
+    ok(GetFileSize(handle, NULL) == sizeof(fooW), "symlink target size does not match (%ld != %d)\n",
+       GetFileSize(handle, NULL), (int)sizeof(fooW));
+    bret = ReadFile(handle, &buf, sizeof(buf), &dwLen, NULL);
+    ok(bret, "Failed to read data from the symlink target.\n");
+    ok(dwLen == sizeof(fooW), "Length of symlink target data does not match (%ld != %d).\n",
+       dwLen, (int)sizeof(fooW));
+    ok(!memcmp(fooW, &buf, sizeof(fooW)), "Symlink target data does not match (%s != %s).\n",
+       wine_dbgstr_wn(buf, dwLen), wine_dbgstr_w(fooW));
+    CloseHandle(handle);
+
+    /* Check deleting a file symlink as if it were a directory */
+    bret = RemoveDirectoryW(reparse_path);
+    ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
+    err = GetLastError();
+    ok(err == ERROR_DIRECTORY,
+                 "Expected last error 0x%x for RemoveDirectory on file symlink (actually 0x%lx)!\n",
+                 ERROR_DIRECTORY, err);
+    dwret = GetFileAttributesW(reparse_path);
+    ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%lx)!\n", dwret);
+    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: 0x%lx)\n", dwret);
+
+    /* Delete the symlink as a file */
+    bret = DeleteFileW(reparse_path);
+    ok(bret, "Failed to delete symlink as a file!\n");
+
+    /* Create a blank slate for directory symlink tests */
+    bret = CreateDirectoryW(reparse_path, NULL);
+    ok(bret, "Failed to create junction point directory.\n");
+    dwret = GetFileAttributesW(reparse_path);
+    ok(dwret != (DWORD)~0, "Path doesn't exist (attributes: 0x%lx)!\n", dwret);
+    ok(!(dwret & FILE_ATTRIBUTE_REPARSE_POINT), "File is already a reparse point! (attributes: %lx)\n", dwret);
+    bret = DeleteFileW(target_path);
+    ok(bret, "Failed to delete symlink target!\n");
+    bret = CreateDirectoryW(target_path, NULL);
+    ok(bret, "Failed to create symlink target directory.\n");
+
+    /* Create the directory symlink */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+    {
+        win_skip("Failed to open symlink directory handle (0x%lx).\n", GetLastError());
+        goto cleanup;
+    }
+    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%lx).\n", dwret);
+    buffer_len = build_reparse_buffer(abs_target, IO_REPARSE_TAG_SYMLINK, 0, &buffer);
+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create symlink! (0x%lx)\n", GetLastError());
+
+    /* Check the file attributes of the symlink */
+    dwret = GetFileAttributesW(reparse_path);
+    ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%lx)!\n", dwret);
+    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: %lx)\n", dwret);
+
+    /* Read back the symlink */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
+    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
+    string_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
+    dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
+    ok(bret, "Failed to read symlink!\n");
+    ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
+                                                      wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
+    path_len = buffer->SymbolicLinkReparseBuffer.PrintNameOffset/sizeof(WCHAR);
+    path_len += buffer->SymbolicLinkReparseBuffer.PrintNameLength/sizeof(WCHAR);
+    total_len = FIELD_OFFSET(typeof(*buffer), SymbolicLinkReparseBuffer.PathBuffer[path_len+1])
+                - FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
+    ok(buffer->ReparseDataLength == total_len, "ReparseDataLength has unexpected value (%d != %d)\n",
+                                               buffer->ReparseDataLength, total_len);
+
+    /* Delete the symlink */
+    memset(&old_attrib, 0x00, sizeof(old_attrib));
+    old_attrib.LastAccessTime.QuadPart = 0x200deadcafebeef;
+    dwret = NtSetInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to set symlink folder's attributes (0x%lx).\n", dwret);
+    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
+    guid_buffer.ReparseTag = IO_REPARSE_TAG_SYMLINK;
+    bret = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
+                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to delete symlink! (0x%lx)\n", GetLastError());
+    memset(&new_attrib, 0x00, sizeof(new_attrib));
+    dwret = NtQueryInformationFile(handle, &iosb, &new_attrib, sizeof(new_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%lx).\n", dwret);
+    ok(old_attrib.LastAccessTime.QuadPart == new_attrib.LastAccessTime.QuadPart,
+       "Symlink folder's access time does not match.\n");
+    CloseHandle(handle);
+
+    /* Create a Unix/Linux symlink */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    RemoveDirectoryW(reparse_path);
+    bret = CreateDirectoryW(reparse_path, NULL);
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+    {
+        win_skip("Failed to open symlink directory handle (0x%lx).\n", GetLastError());
+        goto cleanup;
+    }
+    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%lx).\n", dwret);
+    path_len = strlen(unix_target);
+    buffer_len = offsetof(REPARSE_DATA_BUFFER, LinuxSymbolicLinkReparseBuffer.PathBuffer[path_len]);
+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
+    buffer->ReparseTag = IO_REPARSE_TAG_LX_SYMLINK;
+    buffer->ReparseDataLength = sizeof(ULONG) + path_len;
+    memcpy(buffer->LinuxSymbolicLinkReparseBuffer.PathBuffer, unix_target, path_len);
+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create symlink! (0x%lx)\n", GetLastError());
+
+    /* Read back the Unix/Linux symlink */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
+    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
+    ok(bret, "Failed to read symlink!\n");
+    string_len = buffer->ReparseDataLength - sizeof(ULONG);
+    unix_dest = &buffer->LinuxSymbolicLinkReparseBuffer.PathBuffer[0];
+    ok((memcmp(unix_dest, unix_target, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
+                                                          unix_dest, unix_target);
+    total_len = FIELD_OFFSET(typeof(*buffer), LinuxSymbolicLinkReparseBuffer.PathBuffer[path_len])
+                - FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
+    ok(buffer->ReparseDataLength == total_len, "ReparseDataLength has unexpected value (%d != %d)\n",
+                                               buffer->ReparseDataLength, total_len);
+
+    /* Delete the symlink */
+    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
+    guid_buffer.ReparseTag = IO_REPARSE_TAG_LX_SYMLINK;
+    bret = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
+                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to delete symlink! (0x%lx)\n", GetLastError());
+    CloseHandle(handle);
+    RemoveDirectoryW(reparse_path);
+    DeleteFileW(reparse_path);
+    CreateDirectoryW(reparse_path, NULL);
+
+    /* Create a relative directory symlink */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (handle == INVALID_HANDLE_VALUE)
+    {
+        win_skip("Failed to open symlink directory handle (0x%lx).\n", GetLastError());
+        goto cleanup;
+    }
+    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%lx).\n", dwret);
+    buffer_len = build_reparse_buffer(rel_target, IO_REPARSE_TAG_SYMLINK, SYMLINK_FLAG_RELATIVE, &buffer);
+    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create symlink! (0x%lx)\n", GetLastError());
+
+    /* Read back the relative symlink */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
+    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
+    ok(bret, "Failed to read relative symlink!\n");
+    string_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
+    ok(string_len != lstrlenW(rel_target), "Symlink destination length does not match ('%d' != '%d')!\n",
+                                            string_len, lstrlenW(rel_target));
+    dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
+    ok((memcmp(dest, rel_target, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
+                                                     wine_dbgstr_w(dest), wine_dbgstr_w(rel_target));
+    CloseHandle(handle);
+
+    /* Check moving a reparse point to another location */
+    lstrcpyW(new_path, path);
+    lstrcatW(new_path, parentW);
+    lstrcatW(new_path, new_reparseW);
+    bret = MoveFileW(reparse_path, new_path);
+    ok(bret, "Failed to move and rename reparse point.\n");
+    bret = MoveFileW(new_path, reparse_path);
+    ok(bret, "Failed to move and rename reparse point.\n");
+
+    /* Check copying a reparse point to another location */
+    lstrcpyW(new_path, path);
+    lstrcatW(new_path, new_reparseW);
+    bret = CopyFileW(reparse_path, new_path, TRUE);
+    ok(!bret, "Reparse points cannot be copied.\n");
+
+    /* Create a file on the other side of a reparse point */
+    lstrcpyW(thru_path, reparse_path);
+    lstrcatW(thru_path, new_reparseW);
+    handle = CreateFileW(thru_path, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW, 0, 0);
+    ok( handle != INVALID_HANDLE_VALUE, "Failed to create file on other side of reparse point: %lx.\n", GetLastError() );
+    CloseHandle(handle);
+
+cleanup:
+    /* Cleanup */
+    pRtlFreeUnicodeString(&nameW);
+    HeapFree(GetProcessHeap(), 0, long_path);
+    HeapFree(GetProcessHeap(), 0, buffer);
+    bret = DeleteFileW(thru_path);
+    ok(bret, "Failed to delete file on other side of junction point!\n");
+    bret = RemoveDirectoryW(reparse_path);
+    ok(bret, "Failed to remove temporary reparse point directory!\n");
+    bret = RemoveDirectoryW(target_path);
+    ok(bret, "Failed to remove temporary target directory!\n");
+    RemoveDirectoryW(path);
 }
 
 START_TEST(file)
@@ -5875,6 +6501,7 @@ START_TEST(file)
 
     test_read_write();
     test_NtCreateFile();
+    test_readonly();
     create_file_test();
     open_file_test();
     delete_file_test();
@@ -5908,6 +6535,6 @@ START_TEST(file)
     test_ioctl();
     test_query_ea();
     test_flush_buffers_file();
-    test_mailslot_name();
     test_reparse_points();
+    test_mailslot_name();
 }
diff --git a/dlls/ntdll/tests/rtl.c b/dlls/ntdll/tests/rtl.c
index 754f5b7..09c5d89 100644
--- a/dlls/ntdll/tests/rtl.c
+++ b/dlls/ntdll/tests/rtl.c
@@ -29,6 +29,9 @@
 #include "ip2string.h"
 #include "ddk/ntifs.h"
 #include "wine/asm.h"
+#include "initguid.h"
+#define COBJMACROS
+#include "shobjidl.h"
 
 #ifndef __WINE_WINTERNL_H
 
@@ -97,6 +100,9 @@ static BOOL      (WINAPI *pRtlIsCriticalSectionLockedByThread)(CRITICAL_SECTION
 static NTSTATUS  (WINAPI *pRtlInitializeCriticalSectionEx)(CRITICAL_SECTION *, ULONG, ULONG);
 static void *    (WINAPI *pRtlFindExportedRoutineByName)(HMODULE,const char *);
 static NTSTATUS  (WINAPI *pLdrEnumerateLoadedModules)(void *, void *, void *);
+static NTSTATUS  (WINAPI *pRtlQueryPackageIdentity)(HANDLE, WCHAR*, SIZE_T*, WCHAR*, SIZE_T*, BOOLEAN*);
+static NTSTATUS  (WINAPI *pRtlMakeSelfRelativeSD)(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,LPDWORD);
+static NTSTATUS  (WINAPI *pRtlAbsoluteToSelfRelativeSD)(PSECURITY_DESCRIPTOR,PSECURITY_DESCRIPTOR,PULONG);
 static NTSTATUS  (WINAPI *pLdrRegisterDllNotification)(ULONG, PLDR_DLL_NOTIFICATION_FUNCTION, void *, void **);
 static NTSTATUS  (WINAPI *pLdrUnregisterDllNotification)(void *);
 
@@ -140,6 +146,9 @@ static void InitFunctionPtrs(void)
         pRtlInitializeCriticalSectionEx = (void *)GetProcAddress(hntdll, "RtlInitializeCriticalSectionEx");
         pRtlFindExportedRoutineByName = (void *)GetProcAddress(hntdll, "RtlFindExportedRoutineByName");
         pLdrEnumerateLoadedModules = (void *)GetProcAddress(hntdll, "LdrEnumerateLoadedModules");
+        pRtlQueryPackageIdentity = (void *)GetProcAddress(hntdll, "RtlQueryPackageIdentity");
+        pRtlMakeSelfRelativeSD = (void *)GetProcAddress(hntdll, "RtlMakeSelfRelativeSD");
+        pRtlAbsoluteToSelfRelativeSD = (void *)GetProcAddress(hntdll, "RtlAbsoluteToSelfRelativeSD");
         pLdrRegisterDllNotification = (void *)GetProcAddress(hntdll, "LdrRegisterDllNotification");
         pLdrUnregisterDllNotification = (void *)GetProcAddress(hntdll, "LdrUnregisterDllNotification");
     }
@@ -3699,6 +3708,76 @@ static void test_RtlFirstFreeAce(void)
     HeapFree(GetProcessHeap(), 0, acl);
 }
 
+static void test_RtlQueryPackageIdentity(void)
+{
+    const WCHAR programW[] = {'M','i','c','r','o','s','o','f','t','.','W','i','n','d','o','w','s','.',
+                              'P','h','o','t','o','s','_','8','w','e','k','y','b','3','d','8','b','b','w','e','!','A','p','p',0};
+    const WCHAR fullnameW[] = {'M','i','c','r','o','s','o','f','t','.','W','i','n','d','o','w','s','.',
+                               'P','h','o','t','o','s', 0};
+    const WCHAR appidW[] = {'A','p','p',0};
+    IApplicationActivationManager *manager;
+    WCHAR buf1[MAX_PATH], buf2[MAX_PATH];
+    HANDLE process, token;
+    SIZE_T size1, size2;
+    NTSTATUS status;
+    DWORD processid;
+    HRESULT hr;
+    BOOL ret;
+
+    if (!pRtlQueryPackageIdentity)
+    {
+        win_skip("RtlQueryPackageIdentity not available\n");
+        return;
+    }
+
+    size1 = size2 = MAX_PATH * sizeof(WCHAR);
+    status = pRtlQueryPackageIdentity((HANDLE)~(ULONG_PTR)3, buf1, &size1, buf2, &size2, NULL);
+    ok(status == STATUS_NOT_FOUND, "expected STATUS_NOT_FOUND, got %08lx\n", status);
+
+    CoInitializeEx(0, COINIT_APARTMENTTHREADED);
+    hr = CoCreateInstance(&CLSID_ApplicationActivationManager, NULL, CLSCTX_LOCAL_SERVER,
+                          &IID_IApplicationActivationManager, (void **)&manager);
+    if (FAILED(hr))
+    {
+        todo_wine win_skip("Failed to create ApplicationActivationManager (%lx)\n", hr);
+        goto done;
+    }
+
+    hr = IApplicationActivationManager_ActivateApplication(manager, programW, NULL,
+                                                           AO_NOERRORUI, &processid);
+    if (FAILED(hr))
+    {
+        todo_wine win_skip("Failed to start program (%lx)\n", hr);
+        IApplicationActivationManager_Release(manager);
+        goto done;
+    }
+
+    process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_TERMINATE, FALSE, processid);
+    ok(process != NULL, "OpenProcess failed with %lx\n", GetLastError());
+    ret = OpenProcessToken(process, TOKEN_QUERY, &token);
+    ok(ret, "OpenProcessToken failed with error %lx\n", GetLastError());
+
+    size1 = size2 = MAX_PATH * sizeof(WCHAR);
+    status = pRtlQueryPackageIdentity(token, buf1, &size1, buf2, &size2, NULL);
+    ok(status == STATUS_SUCCESS, "Expected STATUS_SUCCESS, got %08lx\n", status);
+
+    ok(!memcmp(buf1, fullnameW, sizeof(fullnameW) - sizeof(WCHAR)),
+       "Expected buf1 to begin with %s, got %s\n", wine_dbgstr_w(fullnameW), wine_dbgstr_w(buf1));
+    ok(size1 >= sizeof(WCHAR) && !(size1 % sizeof(WCHAR)), "Unexpected size1 = %Iu\n", size1);
+    ok(buf1[size1 / sizeof(WCHAR) - 1] == 0, "Expected buf1[%Iu] == 0\n", size1 / sizeof(WCHAR) - 1);
+
+    ok(!lstrcmpW(buf2, appidW), "Expected buf2 to be %s, got %s\n", wine_dbgstr_w(appidW), wine_dbgstr_w(buf2));
+    ok(size2 >= sizeof(WCHAR) && !(size2 % sizeof(WCHAR)), "Unexpected size2 = %Iu\n", size2);
+    ok(buf2[size2 / sizeof(WCHAR) - 1] == 0, "Expected buf2[%Iu] == 0\n", size2 / sizeof(WCHAR) - 1);
+
+    CloseHandle(token);
+    TerminateProcess(process, 0);
+    CloseHandle(process);
+
+done:
+    CoUninitialize();
+}
+
 static void test_RtlInitializeSid(void)
 {
     SID_IDENTIFIER_AUTHORITY sid_ident = { SECURITY_NT_AUTHORITY };
@@ -3793,6 +3872,7 @@ START_TEST(rtl)
     test_RtlInitializeCriticalSectionEx();
     test_RtlLeaveCriticalSection();
     test_LdrEnumerateLoadedModules();
+    test_RtlQueryPackageIdentity();
     test_RtlMakeSelfRelativeSD();
     test_LdrRegisterDllNotification();
     test_DbgPrint();
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 4f22114..b59ec9c 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -1062,7 +1062,7 @@ static void CALLBACK timerqueue_thread_proc( void *param )
     TRACE( "starting timer queue thread\n" );
     set_thread_name(L"wine_threadpool_timerqueue");
 
-    RtlEnterCriticalSection( &timerqueue.cs );
+    enter_critical_section( &timerqueue.cs );
     for (;;)
     {
         NtQuerySystemTime( &now );
@@ -1135,7 +1135,7 @@ static void CALLBACK timerqueue_thread_proc( void *param )
     }
 
     timerqueue.thread_running = FALSE;
-    RtlLeaveCriticalSection( &timerqueue.cs );
+    leave_critical_section( &timerqueue.cs );
 
     TRACE( "terminating timer queue thread\n" );
     RtlExitUserThread( 0 );
@@ -1181,7 +1181,7 @@ static NTSTATUS tp_timerqueue_lock( struct threadpool_object *timer )
     timer->u.timer.period               = 0;
     timer->u.timer.window_length        = 0;
 
-    RtlEnterCriticalSection( &timerqueue.cs );
+    enter_critical_section( &timerqueue.cs );
 
     /* Make sure that the timerqueue thread is running. */
     if (!timerqueue.thread_running)
@@ -1202,7 +1202,7 @@ static NTSTATUS tp_timerqueue_lock( struct threadpool_object *timer )
         timerqueue.objcount++;
     }
 
-    RtlLeaveCriticalSection( &timerqueue.cs );
+    leave_critical_section( &timerqueue.cs );
     return status;
 }
 
@@ -1215,7 +1215,7 @@ static void tp_timerqueue_unlock( struct threadpool_object *timer )
 {
     assert( timer->type == TP_OBJECT_TYPE_TIMER );
 
-    RtlEnterCriticalSection( &timerqueue.cs );
+    enter_critical_section( &timerqueue.cs );
     if (timer->u.timer.timer_initialized)
     {
         /* If timer was pending, remove it. */
@@ -1234,7 +1234,7 @@ static void tp_timerqueue_unlock( struct threadpool_object *timer )
 
         timer->u.timer.timer_initialized = FALSE;
     }
-    RtlLeaveCriticalSection( &timerqueue.cs );
+    leave_critical_section( &timerqueue.cs );
 }
 
 /***********************************************************************
@@ -1253,7 +1253,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
     TRACE( "starting wait queue thread\n" );
     set_thread_name(L"wine_threadpool_waitqueue");
 
-    RtlEnterCriticalSection( &waitqueue.cs );
+    enter_critical_section( &waitqueue.cs );
 
     for (;;)
     {
@@ -1302,10 +1302,10 @@ static void CALLBACK waitqueue_thread_proc( void *param )
             /* All wait objects have been destroyed, if no new wait objects are created
              * within some amount of time, then we can shutdown this thread. */
             assert( num_handles == 0 );
-            RtlLeaveCriticalSection( &waitqueue.cs );
+            leave_critical_section( &waitqueue.cs );
             timeout.QuadPart = (ULONGLONG)THREADPOOL_WORKER_TIMEOUT * -10000;
             status = NtWaitForMultipleObjects( 1, &bucket->update_event, TRUE, bucket->alertable, &timeout );
-            RtlEnterCriticalSection( &waitqueue.cs );
+            enter_critical_section( &waitqueue.cs );
 
             if (status == STATUS_TIMEOUT && !bucket->objcount)
                 break;
@@ -1315,7 +1315,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
             handles[num_handles] = bucket->update_event;
             RtlLeaveCriticalSection( &waitqueue.cs );
             status = NtWaitForMultipleObjects( num_handles + 1, handles, TRUE, bucket->alertable, &timeout );
-            RtlEnterCriticalSection( &waitqueue.cs );
+            enter_critical_section( &waitqueue.cs );
 
             if (status >= STATUS_WAIT_0 && status < STATUS_WAIT_0 + num_handles)
             {
@@ -1399,7 +1399,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
     if (!--waitqueue.num_buckets)
         assert( list_empty( &waitqueue.buckets ) );
 
-    RtlLeaveCriticalSection( &waitqueue.cs );
+    leave_critical_section( &waitqueue.cs );
 
     TRACE( "terminating wait queue thread\n" );
 
@@ -1429,7 +1429,7 @@ static NTSTATUS tp_waitqueue_lock( struct threadpool_object *wait )
     wait->u.wait.timeout        = 0;
     wait->u.wait.handle         = INVALID_HANDLE_VALUE;
 
-    RtlEnterCriticalSection( &waitqueue.cs );
+    enter_critical_section( &waitqueue.cs );
 
     /* Try to assign to existing bucket if possible. */
     LIST_FOR_EACH_ENTRY( bucket, &waitqueue.buckets, struct waitqueue_bucket, bucket_entry )
@@ -1486,7 +1486,7 @@ static NTSTATUS tp_waitqueue_lock( struct threadpool_object *wait )
     }
 
 out:
-    RtlLeaveCriticalSection( &waitqueue.cs );
+    leave_critical_section( &waitqueue.cs );
     return status;
 }
 
@@ -1497,7 +1497,7 @@ static void tp_waitqueue_unlock( struct threadpool_object *wait )
 {
     assert( wait->type == TP_OBJECT_TYPE_WAIT );
 
-    RtlEnterCriticalSection( &waitqueue.cs );
+    enter_critical_section( &waitqueue.cs );
     if (wait->u.wait.bucket)
     {
         struct waitqueue_bucket *bucket = wait->u.wait.bucket;
@@ -1509,7 +1509,7 @@ static void tp_waitqueue_unlock( struct threadpool_object *wait )
 
         NtSetEvent( bucket->update_event, NULL );
     }
-    RtlLeaveCriticalSection( &waitqueue.cs );
+    leave_critical_section( &waitqueue.cs );
 }
 
 static void CALLBACK ioqueue_thread_proc( void *param )
@@ -1787,7 +1787,7 @@ static NTSTATUS tp_threadpool_lock( struct threadpool **out, TP_CALLBACK_ENVIRON
         pool = default_threadpool;
     }
 
-    RtlEnterCriticalSection( &pool->cs );
+    enter_critical_section( &pool->cs );
 
     /* Make sure that the threadpool has at least one thread. */
     if (!pool->num_workers)
@@ -1801,7 +1801,7 @@ static NTSTATUS tp_threadpool_lock( struct threadpool **out, TP_CALLBACK_ENVIRON
         pool->objcount++;
     }
 
-    RtlLeaveCriticalSection( &pool->cs );
+    leave_critical_section( &pool->cs );
 
     if (status != STATUS_SUCCESS)
         return status;
@@ -1817,9 +1817,9 @@ static NTSTATUS tp_threadpool_lock( struct threadpool **out, TP_CALLBACK_ENVIRON
  */
 static void tp_threadpool_unlock( struct threadpool *pool )
 {
-    RtlEnterCriticalSection( &pool->cs );
+    enter_critical_section( &pool->cs );
     pool->objcount--;
-    RtlLeaveCriticalSection( &pool->cs );
+    leave_critical_section( &pool->cs );
     tp_threadpool_release( pool );
 }
 
@@ -1957,10 +1957,10 @@ static void tp_object_initialize( struct threadpool_object *object, struct threa
         struct threadpool_group *group = object->group;
         InterlockedIncrement( &group->refcount );
 
-        RtlEnterCriticalSection( &group->cs );
+        enter_critical_section( &group->cs );
         list_add_tail( &group->members, &object->group_entry );
         object->is_group_member = TRUE;
-        RtlLeaveCriticalSection( &group->cs );
+        leave_critical_section( &group->cs );
     }
 
     if (is_simple_callback)
@@ -1987,7 +1987,7 @@ static void tp_object_submit( struct threadpool_object *object, BOOL signaled )
     assert( !object->shutdown );
     assert( !pool->shutdown );
 
-    RtlEnterCriticalSection( &pool->cs );
+    enter_critical_section( &pool->cs );
 
     /* Start new worker threads if required. */
     if (pool->num_busy_workers >= pool->num_workers &&
@@ -2010,7 +2010,7 @@ static void tp_object_submit( struct threadpool_object *object, BOOL signaled )
         RtlWakeConditionVariable( &pool->update_event );
     }
 
-    RtlLeaveCriticalSection( &pool->cs );
+    leave_critical_section( &pool->cs );
 }
 
 /***********************************************************************
@@ -2023,7 +2023,7 @@ static void tp_object_cancel( struct threadpool_object *object )
     struct threadpool *pool = object->pool;
     LONG pending_callbacks = 0;
 
-    RtlEnterCriticalSection( &pool->cs );
+    enter_critical_section( &pool->cs );
     if (object->num_pending_callbacks)
     {
         pending_callbacks = object->num_pending_callbacks;
@@ -2038,7 +2038,7 @@ static void tp_object_cancel( struct threadpool_object *object )
         object->u.io.skipped_count += object->u.io.pending_count;
         object->u.io.pending_count = 0;
     }
-    RtlLeaveCriticalSection( &pool->cs );
+    leave_critical_section( &pool->cs );
 
     while (pending_callbacks--)
         tp_object_release( object );
@@ -2067,7 +2067,7 @@ static void tp_object_wait( struct threadpool_object *object, BOOL group_wait )
 {
     struct threadpool *pool = object->pool;
 
-    RtlEnterCriticalSection( &pool->cs );
+    enter_critical_section( &pool->cs );
     while (!object_is_finished( object, group_wait ))
     {
         if (group_wait)
@@ -2075,7 +2075,7 @@ static void tp_object_wait( struct threadpool_object *object, BOOL group_wait )
         else
             RtlSleepConditionVariableCS( &object->finished_event, &pool->cs, NULL );
     }
-    RtlLeaveCriticalSection( &pool->cs );
+    leave_critical_section( &pool->cs );
 }
 
 static void tp_ioqueue_unlock( struct threadpool_object *io )
@@ -2129,13 +2129,13 @@ static BOOL tp_object_release( struct threadpool_object *object )
     {
         struct threadpool_group *group = object->group;
 
-        RtlEnterCriticalSection( &group->cs );
+        enter_critical_section( &group->cs );
         if (object->is_group_member)
         {
             list_remove( &object->group_entry );
             object->is_group_member = FALSE;
         }
-        RtlLeaveCriticalSection( &group->cs );
+        leave_critical_section( &group->cs );
 
         tp_group_release( group );
     }
@@ -2337,7 +2337,7 @@ static void CALLBACK threadpool_worker_proc( void *param )
     TRACE( "starting worker thread for pool %p\n", pool );
     set_thread_name(L"wine_threadpool_worker");
 
-    RtlEnterCriticalSection( &pool->cs );
+    enter_critical_section( &pool->cs );
     for (;;)
     {
         while ((ptr = threadpool_get_next_item( pool )))
@@ -2377,7 +2377,7 @@ static void CALLBACK threadpool_worker_proc( void *param )
         }
     }
     pool->num_workers--;
-    RtlLeaveCriticalSection( &pool->cs );
+    leave_critical_section( &pool->cs );
 
     TRACE( "terminating worker thread for pool %p\n", pool );
     tp_threadpool_release( pool );
@@ -2625,7 +2625,7 @@ NTSTATUS WINAPI TpCallbackMayRunLong( TP_CALLBACK_INSTANCE *instance )
         return STATUS_SUCCESS;
 
     pool = object->pool;
-    RtlEnterCriticalSection( &pool->cs );
+    enter_critical_section( &pool->cs );
 
     /* Start new worker threads if required. */
     if (pool->num_busy_workers >= pool->num_workers)
@@ -2640,7 +2640,7 @@ NTSTATUS WINAPI TpCallbackMayRunLong( TP_CALLBACK_INSTANCE *instance )
         }
     }
 
-    RtlLeaveCriticalSection( &pool->cs );
+    leave_critical_section( &pool->cs );
     this->may_run_long = TRUE;
     return status;
 }
@@ -2721,13 +2721,13 @@ VOID WINAPI TpDisassociateCallback( TP_CALLBACK_INSTANCE *instance )
         return;
 
     pool = object->pool;
-    RtlEnterCriticalSection( &pool->cs );
+    enter_critical_section( &pool->cs );
 
     object->num_associated_callbacks--;
     if (object_is_finished( object, FALSE ))
         RtlWakeAllConditionVariable( &object->finished_event );
 
-    RtlLeaveCriticalSection( &pool->cs );
+    leave_critical_section( &pool->cs );
     this->associated = FALSE;
 }
 
@@ -2779,7 +2779,7 @@ VOID WINAPI TpReleaseCleanupGroupMembers( TP_CLEANUP_GROUP *group, BOOL cancel_p
 
     TRACE( "%p %u %p\n", group, cancel_pending, userdata );
 
-    RtlEnterCriticalSection( &this->cs );
+    enter_critical_section( &this->cs );
 
     /* Unset group, increase references, and mark objects for shutdown */
     LIST_FOR_EACH_ENTRY_SAFE( object, next, &this->members, struct threadpool_object, group_entry )
@@ -2805,7 +2805,7 @@ VOID WINAPI TpReleaseCleanupGroupMembers( TP_CLEANUP_GROUP *group, BOOL cancel_p
     list_init( &members );
     list_move_tail( &members, &this->members );
 
-    RtlLeaveCriticalSection( &this->cs );
+    leave_critical_section( &this->cs );
 
     /* Cancel pending callbacks if requested */
     if (cancel_pending)
@@ -2928,10 +2928,10 @@ VOID WINAPI TpSetPoolMaxThreads( TP_POOL *pool, DWORD maximum )
 
     TRACE( "%p %lu\n", pool, maximum );
 
-    RtlEnterCriticalSection( &this->cs );
+    enter_critical_section( &this->cs );
     this->max_workers = max( maximum, 1 );
     this->min_workers = min( this->min_workers, this->max_workers );
-    RtlLeaveCriticalSection( &this->cs );
+    leave_critical_section( &this->cs );
 }
 
 /***********************************************************************
@@ -2944,7 +2944,7 @@ BOOL WINAPI TpSetPoolMinThreads( TP_POOL *pool, DWORD minimum )
 
     TRACE( "%p %lu\n", pool, minimum );
 
-    RtlEnterCriticalSection( &this->cs );
+    enter_critical_section( &this->cs );
 
     while (this->num_workers < minimum)
     {
@@ -2959,7 +2959,7 @@ BOOL WINAPI TpSetPoolMinThreads( TP_POOL *pool, DWORD minimum )
         this->max_workers = max( this->min_workers, this->max_workers );
     }
 
-    RtlLeaveCriticalSection( &this->cs );
+    leave_critical_section( &this->cs );
     return !status;
 }
 
@@ -2975,7 +2975,7 @@ VOID WINAPI TpSetTimer( TP_TIMER *timer, LARGE_INTEGER *timeout, LONG period, LO
 
     TRACE( "%p %p %lu %lu\n", timer, timeout, period, window_length );
 
-    RtlEnterCriticalSection( &timerqueue.cs );
+    enter_critical_section( &timerqueue.cs );
 
     assert( this->u.timer.timer_initialized );
     this->u.timer.timer_set = timeout != NULL;
@@ -3035,7 +3035,7 @@ VOID WINAPI TpSetTimer( TP_TIMER *timer, LARGE_INTEGER *timeout, LONG period, LO
         this->u.timer.timer_pending = TRUE;
     }
 
-    RtlLeaveCriticalSection( &timerqueue.cs );
+    leave_critical_section( &timerqueue.cs );
 
     if (submit_timer)
        tp_object_submit( this, FALSE );
@@ -3051,7 +3051,7 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
 
     TRACE( "%p %p %p\n", wait, handle, timeout );
 
-    RtlEnterCriticalSection( &waitqueue.cs );
+    enter_critical_section( &waitqueue.cs );
 
     assert( this->u.wait.bucket );
     this->u.wait.handle = handle;
@@ -3090,7 +3090,7 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
         NtSetEvent( bucket->update_event, NULL );
     }
 
-    RtlLeaveCriticalSection( &waitqueue.cs );
+    leave_critical_section( &waitqueue.cs );
 }
 
 /***********************************************************************
diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index ad9ab0d..427c577 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -1924,6 +1924,7 @@ static void init_peb( RTL_USER_PROCESS_PARAMETERS *params, void *module )
  */
 static RTL_USER_PROCESS_PARAMETERS *build_initial_params( void **module )
 {
+    static const char *args[] = { "start.exe", "/exec" };
     static const WCHAR valueW[] = {'1',0};
     static const WCHAR pathW[] = {'P','A','T','H'};
     RTL_USER_PROCESS_PARAMETERS *params = NULL;
@@ -1952,29 +1953,8 @@ static RTL_USER_PROCESS_PARAMETERS *build_initial_params( void **module )
     add_registry_environment( &env, &env_pos, &env_size );
     env[env_pos++] = 0;
 
-    status = load_main_exe( NULL, main_argv[1], curdir, 0, &image, module );
-    if (!status)
-    {
-        char *loader;
-
-        if (main_image_info.ImageCharacteristics & IMAGE_FILE_DLL) status = STATUS_INVALID_IMAGE_FORMAT;
-        /* if we have to use a different loader, fall back to start.exe */
-        if ((loader = get_alternate_wineloader( main_image_info.Machine )))
-        {
-            free( loader );
-            status = STATUS_INVALID_IMAGE_FORMAT;
-        }
-    }
-
-    if (status)  /* try launching it through start.exe */
-    {
-        static const char *args[] = { "start.exe", "/exec" };
-        free( image );
-        if (*module) NtUnmapViewOfSection( GetCurrentProcess(), *module );
-        load_start_exe( &image, module );
-        prepend_argv( args, 2 );
-    }
-    else rebuild_argv();
+    load_start_exe( &image, module );
+    prepend_argv( args, 2 );
 
     main_wargv = build_wargv( get_dos_path( image ));
     cmdline = build_command_line( main_wargv );
diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index ee68e4d..f9681b1 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -36,6 +36,8 @@
 #include <stdlib.h>
 #include <stdint.h>
 #include <stdio.h>
+#include <math.h>
+#include <libgen.h>
 #include <limits.h>
 #include <unistd.h>
 #ifdef HAVE_MNTENT_H
@@ -124,6 +126,7 @@
 #include "wine/list.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "ntifs.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(file);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
@@ -135,6 +138,12 @@ WINE_DECLARE_DEBUG_CHANNEL(winediag);
 #undef EXT2_IOC_GETFLAGS
 #undef EXT4_CASEFOLD_FL
 
+#ifndef RENAME_EXCHANGE
+#define RENAME_EXCHANGE		(1 << 1)
+#endif
+
+#define SYM_MAX (PATH_MAX-1) /* PATH_MAX includes the NUL character */
+
 #ifdef linux
 
 /* We want the real kernel dirent structure, not the libc one */
@@ -246,6 +255,173 @@ static const BOOL is_case_sensitive = FALSE;
 static pthread_mutex_t dir_mutex = PTHREAD_MUTEX_INITIALIZER;
 static pthread_mutex_t mnt_mutex = PTHREAD_MUTEX_INITIALIZER;
 
+#ifndef HAVE_RENAMEAT2
+int renameat2( int olddirfd, const char *oldpath, int newdirfd, const char *newpath,
+               unsigned int flags )
+{
+    if (flags == 0)
+        return renameat( olddirfd, oldpath, newdirfd, newpath );
+#if defined(__NR_renameat2)
+    return syscall( __NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags );
+#elif defined(RENAME_SWAP)
+    return renameatx_np(olddirfd, oldpath, newdirfd, newpath,
+                        (flags & RENAME_EXCHANGE ? RENAME_SWAP : 0));
+#else
+    errno = ENOSYS;
+    return -1;
+#endif
+}
+#endif /* HAVE_RENAMEAT2 */
+
+static char *itoa( int i )
+{
+    static char buffer[11];
+
+    snprintf(buffer, sizeof(buffer), "%d", i);
+    return buffer;
+}
+
+/* base64url (RFC 4648 Â§5) encode a binary string
+ * 1) start with base64
+ * 2) replace '+' by '-' and replace '/' by '_'
+ * 3) do not add padding characters
+ * 4) do not add line separators
+ */
+static UINT encode_base64url( const char *bin, unsigned int len, char *base64 )
+{
+    UINT n = 0, x;
+    static const char base64enc[] =
+        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
+
+    while (len > 0)
+    {
+        /* first 6 bits, all from bin[0] */
+        base64[n++] = base64enc[(bin[0] & 0xfc) >> 2];
+        x = (bin[0] & 3) << 4;
+
+        /* next 6 bits, 2 from bin[0] and 4 from bin[1] */
+        if (len == 1)
+        {
+            base64[n++] = base64enc[x];
+            break;
+        }
+        base64[n++] = base64enc[x | ((bin[1] & 0xf0) >> 4)];
+        x = (bin[1] & 0x0f) << 2;
+
+        /* next 6 bits 4 from bin[1] and 2 from bin[2] */
+        if (len == 2)
+        {
+            base64[n++] = base64enc[x];
+            break;
+        }
+        base64[n++] = base64enc[x | ((bin[2] & 0xc0) >> 6)];
+
+        /* last 6 bits, all from bin [2] */
+        base64[n++] = base64enc[bin[2] & 0x3f];
+        bin += 3;
+        len -= 3;
+    }
+    base64[n] = 0;
+    return n;
+}
+
+static inline char decode_base64url_char( char c )
+{
+    if (c >= 'A' && c <= 'Z') return c - 'A';
+    if (c >= 'a' && c <= 'z') return c - 'a' + 26;
+    if (c >= '0' && c <= '9') return c - '0' + 52;
+    if (c == '-') return 62;
+    if (c == '_') return 63;
+    return 64;
+}
+
+/* decode a base64url (RFC 4648 Â§5) binary string
+ * 1) start with base64
+ * 2) replace '+' by '-' and replace '/' by '_'
+ * 3) do not add padding characters
+ * 4) do not add line separators
+ */
+static unsigned int decode_base64url( const char *base64, unsigned int len, char *buf )
+{
+    unsigned int i = 0;
+    char c0, c1, c2, c3;
+    const char *p = base64;
+
+    while (len > 4)
+    {
+        if ((c0 = decode_base64url_char( p[0] )) > 63) return 0;
+        if ((c1 = decode_base64url_char( p[1] )) > 63) return 0;
+        if ((c2 = decode_base64url_char( p[2] )) > 63) return 0;
+        if ((c3 = decode_base64url_char( p[3] )) > 63) return 0;
+
+        if (buf)
+        {
+            buf[i + 0] = (c0 << 2) | (c1 >> 4);
+            buf[i + 1] = (c1 << 4) | (c2 >> 2);
+            buf[i + 2] = (c2 << 6) |  c3;
+        }
+        len -= 4;
+        i += 3;
+        p += 4;
+    }
+    if (len == 2)
+    {
+        if ((c0 = decode_base64url_char( p[0] )) > 63) return 0;
+        if ((c1 = decode_base64url_char( p[1] )) > 63) return 0;
+
+        if (buf) buf[i] = (c0 << 2) | (c1 >> 4);
+        i++;
+    }
+    else if (len == 3)
+    {
+        if ((c0 = decode_base64url_char( p[0] )) > 63) return 0;
+        if ((c1 = decode_base64url_char( p[1] )) > 63) return 0;
+        if ((c2 = decode_base64url_char( p[2] )) > 63) return 0;
+
+        if (buf)
+        {
+            buf[i + 0] = (c0 << 2) | (c1 >> 4);
+            buf[i + 1] = (c1 << 4) | (c2 >> 2);
+        }
+        i += 2;
+    }
+    else
+    {
+        if ((c0 = decode_base64url_char( p[0] )) > 63) return 0;
+        if ((c1 = decode_base64url_char( p[1] )) > 63) return 0;
+        if ((c2 = decode_base64url_char( p[2] )) > 63) return 0;
+        if ((c3 = decode_base64url_char( p[3] )) > 63) return 0;
+
+        if (buf)
+        {
+            buf[i + 0] = (c0 << 2) | (c1 >> 4);
+            buf[i + 1] = (c1 << 4) | (c2 >> 2);
+            buf[i + 2] = (c2 << 6) |  c3;
+        }
+        i += 3;
+    }
+    return i;
+}
+
+/* create a directory and all the needed parent directories */
+static int mkdir_p( int dirfd, const char *path, mode_t mode )
+{
+    char path_tmp[PATH_MAX], *p;
+
+    strcpy( path_tmp, path );
+    for (p = path_tmp + 1; *p; p++) {
+        if (*p == '/') {
+            *p = '\0';
+            if (mkdirat( dirfd, path_tmp, mode ) != 0 && errno != EEXIST)
+                return -1;
+            *p = '/';
+        }
+    }
+    if (mkdirat( dirfd, path_tmp, mode ) != 0 && errno != EEXIST)
+        return -1;
+    return 0;
+}
+
 /* check if a given Unicode char is OK in a DOS short name */
 static inline BOOL is_invalid_dos_char( WCHAR ch )
 {
@@ -1565,6 +1741,28 @@ static int parse_samba_dos_attrib_data( char *data, int len )
 }
 
 
+/* determine whether a reparse point is meant to be a directory or a file */
+static int is_reparse_dir( int fd, const char *path, BOOL *is_dir )
+{
+    char link_path[PATH_MAX], *p;
+    int ret;
+
+    if ((ret = readlinkat( fd, path, link_path, sizeof(link_path) )) < 0)
+        return ret;
+    /* confirm that this file is a reparse point */
+    if (strncmp( link_path, ".REPARSE_POINT/", 15) != 0)
+        return -1;
+    /* skip past the reparse point indicator and the filename */
+    p = &link_path[15];
+    if ((p = strchr( p, '/' )) == NULL)
+        return -1;
+    p++;
+    /* read the flag indicating whether this reparse point is a directory */
+    if (is_dir) *is_dir = (*p == '.');
+    return 0;
+}
+
+
 static BOOL fd_is_mount_point( int fd, const struct stat *st )
 {
     struct stat parent;
@@ -1582,6 +1780,18 @@ static int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULON
     *attr = 0;
     ret = fstat( fd, st );
     if (ret == -1) return ret;
+    if (S_ISLNK( st->st_mode ))
+    {
+        BOOL is_dir;
+
+        /* symbolic links (either junction points or NT symlinks) are "reparse points" */
+        *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+        /* symbolic links always report size 0 */
+        st->st_size = 0;
+        /* whether a reparse point is a file or a directory is stored inside the link target */
+        if (is_reparse_dir( fd, "", &is_dir ) == 0)
+            st->st_mode = (st->st_mode & ~S_IFMT) | (is_dir ? S_IFDIR : S_IFREG);
+    }
     *attr |= get_file_attributes( st );
     /* consider mount points to be reparse points (IO_REPARSE_TAG_MOUNT_POINT) */
     if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, st ))
@@ -1664,10 +1874,17 @@ static int get_file_info( const char *path, struct stat *st, ULONG *attr )
     if (ret == -1) return ret;
     if (S_ISLNK( st->st_mode ))
     {
-        ret = stat( path, st );
-        if (ret == -1) return ret;
-        /* is a symbolic link and a directory, consider these "reparse points" */
-        if (S_ISDIR( st->st_mode )) *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+        BOOL is_dir;
+
+        /* return information about the destination (unless this is a dangling symlink) */
+        stat( path, st );
+        /* symbolic links (either junction points or NT symlinks) are "reparse points" */
+        *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
+        /* symbolic links always report size 0 */
+        st->st_size = 0;
+        /* whether a reparse point is a file or a directory is stored inside the link target */
+        if (is_reparse_dir( AT_FDCWD, path, &is_dir ) == 0)
+            st->st_mode = (st->st_mode & ~S_IFMT) | (is_dir ? S_IFDIR : S_IFREG);
     }
     else if (S_ISDIR( st->st_mode ) && (parent_path = malloc( strlen(path) + 4 )))
     {
@@ -2721,7 +2938,7 @@ static NTSTATUS find_file_in_dir( char *unix_name, int pos, const WCHAR *name, i
     if (ret >= 0 && ret <= MAX_DIR_ENTRY_LEN)
     {
         unix_name[pos + ret] = 0;
-        if (!stat( unix_name, &st )) return STATUS_SUCCESS;
+        if (!lstat( unix_name, &st )) return STATUS_SUCCESS;
     }
     if (check_case) goto not_found;  /* we want an exact match */
 
@@ -3335,15 +3552,696 @@ done:
 }
 
 
+static NTSTATUS get_reparse_target( UNICODE_STRING *nt_target, REPARSE_DATA_BUFFER *buffer,
+                                    int *is_relative )
+{
+    int target_len, offset;
+    WCHAR *target;
+
+    switch( buffer->ReparseTag )
+    {
+    case IO_REPARSE_TAG_MOUNT_POINT:
+        offset = buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR);
+        target = &buffer->MountPointReparseBuffer.PathBuffer[offset];
+        target_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
+        *is_relative = FALSE;
+        break;
+    case IO_REPARSE_TAG_SYMLINK:
+        offset = buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR);
+        target = &buffer->SymbolicLinkReparseBuffer.PathBuffer[offset];
+        target_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
+        *is_relative = (buffer->SymbolicLinkReparseBuffer.Flags & SYMLINK_FLAG_RELATIVE) == SYMLINK_FLAG_RELATIVE;
+        break;
+    default:
+        return STATUS_IO_REPARSE_TAG_NOT_HANDLED;
+    }
+    nt_target->Buffer = target;
+    nt_target->Length = target_len;
+    return STATUS_REPARSE;
+}
+
+
+int find_prefix_end( const char *path, int *offset )
+{
+    static int config_dir_len = 0;
+
+    if (!config_dir_len) config_dir_len = strlen(config_dir);
+    if (path[config_dir_len] != '/') return FALSE;
+    if (strncmp( config_dir, path, config_dir_len ) != 0) return FALSE;
+    *offset = config_dir_len;
+    return TRUE;
+}
+
+
+/* add a symlink to the unix target at the last point of the reparse point metadata */
+NTSTATUS create_reparse_target( int dirfd, const char *unix_src, int depth, const char *link_path,
+                                REPARSE_DATA_BUFFER *buffer )
+{
+    ULONG nt_path_len = PATH_MAX, unix_path_len = PATH_MAX;
+    UNICODE_STRING nt_target, nt_full_target;
+    ULONG unix_target_len = PATH_MAX;
+    char *unix_path = NULL, *d;
+    char target_path[PATH_MAX];
+    OBJECT_ATTRIBUTES attr;
+    int nt_target_len;
+    char *unix_target;
+    int is_relative;
+    NTSTATUS status;
+    WCHAR *nt_path;
+
+    if ((status = get_reparse_target( &nt_target, buffer, &is_relative )) != STATUS_REPARSE)
+        return status;
+    /* if the target path is relative then turn the source path into an NT path */
+    if (is_relative)
+    {
+        UNICODE_STRING nt_path_tmp;
+
+        /* resolve the NT path of the source */
+        unix_path = malloc( strlen(unix_src) + 2 );
+        if (!unix_path) return STATUS_NO_MEMORY;
+        strcpy( unix_path, unix_src );
+        d = dirname( unix_path );
+        if (d != unix_path) strcpy( unix_path, d );
+        strcat( unix_path, "/");
+        for (;;)
+        {
+            nt_path = malloc( nt_path_len * sizeof(WCHAR) );
+            if (!nt_path)
+            {
+                free( unix_path );
+                return STATUS_NO_MEMORY;
+            }
+            status = wine_unix_to_nt_file_name( unix_path, nt_path, &nt_path_len );
+            if (status != STATUS_BUFFER_TOO_SMALL) break;
+            free( nt_path );
+        }
+        free( unix_path );
+        if (status != STATUS_SUCCESS)
+            return status;
+        /* re-resolve the unix path for the source */
+        nt_path_tmp.Buffer = nt_path;
+        nt_path_tmp.Length = wcslen(nt_path) * sizeof(WCHAR);
+        InitializeObjectAttributes( &attr, &nt_path_tmp, 0, 0, NULL );
+        for (;;)
+        {
+            unix_path = malloc( unix_path_len );
+            if (!unix_path) return STATUS_NO_MEMORY;
+            status = wine_nt_to_unix_file_name( &attr, unix_path, &unix_path_len, FILE_OPEN_IF );
+            if (status != STATUS_BUFFER_TOO_SMALL) break;
+            free( unix_path );
+        }
+    }
+    else
+    {
+        nt_path = malloc( sizeof(WCHAR) );
+        if (!nt_path) return STATUS_NO_MEMORY;
+        nt_path[0] = 0;
+    }
+    /* append the target path (if absolute, appends to empty string) */
+    nt_target_len = nt_target.Length + sizeof(WCHAR);
+    nt_full_target.MaximumLength = nt_target_len + wcslen(nt_path) * sizeof(WCHAR);
+    nt_full_target.Buffer = malloc( nt_full_target.MaximumLength + 2 );
+    if (!nt_full_target.Buffer)
+    {
+        status = STATUS_NO_MEMORY;
+        goto cleanup;
+    }
+    wcscpy( nt_full_target.Buffer, nt_path );
+    free( nt_path );
+    memcpy( &nt_full_target.Buffer[wcslen(nt_full_target.Buffer)], nt_target.Buffer, nt_target_len );
+    nt_full_target.Length = wcslen( nt_full_target.Buffer ) * sizeof(WCHAR);
+    /* find the unix path for the target */
+    InitializeObjectAttributes( &attr, &nt_full_target, 0, 0, NULL );
+    for (;;)
+    {
+        unix_target = malloc( unix_target_len );
+        if (!unix_target)
+        {
+            status = STATUS_NO_MEMORY;
+            goto cleanup;
+        }
+        status = wine_nt_to_unix_file_name( &attr, unix_target, &unix_target_len, FILE_OPEN_IF );
+        if (status != STATUS_BUFFER_TOO_SMALL) break;
+        free( unix_target );
+    }
+    /* create the symlink to the target at the last metadata location */
+    if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+    {
+        const char prefix_string[] = "${WINEPREFIX}";
+        int append_prefix = FALSE;
+        int relative_offset;
+
+        target_path[0] = 0;
+        relative_offset = unix_path ? strlen( unix_path ) : 0;
+        if (unix_path && strncmp( unix_path, unix_target, relative_offset ) != 0)
+        {
+            relative_offset = 0;
+            is_relative = FALSE;
+        }
+        else if (find_prefix_end( unix_target, &relative_offset ))
+        {
+            char prefix_link[MAX_PATH];
+
+            append_prefix = TRUE;
+            is_relative = FALSE;
+            strcpy( prefix_link, link_path );
+            prefix_link[strlen(prefix_link)-1] = 0;
+            strcat( prefix_link, prefix_string );
+            symlink( config_dir, prefix_link );
+        }
+        for (;is_relative && depth > 0; depth--)
+            strcat( target_path, "../" );
+        if (append_prefix)
+            strcat( target_path, prefix_string );
+        strcat( target_path, &unix_target[relative_offset] );
+        TRACE( "adding reparse point target: %s\n", target_path );
+        symlinkat( target_path, dirfd, link_path );
+    }
+    free( unix_target );
+    status = STATUS_SUCCESS;
+
+cleanup:
+    free( unix_path );
+    free( nt_full_target.Buffer );
+    return status;
+}
+
+
+/*
+ * Retrieve the unix name corresponding to a file handle, remove that directory, and then symlink
+ * the requested directory to the location of the old directory.
+ */
+NTSTATUS create_reparse_point(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+{
+    int buffer_len = buffer->ReparseDataLength+FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
+    char target_path[PATH_MAX], link_path[PATH_MAX], link_dir[PATH_MAX];
+    int encoded_len = (int)ceil(buffer_len*4/3.0) + 1, chunk_len;
+    char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
+    BOOL needs_close, tempdir_created = FALSE;
+    char filename_buf[PATH_MAX], *filename;
+    char *unix_src = NULL, *encoded = NULL;
+    int i = 0, j = 0, depth = 0, fd;
+    int link_dir_fd = -1;
+    NTSTATUS status;
+    struct stat st;
+    BOOL is_dir;
+
+    if (buffer_len > 16*1024)
+        return STATUS_IO_REPARSE_DATA_INVALID;
+
+    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &fd, &needs_close, NULL, NULL )))
+        return status;
+    if (fstat( fd, &st ) == -1)
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+    if ((status = server_get_unix_name( handle, &unix_src )))
+        goto cleanup;
+    is_dir = S_ISDIR( st.st_mode );
+    is_reparse_dir( AT_FDCWD, unix_src, &is_dir ); /* keep type (replace existing reparse point) */
+    encoded = malloc( encoded_len );
+    if (!encoded)
+    {
+        status = STATUS_NO_MEMORY;
+        goto cleanup;
+    }
+    encoded_len = encode_base64url( (const char *)buffer, buffer_len, encoded );
+
+    TRACE( "Linking %s to %s\n", unix_src, encoded );
+    strcpy( filename_buf, unix_src );
+    filename = basename( filename_buf );
+
+    /* Create the symlink that represents the initial data in the reparse tag:
+     * *) Begin all reparse tags with the hidden folder .REPARSE_POINT.  This serves two purposes:
+     *    1) it makes it easy to identify reparse points
+     *    2) if the reparse buffer exceeds what can be stored in a single symlink (4095+1 bytes)
+     *       then we need to store additional data, so link to it and store it in a hidden folder
+     * *) Append the filename of the reparse point to the hidden folder, this ensures that if
+     *    multiple reparse points contain the same data that there is no possibility of collision
+     * *) Append a special flag to indicate whether this is a directory (./) or file (/)
+     * *) Append the base64-url encoded reparse point buffer
+     * *) Append the filename of the first continuing symlink (0) in case we need it
+     */
+    if (buffer->ReparseTag != IO_REPARSE_TAG_LX_SYMLINK)
+    {
+        strcpy( target_path, ".REPARSE_POINT/" );
+        strcat( target_path, filename );
+        strcat( target_path, "/" );
+        if (is_dir)
+            strcat( target_path, "." );
+        strcat( target_path, "/" );
+        for (depth=0; i<encoded_len && strlen(target_path)<SYM_MAX-2; i+=chunk_len, depth++)
+        {
+            chunk_len = min(NAME_MAX, SYM_MAX-2-strlen(target_path));
+            strncat( target_path, &encoded[i], chunk_len );
+            strcat( target_path, "/" );
+        }
+        strcat( target_path, itoa(j) );
+    }
+    else
+    {
+        int unix_dest_len;
+        char *unix_dest;
+
+        unix_dest_len = buffer->ReparseDataLength - sizeof(ULONG);
+        unix_dest = (char *) &buffer->LinuxSymbolicLinkReparseBuffer.PathBuffer[0];
+        memcpy( target_path, unix_dest, unix_dest_len );
+        target_path[unix_dest_len] = 0;
+        i = encoded_len; /* no extended metadata to store */
+    }
+
+    /* Produce the link in a temporary location in the same folder */
+    strcpy( tmpdir, unix_src );
+    d = dirname( tmpdir);
+    if (d != tmpdir) strcpy( tmpdir, d );
+    strcat( tmpdir, "/.winelink.XXXXXX" );
+    if (mkdtemp( tmpdir ) == NULL)
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+    tempdir_created = TRUE;
+    strcpy( tmplink, tmpdir );
+    strcat( tmplink, "/tmplink" );
+    if (symlink( target_path, tmplink ))
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+
+    /* change to the link folder so that we can build any necessary additional data */
+    strcpy( link_dir, tmpdir );
+    link_dir[strlen(link_dir)-16] = 0;
+    link_dir_fd = open( link_dir, O_RDONLY|O_DIRECTORY );
+
+    /* If there is any further information in the reparse tag then store it in the hidden folder */
+    while(i < encoded_len)
+    {
+        int fd;
+
+        j++;
+        strcpy( link_path, target_path );
+
+        target_path[0] = 0;
+        for (; depth>0; depth--)
+        {
+            strcat( target_path, "../" );
+        }
+        for (depth=0; i<encoded_len && strlen(target_path)<SYM_MAX-2; i+=chunk_len, depth++)
+        {
+            chunk_len = min(NAME_MAX, SYM_MAX-2-strlen(target_path));
+            strncat( target_path, &encoded[i], chunk_len );
+            strcat( target_path, "/" );
+        }
+        strcat( target_path, itoa(j) );
+
+        strcpy( link_dir, link_path );
+        link_dir[strlen(link_dir)-1] = 0;
+        if (mkdir_p( link_dir_fd, link_dir, 0777))
+        {
+            status = errno_to_status( errno );
+            goto cleanup;
+        }
+        if (symlinkat( target_path, link_dir_fd, link_path ))
+        {
+            status = errno_to_status( errno );
+            goto cleanup;
+        }
+        fd = openat( link_dir_fd, link_dir, O_RDONLY|O_DIRECTORY );
+        close( link_dir_fd );
+        link_dir_fd = fd;
+    }
+
+    /* create the very last link directory */
+    if (IsReparseTagNameSurrogate( buffer->ReparseTag )
+        && buffer->ReparseTag != IO_REPARSE_TAG_LX_SYMLINK)
+    {
+        strcpy( link_path, target_path );
+        strcpy( link_dir, link_path );
+        link_dir[strlen(link_dir)-1] = 0;
+        if (mkdir_p( link_dir_fd, link_dir, 0777 ) == 0)
+            create_reparse_target( link_dir_fd, unix_src, depth + 2, link_path, buffer );
+    }
+
+    /* Atomically move the initial link into position */
+    if (!renameat2( -1, tmplink, -1, unix_src, RENAME_EXCHANGE ))
+    {
+        /* success: link and folder/file have switched locations */
+        if (S_ISDIR( st.st_mode ))
+            rmdir( tmplink ); /* remove the folder (at link location) */
+        else
+            unlink( tmplink ); /* remove the file (at link location) */
+    }
+    else if (errno == ENOSYS)
+    {
+        FIXME( "Atomic exchange of directory with symbolic link unsupported on this system, "
+               "using unsafe exchange instead.\n" );
+        if (rmdir( unix_src ))
+        {
+            status = errno_to_status( errno );
+            goto cleanup;
+        }
+        if (rename( tmplink, unix_src ))
+        {
+            status = errno_to_status( errno );
+            goto cleanup; /* not moved, orignal file/folder at destination is orphaned */
+        }
+    }
+    else
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+    status = STATUS_SUCCESS;
+
+cleanup:
+    if (link_dir_fd != -1) close( link_dir_fd );
+    if (tempdir_created) rmdir( tmpdir );
+    if (needs_close) close( fd );
+    free( unix_src );
+    free( encoded );
+
+    return status;
+}
+
+
+/*
+ * Obtain the reparse point buffer from the unix filename for the reparse point.
+ */
+NTSTATUS get_reparse_point_unix(const char *unix_name, REPARSE_DATA_BUFFER *buffer, ULONG *size)
+{
+    char link_dir[PATH_MAX], link_path[PATH_MAX], *d;
+    const char prefix_string[] = "${WINEPREFIX}";
+    int link_path_len, buffer_len, encoded_len;
+    REPARSE_DATA_BUFFER header;
+    ULONG out_size = *size;
+    char *encoded = NULL;
+    int link_dir_fd = -1;
+    NTSTATUS status;
+    ssize_t ret;
+    int depth;
+    char *p;
+
+    ret = readlink( unix_name, link_path, sizeof(link_path) );
+    if (ret < 0)
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+    link_path_len = ret;
+    link_path[link_path_len] = 0;
+    if (strncmp( link_path, ".REPARSE_POINT/", 15 ) != 0)
+    {
+        /* treat regular Unix symlinks as WSL Linux/Unix symlinks */
+        *size = FIELD_OFFSET(typeof(*buffer), LinuxSymbolicLinkReparseBuffer.PathBuffer[link_path_len]);
+        if (*size > out_size) { status = STATUS_BUFFER_TOO_SMALL; goto cleanup; }
+        buffer->ReparseTag = IO_REPARSE_TAG_LX_SYMLINK;
+        buffer->LinuxSymbolicLinkReparseBuffer.Version = 2;
+        memcpy( &buffer->LinuxSymbolicLinkReparseBuffer.PathBuffer[0], link_path, link_path_len );
+        buffer->ReparseDataLength = *size - FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
+        status = STATUS_SUCCESS;
+        goto cleanup;
+    }
+    encoded_len = link_path_len;
+    encoded = malloc( encoded_len );
+    if (!encoded)
+    {
+        status = STATUS_NO_MEMORY;
+        goto cleanup;
+    }
+
+    /* Copy the encoded data from the inital symlink */
+    encoded[0] = 0;
+    p = &link_path[15];
+    if ((p = strchr( p, '/' )) == NULL)
+    {
+        status = STATUS_IO_REPARSE_DATA_INVALID;
+        goto cleanup;
+    }
+    p++;
+    if (*(p++) == '.')
+        p++;
+    for (depth=0; p < link_path + link_path_len; p += NAME_MAX+1, depth++)
+        strncat( encoded, p, NAME_MAX );
+    encoded[strlen(encoded)-1] = 0; /* chunk id */
+    encoded[strlen(encoded)-1] = 0; /* final slash */
+
+    /* get the length of the full buffer so that we know when to stop collecting data */
+    decode_base64url( encoded, sizeof(header), (char*)&header );
+    buffer_len = header.ReparseDataLength+FIELD_OFFSET(typeof(header), GenericReparseBuffer);
+    *size = buffer_len;
+
+    if (buffer_len > out_size)
+    {
+        status = STATUS_BUFFER_TOO_SMALL;
+        goto cleanup;
+    }
+    encoded_len = (int)ceil(buffer_len*4/3.0);
+    encoded = realloc( encoded, encoded_len + 3 ); /* 3 chars = slash, chunk ID, NUL character */
+    if (!encoded)
+    {
+        status = STATUS_NO_MEMORY;
+        goto cleanup;
+    }
+
+    /* change to the link folder so that we can build any necessary additional data */
+    strcpy( link_dir, unix_name );
+    d = dirname( link_dir);
+    if (d != link_dir) strcpy( link_dir, d );
+    link_dir_fd = open( link_dir, O_RDONLY|O_DIRECTORY );
+
+    /* Copy the encoded data from the follow on symlinks */
+    while(strlen(encoded) < encoded_len)
+    {
+        int fd;
+
+        strcpy( link_dir, link_path );
+        ret = readlinkat( link_dir_fd, link_dir, link_path, sizeof(link_path) );
+        if (ret < 0)
+        {
+            status = errno_to_status( errno );
+            goto cleanup;
+        }
+        link_path_len = ret;
+        link_path[link_path_len] = 0; /* readlink does not NUL terminate */
+
+        p = &link_path[3*depth];
+        for (depth=0; p < link_path + link_path_len; p += NAME_MAX+1, depth++)
+            strncat( encoded, p, NAME_MAX );
+        encoded[strlen(encoded)-1] = 0; /* chunk id */
+        encoded[strlen(encoded)-1] = 0; /* final slash */
+
+        link_dir[strlen(link_dir)-1] = 0;
+        fd = openat( link_dir_fd, link_dir, O_RDONLY|O_DIRECTORY );
+        close( link_dir_fd );
+        link_dir_fd = fd;
+    }
+
+    /* if the prefix location has moved then update the Unix prefix passthrough link */
+    strcpy( link_dir, link_path );
+    link_dir[strlen(link_dir)-1] = 0;
+    link_path_len = readlinkat( link_dir_fd, prefix_string, link_path, sizeof(link_path) );
+    if (link_path_len > 0) link_path[link_path_len] = 0;
+    if (link_path_len > 0 && strcmp( config_dir, link_path) != 0)
+    {
+        unlinkat( link_dir_fd, prefix_string, 0 );
+        symlinkat( config_dir, link_dir_fd, prefix_string );
+    }
+
+    /* Decode the reparse buffer from the base64-encoded symlink data */
+    *size = decode_base64url( encoded, strlen(encoded), (char*)buffer );
+    status = STATUS_SUCCESS;
+    if (buffer_len != *size)
+    {
+        status = STATUS_IO_REPARSE_DATA_INVALID;
+        ERR("Size mismatch decoding reparse point buffer (%d != %d)\n", *size, buffer_len);
+    }
+
+cleanup:
+    if (link_dir_fd != -1) close( link_dir_fd );
+    free( encoded );
+    return status;
+}
+
+
+/*
+ * Retrieve the unix name corresponding to a file handle and use that to find the destination of the
+ * symlink corresponding to that file handle.
+ */
+NTSTATUS get_reparse_point(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG *size)
+{
+    char *unix_name = NULL;
+    NTSTATUS status;
+
+    if ((status = server_get_unix_name( handle, &unix_name )))
+        return status;
+    status = get_reparse_point_unix( unix_name, buffer, size );
+    free( unix_name );
+    return status;
+}
+
+
+/* find the NT target of a reparse point */
+static NTSTATUS find_reparse_target( const char *unix_name, const WCHAR *parent, int parent_len,
+                                     WCHAR **new_name, int *new_name_len)
+{
+    REPARSE_DATA_BUFFER *buffer = NULL;
+    UNICODE_STRING nt_target;
+    ULONG buffer_len = 0;
+    int is_relative;
+    NTSTATUS status;
+
+    status = get_reparse_point_unix( unix_name, NULL, &buffer_len );
+    if (status != STATUS_BUFFER_TOO_SMALL)
+        return status;
+
+    buffer = malloc( buffer_len );
+    if (!buffer)
+        return STATUS_NO_MEMORY;
+    if ((status = get_reparse_point_unix( unix_name, buffer, &buffer_len )) != STATUS_SUCCESS)
+    {
+        free( buffer );
+        return status;
+    }
+    if ((status = get_reparse_target( &nt_target, buffer, &is_relative )) == STATUS_REPARSE)
+    {
+        WCHAR *p;
+
+        p = *new_name = malloc( nt_target.Length + parent_len*sizeof(WCHAR) );
+        if (!p)
+        {
+            status = STATUS_NO_MEMORY;
+            goto done;
+        }
+        if (is_relative)
+        {
+            memcpy( p, parent, parent_len*sizeof(WCHAR) );
+            p += parent_len;
+        }
+        memcpy( p, nt_target.Buffer, nt_target.Length );
+        p += nt_target.Length/sizeof(WCHAR);
+        *new_name_len = p - *new_name;
+    }
+
+done:
+    free( buffer );
+    return status;
+}
+
+
+/*
+ * Retrieve the unix name corresponding to a file handle, remove that symlink, and then recreate
+ * a directory at the location of the old filename.
+ */
+NTSTATUS remove_reparse_point(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
+{
+    char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
+    BOOL tempdir_created = FALSE;
+    int dest_fd, needs_close;
+    BOOL is_dir = TRUE;
+    NTSTATUS status;
+    char *unix_name;
+    struct stat st;
+
+    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
+        return status;
+
+    if ((status = server_get_unix_name( handle, &unix_name )))
+        goto cleanup;
+
+    TRACE( "Deleting symlink %s\n", unix_name );
+
+    /* Produce the file/directory in a temporary location in the same folder */
+    if (fstat( dest_fd, &st ) == -1)
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+    is_dir = S_ISDIR(st.st_mode);
+    strcpy( tmpdir, unix_name );
+    d = dirname( tmpdir);
+    if (d != tmpdir) strcpy( tmpdir, d );
+    strcat( tmpdir, "/.winelink.XXXXXX" );
+    if (mkdtemp( tmpdir ) == NULL)
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+    tempdir_created = TRUE;
+    strcpy( tmplink, tmpdir );
+    strcat( tmplink, "/tmplink" );
+    if (is_dir && mkdir( tmplink, st.st_mode ))
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+    else if (!is_dir)
+    {
+        int fd = open( tmplink, O_CREAT|O_WRONLY|O_TRUNC, st.st_mode );
+        if (fd < 0)
+        {
+            status = errno_to_status( errno );
+            goto cleanup;
+        }
+        close( fd );
+    }
+    /* attemp to retain the ownership (if possible) */
+    lchown( tmplink, st.st_uid, st.st_gid );
+    /* Atomically move the directory into position */
+    if (!renameat2( -1, tmplink, -1, unix_name, RENAME_EXCHANGE ))
+    {
+        /* success: link and folder/file have switched locations */
+        unlink( tmplink ); /* remove the file (at link location) */
+    }
+    else if (errno == ENOSYS)
+    {
+        FIXME( "Atomic exchange of directory with symbolic link unsupported on this system, "
+               "using unsafe exchange instead.\n" );
+        if (unlink( unix_name ))
+        {
+            status = errno_to_status( errno );
+            goto cleanup;
+        }
+        if (rename( tmplink, unix_name ))
+        {
+            status = errno_to_status( errno );
+            goto cleanup; /* not moved, orignal file/folder at destination is orphaned */
+        }
+    }
+    else
+    {
+        status = errno_to_status( errno );
+        goto cleanup;
+    }
+    status = STATUS_SUCCESS;
+
+cleanup:
+    if (tempdir_created) rmdir( tmpdir );
+    if (needs_close) close( dest_fd );
+    return status;
+}
+
+
+static NTSTATUS IoReplaceFileObjectName( FILE_OBJECT *fileobj, PWSTR name, USHORT name_len )
+{
+    fileobj->FileName.Buffer = name;
+    fileobj->FileName.Length = name_len;
+    return STATUS_SUCCESS;
+}
+
+
 /******************************************************************************
  *           lookup_unix_name
  *
  * Helper for nt_to_unix_file_name
  */
-static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer, int unix_len, int pos,
-                                  UINT disposition, BOOL is_unix )
+static NTSTATUS lookup_unix_name( FILE_OBJECT *fileobj, const WCHAR *name, int name_len,
+                                  char **buffer, int unix_len, int pos, UINT disposition,
+                                  BOOL is_unix )
 {
     static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, '/', 0 };
+    const WCHAR *fullname = fileobj->FileName.Buffer;
     NTSTATUS status;
     int ret;
     struct stat st;
@@ -3383,7 +4281,7 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
         char *p;
         unix_name[pos + 1 + ret] = 0;
         for (p = unix_name + pos ; *p; p++) if (*p == '\\') *p = '/';
-        if (!stat( unix_name, &st ))
+        if (!lstat( unix_name, &st ))
         {
             if (disposition == FILE_CREATE) return STATUS_OBJECT_NAME_COLLISION;
             return STATUS_SUCCESS;
@@ -3400,6 +4298,8 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
     while (name_len)
     {
         const WCHAR *end, *next;
+        WCHAR *target = NULL;
+        int target_len = 0;
 
         end = name;
         while (end < name + name_len && *end != '\\') end++;
@@ -3419,8 +4319,31 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
 
         status = find_file_in_dir( unix_name, pos, name, end - name, is_unix );
 
+        /* follow reparse point and restart from there (if applicable) */
+        if (name_len && find_reparse_target( unix_name, fullname, name - fullname, &target, &target_len ) == STATUS_REPARSE)
+        {
+            int new_name_len = target_len + name_len + 1;
+            WCHAR *p, *new_name;
+
+            if (!(p = new_name = malloc( new_name_len*sizeof(WCHAR) )))
+            {
+                free( target );
+                status = STATUS_NO_MEMORY;
+                break;
+            }
+            memcpy( p, target, target_len*sizeof(WCHAR) );
+            p += target_len;
+            (p++)[0] = '\\';
+            memcpy( p, next, name_len*sizeof(WCHAR) );
+            TRACE( "Follow reparse point %s => %s\n", debugstr_wn(fullname, end-fullname),
+                                                      debugstr_wn(new_name, new_name_len) );
+            free( target );
+            if (IoReplaceFileObjectName( fileobj, new_name, new_name_len*sizeof(WCHAR) ))
+                free( new_name );
+            return STATUS_REPARSE;
+        }
         /* if this is the last element, not finding it is not necessarily fatal */
-        if (!name_len)
+        else if (!name_len)
         {
             if (status == STATUS_OBJECT_NAME_NOT_FOUND)
             {
@@ -3459,12 +4382,12 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
 /******************************************************************************
  *           nt_to_unix_file_name_no_root
  */
-static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char **unix_name_ret,
+static NTSTATUS nt_to_unix_file_name_no_root( FILE_OBJECT *fileobj, char **unix_name_ret,
                                               UINT disposition )
 {
     static const WCHAR unixW[] = {'u','n','i','x'};
     static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
-
+    const UNICODE_STRING *nameW = &fileobj->FileName;
     NTSTATUS status = STATUS_SUCCESS;
     const WCHAR *name;
     struct stat st;
@@ -3554,7 +4477,7 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char
     name += prefix_len;
     name_len -= prefix_len;
 
-    status = lookup_unix_name( name, name_len, &unix_name, unix_len, pos, disposition, is_unix );
+    status = lookup_unix_name( fileobj, name, name_len, &unix_name, unix_len, pos, disposition, is_unix );
     if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
     {
         TRACE( "%s -> %s\n", debugstr_us(nameW), debugstr_a(unix_name) );
@@ -3562,7 +4485,8 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char
     }
     else
     {
-        TRACE( "%s not found in %s\n", debugstr_w(name), debugstr_an(unix_name, pos) );
+        if (status != STATUS_REPARSE)
+            TRACE( "%s not found in %s\n", debugstr_w(name), debugstr_an(unix_name, pos) );
         free( unix_name );
     }
     return status;
@@ -3570,7 +4494,7 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char
 
 
 /******************************************************************************
- *           nt_to_unix_file_name
+ *           nt_to_unix_file_name_internal
  *
  * Convert a file name from NT namespace to Unix namespace.
  *
@@ -3578,20 +4502,32 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char
  * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
  * returned, but the unix name is still filled in properly.
  */
-NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
+NTSTATUS nt_to_unix_file_name_internal( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
 {
+    HANDLE rootdir = attr->RootDirectory;
     enum server_fd_type type;
     int old_cwd, root_fd, needs_close;
+    int reparse_count = 0;
+    FILE_OBJECT fileobj;
     const WCHAR *name;
     char *unix_name;
     int name_len, unix_len;
     NTSTATUS status;
 
-    if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
-        return nt_to_unix_file_name_no_root( attr->ObjectName, name_ret, disposition );
+    fileobj.FileName = *attr->ObjectName;
+reparse:
+    if (reparse_count++ == 31)
+        return STATUS_REPARSE_POINT_NOT_RESOLVED;
+    if (!rootdir) /* without root dir fall back to normal lookup */
+    {
+        status = nt_to_unix_file_name_no_root( &fileobj, name_ret, disposition );
+        if (status == STATUS_REPARSE) goto reparse;
+        if (fileobj.FileName.Buffer != attr->ObjectName->Buffer) free( fileobj.FileName.Buffer);
+        return status;
+    }
 
-    name     = attr->ObjectName->Buffer;
-    name_len = attr->ObjectName->Length / sizeof(WCHAR);
+    name     = fileobj.FileName.Buffer;
+    name_len = fileobj.FileName.Length / sizeof(WCHAR);
 
     if (name_len && name[0] == '\\') return STATUS_INVALID_PARAMETER;
 
@@ -3599,7 +4535,7 @@ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, U
     if (!(unix_name = malloc( unix_len ))) return STATUS_NO_MEMORY;
     unix_name[0] = '.';
 
-    if (!(status = server_get_unix_fd( attr->RootDirectory, 0, &root_fd, &needs_close, &type, NULL )))
+    if (!(status = server_get_unix_fd( rootdir, 0, &root_fd, &needs_close, &type, NULL )))
     {
         if (type != FD_TYPE_DIR)
         {
@@ -3611,7 +4547,8 @@ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, U
             mutex_lock( &dir_mutex );
             if ((old_cwd = open( ".", O_RDONLY )) != -1 && fchdir( root_fd ) != -1)
             {
-                status = lookup_unix_name( name, name_len, &unix_name, unix_len, 1, disposition, FALSE );
+                status = lookup_unix_name( &fileobj, name, name_len, &unix_name, unix_len, 1,
+                                           disposition, FALSE );
                 if (fchdir( old_cwd ) == -1) chdir( "/" );
             }
             else status = errno_to_status( errno );
@@ -3624,18 +4561,156 @@ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, U
 
     if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
     {
-        TRACE( "%s -> %s\n", debugstr_us(attr->ObjectName), debugstr_a(unix_name) );
+        TRACE( "%s -> %s\n", debugstr_us(&fileobj.FileName), debugstr_a(unix_name) );
         *name_ret = unix_name;
     }
+    else if (status == STATUS_REPARSE)
+    {
+        if (fileobj.FileName.Buffer[0] == '\\') rootdir = 0;
+        free( unix_name );
+        goto reparse;
+    }
     else
     {
         TRACE( "%s not found in %s\n", debugstr_w(name), unix_name );
         free( unix_name );
     }
+
+    if (fileobj.FileName.Buffer != attr->ObjectName->Buffer) free( fileobj.FileName.Buffer);
     return status;
 }
 
 
+/* read the contents of an NT symlink object */
+static NTSTATUS read_nt_symlink( HANDLE root, UNICODE_STRING *name, WCHAR *target, size_t length )
+{
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING targetW;
+    NTSTATUS status;
+    HANDLE handle;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.ObjectName = name;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    if (!(status = NtOpenSymbolicLinkObject( &handle, SYMBOLIC_LINK_QUERY, &attr )))
+    {
+        targetW.Buffer = target;
+        targetW.MaximumLength = (length - 1) * sizeof(WCHAR);
+        status = NtQuerySymbolicLinkObject( handle, &targetW, NULL );
+        NtClose( handle );
+    }
+
+    return status;
+}
+
+/* try to find dos device based on nt device name */
+static NTSTATUS nt_to_dos_device( WCHAR *name, size_t length, WCHAR *device_ret )
+{
+    static const WCHAR dosdevicesW[] = {'\\','D','o','s','D','e','v','i','c','e','s',0};
+    UNICODE_STRING dosdevW = { sizeof(dosdevicesW) - sizeof(WCHAR), sizeof(dosdevicesW), (WCHAR *)dosdevicesW };
+    WCHAR symlinkW[MAX_DIR_ENTRY_LEN];
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status;
+    char data[1024];
+    HANDLE handle;
+    ULONG ctx = 0;
+
+    DIRECTORY_BASIC_INFORMATION *info = (DIRECTORY_BASIC_INFORMATION *)data;
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.ObjectName = &dosdevW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    status = NtOpenDirectoryObject( &handle, FILE_LIST_DIRECTORY, &attr );
+    if (status) return STATUS_BAD_DEVICE_TYPE;
+
+    while (!NtQueryDirectoryObject( handle, info, sizeof(data), TRUE, FALSE, &ctx, NULL ))
+    {
+        if (read_nt_symlink( handle, &info->ObjectName, symlinkW, MAX_DIR_ENTRY_LEN )) continue;
+        if (wcsnicmp( symlinkW, name, length )) continue;
+        if (info->ObjectName.Length != 2 * sizeof(WCHAR) || info->ObjectName.Buffer[1] != ':') continue;
+
+        *device_ret = info->ObjectName.Buffer[0];
+        NtClose( handle );
+        return STATUS_SUCCESS;
+    }
+
+    NtClose( handle );
+    return STATUS_BAD_DEVICE_TYPE;
+}
+
+/******************************************************************************
+ *           nt_to_unix_file_name
+ *
+ * Convert a file name from NT namespace to Unix namespace.
+ *
+ * If disposition is not FILE_OPEN or FILE_OVERWRITE, the last path
+ * element doesn't have to exist; in that case STATUS_NO_SUCH_FILE is
+ * returned, but the unix name is still filled in properly.
+ */
+NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
+{
+    static const WCHAR systemrootW[] = {'\\','S','y','s','t','e','m','R','o','o','t','\\',0};
+    static const WCHAR dosprefixW[] = {'\\','?','?','\\'};
+    static const WCHAR deviceW[] = {'\\','D','e','v','i','c','e','\\',0};
+    WCHAR *name, *ptr, *prefix, buffer[3] = {'c',':',0};
+    UNICODE_STRING dospathW, *nameW;
+    OBJECT_ATTRIBUTES attr_copy;
+    size_t offset, name_len;
+    NTSTATUS status;
+
+    if (attr->RootDirectory) return nt_to_unix_file_name_internal( attr, name_ret, disposition );
+
+    nameW = attr->ObjectName;
+
+    if (nameW->Length >= sizeof(deviceW) - sizeof(WCHAR)
+        && !wcsnicmp( nameW->Buffer, deviceW, ARRAY_SIZE(deviceW) - 1 ))
+    {
+        offset = sizeof(deviceW) / sizeof(WCHAR);
+        while (offset * sizeof(WCHAR) < nameW->Length && nameW->Buffer[ offset ] != '\\') offset++;
+        if ((status = nt_to_dos_device( nameW->Buffer, offset, buffer ))) return status;
+        prefix = buffer;
+    }
+    else if (nameW->Length >= sizeof(systemrootW) - sizeof(WCHAR) &&
+             !wcsnicmp( nameW->Buffer, systemrootW, ARRAY_SIZE(systemrootW) - 1 ))
+    {
+        offset = (sizeof(systemrootW) - 1) / sizeof(WCHAR);
+        prefix = user_shared_data->NtSystemRoot;
+    }
+    else
+        return nt_to_unix_file_name_internal( attr, name_ret, disposition );
+
+    name_len = sizeof(dosprefixW) + wcslen(prefix) * sizeof(WCHAR)
+               + sizeof(WCHAR) /* '\\' */ + nameW->Length - offset * sizeof(WCHAR) + sizeof(WCHAR);
+    if (!(name = malloc( name_len )))
+        return STATUS_NO_MEMORY;
+
+    ptr = name;
+    memcpy( ptr, dosprefixW, sizeof(dosprefixW) );
+    ptr += sizeof(dosprefixW) / sizeof(WCHAR);
+    wcscpy( ptr, prefix );
+    ptr += wcslen(ptr);
+    *ptr++ = '\\';
+    memcpy( ptr, nameW->Buffer + offset, nameW->Length - offset * sizeof(WCHAR) );
+    ptr[ nameW->Length / sizeof(WCHAR) - offset ] = 0;
+
+    dospathW.Buffer = name;
+    dospathW.Length = wcslen( name ) * sizeof(WCHAR);
+    attr_copy = *attr;
+    attr_copy.ObjectName = &dospathW;
+    status = nt_to_unix_file_name_internal( &attr_copy, name_ret, disposition );
+
+    free( name );
+    return status;
+}
+
 /******************************************************************************
  *           wine_nt_to_unix_file_name
  *
@@ -4544,7 +5619,20 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
         {
             FILE_ATTRIBUTE_TAG_INFORMATION *info = ptr;
             info->FileAttributes = attr;
-            info->ReparseTag = 0; /* FIXME */
+            info->ReparseTag = 0;
+            if (attr & FILE_ATTRIBUTE_REPARSE_POINT)
+            {
+                REPARSE_DATA_BUFFER *buffer = NULL;
+                ULONG buffer_len = 0;
+
+                if (get_reparse_point( handle, NULL, &buffer_len ) == STATUS_BUFFER_TOO_SMALL)
+                {
+                    buffer = malloc( buffer_len );
+                    if (get_reparse_point( handle, buffer, &buffer_len ) == STATUS_SUCCESS)
+                        info->ReparseTag = buffer->ReparseTag;
+                    free( buffer );
+                }
+            }
             if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, &st ))
                 info->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
         }
@@ -4794,8 +5882,10 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
         {
             FILE_RENAME_INFORMATION *info = ptr;
             unsigned int flags;
+            REPARSE_DATA_BUFFER *buffer = NULL;
             UNICODE_STRING name_str, redir;
             OBJECT_ATTRIBUTES attr;
+            ULONG buffer_len = 0;
             char *unix_name;
 
             if (class == FileRenameInformation)
@@ -4812,6 +5902,19 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
             InitializeObjectAttributes( &attr, &name_str, OBJ_CASE_INSENSITIVE, info->RootDirectory, NULL );
             get_redirect( &attr, &redir );
 
+            /* obtain all the data from the reparse point (if applicable) */
+            status = get_reparse_point( handle, NULL, &buffer_len );
+            if (status == STATUS_BUFFER_TOO_SMALL)
+            {
+                buffer = malloc( buffer_len );
+                status = get_reparse_point( handle, buffer, &buffer_len );
+                if (status != STATUS_SUCCESS)
+                {
+                    free( buffer );
+                    break;
+                }
+            }
+
             status = nt_to_unix_file_name( &attr, &unix_name, FILE_OPEN_IF );
             if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
             {
@@ -4828,9 +5931,14 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
                 }
                 SERVER_END_REQ;
 
+                /* rebuild reparse point in new location (if applicable) */
+                if (buffer && status == STATUS_SUCCESS)
+                    status = create_reparse_point( handle, buffer );
+
                 free( unix_name );
             }
             free( redir.Buffer );
+            free( buffer );
         }
         else status = STATUS_INVALID_PARAMETER_3;
         break;
@@ -4944,18 +6052,29 @@ void release_fileio( struct async_fileio *io )
 struct async_fileio *alloc_fileio( DWORD size, async_callback_t callback, HANDLE handle )
 {
     /* first free remaining previous fileinfos */
-    struct async_fileio *io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
+    struct async_fileio *old_io = InterlockedExchangePointer( (void **)&fileio_freelist, NULL );
+    struct async_fileio *io = NULL;
 
-    while (io)
+    while (old_io)
     {
-        struct async_fileio *next = io->next;
-        free( io );
-        io = next;
+        if (!io && old_io->size >= size && old_io->size <= max(4096, 4 * size))
+        {
+            io     = old_io;
+            size   = old_io->size;
+            old_io = old_io->next;
+        }
+        else
+        {
+            struct async_fileio *next = old_io->next;
+            free( old_io );
+            old_io = next;
+        }
     }
 
-    if ((io = malloc( size )))
+    if (io || (io = malloc( size )))
     {
         io->callback = callback;
+        io->size     = size;
         io->handle   = handle;
     }
     return io;
@@ -5459,6 +6578,11 @@ NTSTATUS WINAPI NtReadFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, vo
         if (needs_close) close( unix_handle );
         return status;
     }
+    else if (type == FD_TYPE_SYMLINK)
+    {
+        status = STATUS_SUCCESS;
+        goto done;
+    }
 
     if (type == FD_TYPE_SERIAL && async_read && length)
     {
@@ -6121,16 +7245,6 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
         break;
     }
 
-    case FSCTL_GET_REPARSE_POINT:
-        io->Information = 0;
-        if (out_buffer && out_size)
-        {
-            FIXME("FSCTL_GET_REPARSE_POINT semi-stub\n");
-            status = STATUS_NOT_A_REPARSE_POINT;
-        }
-        else status = STATUS_INVALID_USER_BUFFER;
-        break;
-
     case FSCTL_GET_OBJECT_ID:
     {
         FILE_OBJECTID_BUFFER *info = out_buffer;
@@ -6153,6 +7267,27 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
         break;
     }
 
+    case FSCTL_DELETE_REPARSE_POINT:
+    {
+        REPARSE_GUID_DATA_BUFFER *buffer = (REPARSE_GUID_DATA_BUFFER *)in_buffer;
+        status = remove_reparse_point( handle, buffer );
+        break;
+    }
+    case FSCTL_GET_REPARSE_POINT:
+    {
+        REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)out_buffer;
+        ULONG size = out_size;
+        status = get_reparse_point( handle, buffer, &size );
+        io->Information = size;
+        break;
+    }
+    case FSCTL_SET_REPARSE_POINT:
+    {
+        REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)in_buffer;
+        status = create_reparse_point( handle, buffer );
+        break;
+    }
+
     case FSCTL_SET_SPARSE:
         TRACE("FSCTL_SET_SPARSE: Ignoring request\n");
         io->Information = 0;
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 803d807..b11e2de 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -88,6 +88,7 @@ extern char **environ;
 #include "winioctl.h"
 #include "winternl.h"
 #include "unix_private.h"
+#include "esync.h"
 #include "wine/list.h"
 #include "ntsyscalls.h"
 #include "wine/debug.h"
@@ -1808,6 +1809,7 @@ static void start_main_thread(void)
     signal_alloc_thread( teb );
     dbg_init();
     startup_info_size = server_init_process();
+    esync_init();
     virtual_map_user_shared_data();
     init_cpu_info();
     init_files();
@@ -2153,6 +2155,8 @@ DECLSPEC_EXPORT void __wine_main( int argc, char *argv[], char *envp[] )
 #endif
 
     virtual_init();
+    signal_init_early();
+
     init_environment();
 
 #ifdef __APPLE__
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index 71eab55..f5c44ab 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -1118,7 +1118,6 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
 
     switch (class)
     {
-    UNIMPLEMENTED_INFO_CLASS(ProcessQuotaLimits);
     UNIMPLEMENTED_INFO_CLASS(ProcessBasePriority);
     UNIMPLEMENTED_INFO_CLASS(ProcessRaisePriority);
     UNIMPLEMENTED_INFO_CLASS(ProcessExceptionPort);
@@ -1183,6 +1182,37 @@ NTSTATUS WINAPI NtQueryInformationProcess( HANDLE handle, PROCESSINFOCLASS class
         }
         break;
 
+    case ProcessQuotaLimits:
+        {
+            QUOTA_LIMITS pqli;
+
+            if (size >= sizeof(QUOTA_LIMITS))
+            {
+                if (!info)
+                    ret = STATUS_ACCESS_VIOLATION;
+                else if (!handle)
+                    ret = STATUS_INVALID_HANDLE;
+                else
+                {
+                    /* FIXME : real data */
+                    memset(&pqli, 0, sizeof(QUOTA_LIMITS));
+
+                    memcpy(info, &pqli, sizeof(QUOTA_LIMITS));
+
+                    len = sizeof(QUOTA_LIMITS);
+                }
+
+                if (size > sizeof(QUOTA_LIMITS))
+                    ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+            else
+            {
+                len = sizeof(QUOTA_LIMITS);
+                ret = STATUS_INFO_LENGTH_MISMATCH;
+            }
+        }
+        break;
+
     case ProcessIoCounters:
         {
             IO_COUNTERS pii;
diff --git a/dlls/ntdll/unix/registry.c b/dlls/ntdll/unix/registry.c
index e19414b..492dd00 100644
--- a/dlls/ntdll/unix/registry.c
+++ b/dlls/ntdll/unix/registry.c
@@ -27,6 +27,10 @@
 
 #include <stdarg.h>
 #include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -68,6 +72,249 @@ NTSTATUS open_hkcu_key( const char *path, HANDLE *key )
     return NtCreateKey( key, KEY_ALL_ACCESS, &attr, 0, NULL, 0, NULL );
 }
 
+/* dump a Unicode string with proper escaping */
+int dump_strW( const WCHAR *str, data_size_t len, FILE *f, const char escape[2] )
+{
+    static const char escapes[32] = ".......abtnvfr.............e....";
+    char buffer[256];
+    char *pos = buffer;
+    int count = 0;
+
+    for (len /= sizeof(WCHAR); len; str++, len--)
+    {
+        if (pos > buffer + sizeof(buffer) - 8)
+        {
+            fwrite( buffer, pos - buffer, 1, f );
+            count += pos - buffer;
+            pos = buffer;
+        }
+        if (*str > 127)  /* hex escape */
+        {
+            if (len > 1 && str[1] < 128 && isxdigit( (char)str[1] ))
+                pos += sprintf( pos, "\\x%04x", *str );
+            else
+                pos += sprintf( pos, "\\x%x", *str );
+            continue;
+        }
+        if (*str < 32)  /* octal or C escape */
+        {
+            if (!*str && len == 1) continue;  /* do not output terminating NULL */
+            if (escapes[*str] != '.')
+                pos += sprintf( pos, "\\%c", escapes[*str] );
+            else if (len > 1 && str[1] >= '0' && str[1] <= '7')
+                pos += sprintf( pos, "\\%03o", *str );
+            else
+                pos += sprintf( pos, "\\%o", *str );
+            continue;
+        }
+        if (*str == '\\' || *str == escape[0] || *str == escape[1]) *pos++ = '\\';
+        *pos++ = *str;
+    }
+    fwrite( buffer, pos - buffer, 1, f );
+    count += pos - buffer;
+    return count;
+}
+
+struct saved_key
+{
+    data_size_t namelen;
+    WCHAR *name;
+    data_size_t classlen;
+    WCHAR *class;
+    int value_count;
+    int subkey_count;
+    unsigned int is_symlink;
+    timeout_t modif;
+    struct saved_key *parent;
+};
+
+/* read serialized key data */
+static char *fill_saved_key( struct saved_key *key, struct saved_key *parent, char *data )
+{
+    key->parent = parent;
+    key->namelen = *(data_size_t *)data;
+    data += sizeof(data_size_t);
+    key->name = (WCHAR *)data;
+    data += key->namelen;
+    key->classlen = *(data_size_t *)data;
+    data += sizeof(data_size_t);
+    key->class = (WCHAR *)data;
+    data += key->classlen;
+    key->value_count = *(int *)data;
+    data += sizeof(int);
+    key->subkey_count = *(int *)data;
+    data += sizeof(int);
+    key->is_symlink = *(unsigned int *)data;
+    data += sizeof(unsigned int);
+    key->modif = *(timeout_t *)data;
+    data += sizeof(timeout_t);
+
+    return data;
+}
+
+/* dump serialized key full path */
+static char *dump_parents( char *data, FILE *f, int count )
+{
+    data_size_t len;
+    WCHAR *name;
+
+    len = *(data_size_t *)data;
+    data += sizeof(data_size_t);
+    name = (WCHAR *)data;
+    data += len;
+
+    if (count > 1)
+    {
+        data = dump_parents( data, f, count - 1);
+        fprintf( f, "\\\\" );
+    }
+    dump_strW( name, len, f, "[]" );
+    return data;
+}
+
+/* dump the full path of a key */
+static void dump_path( const struct saved_key *key, const struct saved_key *base, FILE *f )
+{
+    if (key->parent && key->parent != base)
+    {
+        dump_path( key->parent, base, f );
+        fprintf( f, "\\\\" );
+    }
+    dump_strW( key->name, key->namelen, f, "[]" );
+}
+
+/* dump a value to a text file */
+static char *dump_value( char *data, FILE *f )
+{
+    unsigned int i, dw;
+    int count;
+    data_size_t namelen, valuelen;
+    char *valuedata;
+    WCHAR *name;
+    unsigned int type;
+
+    namelen = *(data_size_t *)data;
+    data += sizeof(data_size_t);
+    name = (WCHAR *)data;
+    data += namelen;
+    type = *(unsigned int *)data;
+    data += sizeof(unsigned int);
+    valuelen = *(data_size_t *)data;
+    data += sizeof(data_size_t);
+    valuedata = data;
+    data += valuelen;
+
+    if (namelen)
+    {
+        fputc( '\"', f );
+        count = 1 + dump_strW( name, namelen, f, "\"\"" );
+        count += fprintf( f, "\"=" );
+    }
+    else count = fprintf( f, "@=" );
+
+    switch(type)
+    {
+    case REG_SZ:
+    case REG_EXPAND_SZ:
+    case REG_MULTI_SZ:
+        /* only output properly terminated strings in string format */
+        if (valuelen < sizeof(WCHAR)) break;
+        if (valuelen % sizeof(WCHAR)) break;
+        if (((WCHAR *)valuedata)[valuelen / sizeof(WCHAR) - 1]) break;
+        if (type != REG_SZ) fprintf( f, "str(%x):", type );
+        fputc( '\"', f );
+        dump_strW( (WCHAR *)valuedata, valuelen, f, "\"\"" );
+        fprintf( f, "\"\n" );
+        return data;
+
+    case REG_DWORD:
+        if (valuelen != sizeof(dw)) break;
+        memcpy( &dw, valuedata, sizeof(dw) );
+        fprintf( f, "dword:%08x\n", dw );
+        return data;
+    }
+
+    if (type == REG_BINARY) count += fprintf( f, "hex:" );
+    else count += fprintf( f, "hex(%x):", type );
+    for (i = 0; i < valuelen; i++)
+    {
+        count += fprintf( f, "%02x", *((unsigned char *)valuedata + i) );
+        if (i < valuelen-1)
+        {
+            fputc( ',', f );
+            if (++count > 76)
+            {
+                fprintf( f, "\\\n  " );
+                count = 2;
+            }
+        }
+    }
+    fputc( '\n', f );
+    return data;
+}
+
+/* save a registry key and all its subkeys to a text file */
+static char *save_subkeys( char *data, struct saved_key *parent, struct saved_key *base, FILE *f )
+{
+    struct saved_key key;
+    int i;
+
+    if (!base) base = &key;
+    data = fill_saved_key( &key, parent, data );
+
+    /* save key if it has either some values or no subkeys, or needs special options */
+    /* keys with no values but subkeys are saved implicitly by saving the subkeys */
+    if ((key.value_count > 0) || !key.subkey_count || key.classlen || key.is_symlink)
+    {
+        fprintf( f, "\n[" );
+        if (parent) dump_path( &key, base, f );
+        fprintf( f, "] %u\n", (unsigned int)((key.modif - SECS_1601_TO_1970 * TICKSPERSEC) / TICKSPERSEC) );
+        fprintf( f, "#time=%x%08x\n", (unsigned int)(key.modif >> 32), (unsigned int)key.modif );
+        if (key.classlen)
+        {
+            fprintf( f, "#class=\"" );
+            dump_strW( key.class, key.classlen, f, "\"\"" );
+            fprintf( f, "\"\n" );
+        }
+        if (key.is_symlink) fputs( "#link\n", f );
+        for (i = 0; i < key.value_count; i++) data = dump_value( data, f );
+    }
+    for (i = 0; i < key.subkey_count; i++) data = save_subkeys( data, &key, base, f );
+    return data;
+}
+
+/* save a registry branch to a file */
+static char *save_all_subkeys( char *data, FILE *f )
+{
+    /* Output registry format should match server/registry.c:save_all_subkeys(). */
+    enum prefix_type prefix_type;
+    int parent_count;
+
+    prefix_type = *(int *)data;
+    data += sizeof(int);
+
+    parent_count = *(int *)data;
+    data += sizeof(int);
+
+    fprintf( f, "WINE REGISTRY Version 2\n" );
+    fprintf( f, ";; All keys relative to " );
+    data = dump_parents( data, f, parent_count );
+    fprintf( f, "\n" );
+
+    switch (prefix_type)
+    {
+    case PREFIX_32BIT:
+        fprintf( f, "\n#arch=win32\n" );
+        break;
+    case PREFIX_64BIT:
+        fprintf( f, "\n#arch=win64\n" );
+        break;
+    default:
+        break;
+    }
+    return save_subkeys( data, NULL, NULL, f );
+}
+
 
 /******************************************************************************
  *              NtCreateKey  (NTDLL.@)
@@ -672,22 +919,162 @@ NTSTATUS WINAPI NtNotifyChangeKey( HANDLE key, HANDLE event, PIO_APC_ROUTINE apc
                                        io, filter, subtree, buffer, length, async );
 }
 
+/* acquire mutex for registry flush operation */
+static HANDLE get_key_flush_mutex(void)
+{
+    WCHAR bufferW[256];
+    UNICODE_STRING name = {.Buffer = bufferW};
+    OBJECT_ATTRIBUTES attr;
+    char buffer[256];
+    HANDLE mutex;
+
+    snprintf( buffer, ARRAY_SIZE(buffer), "\\Sessions\\%u\\BaseNamedObjects\\__wine_regkey_flush",
+              (int)NtCurrentTeb()->Peb->SessionId );
+    name.Length = name.MaximumLength = (strlen(buffer) + 1) * sizeof(WCHAR);
+    ascii_to_unicode( bufferW, buffer, name.Length / sizeof(WCHAR) );
+
+    InitializeObjectAttributes( &attr, &name, OBJ_OPENIF, NULL, NULL );
+    if (NtCreateMutant( &mutex, MUTEX_ALL_ACCESS, &attr, FALSE ) < 0) return NULL;
+    NtWaitForSingleObject( mutex, FALSE, NULL );
+    return mutex;
+}
+
+/* release registry flush mutex */
+static void release_key_flush_mutex( HANDLE mutex )
+{
+    NtReleaseMutant( mutex, NULL );
+    NtClose( mutex );
+}
+
+/* save registry branch to Wine regsitry storage file */
+static NTSTATUS save_registry_branch( char **data )
+{
+    static const char temp_fn[] = "savereg.tmp";
+    char *file_name, *path = NULL, *tmp = NULL;
+    int file_name_len, path_len, fd;
+    struct stat st;
+    NTSTATUS ret;
+    FILE *f;
+
+    file_name_len = *(int *)*data;
+    *data += sizeof(int);
+    file_name = *data;
+    *data += file_name_len;
+
+    path_len = strlen( config_dir ) + 1 + file_name_len + 1;
+    if (!(path = malloc( path_len ))) return STATUS_NO_MEMORY;
+    sprintf( path, "%s/%s", config_dir, file_name );
+
+    if ((fd = open( path, O_WRONLY )) != -1)
+    {
+        /* if file is not a regular file or has multiple links or is accessed
+         * via symbolic links, write directly into it; otherwise use a temp file */
+        if (!lstat( path, &st ) && (!S_ISREG(st.st_mode) || st.st_nlink > 1))
+        {
+            ftruncate( fd, 0 );
+            goto save;
+        }
+        close( fd );
+    }
+
+    /* create a temp file in the same directory */
+    if (!(tmp = malloc( strlen( config_dir ) + 1 + strlen( temp_fn ) + 1 )))
+    {
+        ret = STATUS_NO_MEMORY;
+        goto done;
+    }
+    sprintf( tmp, "%s/%s", config_dir, temp_fn );
+
+    if ((fd = open( tmp, O_CREAT | O_EXCL | O_WRONLY, 0666 )) == -1)
+    {
+        ret = errno_to_status( errno );
+        goto done;
+    }
+
+save:
+    if (!(f = fdopen( fd, "w" )))
+    {
+        ret = errno_to_status( errno );
+        if (tmp) unlink( tmp );
+        close( fd );
+        goto done;
+    }
+
+    *data = save_all_subkeys( *data, f );
+
+    ret = fclose( f ) ? errno_to_status( errno ) : STATUS_SUCCESS;
+    if (tmp)
+    {
+        if (!ret && rename( tmp, path )) ret = errno_to_status( errno );
+        if (ret) unlink( tmp );
+    }
+
+done:
+    free( tmp );
+    free( path );
+    return ret;
+}
 
 /******************************************************************************
  *              NtFlushKey  (NTDLL.@)
  */
 NTSTATUS WINAPI NtFlushKey( HANDLE key )
 {
+    abstime_t timestamp_counter;
+    data_size_t size = 0;
     unsigned int ret;
+    char *data = NULL, *curr_data;
+    HANDLE mutex;
+    int i, branch_count, branch;
 
     TRACE( "key=%p\n", key );
 
-    SERVER_START_REQ( flush_key )
+    mutex = get_key_flush_mutex();
+
+    while (1)
     {
-	req->hkey = wine_server_obj_handle( key );
-	ret = wine_server_call( req );
+        SERVER_START_REQ( flush_key )
+        {
+            req->hkey = wine_server_obj_handle( key );
+            if (size) wine_server_set_reply( req, data, size );
+            ret = wine_server_call( req );
+            size = reply->total;
+            branch_count = reply->branch_count;
+            timestamp_counter = reply->timestamp_counter;
+        }
+        SERVER_END_REQ;
+
+        if (ret != STATUS_BUFFER_TOO_SMALL) break;
+        free( data );
+        if (!(data = malloc( size )))
+        {
+            ERR( "No memory.\n" );
+            ret = STATUS_NO_MEMORY;
+            goto done;
+        }
     }
-    SERVER_END_REQ;
+    if (ret) goto done;
+
+    curr_data = data;
+    for (i = 0; i < branch_count; ++i)
+    {
+        branch = *(int *)curr_data;
+        curr_data += sizeof(int);
+        if ((ret = save_registry_branch( &curr_data ))) goto done;
+
+        SERVER_START_REQ( flush_key_done )
+        {
+            req->branch = branch;
+            req->timestamp_counter = timestamp_counter;
+            ret = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        if (ret) break;
+    }
+
+done:
+    release_key_flush_mutex( mutex );
+    free( data );
     return ret;
 }
 
@@ -791,17 +1178,53 @@ NTSTATUS WINAPI NtUnloadKey( OBJECT_ATTRIBUTES *attr )
  */
 NTSTATUS WINAPI NtSaveKey( HANDLE key, HANDLE file )
 {
+    data_size_t size = 0;
     unsigned int ret;
+    char *data = NULL;
+    int fd, fd2, needs_close = 0;
+    FILE *f;
 
     TRACE( "(%p,%p)\n", key, file );
 
-    SERVER_START_REQ( save_registry )
+    while (1)
     {
-        req->hkey = wine_server_obj_handle( key );
-        req->file = wine_server_obj_handle( file );
-        ret = wine_server_call( req );
+        SERVER_START_REQ( save_registry )
+        {
+            req->hkey = wine_server_obj_handle( key );
+            if (size) wine_server_set_reply( req, data, size );
+            ret = wine_server_call( req );
+            size = reply->total;
+        }
+        SERVER_END_REQ;
+
+        if (!ret) break;
+        free( data );
+        if (ret != STATUS_BUFFER_TOO_SMALL) return ret;
+        if (!(data = malloc( size )))
+        {
+            ERR( "No memory.\n" );
+            return STATUS_NO_MEMORY;
+        }
     }
-    SERVER_END_REQ;
+
+    if ((ret = server_get_unix_fd( file, FILE_WRITE_DATA, &fd, &needs_close, NULL, NULL ))) goto done;
+    if ((fd2 = dup( fd )) == -1)
+    {
+        ret = errno_to_status( errno );
+        goto done;
+    }
+    if (!(f = fdopen( fd2, "w" )))
+    {
+        close( fd2 );
+        ret = errno_to_status( errno );
+        goto done;
+    }
+    save_all_subkeys( data, f );
+    if (fclose(f)) ret = errno_to_status( errno );
+
+done:
+    if (needs_close) close( fd );
+    free( data );
     return ret;
 }
 
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 69e6567..b5145f1 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -49,6 +49,10 @@
 #ifdef HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
+#include <sys/ioctl.h>
+#ifdef HAVE_LINUX_IOCTL_H
+#include <linux/ioctl.h>
+#endif
 #ifdef HAVE_SYS_PRCTL_H
 # include <sys/prctl.h>
 #endif
@@ -79,10 +83,27 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "esync.h"
 #include "ddk/wdm.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(server);
 
+/* just in case... */
+#undef EXT2_IOC_GETFLAGS
+#undef EXT2_IOC_SETFLAGS
+#undef EXT4_CASEFOLD_FL
+
+#ifdef __linux__
+
+/* Define the ext2 ioctls for handling extra attributes */
+#define EXT2_IOC_GETFLAGS _IOR('f', 1, long)
+#define EXT2_IOC_SETFLAGS _IOW('f', 2, long)
+
+/* Case-insensitivity attribute */
+#define EXT4_CASEFOLD_FL 0x40000000
+
+#endif
+
 #ifndef MSG_CMSG_CLOEXEC
 #define MSG_CMSG_CLOEXEC 0
 #endif
@@ -103,7 +124,7 @@ sigset_t server_block_set;  /* signals to block during server calls */
 static int fd_socket = -1;  /* socket to exchange file descriptors with the server */
 static int initial_cwd = -1;
 static pid_t server_pid;
-static pthread_mutex_t fd_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+pthread_mutex_t fd_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 /* atomically exchange a 64-bit value */
 static inline LONG64 interlocked_xchg64( LONG64 *dest, LONG64 val )
@@ -273,9 +294,17 @@ unsigned int server_call_unlocked( void *req_ptr )
  */
 unsigned int CDECL wine_server_call( void *req_ptr )
 {
+    struct __server_request_info * const req = req_ptr;
     sigset_t old_set;
     unsigned int ret;
 
+    /* trigger write watches, otherwise read() might return EFAULT */
+    if (req->u.req.request_header.reply_size &&
+        !virtual_check_buffer_for_write( req->reply_data, req->u.req.request_header.reply_size ))
+    {
+        return STATUS_ACCESS_VIOLATION;
+    }
+
     pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
     ret = server_call_unlocked( req_ptr );
     pthread_sigmask( SIG_SETMASK, &old_set, NULL );
@@ -918,7 +947,7 @@ void wine_server_send_fd( int fd )
  *
  * Receive a file descriptor passed from the server.
  */
-static int receive_fd( obj_handle_t *handle )
+int receive_fd( obj_handle_t *handle )
 {
     struct iovec vec;
     struct msghdr msghdr;
@@ -1266,6 +1295,28 @@ static const char *init_server_dir( dev_t dev, ino_t ino )
 }
 
 
+/***********************************************************************
+ *           set_case_insensitive
+ *
+ * Make the supplied directory case insensitive, if available.
+ */
+static void set_case_insensitive(const char *dir)
+{
+#if defined(EXT2_IOC_GETFLAGS) && defined(EXT2_IOC_SETFLAGS) && defined(EXT4_CASEFOLD_FL)
+    int flags, fd;
+
+    if ((fd = open(dir, O_RDONLY | O_NONBLOCK | O_LARGEFILE)) == -1)
+        return;
+    if (ioctl(fd, EXT2_IOC_GETFLAGS, &flags) != -1 && !(flags & EXT4_CASEFOLD_FL))
+    {
+        flags |= EXT4_CASEFOLD_FL;
+        ioctl(fd, EXT2_IOC_SETFLAGS, &flags);
+    }
+    close(fd);
+#endif
+}
+
+
 /***********************************************************************
  *           setup_config_dir
  *
@@ -1302,6 +1353,7 @@ static int setup_config_dir(void)
     if (!mkdir( "dosdevices", 0777 ))
     {
         mkdir( "drive_c", 0777 );
+        set_case_insensitive( "drive_c" );
         symlink( "../drive_c", "dosdevices/c:" );
         symlink( "/", "dosdevices/z:" );
     }
@@ -1851,6 +1903,9 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
      * retrieve it again */
     fd = remove_fd_from_cache( handle );
 
+    if (do_esync())
+        esync_close( handle );
+
     SERVER_START_REQ( close_handle )
     {
         req->handle = wine_server_obj_handle( handle );
diff --git a/dlls/ntdll/unix/signal_arm.c b/dlls/ntdll/unix/signal_arm.c
index 1481086..f2d4498 100644
--- a/dlls/ntdll/unix/signal_arm.c
+++ b/dlls/ntdll/unix/signal_arm.c
@@ -1526,6 +1526,12 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+}
 
 /***********************************************************************
  *           call_init_thunk
diff --git a/dlls/ntdll/unix/signal_arm64.c b/dlls/ntdll/unix/signal_arm64.c
index a20bfb8..00e8dd1 100644
--- a/dlls/ntdll/unix/signal_arm64.c
+++ b/dlls/ntdll/unix/signal_arm64.c
@@ -1346,6 +1346,12 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+}
 
 /***********************************************************************
  *           syscall_dispatcher_return_slowpath
diff --git a/dlls/ntdll/unix/signal_i386.c b/dlls/ntdll/unix/signal_i386.c
index 751b008..cc1eff1 100644
--- a/dlls/ntdll/unix/signal_i386.c
+++ b/dlls/ntdll/unix/signal_i386.c
@@ -1895,6 +1895,30 @@ static BOOL handle_syscall_trap( ucontext_t *sigcontext )
 }
 
 
+/**********************************************************************
+ *    segv_handler_early
+ *
+ * Handler for SIGSEGV and related errors. Used only during the initialization
+ * of the process to handle virtual faults.
+ */
+static void segv_handler_early( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    ucontext_t *ucontext = sigcontext;
+
+    switch (TRAP_sig(ucontext))
+    {
+    case TRAP_x86_PAGEFLT:  /* Page fault */
+        if (!virtual_handle_fault( siginfo->si_addr, (ERROR_sig(ucontext) >> 1) & 0x09,
+                NULL))
+            return;
+        /* fall-through */
+    default:
+        WINE_ERR( "Got unexpected trap %d during process initialization\n", TRAP_sig(ucontext) );
+        abort_thread(1);
+        break;
+    }
+}
+
 /**********************************************************************
  *		segv_handler
  *
@@ -2309,7 +2333,7 @@ NTSTATUS get_thread_ldt_entry( HANDLE handle, void *data, ULONG len, ULONG *ret_
                 if (reply->flags)
                     info->Entry = ldt_make_entry( (void *)reply->base, reply->limit, reply->flags );
                 else
-                    status = STATUS_UNSUCCESSFUL;
+                    status = STATUS_ACCESS_VIOLATION;
             }
         }
         SERVER_END_REQ;
@@ -2331,8 +2355,6 @@ NTSTATUS WINAPI NtSetLdtEntries( ULONG sel1, LDT_ENTRY entry1, ULONG sel2, LDT_E
     sigset_t sigset;
 
     if (sel1 >> 16 || sel2 >> 16) return STATUS_INVALID_LDT_DESCRIPTOR;
-    if (sel1 && (sel1 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
-    if (sel2 && (sel2 >> 3) < first_ldt_entry) return STATUS_INVALID_LDT_DESCRIPTOR;
 
     server_enter_uninterrupted_section( &ldt_mutex, &sigset );
     if (sel1) ldt_set_entry( sel1, entry1 );
@@ -2467,6 +2489,34 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+    struct sigaction sig_act;
+
+    sig_act.sa_mask = server_block_set;
+    sig_act.sa_flags = SA_SIGINFO | SA_RESTART;
+#ifdef SA_ONSTACK
+    sig_act.sa_flags |= SA_ONSTACK;
+#endif
+#ifdef __ANDROID__
+    sig_act.sa_flags |= SA_RESTORER;
+    sig_act.sa_restorer = rt_sigreturn;
+#endif
+    sig_act.sa_sigaction = segv_handler_early;
+    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
+    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
+#ifdef SIGBUS
+    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+#endif
+    return;
+
+error:
+    perror("sigaction");
+    exit(1);
+}
 
 /***********************************************************************
  *           call_init_thunk
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 5382762..35dbec7 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -27,6 +27,7 @@
 #include "config.h"
 
 #include <assert.h>
+#include <errno.h>
 #include <pthread.h>
 #include <signal.h>
 #include <stdlib.h>
@@ -34,6 +35,8 @@
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/mman.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 #include <unistd.h>
 #ifdef HAVE_MACHINE_SYSARCH_H
 # include <machine/sysarch.h>
@@ -65,6 +68,14 @@
 # include <mach/mach.h>
 #endif
 
+#if defined(HAVE_LINUX_FILTER_H) && defined(HAVE_LINUX_SECCOMP_H) && defined(HAVE_SYS_PRCTL_H)
+#define HAVE_SECCOMP 1
+# include <linux/filter.h>
+# include <linux/seccomp.h>
+# include <sys/prctl.h>
+# include <linux/audit.h>
+#endif
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -1783,6 +1794,186 @@ static inline DWORD is_privileged_instr( CONTEXT *context )
     return 0;
 }
 
+#ifdef HAVE_SECCOMP
+static void sigsys_handler( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    extern const void *__wine_syscall_dispatcher_prolog_end_ptr;
+    struct syscall_frame *frame = amd64_thread_data()->syscall_frame;
+    ucontext_t *ctx = sigcontext;
+
+    TRACE_(seh)("SIGSYS, rax %#llx, rip %#llx.\n", ctx->uc_mcontext.gregs[REG_RAX],
+            ctx->uc_mcontext.gregs[REG_RIP]);
+
+    if (ctx->uc_mcontext.gregs[REG_RAX] == 0xffff)
+    {
+        /* Test syscall from the Unix side (install_bpf). */
+        ctx->uc_mcontext.gregs[REG_RAX] = STATUS_INVALID_PARAMETER;
+        return;
+    }
+
+    frame->rip = ctx->uc_mcontext.gregs[REG_RIP] + 0xb;
+    frame->rcx = ctx->uc_mcontext.gregs[REG_RIP];
+    frame->eflags = ctx->uc_mcontext.gregs[REG_EFL];
+    frame->restore_flags = 0;
+    ctx->uc_mcontext.gregs[REG_RCX] = (ULONG_PTR)frame;
+    ctx->uc_mcontext.gregs[REG_R11] = frame->eflags;
+    ctx->uc_mcontext.gregs[REG_EFL] &= ~0x100;  /* clear single-step flag */
+    ctx->uc_mcontext.gregs[REG_RIP] = (ULONG64)__wine_syscall_dispatcher_prolog_end_ptr;
+}
+#endif
+
+#ifdef HAVE_SECCOMP
+static int sc_seccomp(unsigned int operation, unsigned int flags, void *args)
+{
+#ifndef __NR_seccomp
+#   define __NR_seccomp 317
+#endif
+    return syscall(__NR_seccomp, operation, flags, args);
+}
+#endif
+
+static void check_bpf_jit_enable(void)
+{
+    char enabled;
+    int fd;
+
+    fd = open("/proc/sys/net/core/bpf_jit_enable", O_RDONLY);
+    if (fd == -1)
+    {
+        WARN_(seh)("Could not open /proc/sys/net/core/bpf_jit_enable.\n");
+        return;
+    }
+
+    if (read(fd, &enabled, sizeof(enabled)) == sizeof(enabled))
+    {
+        TRACE_(seh)("enabled %#x.\n", enabled);
+
+        if (enabled != '1')
+            ERR_(seh)("BPF JIT is not enabled in the kernel, enable it to reduce syscall emulation overhead.\n");
+    }
+    else
+    {
+        WARN_(seh)("Could not read /proc/sys/net/core/bpf_jit_enable.\n");
+    }
+    close(fd);
+}
+
+static void install_bpf(struct sigaction *sig_act)
+{
+#ifdef HAVE_SECCOMP
+#   ifndef SECCOMP_FILTER_FLAG_SPEC_ALLOW
+#       define SECCOMP_FILTER_FLAG_SPEC_ALLOW (1UL << 2)
+#   endif
+
+#   ifndef SECCOMP_SET_MODE_FILTER
+#       define SECCOMP_SET_MODE_FILTER 1
+#   endif
+    static const BYTE syscall_trap_test[] =
+    {
+        0x48, 0x89, 0xf8,   /* mov %rdi, %rax */
+        0x0f, 0x05,         /* syscall */
+        0xc3,               /* retq */
+    };
+    static const unsigned int flags = SECCOMP_FILTER_FLAG_SPEC_ALLOW;
+
+#define NATIVE_SYSCALL_ADDRESS_START 0x700000000000
+
+    static struct sock_filter filter[] =
+    {
+        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, instruction_pointer) + 4),
+        /* Native libs are loaded at high addresses. */
+        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, NATIVE_SYSCALL_ADDRESS_START >> 32, 0, 1),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
+        /* Allow i386. */
+        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, arch)),
+        BPF_JUMP (BPF_JMP | BPF_JEQ | BPF_K, AUDIT_ARCH_X86_64, 1, 0),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
+        /* Allow wine64-preloader */
+        BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, instruction_pointer)),
+        BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 0x7d400000, 1, 0),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_TRAP),
+        BPF_JUMP(BPF_JMP | BPF_JGE | BPF_K, 0x7d402000, 0, 1),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_TRAP),
+        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
+    };
+    long (*test_syscall)(long sc_number);
+    struct syscall_frame *frame = amd64_thread_data()->syscall_frame;
+    struct sock_fprog prog;
+    NTSTATUS status;
+
+    if ((ULONG_PTR)sc_seccomp < NATIVE_SYSCALL_ADDRESS_START
+            || (ULONG_PTR)syscall < NATIVE_SYSCALL_ADDRESS_START)
+    {
+        ERR_(seh)("Native libs are being loaded in low addresses, sc_seccomp %p, syscall %p, not installing seccomp.\n",
+                sc_seccomp, syscall);
+        ERR_(seh)("The known reasons are /proc/sys/vm/legacy_va_layout set to 1 or 'ulimit -s' being 'unlimited'.\n");
+        return;
+    }
+
+    sig_act->sa_sigaction = sigsys_handler;
+    memset(&prog, 0, sizeof(prog));
+
+    sigaction(SIGSYS, sig_act, NULL);
+
+    frame->syscall_flags = syscall_flags;
+
+
+    test_syscall = mmap((void *)0x600000000000, 0x1000, PROT_EXEC | PROT_READ | PROT_WRITE,
+            MAP_PRIVATE | MAP_ANON, -1, 0);
+    if (test_syscall != (void *)0x600000000000)
+    {
+        int ret;
+
+        ERR("Could not allocate test syscall, falling back to seccomp presence check, test_syscall %p, errno %d.\n",
+                test_syscall, errno);
+        if (test_syscall != MAP_FAILED) munmap(test_syscall, 0x1000);
+
+        if ((ret = prctl(PR_GET_SECCOMP, 0, NULL, 0, 0)))
+        {
+            if (ret == 2)
+                TRACE_(seh)("Seccomp filters already installed.\n");
+            else
+                ERR_(seh)("Seccomp filters cannot be installed, ret %d, error %s.\n", ret, strerror(errno));
+            return;
+        }
+    }
+    else
+    {
+        memcpy(test_syscall, syscall_trap_test, sizeof(syscall_trap_test));
+        status = test_syscall(0xffff);
+        munmap(test_syscall, 0x1000);
+        if (status == STATUS_INVALID_PARAMETER)
+        {
+            TRACE_(seh)("Seccomp filters already installed.\n");
+            return;
+        }
+        if (status != -ENOSYS && (status != -1 || errno != ENOSYS))
+        {
+            ERR_(seh)("Unexpected status %#x, errno %d.\n", status, errno);
+            return;
+        }
+    }
+
+    TRACE_(seh)("Installing seccomp filters.\n");
+
+    prog.len = ARRAY_SIZE(filter);
+    prog.filter = filter;
+
+    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0))
+    {
+        ERR_(seh)("prctl(PR_SET_NO_NEW_PRIVS, ...): %s.\n", strerror(errno));
+        return;
+    }
+    if (sc_seccomp(SECCOMP_SET_MODE_FILTER, flags, &prog))
+    {
+        ERR_(seh)("prctl(PR_SET_SECCOMP, ...): %s.\n", strerror(errno));
+        return;
+    }
+    check_bpf_jit_enable();
+#else
+    WARN_(seh)("Built without seccomp.\n");
+#endif
+}
 
 /***********************************************************************
  *           handle_interrupt
@@ -1919,6 +2110,30 @@ static BOOL handle_syscall_trap( ucontext_t *sigcontext )
 }
 
 
+/**********************************************************************
+ *    segv_handler_early
+ *
+ * Handler for SIGSEGV and related errors. Used only during the initialization
+ * of the process to handle virtual faults.
+ */
+static void segv_handler_early( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    ucontext_t *ucontext = sigcontext;
+
+    switch(TRAP_sig(ucontext))
+    {
+    case TRAP_x86_PAGEFLT:  /* Page fault */
+        if (!virtual_handle_fault( siginfo->si_addr, (ERROR_sig(ucontext) >> 1) & 0x09,
+                NULL ))
+            return;
+        /* fall-through */
+    default:
+        WINE_ERR( "Got unexpected trap %lld during process initialization\n", TRAP_sig(ucontext) );
+        abort_thread(1);
+        break;
+    }
+}
+
 /**********************************************************************
  *		segv_handler
  *
@@ -2460,6 +2675,7 @@ void signal_init_process(void)
     if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
     if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+    install_bpf(&sig_act);
     return;
 
  error:
@@ -2467,6 +2683,29 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+    struct sigaction sig_act;
+
+    sig_act.sa_mask = server_block_set;
+    sig_act.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
+
+    sig_act.sa_sigaction = segv_handler_early;
+    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1) goto error;
+    if (sigaction( SIGILL, &sig_act, NULL ) == -1) goto error;
+#ifdef SIGBUS
+    if (sigaction( SIGBUS, &sig_act, NULL ) == -1) goto error;
+#endif
+
+    return;
+
+ error:
+    perror("sigaction");
+    exit(1);
+}
 
 /***********************************************************************
  *           call_init_thunk
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index bfbcaf4..3a9fc76 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -63,6 +63,7 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "unix_private.h"
+#include "esync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(sync);
 
@@ -272,6 +273,9 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
+    if (do_esync())
+        return esync_create_semaphore( handle, access, attr, initial, max );
+
     SERVER_START_REQ( create_semaphore )
     {
         req->access  = access;
@@ -296,6 +300,10 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJEC
     unsigned int ret;
 
     *handle = 0;
+
+    if (do_esync())
+        return esync_open_semaphore( handle, access, attr );
+
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
     SERVER_START_REQ( open_semaphore )
@@ -332,6 +340,9 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
 
     if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if (do_esync())
+        return esync_query_semaphore( handle, info, ret_len );
+
     SERVER_START_REQ( query_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -354,6 +365,9 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
 {
     unsigned int ret;
 
+    if (do_esync())
+        return esync_release_semaphore( handle, count, previous );
+
     SERVER_START_REQ( release_semaphore )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -380,6 +394,10 @@ NTSTATUS WINAPI NtCreateEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_
 
     *handle = 0;
     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
+
+    if (do_esync())
+        return esync_create_event( handle, access, attr, type, state );
+
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_event )
@@ -408,6 +426,9 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
+    if (do_esync())
+        return esync_open_event( handle, access, attr );
+
     SERVER_START_REQ( open_event )
     {
         req->access     = access;
@@ -428,8 +449,12 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
  */
 NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
 {
+    /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
+    if (do_esync())
+        return esync_set_event( handle );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -447,8 +472,13 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
  */
 NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
 {
+    /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
+    if (do_esync())
+        return esync_reset_event( handle );
+
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -478,6 +508,9 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
 {
     unsigned int ret;
 
+    if (do_esync())
+        return esync_pulse_event( handle );
+
     SERVER_START_REQ( event_op )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -509,6 +542,9 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
 
     if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if (do_esync())
+        return esync_query_event( handle, info, ret_len );
+
     SERVER_START_REQ( query_event )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -535,6 +571,10 @@ NTSTATUS WINAPI NtCreateMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT
     struct object_attributes *objattr;
 
     *handle = 0;
+
+    if (do_esync())
+        return esync_create_mutex( handle, access, attr, owned );
+
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
     SERVER_START_REQ( create_mutex )
@@ -562,6 +602,9 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_A
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
+    if (do_esync())
+        return esync_open_mutex( handle, access, attr );
+
     SERVER_START_REQ( open_mutex )
     {
         req->access  = access;
@@ -584,6 +627,9 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
 {
     unsigned int ret;
 
+    if (do_esync())
+        return esync_release_mutex( handle, prev_count );
+
     SERVER_START_REQ( release_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -614,6 +660,9 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
 
     if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if (do_esync())
+        return esync_query_mutex( handle, info, ret_len );
+
     SERVER_START_REQ( query_mutex )
     {
         req->handle = wine_server_obj_handle( handle );
@@ -1472,6 +1521,13 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
+    if (do_esync())
+    {
+        NTSTATUS ret = esync_wait_objects( count, handles, wait_any, alertable, timeout );
+        if (ret != STATUS_NOT_IMPLEMENTED)
+            return ret;
+    }
+
     if (alertable) flags |= SELECT_ALERTABLE;
     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
@@ -1497,6 +1553,9 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    if (do_esync())
+        return esync_signal_and_wait( signal, wait, alertable, timeout );
+
     if (!signal) return STATUS_INVALID_HANDLE;
 
     if (alertable) flags |= SELECT_ALERTABLE;
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 07f2724..d8eaabe 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -93,6 +93,7 @@ struct ntdll_thread_data
 {
     void              *cpu_data[16];  /* reserved for CPU-specific data */
     void              *kernel_stack;  /* stack for thread startup and kernel syscalls */
+    int                esync_apc_fd;  /* fd to wait on for user APCs */
     int                request_fd;    /* fd for sending server requests */
     int                reply_fd;      /* fd for receiving server replies */
     int                wait_fd[2];    /* fd for sleeping server requests */
@@ -117,6 +118,7 @@ struct async_fileio
 {
     async_callback_t    *callback;
     struct async_fileio *next;
+    DWORD                size;
     HANDLE               handle;
 };
 
@@ -275,6 +277,7 @@ extern void signal_init_threading(void);
 extern NTSTATUS signal_alloc_thread( TEB *teb );
 extern void signal_free_thread( TEB *teb );
 extern void signal_init_process(void);
+extern void signal_init_early(void);
 extern void DECLSPEC_NORETURN signal_start_thread( PRTL_THREAD_START_ROUTINE entry, void *arg,
                                                    BOOL suspend, TEB *teb );
 extern SYSTEM_SERVICE_TABLE KeServiceDescriptorTable[4];
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index abe1b4d..e18a1f0 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -122,11 +122,13 @@ struct file_view
 #define VPROT_GUARD      0x10
 #define VPROT_COMMITTED  0x20
 #define VPROT_WRITEWATCH 0x40
+#define VPROT_WRITTEN    0x80
 /* per-mapping protection flags */
 #define VPROT_ARM64EC          0x0100  /* view may contain ARM64EC code */
 #define VPROT_SYSTEM           0x0200  /* system view (underlying mmap not under our control) */
 #define VPROT_PLACEHOLDER      0x0400
 #define VPROT_FREE_PLACEHOLDER 0x0800
+#define VPROT_NATIVE           0x1000
 
 /* Conversion from VPROT_* to Win32 flags */
 static const BYTE VIRTUAL_Win32Flags[16] =
@@ -175,6 +177,8 @@ static void *working_set_limit   = (void *)0x7fff0000;
 static void *host_addr_space_limit;  /* top of the host virtual address space */
 
 static struct file_view *arm64ec_view;
+static const ptrdiff_t max_try_map_step = 0x40000000;
+static BOOL increase_try_map_step = TRUE;
 
 ULONG_PTR user_space_wow_limit = 0;
 struct _KUSER_SHARED_DATA *user_shared_data = (void *)0x7ffe0000;
@@ -205,7 +209,11 @@ static BYTE *pages_vprot;
 #endif
 
 static struct file_view *view_block_start, *view_block_end, *next_free_view;
+#ifdef _WIN64
+static const size_t view_block_size = 0x200000;
+#else
 static const size_t view_block_size = 0x100000;
+#endif
 static void *preload_reserve_start;
 static void *preload_reserve_end;
 static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
@@ -500,6 +508,21 @@ static void reserve_area( void *addr, void *end )
 #endif /* __APPLE__ */
 }
 
+/* This might look like a hack, but it actually isn't - the 'experimental' version
+ * is correct, but it already has revealed a couple of additional Wine bugs, which
+ * were not triggered before, and there are probably some more.
+ * To avoid breaking Wine for everyone, the new correct implementation has to be
+ * manually enabled, until it is tested a bit more. */
+static inline BOOL experimental_WRITECOPY( void )
+{
+    static int enabled = -1;
+    if (enabled == -1)
+    {
+        const char *str = getenv("STAGING_WRITECOPY");
+        enabled = str && (atoi(str) != 0);
+    }
+    return enabled;
+}
 
 static void mmap_init( const struct preload_info *preload_info )
 {
@@ -1106,8 +1129,19 @@ static int get_unix_prot( BYTE vprot )
     {
         if (vprot & VPROT_READ) prot |= PROT_READ;
         if (vprot & VPROT_WRITE) prot |= PROT_WRITE | PROT_READ;
-        if (vprot & VPROT_WRITECOPY) prot |= PROT_WRITE | PROT_READ;
         if (vprot & VPROT_EXEC) prot |= PROT_EXEC | PROT_READ;
+#if defined(__i386__) || defined(__x86_64__)
+        if (vprot & VPROT_WRITECOPY)
+        {
+            if (experimental_WRITECOPY() && !(vprot & VPROT_WRITTEN))
+                prot = (prot & ~PROT_WRITE) | PROT_READ;
+            else
+                prot |= PROT_WRITE | PROT_READ;
+        }
+#else
+        /* FIXME: Architecture needs implementation of signal_init_early. */
+        if (vprot & VPROT_WRITECOPY) prot |= PROT_WRITE | PROT_READ;
+#endif
         if (vprot & VPROT_WRITEWATCH) prot &= ~PROT_WRITE;
     }
     if (!prot) prot = PROT_NONE;
@@ -1125,7 +1159,9 @@ static void dump_view( struct file_view *view )
     BYTE prot = get_page_vprot( addr );
 
     TRACE( "View: %p - %p", addr, addr + view->size - 1 );
-    if (view->protect & VPROT_SYSTEM)
+    if (view->protect & VPROT_NATIVE)
+        TRACE(" (native)\n");
+    else if (view->protect & VPROT_SYSTEM)
         TRACE( " (builtin image)\n" );
     else if (view->protect & VPROT_FREE_PLACEHOLDER)
         TRACE( " (placeholder)\n" );
@@ -1237,43 +1273,17 @@ static struct file_view *find_view_range( const void *addr, size_t size )
 }
 
 
-/***********************************************************************
- *           find_view_inside_range
- *
- * Find first (resp. last, if top_down) view inside a range.
- * virtual_mutex must be held by caller.
- */
-static struct wine_rb_entry *find_view_inside_range( void **base_ptr, void **end_ptr, int top_down )
-{
-    struct wine_rb_entry *first = NULL, *ptr = views_tree.root;
-    void *base = *base_ptr, *end = *end_ptr;
-
-    /* find the first (resp. last) view inside the range */
-    while (ptr)
-    {
-        struct file_view *view = WINE_RB_ENTRY_VALUE( ptr, struct file_view, entry );
-        if ((char *)view->base + view->size >= (char *)end)
-        {
-            end = min( end, view->base );
-            ptr = ptr->left;
-        }
-        else if (view->base <= base)
-        {
-            base = max( (char *)base, (char *)view->base + view->size );
-            ptr = ptr->right;
-        }
-        else
-        {
-            first = ptr;
-            ptr = top_down ? ptr->right : ptr->left;
-        }
-    }
-
-    *base_ptr = base;
-    *end_ptr = end;
-    return first;
-}
 
+struct alloc_area
+{
+    size_t size;
+    ptrdiff_t step;
+    int unix_prot;
+    BOOL top_down;
+    UINT_PTR align_mask;
+    char *native_mapped;
+    size_t native_mapped_size;
+};
 
 /***********************************************************************
  *           try_map_free_area
@@ -1281,9 +1291,12 @@ static struct wine_rb_entry *find_view_inside_range( void **base_ptr, void **end
  * Try mmaping some expected free memory region, eventually stepping and
  * retrying inside it, and return where it actually succeeded, or NULL.
  */
-static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
-                                void *start, size_t size, int unix_prot )
+static void* try_map_free_area( struct alloc_area *area, void *base, void *end, void *start )
 {
+    ptrdiff_t step = area->step;
+    size_t abs_step = step > 0 ? step : -step;
+    size_t size = area->size;
+    int unix_prot = area->unix_prot;
     void *ptr;
 
     while (start && base <= start && (char*)start + size <= (char*)end)
@@ -1296,123 +1309,25 @@ static void* try_map_free_area( void *base, void *end, ptrdiff_t step,
                  strerror(errno), start, (char *)start + size, unix_prot );
             return NULL;
         }
+        if (!area->native_mapped && step && abs_step < (granularity_mask + 1) * 2)
+        {
+            area->native_mapped = start;
+            area->native_mapped_size = abs_step;
+            area->native_mapped_size = min(area->native_mapped_size, (char *)end - (char *)start);
+        }
         if ((step > 0 && (char *)end - (char *)start < step) ||
             (step < 0 && (char *)start - (char *)base < -step) ||
             step == 0)
             break;
         start = (char *)start + step;
+        if (increase_try_map_step && llabs(step) < max_try_map_step)
+            step *= 2;
     }
 
     return NULL;
 }
 
 
-/***********************************************************************
- *           map_free_area
- *
- * Find a free area between views inside the specified range and map it.
- * virtual_mutex must be held by caller.
- */
-static void *map_free_area( void *base, void *end, size_t size, int top_down, int unix_prot, size_t align_mask )
-{
-    struct wine_rb_entry *first = find_view_inside_range( &base, &end, top_down );
-    ptrdiff_t step = top_down ? -(align_mask + 1) : (align_mask + 1);
-    void *start;
-
-    if (top_down)
-    {
-        start = ROUND_ADDR( (char *)end - size, align_mask );
-        if (start >= end || start < base) return NULL;
-
-        while (first)
-        {
-            struct file_view *view = WINE_RB_ENTRY_VALUE( first, struct file_view, entry );
-            if ((start = try_map_free_area( (char *)view->base + view->size, (char *)start + size, step,
-                                            start, size, unix_prot ))) break;
-            start = ROUND_ADDR( (char *)view->base - size, align_mask );
-            /* stop if remaining space is not large enough */
-            if (!start || start >= end || start < base) return NULL;
-            first = rb_prev( first );
-        }
-    }
-    else
-    {
-        start = ROUND_ADDR( (char *)base + align_mask, align_mask );
-        if (!start || start >= end || (char *)end - (char *)start < size) return NULL;
-
-        while (first)
-        {
-            struct file_view *view = WINE_RB_ENTRY_VALUE( first, struct file_view, entry );
-            if ((start = try_map_free_area( start, view->base, step,
-                                            start, size, unix_prot ))) break;
-            start = ROUND_ADDR( (char *)view->base + view->size + align_mask, align_mask );
-            /* stop if remaining space is not large enough */
-            if (!start || start >= end || (char *)end - (char *)start < size) return NULL;
-            first = rb_next( first );
-        }
-    }
-
-    if (!first)
-        start = try_map_free_area( base, end, step, start, size, unix_prot );
-
-    if (!start)
-        ERR( "couldn't map free area in range %p-%p, size %p\n", base, end, (void *)size );
-
-    return start;
-}
-
-
-/***********************************************************************
- *           find_reserved_free_area
- *
- * Find a free area between views inside the specified range.
- * virtual_mutex must be held by caller.
- * The range must be inside a reserved area.
- */
-static void *find_reserved_free_area( void *base, void *end, size_t size, int top_down, size_t align_mask )
-{
-    struct range_entry *range;
-    void *start;
-
-    base = ROUND_ADDR( (char *)base + align_mask, align_mask );
-    end = (char *)ROUND_ADDR( (char *)end - size, align_mask ) + size;
-
-    if (top_down)
-    {
-        start = (char *)end - size;
-        range = free_ranges_lower_bound( start );
-        assert(range != free_ranges_end && range->end >= start);
-
-        if ((char *)range->end - (char *)start < size) start = ROUND_ADDR( (char *)range->end - size, align_mask );
-        do
-        {
-            if (start >= end || start < base || (char *)end - (char *)start < size) return NULL;
-            if (start < range->end && start >= range->base && (char *)range->end - (char *)start >= size) break;
-            if (--range < free_ranges) return NULL;
-            start = ROUND_ADDR( (char *)range->end - size, align_mask );
-        }
-        while (1);
-    }
-    else
-    {
-        start = base;
-        range = free_ranges_lower_bound( start );
-        assert(range != free_ranges_end && range->end >= start);
-
-        if (start < range->base) start = ROUND_ADDR( (char *)range->base + align_mask, align_mask );
-        do
-        {
-            if (start >= end || start < base || (char *)end - (char *)start < size) return NULL;
-            if (start < range->end && start >= range->base && (char *)range->end - (char *)start >= size) break;
-            if (++range == free_ranges_end) return NULL;
-            start = ROUND_ADDR( (char *)range->base + align_mask, align_mask );
-        }
-        while (1);
-    }
-    return start;
-}
-
-
 /***********************************************************************
  *           remove_reserved_area
  *
@@ -1522,8 +1437,7 @@ static void free_view( struct file_view *view )
  */
 static void unregister_view( struct file_view *view )
 {
-    if (mmap_is_in_reserved_area( view->base, view->size ))
-        free_ranges_remove_view( view );
+    free_ranges_remove_view( view );
     wine_rb_remove( &views_tree, &view->entry );
 }
 
@@ -1551,8 +1465,7 @@ static void delete_view( struct file_view *view ) /* [in] View */
 static void register_view( struct file_view *view )
 {
     wine_rb_put( &views_tree, view->base, &view->entry );
-    if (mmap_is_in_reserved_area( view->base, view->size ))
-        free_ranges_insert_view( view );
+    free_ranges_insert_view( view );
 }
 
 
@@ -1616,7 +1529,11 @@ static NTSTATUS create_view( struct file_view **view_ret, void *base, size_t siz
  */
 static DWORD get_win32_prot( BYTE vprot, unsigned int map_prot )
 {
-    DWORD ret = VIRTUAL_Win32Flags[vprot & 0x0f];
+    DWORD ret;
+
+    if ((vprot & VPROT_WRITECOPY) && (vprot & VPROT_WRITTEN))
+        vprot = (vprot & ~VPROT_WRITECOPY) | VPROT_WRITE;
+    ret = VIRTUAL_Win32Flags[vprot & 0x0f];
     if (vprot & VPROT_GUARD) ret |= PAGE_GUARD;
     if (map_prot & SEC_NOCACHE) ret |= PAGE_NOCACHE;
     return ret;
@@ -1727,12 +1644,22 @@ static BOOL set_vprot( struct file_view *view, void *base, size_t size, BYTE vpr
     if (view->protect & VPROT_WRITEWATCH)
     {
         /* each page may need different protections depending on write watch flag */
-        set_page_vprot_bits( base, size, vprot & ~VPROT_WRITEWATCH, ~vprot & ~VPROT_WRITEWATCH );
+        set_page_vprot_bits( base, size, vprot & ~VPROT_WRITEWATCH, ~vprot & ~(VPROT_WRITEWATCH|VPROT_WRITTEN) );
         mprotect_range( base, size, 0, 0 );
         return TRUE;
     }
+
+    /* check that we can map this memory with PROT_WRITE since we cannot fail later,
+     * but we fallback to copying pages for read-only mappings in virtual_handle_fault */
+    if ((vprot & VPROT_WRITECOPY) && (view->protect & VPROT_WRITECOPY))
+        unix_prot |= PROT_WRITE;
+
     if (mprotect_exec( base, size, unix_prot )) return FALSE;
-    set_page_vprot( base, size, vprot );
+    /* each page may need different protections depending on writecopy */
+    set_page_vprot_bits( base, size, vprot, ~vprot & ~VPROT_WRITTEN );
+    if (vprot & VPROT_WRITECOPY)
+        mprotect_range( base, size, 0, 0 );
+
     return TRUE;
 }
 
@@ -1788,7 +1715,7 @@ static void update_write_watches( void *base, size_t size, size_t accessed_size
 {
     TRACE( "updating watch %p-%p-%p\n", base, (char *)base + accessed_size, (char *)base + size );
     /* clear write watch flag on accessed pages */
-    set_page_vprot_bits( base, accessed_size, 0, VPROT_WRITEWATCH );
+    set_page_vprot_bits( base, accessed_size, VPROT_WRITE, VPROT_WRITEWATCH | VPROT_WRITECOPY );
     /* restore page protections on the entire range */
     mprotect_range( base, size, 0, 0 );
 }
@@ -1825,89 +1752,221 @@ static inline void *unmap_extra_space( void *ptr, size_t total_size, size_t want
     return ptr;
 }
 
-
-/***********************************************************************
- *           find_reserved_free_area_outside_preloader
- *
- * Find a free area inside a reserved area, skipping the preloader reserved range.
- * virtual_mutex must be held by caller.
- */
-static void *find_reserved_free_area_outside_preloader( void *start, void *end, size_t size,
-                                                        int top_down, size_t align_mask )
+static void *try_map_free_area_range( struct alloc_area *area, char *start, char *end )
 {
-    void *ret;
+    char *alloc_start;
 
-    if (preload_reserve_end >= end)
+    if (area->top_down)
     {
-        if (preload_reserve_start <= start) return NULL;  /* no space in that area */
-        if (preload_reserve_start < end) end = preload_reserve_start;
+        if (end - start < area->size) return NULL;
+        alloc_start = ROUND_ADDR( end - area->size, area->align_mask );
+        return try_map_free_area( area, start, alloc_start + area->size, alloc_start );
     }
-    else if (preload_reserve_start <= start)
-    {
-        if (preload_reserve_end > start) start = preload_reserve_end;
-    }
-    else /* range is split in two by the preloader reservation, try both parts */
+
+    alloc_start = ROUND_ADDR( start + area->align_mask, area->align_mask );
+    return try_map_free_area( area, start, end, alloc_start );
+}
+
+static void *alloc_free_area_in_range( struct alloc_area *area, char *base, char *end )
+{
+    UINT_PTR align_mask = area->align_mask;
+    char *intersect_start, *intersect_end, *result, *alloc_start;
+    struct reserved_area *res_area;
+
+    TRACE("range %p-%p.\n", base, end);
+
+    if (base >= end)
+        return NULL;
+
+    if (area->top_down)
     {
-        if (top_down)
+        if ((ULONG_PTR)end < area->size) return NULL;
+        alloc_start = ROUND_ADDR( end - area->size, align_mask );
+        if (alloc_start >= end || alloc_start < base) return NULL;
+
+        LIST_FOR_EACH_ENTRY_REV( res_area, &reserved_areas, struct reserved_area, entry )
         {
-            ret = find_reserved_free_area( preload_reserve_end, end, size, top_down, align_mask );
-            if (ret) return ret;
-            end = preload_reserve_start;
+            char *res_start = res_area->base;
+            char *res_end = res_start + res_area->size;
+
+            if (res_start >= end) continue;
+            if (res_end <= base) break;
+
+            intersect_start = max( res_start, base );
+            intersect_end = min( res_end, end );
+            assert( intersect_start <= intersect_end );
+            if ((result = try_map_free_area_range( area, intersect_end, end))) return result;
+
+            if (intersect_end - intersect_start >= area->size)
+            {
+                alloc_start = ROUND_ADDR( intersect_end - area->size, align_mask );
+                if (alloc_start >= intersect_start)
+                {
+                    if ((result = anon_mmap_fixed( alloc_start, area->size, area->unix_prot, 0 )) != alloc_start)
+                        ERR("Could not map in reserved area, alloc_start %p, size %p.\n",
+                                alloc_start, (void *)area->size);
+                    return result;
+                }
+            }
+
+            end = intersect_start;
+            if (end - base < area->size) return NULL;
         }
-        else
+        return try_map_free_area_range( area, base, end );
+    }
+
+    if (base + align_mask < base) return NULL;
+    alloc_start = ROUND_ADDR( base + align_mask, align_mask );
+    if (alloc_start >= end || end - alloc_start < area->size)
+        return NULL;
+
+    LIST_FOR_EACH_ENTRY( res_area, &reserved_areas, struct reserved_area, entry )
+    {
+        char *res_start = res_area->base;
+        char *res_end = res_start + res_area->size;
+
+        if (res_end <= base) continue;
+        if (res_start >= end) break;
+
+        intersect_start = max( res_start, base );
+        intersect_end = min( res_end, end );
+        assert( intersect_start <= intersect_end );
+        if ((result = try_map_free_area_range( area, base, intersect_start ))) return result;
+
+        if (intersect_end - intersect_start >= area->size)
         {
-            ret = find_reserved_free_area( start, preload_reserve_start, size, top_down, align_mask );
-            if (ret) return ret;
-            start = preload_reserve_end;
+            alloc_start = ROUND_ADDR( intersect_start + align_mask, align_mask );
+            if (alloc_start + area->size <= intersect_end)
+            {
+                if ((result = anon_mmap_fixed( alloc_start, area->size, area->unix_prot, 0 )) != alloc_start)
+                    ERR("Could not map in reserved area, alloc_start %p, size %p.\n", alloc_start, (void *)area->size);
+                return result;
+            }
         }
+        base = intersect_end;
+        if (end - base < area->size) return NULL;
     }
-    return find_reserved_free_area( start, end, size, top_down, align_mask );
+    return try_map_free_area_range( area, base, end );
 }
 
-/***********************************************************************
- *           map_reserved_area
- *
- * Try to map some space inside a reserved area.
- * virtual_mutex must be held by caller.
- */
-static void *map_reserved_area( void *limit_low, void *limit_high, size_t size, int top_down,
-                                int unix_prot, size_t align_mask )
+static void *alloc_free_area( char *limit_low, char *limit_high, size_t size, BOOL top_down, int unix_prot, UINT_PTR align_mask )
 {
-    void *ptr = NULL;
-    struct reserved_area *area = LIST_ENTRY( ptr, struct reserved_area, entry );
+    struct range_entry *range, *ranges_start, *ranges_end;
+    char *reserve_start, *reserve_end;
+    struct alloc_area area;
+    char *result = NULL;
+    char *base, *end;
+    int ranges_inc;
+    UINT status;
+
+    TRACE("limit %p-%p, size %p, top_down %#x.\n", limit_low, limit_high, (void *)size, top_down);
 
     if (top_down)
     {
-        LIST_FOR_EACH_ENTRY_REV( area, &reserved_areas, struct reserved_area, entry )
+        ranges_start = free_ranges_end - 1;
+        ranges_end = free_ranges - 1;
+        ranges_inc = -1;
+    }
+    else
+    {
+        ranges_start = free_ranges;
+        ranges_end = free_ranges_end;
+        ranges_inc = 1;
+    }
+
+    memset( &area, 0, sizeof(area) );
+    area.step = top_down ? -(align_mask + 1) : (align_mask + 1);
+    area.size = size;
+    area.top_down = top_down;
+    area.unix_prot = unix_prot;
+    area.align_mask = align_mask;
+
+    reserve_start = preload_reserve_start;
+    reserve_end = preload_reserve_end;
+
+    for (range = ranges_start; range != ranges_end; range += ranges_inc)
+    {
+        base = range->base;
+        end = range->end;
+
+        TRACE("range %p-%p.\n", base, end);
+
+        if (base < limit_low) base = limit_low;
+        if (end > limit_high) end = limit_high;
+        if (base > end || end - base < size) continue;
+
+        if (reserve_end >= base)
         {
-            void *start = area->base;
-            void *end = (char *)start + area->size;
-
-            if (start >= limit_high) continue;
-            if (end <= limit_low) return NULL;
-            if (start < limit_low) start = limit_low;
-            if (end > limit_high) end = limit_high;
-            ptr = find_reserved_free_area_outside_preloader( start, end, size, top_down, align_mask );
-            if (ptr) break;
+            if (reserve_end >= end)
+            {
+                if (reserve_start <= base)
+                    continue;  /* no space in that area */
+
+                if (reserve_start < end)
+                    end = reserve_start;
+            }
+            else if (reserve_start <= base)
+            {
+                base = reserve_end;
+            }
+            else
+            {
+                /* range is split in two by the preloader reservation, try first part. */
+                if ((result = alloc_free_area_in_range( &area, base, reserve_start )))
+                    break;
+                /* then fall through to try second part. */
+                base = reserve_end;
+            }
         }
+
+        if ((result = alloc_free_area_in_range( &area, base, end )))
+            break;
     }
-    else
+
+    if (area.native_mapped)
     {
-        LIST_FOR_EACH_ENTRY( area, &reserved_areas, struct reserved_area, entry )
+        char *native_mapped_start, *native_mapped_end;
+
+        TRACE("Excluding %p - %p from free list.\n",
+                area.native_mapped, (char *)area.native_mapped + area.native_mapped_size );
+
+        native_mapped_start = ROUND_ADDR(area.native_mapped, granularity_mask);
+        native_mapped_end = ROUND_ADDR(area.native_mapped + area.native_mapped_size + granularity_mask,
+                granularity_mask);
+
+        if (result >= native_mapped_end || result + size < native_mapped_start)
+        /* In case of top down allocation try_map_free_area() result area can overlap the
+         * area previously marked as native if the latter was unmapped behind our back. */
         {
-            void *start = area->base;
-            void *end = (char *)start + area->size;
-
-            if (start >= limit_high) return NULL;
-            if (end <= limit_low) continue;
-            if (start < limit_low) start = limit_low;
-            if (end > limit_high) end = limit_high;
-            ptr = find_reserved_free_area_outside_preloader( start, end, size, top_down, align_mask );
-            if (ptr) break;
+            struct file_view *prev, *next;
+
+            prev = find_view_range( native_mapped_start - 1, native_mapped_end - native_mapped_start + 2 );
+            if (prev && (char *)prev->base >= native_mapped_end)
+            {
+                next = prev;
+                prev = WINE_RB_ENTRY_VALUE( rb_prev( &next->entry ), struct file_view, entry );
+            }
+            else if (prev) next = WINE_RB_ENTRY_VALUE( rb_next( &prev->entry ), struct file_view, entry );
+            else           next = NULL;
+
+            if (prev && prev->protect & VPROT_NATIVE && (char *)prev->base + prev->size >= native_mapped_start)
+            {
+                assert( (char *)prev->base + prev->size == native_mapped_start );
+                native_mapped_start = prev->base;
+                delete_view( prev );
+            }
+            if (next && next->protect & VPROT_NATIVE && native_mapped_end >= (char *)next->base)
+            {
+                assert( native_mapped_end == (char *)next->base );
+                native_mapped_end = (char *)next->base + next->size;
+                delete_view( next );
+            }
+            if ((status = create_view( &next, native_mapped_start, native_mapped_end - native_mapped_start,
+                    VPROT_SYSTEM | VPROT_NATIVE )))
+                ERR("Could not create view for natively mapped area, status %#x.\n", status);
         }
     }
-    if (ptr && anon_mmap_fixed( ptr, size, unix_prot, 0 ) != ptr) ptr = NULL;
-    return ptr;
+    return result;
 }
 
 /***********************************************************************
@@ -1966,6 +2025,17 @@ failed:
     return status;
 }
 
+static void clear_native_views(void)
+{
+    struct file_view *view, *next_view;
+
+    WINE_RB_FOR_EACH_ENTRY_DESTRUCTOR( view, next_view, &views_tree, struct file_view, entry )
+    {
+        if (view->protect & VPROT_NATIVE)
+            delete_view( view );
+    }
+}
+
 /***********************************************************************
  *           map_view
  *
@@ -2011,48 +2081,21 @@ static NTSTATUS map_view( struct file_view **view_ret, void *base, size_t size,
     }
     else
     {
-        void *start = address_space_start;
-        void *end = min( user_space_limit, host_addr_space_limit );
-        size_t view_size, unmap_size;
-
+        limit_high = limit_high ? min( limit_high + 1, (UINT_PTR)user_space_limit) : (UINT_PTR)user_space_limit;
+        if (limit_low < (ULONG_PTR)address_space_start) limit_low = (ULONG_PTR)address_space_start;
         if (!align_mask) align_mask = granularity_mask;
-        view_size = size + align_mask + 1;
 
-        if (limit_low && (void *)limit_low > start) start = (void *)limit_low;
-        if (limit_high && (void *)limit_high < end) end = (char *)limit_high + 1;
-
-        if ((ptr = map_reserved_area( start, end, size, top_down, get_unix_prot(vprot), align_mask )))
+        if (!(ptr = alloc_free_area( (void *)limit_low, (void *)limit_high, size, top_down, get_unix_prot( vprot ), align_mask )))
         {
-            TRACE( "got mem in reserved area %p-%p\n", ptr, (char *)ptr + size );
-            goto done;
-        }
+            WARN("Allocation failed, clearing native views.\n");
 
-        if (start > address_space_start || end < host_addr_space_limit || top_down)
-        {
-            if (!(ptr = map_free_area( start, end, size, top_down, get_unix_prot(vprot), align_mask )))
-                return STATUS_NO_MEMORY;
-            TRACE( "got mem with map_free_area %p-%p\n", ptr, (char *)ptr + size );
-            goto done;
+            clear_native_views();
+            if (!is_win64) increase_try_map_step = FALSE;
+            ptr = alloc_free_area( (void *)limit_low, (void *)limit_high, size, top_down, get_unix_prot( vprot ), align_mask );
+            if (!is_win64) increase_try_map_step = TRUE;
+            if (!ptr) return STATUS_NO_MEMORY;
         }
-
-        for (;;)
-        {
-            if ((ptr = anon_mmap_alloc( view_size, get_unix_prot(vprot) )) == MAP_FAILED)
-            {
-                status = (errno == ENOMEM) ? STATUS_NO_MEMORY : STATUS_INVALID_PARAMETER;
-                ERR( "anon mmap error %s, size %p, unix_prot %#x\n",
-                     strerror(errno), (void *)view_size, get_unix_prot( vprot ) );
-                return status;
-            }
-            TRACE( "got mem with anon mmap %p-%p\n", ptr, (char *)ptr + size );
-            /* if we got something beyond the user limit, unmap it and retry */
-            if (!is_beyond_limit( ptr, view_size, user_space_limit )) break;
-            unmap_size = unmap_area_above_user_limit( ptr, view_size );
-            if (unmap_size) munmap( ptr, unmap_size );
-        }
-        ptr = unmap_extra_space( ptr, view_size, size, align_mask );
     }
-done:
     status = create_view( view_ret, ptr, size, vprot );
     if (status != STATUS_SUCCESS) unmap_area( ptr, size );
     return status;
@@ -2854,6 +2897,8 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
                            ptr + sec->VirtualAddress + file_size,
                            ptr + sec->VirtualAddress + end );
             memset( ptr + sec->VirtualAddress + file_size, 0, end - file_size );
+            /* clear WRITTEN mark so QueryVirtualMemory returns correct values */
+            set_page_vprot_bits( ptr + sec->VirtualAddress + file_size, 1, 0, VPROT_WRITTEN );
         }
     }
 
@@ -3231,6 +3276,7 @@ static unsigned int virtual_map_section( HANDLE handle, PVOID *addr_ptr, ULONG_P
 done:
     server_leave_uninterrupted_section( &virtual_mutex, &sigset );
     if (needs_close) close( unix_handle );
+    TRACE("status %#x.\n", res);
     return res;
 }
 
@@ -3641,6 +3687,7 @@ static TEB *init_teb( void *ptr, BOOL is_wow )
     teb->StaticUnicodeString.Buffer = teb->StaticUnicodeBuffer;
     teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
     thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
+    thread_data->esync_apc_fd = -1;
     thread_data->request_fd = -1;
     thread_data->reply_fd   = -1;
     thread_data->wait_fd[0] = -1;
@@ -3787,7 +3834,7 @@ NTSTATUS virtual_clear_tls_index( ULONG index )
         server_enter_uninterrupted_section( &virtual_mutex, &sigset );
         LIST_FOR_EACH_ENTRY( thread_data, &teb_list, struct ntdll_thread_data, entry )
         {
-            TEB *teb = CONTAINING_RECORD( thread_data, TEB, GdiTebBatch );
+            TEB *teb = CONTAINING_RECORD( (GDI_TEB_BATCH *)thread_data, TEB, GdiTebBatch );
 #ifdef _WIN64
             WOW_TEB *wow_teb = get_wow_teb( teb );
             if (wow_teb) wow_teb->TlsSlots[index] = 0;
@@ -3805,7 +3852,7 @@ NTSTATUS virtual_clear_tls_index( ULONG index )
         server_enter_uninterrupted_section( &virtual_mutex, &sigset );
         LIST_FOR_EACH_ENTRY( thread_data, &teb_list, struct ntdll_thread_data, entry )
         {
-            TEB *teb = CONTAINING_RECORD( thread_data, TEB, GdiTebBatch );
+            TEB *teb = CONTAINING_RECORD( (GDI_TEB_BATCH *)thread_data, TEB, GdiTebBatch );
 #ifdef _WIN64
             WOW_TEB *wow_teb = get_wow_teb( teb );
             if (wow_teb)
@@ -3988,7 +4035,7 @@ NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
     }
 #endif
 
-    if (!is_inside_signal_stack( stack ) && (vprot & VPROT_GUARD))
+    if (stack && !is_inside_signal_stack( stack ) && (vprot & VPROT_GUARD))
     {
         struct thread_stack_info stack_info;
         if (!is_inside_thread_stack( page, &stack_info ))
@@ -4006,12 +4053,29 @@ NTSTATUS virtual_handle_fault( void *addr, DWORD err, void *stack )
             set_page_vprot_bits( page, page_size, 0, VPROT_WRITEWATCH );
             mprotect_range( page, page_size, 0, 0 );
         }
-        /* ignore fault if page is writable now */
-        if (get_unix_prot( get_page_vprot( page )) & PROT_WRITE)
+        if ((vprot & VPROT_WRITECOPY) && (vprot & VPROT_COMMITTED))
         {
-            if ((vprot & VPROT_WRITEWATCH) || is_write_watch_range( page, page_size ))
-                ret = STATUS_SUCCESS;
+            struct file_view *view = find_view( page, 0 );
+
+            set_page_vprot_bits( page, page_size, VPROT_WRITE | VPROT_WRITTEN, VPROT_WRITECOPY );
+            if (view->protect & VPROT_WRITECOPY)
+            {
+                mprotect_range( page, page_size, 0, 0 );
+            }
+            else
+            {
+                static BYTE *temp_page = NULL;
+                if (!temp_page)
+                    temp_page = anon_mmap_alloc( page_size, PROT_READ | PROT_WRITE );
+
+                /* original mapping is shared, replace with a private page */
+                memcpy( temp_page, page, page_size );
+                anon_mmap_fixed( page, page_size, get_unix_prot( vprot | VPROT_WRITE | VPROT_WRITTEN ), 0 );
+                memcpy( page, temp_page, page_size );
+            }
         }
+        /* ignore fault if page is writable now */
+        if (get_unix_prot( get_page_vprot( page ) ) & PROT_WRITE) ret = STATUS_SUCCESS;
     }
     mutex_unlock( &virtual_mutex );
     return ret;
@@ -4084,11 +4148,16 @@ static NTSTATUS check_write_access( void *base, size_t size, BOOL *has_write_wat
     {
         BYTE vprot = get_page_vprot( addr + i );
         if (vprot & VPROT_WRITEWATCH) *has_write_watch = TRUE;
+        if (vprot & VPROT_WRITECOPY)
+        {
+            vprot = (vprot & ~VPROT_WRITECOPY) | VPROT_WRITE;
+            *has_write_watch = TRUE;
+        }
         if (!(get_unix_prot( vprot & ~VPROT_WRITEWATCH ) & PROT_WRITE))
             return STATUS_INVALID_USER_BUFFER;
     }
     if (*has_write_watch)
-        mprotect_range( addr, size, 0, VPROT_WRITEWATCH );  /* temporarily enable write access */
+        mprotect_range( addr, size, VPROT_WRITE, VPROT_WRITEWATCH | VPROT_WRITECOPY );  /* temporarily enable write access */
     return STATUS_SUCCESS;
 }
 
@@ -4364,7 +4433,12 @@ void virtual_set_force_exec( BOOL enable )
         WINE_RB_FOR_EACH_ENTRY( view, &views_tree, struct file_view, entry )
         {
             /* file mappings are always accessible */
-            BYTE commit = is_view_valloc( view ) ? 0 : VPROT_COMMITTED;
+            BYTE commit;
+
+            if (view->protect & VPROT_NATIVE)
+                continue;
+
+            commit = is_view_valloc( view ) ? 0 : VPROT_COMMITTED;
 
             mprotect_range( view->base, view->size, commit, 0 );
         }
@@ -5218,7 +5292,7 @@ static NTSTATUS get_working_set_ex( HANDLE process, LPCVOID addr,
             }
 
             p->VirtualAttributes.Valid = !(vprot & VPROT_GUARD) && (vprot & 0x0f) && (pagemap >> 63);
-            p->VirtualAttributes.Shared = !is_view_valloc( view ) && ((pagemap >> 61) & 1);
+            p->VirtualAttributes.Shared = (!is_view_valloc( view ) && ((pagemap >> 61) & 1)) || ((view->protect & VPROT_WRITECOPY) && !(vprot & VPROT_WRITTEN));
             if (p->VirtualAttributes.Shared && p->VirtualAttributes.Valid)
                 p->VirtualAttributes.ShareCount = 1; /* FIXME */
             if (p->VirtualAttributes.Valid)
@@ -6137,6 +6211,7 @@ NTSTATUS WINAPI NtWow64AllocateVirtualMemory64( HANDLE process, ULONG64 *ret, UL
         *ret = (ULONG_PTR)base;
         *size_ptr = size;
     }
+    TRACE("status %#x.\n", status);
     return status;
 }
 
diff --git a/dlls/ntoskrnl.exe/tests/Makefile.in b/dlls/ntoskrnl.exe/tests/Makefile.in
index f610df6..97dee8b 100644
--- a/dlls/ntoskrnl.exe/tests/Makefile.in
+++ b/dlls/ntoskrnl.exe/tests/Makefile.in
@@ -1,7 +1,7 @@
 TESTDLL   = ntoskrnl.exe
 IMPORTS   = advapi32 crypt32 newdev setupapi user32 wintrust ws2_32 hid
 
-driver_IMPORTS = winecrt0 ntoskrnl hal
+driver_IMPORTS = winecrt0 ntoskrnl hal fltmgr
 driver_EXTRADLLFLAGS = -nodefaultlibs -nostartfiles -Wl,--subsystem,native
 driver2_IMPORTS = winecrt0 ntoskrnl hal
 driver2_EXTRADLLFLAGS = -nodefaultlibs -nostartfiles -Wl,--subsystem,native
diff --git a/dlls/ntoskrnl.exe/tests/driver.c b/dlls/ntoskrnl.exe/tests/driver.c
index de68dcc..844a181 100644
--- a/dlls/ntoskrnl.exe/tests/driver.c
+++ b/dlls/ntoskrnl.exe/tests/driver.c
@@ -36,6 +36,7 @@
 #include "ddk/ntddk.h"
 #include "ddk/ntifs.h"
 #include "ddk/wdm.h"
+#include "ddk/fltkernel.h"
 
 #include "driver.h"
 
@@ -56,6 +57,7 @@ static int kmemcmp( const void *ptr1, const void *ptr2, size_t n )
 
 static DRIVER_OBJECT *driver_obj;
 static DEVICE_OBJECT *lower_device, *upper_device;
+static LDR_DATA_TABLE_ENTRY *ldr_module;
 
 static POBJECT_TYPE *pExEventObjectType, *pIoFileObjectType, *pPsThreadType, *pIoDriverObjectType;
 static PEPROCESS *pPsInitialSystemProcess;
@@ -1715,6 +1717,7 @@ static void test_resource(void)
     ok(status == STATUS_SUCCESS, "got status %#lx\n", status);
 }
 
+
 static void test_lookup_thread(void)
 {
     NTSTATUS status;
@@ -2345,6 +2348,131 @@ static void test_driver_object_extension(void)
     ok(get_obj_ext == NULL, "got %p\n", get_obj_ext);
 }
 
+static void test_default_modules(void)
+{
+    BOOL win32k = FALSE, dxgkrnl = FALSE, dxgmms1 = FALSE;
+    LIST_ENTRY *start, *entry;
+    ANSI_STRING name_a;
+    LDR_DATA_TABLE_ENTRY *mod;
+    NTSTATUS status;
+
+    /* Try to find start of the InLoadOrderModuleList list */
+    for (start = ldr_module->InLoadOrderLinks.Flink; ; start = start->Flink)
+    {
+        mod = CONTAINING_RECORD(start, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
+
+        if (!MmIsAddressValid(&mod->DllBase) || !mod->DllBase) break;
+        if (!MmIsAddressValid(&mod->LoadCount) || !mod->LoadCount) break;
+        if (!MmIsAddressValid(&mod->SizeOfImage) || !mod->SizeOfImage) break;
+        if (!MmIsAddressValid(&mod->EntryPoint) || mod->EntryPoint < mod->DllBase ||
+            (DWORD_PTR)mod->EntryPoint > (DWORD_PTR)mod->DllBase + mod->SizeOfImage) break;
+    }
+
+    for (entry = start->Flink; entry != start; entry = entry->Flink)
+    {
+        mod = CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
+
+        status = RtlUnicodeStringToAnsiString(&name_a, &mod->BaseDllName, TRUE);
+        ok(!status, "RtlUnicodeStringToAnsiString failed with %08lx\n", status);
+        if (status) continue;
+
+        if (entry == start->Flink)
+        {
+            ok(!strncmp(name_a.Buffer, "ntoskrnl.exe", name_a.Length),
+               "Expected ntoskrnl.exe, got %.*s\n", name_a.Length, name_a.Buffer);
+        }
+
+        if (!strncmp(name_a.Buffer, "win32k.sys", name_a.Length)) win32k = TRUE;
+        if (!strncmp(name_a.Buffer, "dxgkrnl.sys", name_a.Length)) dxgkrnl = TRUE;
+        if (!strncmp(name_a.Buffer, "dxgmms1.sys", name_a.Length)) dxgmms1 = TRUE;
+
+        RtlFreeAnsiString(&name_a);
+    }
+
+    ok(win32k, "Failed to find win32k.sys\n");
+    ok(dxgkrnl, "Failed to find dxgkrnl.sys\n");
+    ok(dxgmms1, "Failed to find dxgmms1.sys\n");
+}
+
+static void test_default_security(void)
+{
+    PSECURITY_DESCRIPTOR sd = NULL;
+    NTSTATUS status;
+    PSID group = NULL, owner = NULL;
+    BOOLEAN isdefault, present;
+    PACL acl = NULL;
+    PACCESS_ALLOWED_ACE ace;
+    SID_IDENTIFIER_AUTHORITY auth = { SECURITY_NULL_SID_AUTHORITY };
+    SID_IDENTIFIER_AUTHORITY authwine7 = { SECURITY_NT_AUTHORITY };
+    PSID sid1, sid2, sidwin7;
+    BOOL ret;
+
+    status = FltBuildDefaultSecurityDescriptor(&sd, STANDARD_RIGHTS_ALL);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    if (status != STATUS_SUCCESS)
+    {
+        win_skip("Skipping FltBuildDefaultSecurityDescriptor tests\n");
+        return;
+    }
+    ok(sd != NULL, "Failed to return descriptor\n");
+
+    status = RtlGetGroupSecurityDescriptor(sd, &group, &isdefault);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    ok(group == NULL, "group isn't NULL\n");
+
+    status = RtlGetOwnerSecurityDescriptor(sd, &owner, &isdefault);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    ok(owner == NULL, "owner isn't NULL\n");
+
+    status = RtlGetDaclSecurityDescriptor(sd, &present, &acl, &isdefault);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    ok(acl != NULL, "acl is NULL\n");
+    ok(acl->AceCount == 2, "got %d\n", acl->AceCount);
+
+    sid1 = ExAllocatePool(NonPagedPool, RtlLengthRequiredSid(2));
+    status = RtlInitializeSid(sid1, &auth, 2);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    *RtlSubAuthoritySid(sid1, 0)  = SECURITY_BUILTIN_DOMAIN_RID;
+    *RtlSubAuthoritySid(sid1, 1) = DOMAIN_GROUP_RID_ADMINS;
+
+    sidwin7 = ExAllocatePool(NonPagedPool, RtlLengthRequiredSid(2));
+    status = RtlInitializeSid(sidwin7, &authwine7, 2);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+    *RtlSubAuthoritySid(sidwin7, 0)  = SECURITY_BUILTIN_DOMAIN_RID;
+    *RtlSubAuthoritySid(sidwin7, 1) = DOMAIN_ALIAS_RID_ADMINS;
+
+    sid2 = ExAllocatePool(NonPagedPool, RtlLengthRequiredSid(1));
+    RtlInitializeSid(sid2, &auth, 1);
+    *RtlSubAuthoritySid(sid2, 0)  = SECURITY_LOCAL_SYSTEM_RID;
+
+    /* SECURITY_BUILTIN_DOMAIN_RID */
+    status = RtlGetAce(acl, 0, (void**)&ace);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+
+    ok(ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE, "got %#x\n", ace->Header.AceType);
+    ok(ace->Header.AceFlags == 0, "got %#x\n", ace->Header.AceFlags);
+    ok(ace->Mask == STANDARD_RIGHTS_ALL, "got %#lx\n", ace->Mask);
+
+    ret = RtlEqualSid(sid1, (PSID)&ace->SidStart) || RtlEqualSid(sidwin7, (PSID)&ace->SidStart);
+    ok(ret, "SID not equal\n");
+
+    /* SECURITY_LOCAL_SYSTEM_RID */
+    status = RtlGetAce(acl, 1, (void**)&ace);
+    ok(status == STATUS_SUCCESS, "got %#lx\n", status);
+
+    ok(ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE, "got %#x\n", ace->Header.AceType);
+    ok(ace->Header.AceFlags == 0, "got %#x\n", ace->Header.AceFlags);
+    ok(ace->Mask == STANDARD_RIGHTS_ALL, "got %#lx\n", ace->Mask);
+
+    ret = RtlEqualSid(sid2, (PSID)&ace->SidStart) || RtlEqualSid(sidwin7, (PSID)&ace->SidStart);
+    ok(ret, "SID not equal\n");
+
+    ExFreePool(sid1);
+    ExFreePool(sid2);
+
+    FltFreeSecurityDescriptor(sd);
+}
+
 static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *stack)
 {
     void *buffer = irp->AssociatedIrp.SystemBuffer;
@@ -2377,6 +2505,7 @@ static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *st
     test_stack_callout();
     test_lookaside_list();
     test_ob_reference();
+    test_default_modules();
     test_resource();
     test_lookup_thread();
     test_IoAttachDeviceToDeviceStack();
@@ -2389,6 +2518,7 @@ static NTSTATUS main_test(DEVICE_OBJECT *device, IRP *irp, IO_STACK_LOCATION *st
     test_process_memory(test_input);
     test_permanence();
     test_driver_object_extension();
+    test_default_security();
 
     IoMarkIrpPending(irp);
     IoQueueWorkItem(work_item, main_test_task, DelayedWorkQueue, irp);
@@ -2857,6 +2987,7 @@ NTSTATUS WINAPI DriverEntry(DRIVER_OBJECT *driver, PUNICODE_STRING registry)
     DbgPrint("loading driver\n");
 
     driver_obj = driver;
+    ldr_module = (LDR_DATA_TABLE_ENTRY *)driver->DriverSection;
 
     /* Allow unloading of the driver */
     driver->DriverUnload = driver_Unload;
diff --git a/dlls/odbc32/Makefile.in b/dlls/odbc32/Makefile.in
index 44962ca..65d481f 100644
--- a/dlls/odbc32/Makefile.in
+++ b/dlls/odbc32/Makefile.in
@@ -5,5 +5,4 @@ IMPORTS   = advapi32
 
 SOURCES = \
 	proxyodbc.c \
-	rsrc.rc \
-	unixlib.c
+	rsrc.rc
diff --git a/dlls/odbc32/proxyodbc.c b/dlls/odbc32/proxyodbc.c
index 679f3d7..f29931d 100644
--- a/dlls/odbc32/proxyodbc.c
+++ b/dlls/odbc32/proxyodbc.c
@@ -40,300 +40,287 @@
 #include "sql.h"
 #include "sqltypes.h"
 #include "sqlext.h"
-#include "unixlib.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(odbc);
-WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
-#define ODBC_CALL( func, params ) WINE_UNIX_CALL( unix_ ## func, params )
-
-/***********************************************************************
- * ODBC_ReplicateODBCInstToRegistry
- *
- * PARAMS
- *
- * RETURNS
- *
- * Utility to ODBC_ReplicateToRegistry to replicate the drivers of the
- * ODBCINST.INI settings
- *
- * The driver settings are not replicated to the registry.  If we were to 
- * replicate them we would need to decide whether to replicate all settings
- * or to do some translation; whether to remove any entries present only in
- * the windows registry, etc.
- */
-
-static void ODBC_ReplicateODBCInstToRegistry (SQLHENV hEnv)
-{
-    HKEY hODBCInst;
-    LONG reg_ret;
-    BOOL success;
-
-    success = FALSE;
-    TRACE ("Driver settings are not currently replicated to the registry\n");
-    if ((reg_ret = RegCreateKeyExA (HKEY_LOCAL_MACHINE,
-            "Software\\ODBC\\ODBCINST.INI", 0, NULL,
-            REG_OPTION_NON_VOLATILE,
-            KEY_ALL_ACCESS /* a couple more than we need */, NULL,
-            &hODBCInst, NULL)) == ERROR_SUCCESS)
-    {
-        HKEY hDrivers;
-        if ((reg_ret = RegCreateKeyExA (hODBCInst, "ODBC Drivers", 0,
-                NULL, REG_OPTION_NON_VOLATILE,
-                KEY_ALL_ACCESS /* overkill */, NULL, &hDrivers, NULL))
-                == ERROR_SUCCESS)
-        {
-            SQLRETURN sql_ret;
-            SQLUSMALLINT dirn;
-            CHAR desc [256];
-            SQLSMALLINT sizedesc;
-
-            success = TRUE;
-            dirn = SQL_FETCH_FIRST;
-            while ((sql_ret = SQLDrivers (hEnv, dirn, (SQLCHAR*)desc, sizeof(desc),
-                    &sizedesc, NULL, 0, NULL)) == SQL_SUCCESS ||
-                    sql_ret == SQL_SUCCESS_WITH_INFO)
-            {
-                /* FIXME Do some proper handling of the SUCCESS_WITH_INFO */
-                dirn = SQL_FETCH_NEXT;
-                if (sizedesc == lstrlenA(desc))
-                {
-                    HKEY hThis;
-                    if ((reg_ret = RegQueryValueExA (hDrivers, desc, NULL,
-                            NULL, NULL, NULL)) == ERROR_FILE_NOT_FOUND)
-                    {
-                        if ((reg_ret = RegSetValueExA (hDrivers, desc, 0,
-                                REG_SZ, (const BYTE *)"Installed", 10)) != ERROR_SUCCESS)
-                        {
-                            TRACE ("Error %ld replicating driver %s\n",
-                                    reg_ret, desc);
-                            success = FALSE;
-                        }
-                    }
-                    else if (reg_ret != ERROR_SUCCESS)
-                    {
-                        TRACE ("Error %ld checking for %s in drivers\n",
-                                reg_ret, desc);
-                        success = FALSE;
-                    }
-                    if ((reg_ret = RegCreateKeyExA (hODBCInst, desc, 0,
-                            NULL, REG_OPTION_NON_VOLATILE,
-                            KEY_ALL_ACCESS, NULL, &hThis, NULL))
-                            == ERROR_SUCCESS)
-                    {
-                        /* FIXME This is where the settings go.
-                         * I suggest that if the disposition says it 
-                         * exists then we leave it alone.  Alternatively
-                         * include an extra value to flag that it is 
-                         * a replication of the unixODBC/iODBC/...
-                         */
-                        if ((reg_ret = RegCloseKey (hThis)) !=
-                                ERROR_SUCCESS)
-                            TRACE ("Error %ld closing %s key\n", reg_ret,
-                                    desc);
-                    }
-                    else
-                    {
-                        TRACE ("Error %ld ensuring driver key %s\n",
-                                reg_ret, desc);
-                        success = FALSE;
-                    }
-                }
-                else
-                {
-                    WARN ("Unusually long driver name %s not replicated\n",
-                            desc);
-                    success = FALSE;
-                }
-            }
-            if (sql_ret != SQL_NO_DATA)
-            {
-                TRACE ("Error %d enumerating drivers\n", (int)sql_ret);
-                success = FALSE;
-            }
-            if ((reg_ret = RegCloseKey (hDrivers)) != ERROR_SUCCESS)
-            {
-                TRACE ("Error %ld closing hDrivers\n", reg_ret);
-            }
-        }
-        else
-        {
-            TRACE ("Error %ld opening HKLM\\S\\O\\OI\\Drivers\n", reg_ret);
-        }
-        if ((reg_ret = RegCloseKey (hODBCInst)) != ERROR_SUCCESS)
-        {
-            TRACE ("Error %ld closing HKLM\\S\\O\\ODBCINST.INI\n", reg_ret);
-        }
-    }
-    else
-    {
-        TRACE ("Error %ld opening HKLM\\S\\O\\ODBCINST.INI\n", reg_ret);
-    }
-    if (!success)
-    {
-        WARN ("May not have replicated all ODBC drivers to the registry\n");
-    }
-}
-
-/***********************************************************************
- * ODBC_ReplicateODBCToRegistry
- *
- * PARAMS
- *
- * RETURNS
- *
- * Utility to ODBC_ReplicateToRegistry to replicate either the USER or 
- * SYSTEM dsns
- *
- * For now simply place the "Driver description" (as returned by SQLDataSources)
- * into the registry as the driver.  This is enough to satisfy Crystal's 
- * requirement that there be a driver entry.  (It doesn't seem to care what
- * the setting is).
- * A slightly more accurate setting would be to access the registry to find
- * the actual driver library for the given description (which appears to map
- * to one of the HKLM/Software/ODBC/ODBCINST.INI keys).  (If you do this note
- * that this will add a requirement that this function be called after
- * ODBC_ReplicateODBCInstToRegistry)
- */
-static void ODBC_ReplicateODBCToRegistry (BOOL is_user, SQLHENV hEnv)
-{
-    HKEY hODBC;
-    LONG reg_ret;
-    SQLRETURN sql_ret;
-    SQLUSMALLINT dirn;
-    CHAR dsn [SQL_MAX_DSN_LENGTH + 1];
-    SQLSMALLINT sizedsn;
-    CHAR desc [256];
-    SQLSMALLINT sizedesc;
-    BOOL success;
-    const char *which = is_user ? "user" : "system";
-
-    success = FALSE;
-    if ((reg_ret = RegCreateKeyExA (
-            is_user ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE,
-            "Software\\ODBC\\ODBC.INI", 0, NULL, REG_OPTION_NON_VOLATILE,
-            KEY_ALL_ACCESS /* a couple more than we need */, NULL, &hODBC,
-            NULL)) == ERROR_SUCCESS)
-    {
-        success = TRUE;
-        dirn = is_user ? SQL_FETCH_FIRST_USER : SQL_FETCH_FIRST_SYSTEM;
-        while ((sql_ret = SQLDataSources (hEnv, dirn,
-                (SQLCHAR*)dsn, sizeof(dsn), &sizedsn,
-                (SQLCHAR*)desc, sizeof(desc), &sizedesc)) == SQL_SUCCESS
-                || sql_ret == SQL_SUCCESS_WITH_INFO)
-        {
-            /* FIXME Do some proper handling of the SUCCESS_WITH_INFO */
-            dirn = SQL_FETCH_NEXT;
-            if (sizedsn == lstrlenA(dsn) && sizedesc == lstrlenA(desc))
-            {
-                HKEY hDSN;
-                if ((reg_ret = RegCreateKeyExA (hODBC, dsn, 0,
-                        NULL, REG_OPTION_NON_VOLATILE,
-                        KEY_ALL_ACCESS, NULL, &hDSN, NULL))
-                        == ERROR_SUCCESS)
-                {
-                    static const char DRIVERKEY[] = "Driver";
-                    if ((reg_ret = RegQueryValueExA (hDSN, DRIVERKEY,
-                            NULL, NULL, NULL, NULL))
-                            == ERROR_FILE_NOT_FOUND)
-                    {
-                        if ((reg_ret = RegSetValueExA (hDSN, DRIVERKEY, 0,
-                                REG_SZ, (LPBYTE)desc, sizedesc)) != ERROR_SUCCESS)
-                        {
-                            TRACE ("Error %ld replicating description of "
-                                    "%s(%s)\n", reg_ret, dsn, desc);
-                            success = FALSE;
-                        }
-                    }
-                    else if (reg_ret != ERROR_SUCCESS)
-                    {
-                        TRACE ("Error %ld checking for description of %s\n",
-                                reg_ret, dsn);
-                        success = FALSE;
-                    }
-                    if ((reg_ret = RegCloseKey (hDSN)) != ERROR_SUCCESS)
-                    {
-                        TRACE ("Error %ld closing %s DSN key %s\n",
-                                reg_ret, which, dsn);
-                    }
-                }
-                else
-                {
-                    TRACE ("Error %ld opening %s DSN key %s\n",
-                            reg_ret, which, dsn);
-                    success = FALSE;
-                }
-            }
-            else
-            {
-                WARN ("Unusually long %s data source name %s (%s) not "
-                        "replicated\n", which, dsn, desc);
-                success = FALSE;
-            }
-        }
-        if (sql_ret != SQL_NO_DATA)
-        {
-            TRACE ("Error %d enumerating %s datasources\n",
-                    (int)sql_ret, which);
-            success = FALSE;
-        }
-        if ((reg_ret = RegCloseKey (hODBC)) != ERROR_SUCCESS)
-        {
-            TRACE ("Error %ld closing %s ODBC.INI registry key\n", reg_ret,
-                    which);
-        }
-    }
-    else
-    {
-        TRACE ("Error %ld creating/opening %s ODBC.INI registry key\n",
-                reg_ret, which);
-    }
-    if (!success)
-    {
-        WARN ("May not have replicated all %s ODBC DSNs to the registry\n",
-                which);
+struct SQLHENV_data
+{
+    int type;
+    SQLUINTEGER pooling;
+    SQLUINTEGER version;
+};
+
+struct SQLHDBC_data
+{
+    int type;
+    struct SQLHENV_data *environment;
+    HMODULE module;
+    SQLHENV driver_env;
+    SQLHDBC driver_hdbc;
+
+    SQLRETURN (WINAPI *pSQLAllocConnect)(SQLHENV,SQLHDBC*);
+    SQLRETURN (WINAPI *pSQLAllocEnv)(SQLHENV*);
+    SQLRETURN (WINAPI *pSQLAllocHandle)(SQLSMALLINT,SQLHANDLE,SQLHANDLE*);
+    SQLRETURN (WINAPI *pSQLAllocHandleStd)(SQLSMALLINT,SQLHANDLE,SQLHANDLE*);
+    SQLRETURN (WINAPI *pSQLAllocStmt)(SQLHDBC,SQLHSTMT*);
+    SQLRETURN (WINAPI *pSQLBindCol)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLPOINTER,SQLLEN,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLBindParam)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLULEN,SQLSMALLINT,SQLPOINTER,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLBindParameter)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLULEN,SQLSMALLINT,SQLPOINTER,SQLLEN,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLBrowseConnect)(SQLHDBC,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLBrowseConnectW)(SQLHDBC,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLBulkOperations)(SQLHSTMT,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLCancel)(SQLHSTMT);
+    SQLRETURN (WINAPI *pSQLCloseCursor)(SQLHSTMT);
+    SQLRETURN (WINAPI *pSQLColAttribute)(SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLColAttributeW)(SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLColAttributes)(SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLColAttributesW)(SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLColumnPrivileges)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLColumnPrivilegesW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLColumns)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLColumnsW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLConnect)(SQLHDBC,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLConnectW)(SQLHDBC,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLCopyDesc)(SQLHDESC,SQLHDESC);
+    SQLRETURN (WINAPI *pSQLDataSources)(SQLHENV,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLDataSourcesA)(SQLHENV,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLDataSourcesW)(SQLHENV,SQLUSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLDescribeCol)(SQLHSTMT,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLSMALLINT*,SQLULEN*,SQLSMALLINT*,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLDescribeColW)(SQLHSTMT,SQLUSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLSMALLINT*,SQLULEN*,SQLSMALLINT*,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLDescribeParam)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT*,SQLULEN*,SQLSMALLINT*,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLDisconnect)(SQLHDBC);
+    SQLRETURN (WINAPI *pSQLDriverConnect)(SQLHDBC,SQLHWND,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLDriverConnectW)(SQLHDBC,SQLHWND,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLDrivers)(SQLHENV,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLDriversW)(SQLHENV,SQLUSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLEndTran)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLError)(SQLHENV,SQLHDBC,SQLHSTMT,SQLCHAR*,SQLINTEGER*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLErrorW)(SQLHENV,SQLHDBC,SQLHSTMT,SQLWCHAR*,SQLINTEGER*,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLExecDirect)(SQLHSTMT,SQLCHAR*,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLExecDirectW)(SQLHSTMT,SQLWCHAR*,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLExecute)(SQLHSTMT);
+    SQLRETURN (WINAPI *pSQLExtendedFetch)(SQLHSTMT,SQLUSMALLINT,SQLLEN,SQLULEN*,SQLUSMALLINT*);
+    SQLRETURN (WINAPI *pSQLFetch)(SQLHSTMT);
+    SQLRETURN (WINAPI *pSQLFetchScroll)(SQLHSTMT,SQLSMALLINT,SQLLEN);
+    SQLRETURN (WINAPI *pSQLForeignKeys)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLForeignKeysW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLFreeConnect)(SQLHDBC);
+    SQLRETURN (WINAPI *pSQLFreeEnv)(SQLHENV);
+    SQLRETURN (WINAPI *pSQLFreeHandle)(SQLSMALLINT,SQLHANDLE);
+    SQLRETURN (WINAPI *pSQLFreeStmt)(SQLHSTMT,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLGetConnectAttr)(SQLHDBC,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLGetConnectAttrW)(SQLHDBC,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLGetConnectOption)(SQLHDBC,SQLUSMALLINT,SQLPOINTER);
+    SQLRETURN (WINAPI *pSQLGetConnectOptionW)(SQLHDBC,SQLUSMALLINT,SQLPOINTER);
+    SQLRETURN (WINAPI *pSQLGetCursorName)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetCursorNameW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetData)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLPOINTER,SQLLEN,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLGetDescField)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLGetDescFieldW)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLGetDescRec)(SQLHDESC,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLSMALLINT*,SQLSMALLINT*,SQLLEN*,SQLSMALLINT*,SQLSMALLINT*,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetDescRecW)(SQLHDESC,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLSMALLINT*,SQLSMALLINT*,SQLLEN*,SQLSMALLINT*,SQLSMALLINT*,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetDiagField)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetDiagFieldW)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetDiagRec)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLCHAR*,SQLINTEGER*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetDiagRecA)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLCHAR*,SQLINTEGER*, SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetDiagRecW)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLWCHAR*,SQLINTEGER*,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetEnvAttr)(SQLHENV,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLGetFunctions)(SQLHDBC,SQLUSMALLINT,SQLUSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetInfo)(SQLHDBC,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetInfoW)(SQLHDBC,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLGetStmtAttr)(SQLHSTMT,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLGetStmtAttrW)(SQLHSTMT,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLGetStmtOption)(SQLHSTMT,SQLUSMALLINT,SQLPOINTER);
+    SQLRETURN (WINAPI *pSQLGetTypeInfo)(SQLHSTMT,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLGetTypeInfoW)(SQLHSTMT,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLMoreResults)(SQLHSTMT);
+    SQLRETURN (WINAPI *pSQLNativeSql)(SQLHDBC,SQLCHAR*,SQLINTEGER,SQLCHAR*,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLNativeSqlW)(SQLHDBC,SQLWCHAR*,SQLINTEGER,SQLWCHAR*,SQLINTEGER,SQLINTEGER*);
+    SQLRETURN (WINAPI *pSQLNumParams)(SQLHSTMT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLNumResultCols)(SQLHSTMT,SQLSMALLINT*);
+    SQLRETURN (WINAPI *pSQLParamData)(SQLHSTMT,SQLPOINTER*);
+    SQLRETURN (WINAPI *pSQLParamOptions)(SQLHSTMT,SQLULEN,SQLULEN*);
+    SQLRETURN (WINAPI *pSQLPrepare)(SQLHSTMT,SQLCHAR*,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLPrepareW)(SQLHSTMT,SQLWCHAR*,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLPrimaryKeys)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLPrimaryKeysW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLProcedureColumns)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLProcedureColumnsW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLProcedures)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLProceduresW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLPutData)(SQLHSTMT,SQLPOINTER,SQLLEN);
+    SQLRETURN (WINAPI *pSQLRowCount)(SQLHSTMT,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLSetConnectAttr)(SQLHDBC,SQLINTEGER,SQLPOINTER,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLSetConnectAttrW)(SQLHDBC,SQLINTEGER,SQLPOINTER,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLSetConnectOption)(SQLHDBC,SQLUSMALLINT,SQLULEN);
+    SQLRETURN (WINAPI *pSQLSetConnectOptionW)(SQLHDBC,SQLUSMALLINT,SQLULEN);
+    SQLRETURN (WINAPI *pSQLSetCursorName)(SQLHSTMT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLSetCursorNameW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLSetDescField)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLSetDescFieldW)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLSetDescRec)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLLEN,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLLEN*,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLSetEnvAttr)(SQLHENV,SQLINTEGER,SQLPOINTER,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLSetParam)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLULEN,SQLSMALLINT,SQLPOINTER,SQLLEN*);
+    SQLRETURN (WINAPI *pSQLSetPos)(SQLHSTMT,SQLSETPOSIROW,SQLUSMALLINT,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLSetScrollOptions)(SQLHSTMT,SQLUSMALLINT,SQLLEN,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLSetStmtAttr)(SQLHSTMT,SQLINTEGER,SQLPOINTER,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLSetStmtAttrW)(SQLHSTMT,SQLINTEGER,SQLPOINTER,SQLINTEGER);
+    SQLRETURN (WINAPI *pSQLSetStmtOption)(SQLHSTMT,SQLUSMALLINT,SQLULEN);
+    SQLRETURN (WINAPI *pSQLSpecialColumns)(SQLHSTMT,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLSpecialColumnsW)(SQLHSTMT,SQLUSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLStatistics)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLStatisticsW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
+    SQLRETURN (WINAPI *pSQLTablePrivileges)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLTablePrivilegesW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLTables)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLTablesW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
+    SQLRETURN (WINAPI *pSQLTransact)(SQLHENV,SQLHDBC,SQLUSMALLINT);
+
+    SQLUINTEGER login_timeout;
+};
+
+struct SQLHDESC_data
+{
+    struct SQLHSTMT_data *parent;
+    SQLHDESC driver_hdesc;
+};
+
+struct SQLHSTMT_data
+{
+    int type;
+    struct SQLHDBC_data *connection;
+    SQLHSTMT driver_stmt;
+
+    struct SQLHDESC_data app_row_desc;
+    struct SQLHDESC_data imp_row_desc;
+    struct SQLHDESC_data app_param_desc;
+    struct SQLHDESC_data imp_param_desc;
+};
+
+static void connection_bind_sql_funcs(struct SQLHDBC_data *connection)
+{
+#define LOAD_FUNCPTR(f) if((connection->p##f = (void*)GetProcAddress(connection->module, #f)) == NULL) \
+    { \
+        WARN( "function '%s' not found in driver.\n", #f ); \
     }
-}
-
-/***********************************************************************
- * ODBC_ReplicateToRegistry
- *
- * PARAMS
- *
- * RETURNS
- *
- * Unfortunately some of the functions that Windows documents as being part
- * of the ODBC API it implements directly during compilation or something
- * in terms of registry access functions.
- * e.g. SQLGetInstalledDrivers queries the list at
- * HKEY_LOCAL_MACHINE\Software\ODBC\ODBCINST.INI\ODBC Drivers
- *
- * This function is called when the driver manager is loaded and is used
- * to replicate the appropriate details into the Wine registry
- */
-
-static void ODBC_ReplicateToRegistry (void)
-{
-    SQLRETURN sql_ret;
-    SQLHENV hEnv;
-
-    if ((sql_ret = SQLAllocEnv(&hEnv)) == SQL_SUCCESS)
-    {
-        ODBC_ReplicateODBCInstToRegistry (hEnv);
-        ODBC_ReplicateODBCToRegistry (FALSE /* system dsns */, hEnv);
-        ODBC_ReplicateODBCToRegistry (TRUE /* user dsns */, hEnv);
 
-        if ((sql_ret = SQLFreeEnv(hEnv)) != SQL_SUCCESS)
-        {
-            TRACE ("Error %d freeing the SQL environment.\n", (int)sql_ret);
-        }
-    }
-    else
-    {
-        TRACE ("Error %d opening an SQL environment.\n", (int)sql_ret);
-        WARN ("The external ODBC settings have not been replicated to the"
-                " Wine registry\n");
-    }
+    LOAD_FUNCPTR(SQLAllocConnect);
+    LOAD_FUNCPTR(SQLAllocEnv);
+    LOAD_FUNCPTR(SQLAllocHandle);
+    LOAD_FUNCPTR(SQLAllocHandleStd)
+    LOAD_FUNCPTR(SQLAllocStmt);
+    LOAD_FUNCPTR(SQLBindCol);
+    LOAD_FUNCPTR(SQLBindParam);
+    LOAD_FUNCPTR(SQLBindParameter);
+    LOAD_FUNCPTR(SQLBrowseConnect);
+    LOAD_FUNCPTR(SQLBrowseConnectW);
+    LOAD_FUNCPTR(SQLBulkOperations);
+    LOAD_FUNCPTR(SQLCancel);
+    LOAD_FUNCPTR(SQLCloseCursor);
+    LOAD_FUNCPTR(SQLColAttribute);
+    LOAD_FUNCPTR(SQLColAttributeW);
+    LOAD_FUNCPTR(SQLColAttributes);
+    LOAD_FUNCPTR(SQLColAttributesW);
+    LOAD_FUNCPTR(SQLColumnPrivileges);
+    LOAD_FUNCPTR(SQLColumnPrivilegesW)
+    LOAD_FUNCPTR(SQLColumns);
+    LOAD_FUNCPTR(SQLColumnsW);
+    LOAD_FUNCPTR(SQLConnect);
+    LOAD_FUNCPTR(SQLConnectW);
+    LOAD_FUNCPTR(SQLCopyDesc);
+    LOAD_FUNCPTR(SQLDataSources);
+    LOAD_FUNCPTR(SQLDataSourcesA);
+    LOAD_FUNCPTR(SQLDataSourcesW);
+    LOAD_FUNCPTR(SQLDescribeCol);
+    LOAD_FUNCPTR(SQLDescribeColW);
+    LOAD_FUNCPTR(SQLDescribeParam);
+    LOAD_FUNCPTR(SQLDisconnect);
+    LOAD_FUNCPTR(SQLDriverConnect);
+    LOAD_FUNCPTR(SQLDriverConnectW);
+    LOAD_FUNCPTR(SQLDrivers);
+    LOAD_FUNCPTR(SQLDriversW);
+    LOAD_FUNCPTR(SQLEndTran);
+    LOAD_FUNCPTR(SQLError);
+    LOAD_FUNCPTR(SQLErrorW);
+    LOAD_FUNCPTR(SQLExecDirect);
+    LOAD_FUNCPTR(SQLExecDirectW);
+    LOAD_FUNCPTR(SQLExecute);
+    LOAD_FUNCPTR(SQLExtendedFetch);
+    LOAD_FUNCPTR(SQLFetch);
+    LOAD_FUNCPTR(SQLFetchScroll);
+    LOAD_FUNCPTR(SQLForeignKeys);
+    LOAD_FUNCPTR(SQLForeignKeysW);
+    LOAD_FUNCPTR(SQLFreeConnect);
+    LOAD_FUNCPTR(SQLFreeEnv);
+    LOAD_FUNCPTR(SQLFreeHandle);
+    LOAD_FUNCPTR(SQLFreeStmt);
+    LOAD_FUNCPTR(SQLGetConnectAttr);
+    LOAD_FUNCPTR(SQLGetConnectAttrW);
+    LOAD_FUNCPTR(SQLGetConnectOption);
+    LOAD_FUNCPTR(SQLGetConnectOptionW);
+    LOAD_FUNCPTR(SQLGetCursorName);
+    LOAD_FUNCPTR(SQLGetCursorNameW);
+    LOAD_FUNCPTR(SQLGetData);
+    LOAD_FUNCPTR(SQLGetDescField);
+    LOAD_FUNCPTR(SQLGetDescFieldW);
+    LOAD_FUNCPTR(SQLGetDescRec);
+    LOAD_FUNCPTR(SQLGetDescRecW);
+    LOAD_FUNCPTR(SQLGetDiagField);
+    LOAD_FUNCPTR(SQLGetDiagFieldW);
+    LOAD_FUNCPTR(SQLGetDiagRec);
+    LOAD_FUNCPTR(SQLGetDiagRecA);
+    LOAD_FUNCPTR(SQLGetDiagRecW);
+    LOAD_FUNCPTR(SQLGetEnvAttr);
+    LOAD_FUNCPTR(SQLGetFunctions);
+    LOAD_FUNCPTR(SQLGetInfo);
+    LOAD_FUNCPTR(SQLGetInfoW);
+    LOAD_FUNCPTR(SQLGetStmtAttr);
+    LOAD_FUNCPTR(SQLGetStmtAttrW);
+    LOAD_FUNCPTR(SQLGetStmtOption);
+    LOAD_FUNCPTR(SQLGetTypeInfo);
+    LOAD_FUNCPTR(SQLGetTypeInfoW);
+    LOAD_FUNCPTR(SQLMoreResults);
+    LOAD_FUNCPTR(SQLNativeSql);
+    LOAD_FUNCPTR(SQLNativeSqlW);
+    LOAD_FUNCPTR(SQLNumParams);
+    LOAD_FUNCPTR(SQLNumResultCols);
+    LOAD_FUNCPTR(SQLParamData);
+    LOAD_FUNCPTR(SQLParamOptions);
+    LOAD_FUNCPTR(SQLPrepare);
+    LOAD_FUNCPTR(SQLPrepareW);
+    LOAD_FUNCPTR(SQLPrimaryKeys);
+    LOAD_FUNCPTR(SQLPrimaryKeysW);
+    LOAD_FUNCPTR(SQLProcedureColumns);
+    LOAD_FUNCPTR(SQLProcedureColumnsW);
+    LOAD_FUNCPTR(SQLProcedures);
+    LOAD_FUNCPTR(SQLProceduresW);
+    LOAD_FUNCPTR(SQLPutData);
+    LOAD_FUNCPTR(SQLRowCount);
+    LOAD_FUNCPTR(SQLSetConnectAttr);
+    LOAD_FUNCPTR(SQLSetConnectAttrW);
+    LOAD_FUNCPTR(SQLSetConnectOption);
+    LOAD_FUNCPTR(SQLSetConnectOptionW);
+    LOAD_FUNCPTR(SQLSetCursorName);
+    LOAD_FUNCPTR(SQLSetCursorNameW);
+    LOAD_FUNCPTR(SQLSetDescField);
+    LOAD_FUNCPTR(SQLSetDescFieldW);
+    LOAD_FUNCPTR(SQLSetDescRec);
+    LOAD_FUNCPTR(SQLSetEnvAttr);
+    LOAD_FUNCPTR(SQLSetParam);
+    LOAD_FUNCPTR(SQLSetPos);
+    LOAD_FUNCPTR(SQLSetScrollOptions);
+    LOAD_FUNCPTR(SQLSetStmtAttr);
+    LOAD_FUNCPTR(SQLSetStmtAttrW);
+    LOAD_FUNCPTR(SQLSetStmtOption);
+    LOAD_FUNCPTR(SQLSpecialColumns);
+    LOAD_FUNCPTR(SQLSpecialColumnsW);
+    LOAD_FUNCPTR(SQLStatistics);
+    LOAD_FUNCPTR(SQLStatisticsW);
+    LOAD_FUNCPTR(SQLTablePrivileges);
+    LOAD_FUNCPTR(SQLTablePrivilegesW);
+    LOAD_FUNCPTR(SQLTables);
+    LOAD_FUNCPTR(SQLTablesW);
+    LOAD_FUNCPTR(SQLTransact);
 }
 
 /*************************************************************************
@@ -341,15 +328,26 @@ static void ODBC_ReplicateToRegistry (void)
  */
 SQLRETURN WINAPI SQLAllocConnect(SQLHENV EnvironmentHandle, SQLHDBC *ConnectionHandle)
 {
-    struct SQLAllocConnect_params params = { EnvironmentHandle, ConnectionHandle };
-    SQLRETURN ret;
+    struct SQLHDBC_data *hdbc;
 
     TRACE("(EnvironmentHandle %p, ConnectionHandle %p)\n", EnvironmentHandle, ConnectionHandle);
 
+    if(!ConnectionHandle)
+        return SQL_ERROR;
     *ConnectionHandle = SQL_NULL_HDBC;
-    ret = ODBC_CALL( SQLAllocConnect, &params );
-    TRACE("Returning %d, ConnectionHandle %p\n", ret, *ConnectionHandle);
-    return ret;
+
+    hdbc = calloc(1, sizeof(*hdbc));
+    if (!hdbc)
+        return SQL_ERROR;
+
+    hdbc->type = SQL_HANDLE_DBC;
+    hdbc->environment = EnvironmentHandle;
+    hdbc->login_timeout = 0;
+    hdbc->module = NULL;
+
+    *ConnectionHandle = hdbc;
+
+    return SQL_SUCCESS;
 }
 
 /*************************************************************************
@@ -357,15 +355,25 @@ SQLRETURN WINAPI SQLAllocConnect(SQLHENV EnvironmentHandle, SQLHDBC *ConnectionH
  */
 SQLRETURN WINAPI SQLAllocEnv(SQLHENV *EnvironmentHandle)
 {
-    struct SQLAllocEnv_params params = { EnvironmentHandle };
-    SQLRETURN ret;
+    struct SQLHENV_data *henv;
 
     TRACE("(EnvironmentHandle %p)\n", EnvironmentHandle);
 
+    if (!EnvironmentHandle)
+        return SQL_ERROR;
+
     *EnvironmentHandle = SQL_NULL_HENV;
-    ret = ODBC_CALL( SQLAllocEnv, &params );
-    TRACE("Returning %d, EnvironmentHandle %p\n", ret, *EnvironmentHandle);
-    return ret;
+    henv = calloc(1, sizeof(*henv));
+    if (!henv)
+        return SQL_ERROR;
+
+    henv->type = SQL_HANDLE_ENV;
+    henv->pooling = SQL_CP_OFF;
+    henv->version = SQL_OV_ODBC2;
+
+    *EnvironmentHandle = henv;
+
+    return SQL_SUCCESS;
 }
 
 /*************************************************************************
@@ -373,14 +381,24 @@ SQLRETURN WINAPI SQLAllocEnv(SQLHENV *EnvironmentHandle)
  */
 SQLRETURN WINAPI SQLAllocHandle(SQLSMALLINT HandleType, SQLHANDLE InputHandle, SQLHANDLE *OutputHandle)
 {
-    struct SQLAllocHandle_params params = { HandleType, InputHandle, OutputHandle };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(HandleType %d, InputHandle %p, OutputHandle %p)\n", HandleType, InputHandle, OutputHandle);
 
     *OutputHandle = 0;
-    ret = ODBC_CALL( SQLAllocHandle, &params );
-    TRACE("Returning %d, Handle %p\n", ret, *OutputHandle);
+    if (HandleType == SQL_HANDLE_ENV)
+    {
+        ret = SQLAllocEnv(OutputHandle);
+    }
+    else if (HandleType == SQL_HANDLE_DBC)
+    {
+        ret = SQLAllocConnect(InputHandle, OutputHandle);
+    }
+    else if (HandleType == SQL_HANDLE_STMT)
+    {
+        ret = SQLAllocStmt(InputHandle, OutputHandle);
+    }
+
     return ret;
 }
 
@@ -389,14 +407,41 @@ SQLRETURN WINAPI SQLAllocHandle(SQLSMALLINT HandleType, SQLHANDLE InputHandle, S
  */
 SQLRETURN WINAPI SQLAllocStmt(SQLHDBC ConnectionHandle, SQLHSTMT *StatementHandle)
 {
-    struct SQLAllocStmt_params params = { ConnectionHandle, StatementHandle };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    struct SQLHSTMT_data *stmt;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(ConnectionHandle %p, StatementHandle %p)\n", ConnectionHandle, StatementHandle);
 
     *StatementHandle = SQL_NULL_HSTMT;
-    ret = ODBC_CALL( SQLAllocStmt, &params );
-    TRACE ("Returning %d, StatementHandle %p\n", ret, *StatementHandle);
+    if (connection->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", connection->type);
+        return SQL_ERROR;
+    }
+
+    stmt = malloc(sizeof(*stmt));
+    if (!stmt)
+    {
+        return SQL_ERROR;
+    }
+
+    stmt->type = SQL_HANDLE_STMT;
+    stmt->connection = connection;
+
+    /* Default to ODBC v3 function */
+    if(connection->pSQLAllocHandle)
+    {
+        ret = connection->pSQLAllocHandle(SQL_HANDLE_STMT, connection->driver_hdbc, &stmt->driver_stmt);
+    }
+    else if (connection->pSQLAllocStmt)
+    {
+        ret = connection->pSQLAllocStmt(connection->driver_hdbc, &stmt->driver_stmt);
+    }
+
+    *StatementHandle = stmt;
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -405,14 +450,11 @@ SQLRETURN WINAPI SQLAllocStmt(SQLHDBC ConnectionHandle, SQLHSTMT *StatementHandl
  */
 SQLRETURN WINAPI SQLAllocHandleStd(SQLSMALLINT HandleType, SQLHANDLE InputHandle, SQLHANDLE *OutputHandle)
 {
-    struct SQLAllocHandleStd_params params = { HandleType, InputHandle, OutputHandle };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(HandleType %d, InputHandle %p, OutputHandle %p)\n", HandleType, InputHandle, OutputHandle);
+    FIXME("(HandleType %d, InputHandle %p, OutputHandle %p)\n", HandleType, InputHandle, OutputHandle);
 
     *OutputHandle = 0;
-    ret = ODBC_CALL( SQLAllocHandleStd, &params );
-    TRACE ("Returning %d, OutputHandle %p\n", ret, *OutputHandle);
     return ret;
 }
 
@@ -431,15 +473,39 @@ static const char *debugstr_sqllen( SQLLEN len )
 SQLRETURN WINAPI SQLBindCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType,
                             SQLPOINTER TargetValue, SQLLEN BufferLength, SQLLEN *StrLen_or_Ind)
 {
-    struct SQLBindCol_params params = { StatementHandle, ColumnNumber, TargetType, TargetValue,
-                                        BufferLength, StrLen_or_Ind };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, ColumnNumber %d, TargetType %d, TargetValue %p, BufferLength %s, StrLen_or_Ind %p)\n",
           StatementHandle, ColumnNumber, TargetType, TargetValue, debugstr_sqllen(BufferLength), StrLen_or_Ind);
 
-    ret = ODBC_CALL( SQLBindCol, &params );
-    TRACE ("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLBindCol)
+    {
+        /*
+         * Map ODBC3 Datatype back to ODBC2 types when the application has asked for SQL_OV_ODBC2.
+         * Some drivers rely on this (PostgreSQL odbc driver).
+         */
+        if (statement->connection->environment->version == SQL_OV_ODBC2)
+        {
+            if(TargetType == SQL_C_TYPE_TIME)
+                TargetType = SQL_C_TIME;
+            else if(TargetType == SQL_C_TYPE_DATE)
+                TargetType = SQL_C_DATE;
+            else if(TargetType == SQL_C_TYPE_TIMESTAMP)
+                TargetType = SQL_C_TIMESTAMP;
+        }
+
+        ret = statement->connection->pSQLBindCol(statement->driver_stmt, ColumnNumber, TargetType,
+                            TargetValue, BufferLength, StrLen_or_Ind);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -459,16 +525,12 @@ SQLRETURN WINAPI SQLBindParam(SQLHSTMT StatementHandle, SQLUSMALLINT ParameterNu
                               SQLSMALLINT ParameterType, SQLULEN LengthPrecision, SQLSMALLINT ParameterScale,
                               SQLPOINTER ParameterValue, SQLLEN *StrLen_or_Ind)
 {
-    struct SQLBindParam_params params = { StatementHandle, ParameterNumber, ValueType, ParameterType,
-                                          LengthPrecision, ParameterScale, ParameterValue, StrLen_or_Ind };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, ParameterNumber %d, ValueType %d, ParameterType %d, LengthPrecision %s,"
+    FIXME("(StatementHandle %p, ParameterNumber %d, ValueType %d, ParameterType %d, LengthPrecision %s,"
           " ParameterScale %d, ParameterValue %p, StrLen_or_Ind %p)\n", StatementHandle, ParameterNumber, ValueType,
           ParameterType, debugstr_sqlulen(LengthPrecision), ParameterScale, ParameterValue, StrLen_or_Ind);
 
-    ret = ODBC_CALL( SQLBindParam, &params );
-    TRACE ("Returning %d\n", ret);
     return ret;
 }
 
@@ -477,13 +539,10 @@ SQLRETURN WINAPI SQLBindParam(SQLHSTMT StatementHandle, SQLUSMALLINT ParameterNu
  */
 SQLRETURN WINAPI SQLCancel(SQLHSTMT StatementHandle)
 {
-    struct SQLCancel_params params = { StatementHandle };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p)\n", StatementHandle);
+    FIXME("(StatementHandle %p)\n", StatementHandle);
 
-    ret = ODBC_CALL( SQLCancel, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -492,13 +551,10 @@ SQLRETURN WINAPI SQLCancel(SQLHSTMT StatementHandle)
  */
 SQLRETURN WINAPI SQLCloseCursor(SQLHSTMT StatementHandle)
 {
-    struct SQLCloseCursor_params params = { StatementHandle };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p)\n", StatementHandle);
+    FIXME("(StatementHandle %p)\n", StatementHandle);
 
-    ret = ODBC_CALL( SQLCloseCursor, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -510,16 +566,26 @@ SQLRETURN WINAPI SQLColAttribute(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNu
                                  SQLSMALLINT BufferLength, SQLSMALLINT *StringLength,
                                  SQLLEN *NumericAttribute)
 {
-    struct SQLColAttribute_params params = { StatementHandle, ColumnNumber, FieldIdentifier,
-                                             CharacterAttribute, BufferLength, StringLength, NumericAttribute };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, ColumnNumber %d, FieldIdentifier %d, CharacterAttribute %p, BufferLength %d,"
           " StringLength %p, NumericAttribute %p)\n", StatementHandle, ColumnNumber, FieldIdentifier,
           CharacterAttribute, BufferLength, StringLength, NumericAttribute);
 
-    ret = ODBC_CALL( SQLColAttribute, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLColAttribute)
+    {
+        ret = statement->connection->pSQLColAttribute(statement->driver_stmt, ColumnNumber, FieldIdentifier,
+                                 CharacterAttribute, BufferLength, StringLength, NumericAttribute);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -530,19 +596,15 @@ SQLRETURN WINAPI SQLColumns(SQLHSTMT StatementHandle, SQLCHAR *CatalogName, SQLS
                             SQLCHAR *SchemaName, SQLSMALLINT NameLength2, SQLCHAR *TableName,
                             SQLSMALLINT NameLength3, SQLCHAR *ColumnName, SQLSMALLINT NameLength4)
 {
-    struct SQLColumns_params params = { StatementHandle, CatalogName, NameLength1, SchemaName, NameLength2,
-                                        TableName, NameLength3, ColumnName, NameLength4 };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d, TableName %s,"
+    FIXME("(StatementHandle %p, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d, TableName %s,"
           " NameLength3 %d, ColumnName %s, NameLength4 %d)\n", StatementHandle,
           debugstr_an((const char *)CatalogName, NameLength1), NameLength1,
           debugstr_an((const char *)SchemaName, NameLength2), NameLength2,
           debugstr_an((const char *)TableName, NameLength3), NameLength3,
           debugstr_an((const char *)ColumnName, NameLength4), NameLength4);
 
-    ret = ODBC_CALL( SQLColumns, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -553,18 +615,14 @@ SQLRETURN WINAPI SQLConnect(SQLHDBC ConnectionHandle, SQLCHAR *ServerName, SQLSM
                             SQLCHAR *UserName, SQLSMALLINT NameLength2, SQLCHAR *Authentication,
                             SQLSMALLINT NameLength3)
 {
-    struct SQLConnect_params params = { ConnectionHandle, ServerName, NameLength1, UserName, NameLength2,
-                                        Authentication, NameLength3 };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(ConnectionHandle %p, ServerName %s, NameLength1 %d, UserName %s, NameLength2 %d, Authentication %s,"
+    FIXME("(ConnectionHandle %p, ServerName %s, NameLength1 %d, UserName %s, NameLength2 %d, Authentication %s,"
           " NameLength3 %d)\n", ConnectionHandle,
           debugstr_an((const char *)ServerName, NameLength1), NameLength1,
           debugstr_an((const char *)UserName, NameLength2), NameLength2,
           debugstr_an((const char *)Authentication, NameLength3), NameLength3);
 
-    ret = ODBC_CALL( SQLConnect, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -573,13 +631,10 @@ SQLRETURN WINAPI SQLConnect(SQLHDBC ConnectionHandle, SQLCHAR *ServerName, SQLSM
  */
 SQLRETURN WINAPI SQLCopyDesc(SQLHDESC SourceDescHandle, SQLHDESC TargetDescHandle)
 {
-    struct SQLCopyDesc_params params = { SourceDescHandle, TargetDescHandle };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(SourceDescHandle %p, TargetDescHandle %p)\n", SourceDescHandle, TargetDescHandle);
+    FIXME("(SourceDescHandle %p, TargetDescHandle %p)\n", SourceDescHandle, TargetDescHandle);
 
-    ret = ODBC_CALL( SQLCopyDesc, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -590,25 +645,12 @@ SQLRETURN WINAPI SQLDataSources(SQLHENV EnvironmentHandle, SQLUSMALLINT Directio
                                 SQLSMALLINT BufferLength1, SQLSMALLINT *NameLength1, SQLCHAR *Description,
                                 SQLSMALLINT BufferLength2, SQLSMALLINT *NameLength2)
 {
-    struct SQLDataSources_params params = { EnvironmentHandle, Direction, ServerName, BufferLength1,
-                                            NameLength1, Description, BufferLength2, NameLength2 };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(EnvironmentHandle %p, Direction %d, ServerName %p, BufferLength1 %d, NameLength1 %p, Description %p,"
+    FIXME("(EnvironmentHandle %p, Direction %d, ServerName %p, BufferLength1 %d, NameLength1 %p, Description %p,"
           " BufferLength2 %d, NameLength2 %p)\n", EnvironmentHandle, Direction, ServerName, BufferLength1,
           NameLength1, Description, BufferLength2, NameLength2);
 
-    ret = ODBC_CALL( SQLDataSources, &params );
-    if (ret >= 0 && TRACE_ON(odbc))
-    {
-        if (ServerName && NameLength1 && *NameLength1 > 0)
-            TRACE(" DataSource %s", debugstr_an((const char *)ServerName, *NameLength1));
-        if (Description && NameLength2 && *NameLength2 > 0)
-            TRACE(" Description %s", debugstr_an((const char *)Description, *NameLength2));
-        TRACE("\n");
-    }
-
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -616,25 +658,12 @@ SQLRETURN WINAPI SQLDataSourcesA(SQLHENV EnvironmentHandle, SQLUSMALLINT Directi
                                  SQLSMALLINT BufferLength1, SQLSMALLINT *NameLength1, SQLCHAR *Description,
                                  SQLSMALLINT BufferLength2, SQLSMALLINT *NameLength2)
 {
-    struct SQLDataSourcesA_params params = { EnvironmentHandle, Direction, ServerName, BufferLength1,
-                                             NameLength1, Description, BufferLength2, NameLength2 };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(EnvironmentHandle %p, Direction %d, ServerName %p, BufferLength1 %d, NameLength1 %p, Description %p,"
+    FIXME("(EnvironmentHandle %p, Direction %d, ServerName %p, BufferLength1 %d, NameLength1 %p, Description %p,"
           " BufferLength2 %d, NameLength2 %p)\n", EnvironmentHandle, Direction, ServerName, BufferLength1,
           NameLength1, Description, BufferLength2, NameLength2);
 
-    ret = ODBC_CALL( SQLDataSourcesA, &params );
-    if (TRACE_ON(odbc))
-    {
-       if (ServerName && NameLength1 && *NameLength1 > 0)
-            TRACE(" DataSource %s", debugstr_an((const char *)ServerName, *NameLength1));
-       if (Description && NameLength2 && *NameLength2 > 0)
-            TRACE(" Description %s", debugstr_an((const char *)Description, *NameLength2));
-       TRACE("\n");
-    }
-
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -645,28 +674,29 @@ SQLRETURN WINAPI SQLDescribeCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNum
                                 SQLSMALLINT BufferLength, SQLSMALLINT *NameLength, SQLSMALLINT *DataType,
                                 SQLULEN *ColumnSize, SQLSMALLINT *DecimalDigits, SQLSMALLINT *Nullable)
 {
-    struct SQLDescribeCol_params params = { StatementHandle, ColumnNumber, ColumnName, BufferLength,
-                                            NameLength, DataType, ColumnSize, DecimalDigits, Nullable };
+    struct SQLHSTMT_data *statement = StatementHandle;
     SQLSMALLINT dummy;
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, ColumnNumber %d, ColumnName %p, BufferLength %d, NameLength %p, DataType %p,"
           " ColumnSize %p, DecimalDigits %p, Nullable %p)\n", StatementHandle, ColumnNumber, ColumnName,
           BufferLength, NameLength, DataType, ColumnSize, DecimalDigits, Nullable);
 
-    if (!params.NameLength) params.NameLength = &dummy; /* workaround for drivers that don't accept NULL NameLength */
+    if (!NameLength) NameLength = &dummy; /* workaround for drivers that don't accept NULL NameLength */
+
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
 
-    ret = ODBC_CALL( SQLDescribeCol, &params );
-    if (ret >= 0)
+    if (statement->connection->pSQLDescribeCol)
     {
-        if (ColumnName && NameLength) TRACE(" ColumnName %s\n", debugstr_an((const char *)ColumnName, *NameLength));
-        if (DataType) TRACE(" DataType %d\n", *DataType);
-        if (ColumnSize) TRACE(" ColumnSize %s\n", debugstr_sqlulen(*ColumnSize));
-        if (DecimalDigits) TRACE(" DecimalDigits %d\n", *DecimalDigits);
-        if (Nullable) TRACE(" Nullable %d\n", *Nullable);
+        ret = statement->connection->pSQLDescribeCol(statement->driver_stmt, ColumnNumber, ColumnName,
+                                 BufferLength, NameLength, DataType, ColumnSize, DecimalDigits, Nullable);
     }
 
-    TRACE("Returning %d\n", ret);
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -675,13 +705,24 @@ SQLRETURN WINAPI SQLDescribeCol(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNum
  */
 SQLRETURN WINAPI SQLDisconnect(SQLHDBC ConnectionHandle)
 {
-    struct SQLDisconnect_params params = { ConnectionHandle };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(ConnectionHandle %p)\n", ConnectionHandle);
 
-    ret = ODBC_CALL( SQLDisconnect, &params );
-    TRACE("Returning %d\n", ret);
+    if (connection->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", connection->type);
+        return SQL_ERROR;
+    }
+
+    if (connection->pSQLDisconnect)
+    {
+        ret = connection->pSQLDisconnect(connection->driver_hdbc);
+    }
+
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -690,13 +731,10 @@ SQLRETURN WINAPI SQLDisconnect(SQLHDBC ConnectionHandle)
  */
 SQLRETURN WINAPI SQLEndTran(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMALLINT CompletionType)
 {
-    struct SQLEndTran_params params = { HandleType, Handle, CompletionType };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(HandleType %d, Handle %p, CompletionType %d)\n", HandleType, Handle, CompletionType);
+    FIXME("(HandleType %d, Handle %p, CompletionType %d)\n", HandleType, Handle, CompletionType);
 
-    ret = ODBC_CALL( SQLEndTran, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -707,24 +745,12 @@ SQLRETURN WINAPI SQLError(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, S
                           SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText,
                           SQLSMALLINT BufferLength, SQLSMALLINT *TextLength)
 {
-    struct SQLError_params params = { EnvironmentHandle, ConnectionHandle, StatementHandle, Sqlstate,
-                                      NativeError, MessageText, BufferLength, TextLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(EnvironmentHandle %p, ConnectionHandle %p, StatementHandle %p, Sqlstate %p, NativeError %p,"
+    FIXME("(EnvironmentHandle %p, ConnectionHandle %p, StatementHandle %p, Sqlstate %p, NativeError %p,"
           " MessageText %p, BufferLength %d, TextLength %p)\n", EnvironmentHandle, ConnectionHandle,
           StatementHandle, Sqlstate, NativeError, MessageText, BufferLength, TextLength);
 
-    ret = ODBC_CALL( SQLError, &params );
-
-    if (ret == SQL_SUCCESS)
-    {
-        TRACE(" SQLState %s\n", debugstr_an((const char *)Sqlstate, 5));
-        TRACE(" Error %d\n", *NativeError);
-        TRACE(" MessageText %s\n", debugstr_an((const char *)MessageText, *TextLength));
-    }
-
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -733,14 +759,25 @@ SQLRETURN WINAPI SQLError(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, S
  */
 SQLRETURN WINAPI SQLExecDirect(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength)
 {
-    struct SQLExecDirect_params params = { StatementHandle, StatementText, TextLength };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, StatementText %s, TextLength %d)\n", StatementHandle,
-          debugstr_an((const char *)StatementText, TextLength), TextLength);
+          TextLength > 0 ? debugstr_an((char*)StatementText, TextLength) : debugstr_a((char*)StatementText),
+          TextLength);
+
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
 
-    ret = ODBC_CALL( SQLExecDirect, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->connection->pSQLExecDirect)
+    {
+        ret = statement->connection->pSQLExecDirect(statement->driver_stmt, StatementText, TextLength);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -749,13 +786,10 @@ SQLRETURN WINAPI SQLExecDirect(SQLHSTMT StatementHandle, SQLCHAR *StatementText,
  */
 SQLRETURN WINAPI SQLExecute(SQLHSTMT StatementHandle)
 {
-    struct SQLExecute_params params = { StatementHandle };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p)\n", StatementHandle);
+    FIXME("(StatementHandle %p)\n", StatementHandle);
 
-    ret = ODBC_CALL( SQLExecute, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -764,13 +798,23 @@ SQLRETURN WINAPI SQLExecute(SQLHSTMT StatementHandle)
  */
 SQLRETURN WINAPI SQLFetch(SQLHSTMT StatementHandle)
 {
-    struct SQLFetch_params params = { StatementHandle };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p)\n", StatementHandle);
 
-    ret = ODBC_CALL( SQLFetch, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLFetch)
+    {
+        ret = statement->connection->pSQLFetch(statement->driver_stmt);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -779,14 +823,11 @@ SQLRETURN WINAPI SQLFetch(SQLHSTMT StatementHandle)
  */
 SQLRETURN WINAPI SQLFetchScroll(SQLHSTMT StatementHandle, SQLSMALLINT FetchOrientation, SQLLEN FetchOffset)
 {
-    struct SQLFetchScroll_params params = { StatementHandle, FetchOrientation, FetchOffset };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, FetchOrientation %d, FetchOffset %s)\n", StatementHandle, FetchOrientation,
+    FIXME("(StatementHandle %p, FetchOrientation %d, FetchOffset %s)\n", StatementHandle, FetchOrientation,
           debugstr_sqllen(FetchOffset));
 
-    ret = ODBC_CALL( SQLFetchScroll, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -795,14 +836,24 @@ SQLRETURN WINAPI SQLFetchScroll(SQLHSTMT StatementHandle, SQLSMALLINT FetchOrien
  */
 SQLRETURN WINAPI SQLFreeConnect(SQLHDBC ConnectionHandle)
 {
-    struct SQLFreeConnect_params params = { ConnectionHandle };
-    SQLRETURN ret;
+    struct SQLHDBC_data *hdbc = ConnectionHandle;
 
     TRACE("(ConnectionHandle %p)\n", ConnectionHandle);
 
-    ret = ODBC_CALL( SQLFreeConnect, &params );
-    TRACE("Returning %d\n", ret);
-    return ret;
+    if (!hdbc)
+        return SQL_ERROR;
+
+    if (hdbc->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", hdbc->type);
+        return SQL_ERROR;
+    }
+
+    FreeLibrary(hdbc->module);
+
+    free(hdbc);
+
+    return SQL_SUCCESS;
 }
 
 /*************************************************************************
@@ -810,14 +861,15 @@ SQLRETURN WINAPI SQLFreeConnect(SQLHDBC ConnectionHandle)
  */
 SQLRETURN WINAPI SQLFreeEnv(SQLHENV EnvironmentHandle)
 {
-    struct SQLFreeEnv_params params = { EnvironmentHandle };
-    SQLRETURN ret;
-
+    struct SQLHENV_data *data = EnvironmentHandle;
     TRACE("(EnvironmentHandle %p)\n", EnvironmentHandle);
 
-    ret = ODBC_CALL( SQLFreeEnv, &params );
-    TRACE("Returning %d\n", ret);
-    return ret;
+    if (data && data->type != SQL_HANDLE_ENV)
+        WARN("EnvironmentHandle isn't of type SQL_HANDLE_ENV\n");
+    else
+        free(data);
+
+    return SQL_SUCCESS;
 }
 
 /*************************************************************************
@@ -825,13 +877,10 @@ SQLRETURN WINAPI SQLFreeEnv(SQLHENV EnvironmentHandle)
  */
 SQLRETURN WINAPI SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle)
 {
-    struct SQLFreeHandle_params params = { HandleType, Handle };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(HandleType %d, Handle %p)\n", HandleType, Handle);
+    FIXME("(HandleType %d, Handle %p)\n", HandleType, Handle);
 
-    ret = ODBC_CALL( SQLFreeHandle, &params );
-    TRACE ("Returning %d\n", ret);
     return ret;
 }
 
@@ -840,13 +889,23 @@ SQLRETURN WINAPI SQLFreeHandle(SQLSMALLINT HandleType, SQLHANDLE Handle)
  */
 SQLRETURN WINAPI SQLFreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option)
 {
-    struct SQLFreeStmt_params params = { StatementHandle, Option };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, Option %d)\n", StatementHandle, Option);
 
-    ret = ODBC_CALL( SQLFreeStmt, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLFreeStmt)
+    {
+        ret = statement->connection->pSQLFreeStmt(statement->driver_stmt, Option);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -856,14 +915,26 @@ SQLRETURN WINAPI SQLFreeStmt(SQLHSTMT StatementHandle, SQLUSMALLINT Option)
 SQLRETURN WINAPI SQLGetConnectAttr(SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                    SQLINTEGER BufferLength, SQLINTEGER *StringLength)
 {
-    struct SQLGetConnectAttr_params params = { ConnectionHandle, Attribute, Value, BufferLength, StringLength };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(ConnectionHandle %p, Attribute %d, Value %p, BufferLength %d, StringLength %p)\n", ConnectionHandle,
           Attribute, Value, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetConnectAttr, &params );
-    TRACE("Returning %d\n", ret);
+    if (connection->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", connection->type);
+        return SQL_ERROR;
+    }
+
+    if (connection->pSQLGetConnectAttr)
+    {
+        ret = connection->pSQLGetConnectAttr(connection->driver_hdbc, Attribute, Value,
+                                    BufferLength, StringLength);
+    }
+
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -872,13 +943,10 @@ SQLRETURN WINAPI SQLGetConnectAttr(SQLHDBC ConnectionHandle, SQLINTEGER Attribut
  */
 SQLRETURN WINAPI SQLGetConnectOption(SQLHDBC ConnectionHandle, SQLUSMALLINT Option, SQLPOINTER Value)
 {
-    struct SQLGetConnectOption_params params = { ConnectionHandle, Option, Value };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(ConnectionHandle %p, Option %d, Value %p)\n", ConnectionHandle, Option, Value);
+    FIXME("(ConnectionHandle %p, Option %d, Value %p)\n", ConnectionHandle, Option, Value);
 
-    ret = ODBC_CALL( SQLGetConnectOption, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -888,14 +956,11 @@ SQLRETURN WINAPI SQLGetConnectOption(SQLHDBC ConnectionHandle, SQLUSMALLINT Opti
 SQLRETURN WINAPI SQLGetCursorName(SQLHSTMT StatementHandle, SQLCHAR *CursorName, SQLSMALLINT BufferLength,
                                   SQLSMALLINT *NameLength)
 {
-    struct SQLGetCursorName_params params = { StatementHandle, CursorName, BufferLength, NameLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CursorName %p, BufferLength %d, NameLength %p)\n", StatementHandle, CursorName,
+    FIXME("(StatementHandle %p, CursorName %p, BufferLength %d, NameLength %p)\n", StatementHandle, CursorName,
           BufferLength, NameLength);
 
-    ret = ODBC_CALL( SQLGetCursorName, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -905,15 +970,25 @@ SQLRETURN WINAPI SQLGetCursorName(SQLHSTMT StatementHandle, SQLCHAR *CursorName,
 SQLRETURN WINAPI SQLGetData(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber, SQLSMALLINT TargetType,
                             SQLPOINTER TargetValue, SQLLEN BufferLength, SQLLEN *StrLen_or_Ind)
 {
-    struct SQLGetData_params params = { StatementHandle, ColumnNumber, TargetType, TargetValue,
-                                        BufferLength, StrLen_or_Ind };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, ColumnNumber %d, TargetType %d, TargetValue %p, BufferLength %s, StrLen_or_Ind %p)\n",
           StatementHandle, ColumnNumber, TargetType, TargetValue, debugstr_sqllen(BufferLength), StrLen_or_Ind);
 
-    ret = ODBC_CALL( SQLGetData, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLGetData)
+    {
+        ret = statement->connection->pSQLGetData(statement->driver_stmt, ColumnNumber, TargetType,
+                            TargetValue, BufferLength, StrLen_or_Ind);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -923,15 +998,11 @@ SQLRETURN WINAPI SQLGetData(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNumber,
 SQLRETURN WINAPI SQLGetDescField(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier,
                                  SQLPOINTER Value, SQLINTEGER BufferLength, SQLINTEGER *StringLength)
 {
-    struct SQLGetDescField_params params = { DescriptorHandle, RecNumber, FieldIdentifier, Value,
-                                             BufferLength, StringLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(DescriptorHandle %p, RecNumber %d, FieldIdentifier %d, Value %p, BufferLength %d, StringLength %p)\n",
+    FIXME("(DescriptorHandle %p, RecNumber %d, FieldIdentifier %d, Value %p, BufferLength %d, StringLength %p)\n",
           DescriptorHandle, RecNumber, FieldIdentifier, Value, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetDescField, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -943,16 +1014,12 @@ SQLRETURN WINAPI SQLGetDescRec(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber,
                                SQLSMALLINT *SubType, SQLLEN *Length, SQLSMALLINT *Precision,
                                SQLSMALLINT *Scale, SQLSMALLINT *Nullable)
 {
-    struct SQLGetDescRec_params params = { DescriptorHandle, RecNumber, Name, BufferLength, StringLength,
-                                           Type, SubType, Length, Precision, Scale, Nullable };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(DescriptorHandle %p, RecNumber %d, Name %p, BufferLength %d, StringLength %p, Type %p, SubType %p,"
+    FIXME("(DescriptorHandle %p, RecNumber %d, Name %p, BufferLength %d, StringLength %p, Type %p, SubType %p,"
           " Length %p, Precision %p, Scale %p, Nullable %p)\n", DescriptorHandle, RecNumber, Name, BufferLength,
           StringLength, Type, SubType, Length, Precision, Scale, Nullable);
 
-    ret = ODBC_CALL( SQLGetDescRec, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -963,15 +1030,32 @@ SQLRETURN WINAPI SQLGetDiagField(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSM
                                  SQLSMALLINT DiagIdentifier, SQLPOINTER DiagInfo, SQLSMALLINT BufferLength,
                                  SQLSMALLINT *StringLength)
 {
-    struct SQLGetDiagField_params params = { HandleType, Handle, RecNumber, DiagIdentifier, DiagInfo,
-                                             BufferLength, StringLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(HandleType %d, Handle %p, RecNumber %d, DiagIdentifier %d, DiagInfo %p, BufferLength %d,"
           " StringLength %p)\n", HandleType, Handle, RecNumber, DiagIdentifier, DiagInfo, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetDiagField, &params );
-    TRACE("Returning %d\n", ret);
+    if (HandleType == SQL_HANDLE_ENV)
+    {
+        FIXME("Unhandled SQL_HANDLE_ENV records\n");
+    }
+    else if (HandleType == SQL_HANDLE_DBC)
+    {
+        struct SQLHDBC_data *hdbc = Handle;
+
+        if (hdbc->pSQLGetDiagField)
+            ret = hdbc->pSQLGetDiagField(HandleType, hdbc->driver_hdbc, RecNumber, DiagIdentifier,
+                                     DiagInfo, BufferLength, StringLength);
+    }
+    else if (HandleType == SQL_HANDLE_STMT)
+    {
+        struct SQLHSTMT_data *statement = Handle;
+
+        if (statement->connection->pSQLGetDiagField)
+            ret = statement->connection->pSQLGetDiagField(HandleType, statement->driver_stmt, RecNumber,
+                                     DiagIdentifier, DiagInfo, BufferLength, StringLength);
+    }
+
     return ret;
 }
 
@@ -982,16 +1066,44 @@ SQLRETURN WINAPI SQLGetDiagRec(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMAL
                                SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText,
                                SQLSMALLINT BufferLength, SQLSMALLINT *TextLength)
 {
-    struct SQLGetDiagRec_params params = { HandleType, Handle, RecNumber, Sqlstate, NativeError,
-                                           MessageText, BufferLength, TextLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(HandleType %d, Handle %p, RecNumber %d, Sqlstate %p, NativeError %p, MessageText %p, BufferLength %d,"
           " TextLength %p)\n", HandleType, Handle, RecNumber, Sqlstate, NativeError, MessageText, BufferLength,
           TextLength);
 
-    ret = ODBC_CALL( SQLGetDiagRec, &params );
-    TRACE("Returning %d\n", ret);
+    if (HandleType == SQL_HANDLE_ENV)
+    {
+        FIXME("Unhandled SQL_HANDLE_ENV records\n");
+    }
+    else if (HandleType == SQL_HANDLE_DBC)
+    {
+        struct SQLHDBC_data *hdbc = Handle;
+
+        if (hdbc->pSQLGetDiagRec)
+            ret = hdbc->pSQLGetDiagRec(HandleType, hdbc->driver_hdbc, RecNumber, Sqlstate,
+                                NativeError, MessageText, BufferLength, TextLength);
+        else if (hdbc->pSQLGetDiagRecA)
+            ret = hdbc->pSQLGetDiagRecA(HandleType, hdbc->driver_hdbc, RecNumber, Sqlstate,
+                                NativeError, MessageText, BufferLength, TextLength);
+    }
+    else if (HandleType == SQL_HANDLE_STMT)
+    {
+        struct SQLHSTMT_data *statement = Handle;
+
+        if (statement->connection->pSQLGetDiagRec)
+            ret = statement->connection->pSQLGetDiagRec(HandleType, statement->driver_stmt, RecNumber,
+                                Sqlstate, NativeError, MessageText, BufferLength, TextLength);
+        else if (statement->connection->pSQLGetDiagRecA)
+            ret = statement->connection->pSQLGetDiagRecA(HandleType, statement->driver_stmt, RecNumber,
+                                Sqlstate, NativeError, MessageText, BufferLength, TextLength);
+    }
+
+    if (ret != SQL_ERROR)
+    {
+        TRACE("%d: %s %s\n", RecNumber, Sqlstate, MessageText);
+    }
+
     return ret;
 }
 
@@ -1001,15 +1113,50 @@ SQLRETURN WINAPI SQLGetDiagRec(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMAL
 SQLRETURN WINAPI SQLGetEnvAttr(SQLHENV EnvironmentHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                SQLINTEGER BufferLength, SQLINTEGER *StringLength)
 {
-    struct SQLGetEnvAttr_params params = { EnvironmentHandle, Attribute, Value, BufferLength, StringLength };
-    SQLRETURN ret;
+    struct SQLHENV_data *data = EnvironmentHandle;
 
     TRACE("(EnvironmentHandle %p, Attribute %d, Value %p, BufferLength %d, StringLength %p)\n",
           EnvironmentHandle, Attribute, Value, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetEnvAttr, &params );
-    TRACE("Returning %d\n", ret);
-    return ret;
+    if (EnvironmentHandle == SQL_NULL_HENV)
+    {
+        if (StringLength)
+            *StringLength = 0;
+        if (Value)
+            *(SQLINTEGER*)Value = 0;
+        return SQL_SUCCESS;
+    }
+
+    if (data->type != SQL_HANDLE_ENV)
+    {
+        WARN("Wrong handle type %d\n", data->type);
+        return SQL_ERROR;
+    }
+
+    switch (Attribute)
+    {
+        case SQL_ATTR_CONNECTION_POOLING:
+            if (BufferLength != sizeof(data->pooling))
+            {
+                WARN("Invalid buffer size\n");
+                return SQL_ERROR;
+            }
+            *(SQLUINTEGER*)Value = data->pooling;
+            break;
+        case SQL_ATTR_ODBC_VERSION:
+            if (BufferLength != sizeof(data->version))
+            {
+                WARN("Invalid buffer size\n");
+                return SQL_ERROR;
+            }
+            *(SQLUINTEGER*)Value = data->version;
+            break;
+        default:
+            FIXME("Unhandle attribute %d\n", Attribute);
+            return SQL_ERROR;
+    }
+
+    return SQL_SUCCESS;
 }
 
 /*************************************************************************
@@ -1017,13 +1164,16 @@ SQLRETURN WINAPI SQLGetEnvAttr(SQLHENV EnvironmentHandle, SQLINTEGER Attribute,
  */
 SQLRETURN WINAPI SQLGetFunctions(SQLHDBC ConnectionHandle, SQLUSMALLINT FunctionId, SQLUSMALLINT *Supported)
 {
-    struct SQLGetFunctions_params params = { ConnectionHandle, FunctionId, Supported };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(ConnectionHandle %p, FunctionId %d, Supported %p)\n", ConnectionHandle, FunctionId, Supported);
 
-    ret = ODBC_CALL( SQLGetFunctions, &params );
-    TRACE("Returning %d\n", ret);
+    if (connection->pSQLGetFunctions)
+    {
+        ret = connection->pSQLGetFunctions(connection->driver_hdbc, FunctionId, Supported);
+    }
+
     return ret;
 }
 
@@ -1033,14 +1183,33 @@ SQLRETURN WINAPI SQLGetFunctions(SQLHDBC ConnectionHandle, SQLUSMALLINT Function
 SQLRETURN WINAPI SQLGetInfo(SQLHDBC ConnectionHandle, SQLUSMALLINT InfoType, SQLPOINTER InfoValue,
                             SQLSMALLINT BufferLength, SQLSMALLINT *StringLength)
 {
-    struct SQLGetInfo_params params = { ConnectionHandle, InfoType, InfoValue, BufferLength, StringLength };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    char *ptr = InfoValue;
+    SQLRETURN ret = SQL_SUCCESS;
 
     TRACE("(ConnectionHandle, %p, InfoType %d, InfoValue %p, BufferLength %d, StringLength %p)\n", ConnectionHandle,
           InfoType, InfoValue, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetInfo, &params );
-    TRACE("Returning %d\n", ret);
+    switch(InfoType)
+    {
+        case SQL_ODBC_VER:
+            lstrcpynA(ptr, "03.80.0000", BufferLength);
+            if (StringLength)
+                *StringLength = strlen(ptr);
+            break;
+        default:
+            if (connection->pSQLGetInfo)
+                ret = connection->pSQLGetInfo(connection->driver_hdbc, InfoType, InfoValue,
+                             BufferLength, StringLength);
+            else
+            {
+                FIXME("Unsupported type %d\n", InfoType);
+                ret = SQL_ERROR;
+            }
+    }
+
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -1050,20 +1219,63 @@ SQLRETURN WINAPI SQLGetInfo(SQLHDBC ConnectionHandle, SQLUSMALLINT InfoType, SQL
 SQLRETURN WINAPI SQLGetStmtAttr(SQLHSTMT StatementHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                 SQLINTEGER BufferLength, SQLINTEGER *StringLength)
 {
-    struct SQLGetStmtAttr_params params = { StatementHandle, Attribute, Value, BufferLength, StringLength };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, Attribute %d, Value %p, BufferLength %d, StringLength %p)\n", StatementHandle,
           Attribute, Value, BufferLength, StringLength);
 
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
     if (!Value)
     {
         WARN("Unexpected NULL Value return address\n");
         return SQL_ERROR;
     }
 
-    ret = ODBC_CALL( SQLGetStmtAttr, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->connection->pSQLGetStmtAttr)
+    {
+        switch(Attribute)
+        {
+            case SQL_ATTR_APP_ROW_DESC:
+                statement->app_row_desc.parent = statement;
+                ret = statement->connection->pSQLGetStmtAttr(statement->driver_stmt, Attribute,
+                                                             &statement->app_row_desc.driver_hdesc,
+                                                             BufferLength, StringLength);
+                *((SQLHDESC*)Value) = &statement->app_row_desc;
+                break;
+            case SQL_ATTR_IMP_ROW_DESC:
+                statement->imp_row_desc.parent = statement;
+                ret = statement->connection->pSQLGetStmtAttr(statement->driver_stmt, Attribute,
+                                                             &statement->imp_row_desc.driver_hdesc,
+                                                             BufferLength, StringLength);
+                *((SQLHDESC*)Value) = &statement->imp_row_desc;
+                break;
+            case SQL_ATTR_APP_PARAM_DESC:
+                statement->app_param_desc.parent = statement;
+                ret = statement->connection->pSQLGetStmtAttr(statement->driver_stmt, Attribute,
+                                                             &statement->app_param_desc.driver_hdesc,
+                                                             BufferLength, StringLength);
+                *((SQLHDESC*)Value) = &statement->app_param_desc;
+                break;
+            case SQL_ATTR_IMP_PARAM_DESC:
+                statement->imp_param_desc.parent = statement;
+                ret = statement->connection->pSQLGetStmtAttr(statement->driver_stmt, Attribute,
+                                                             &statement->imp_param_desc.driver_hdesc,
+                                                             BufferLength, StringLength);
+                *((SQLHDESC*)Value) = &statement->imp_param_desc;
+                break;
+            default:
+                ret = statement->connection->pSQLGetStmtAttr(statement->driver_stmt, Attribute, Value,
+                                BufferLength, StringLength);
+        }
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1072,13 +1284,10 @@ SQLRETURN WINAPI SQLGetStmtAttr(SQLHSTMT StatementHandle, SQLINTEGER Attribute,
  */
 SQLRETURN WINAPI SQLGetStmtOption(SQLHSTMT StatementHandle, SQLUSMALLINT Option, SQLPOINTER Value)
 {
-    struct SQLGetStmtOption_params params = { StatementHandle, Option, Value };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, Option %d, Value %p)\n", StatementHandle, Option, Value);
+    FIXME("(StatementHandle %p, Option %d, Value %p)\n", StatementHandle, Option, Value);
 
-    ret = ODBC_CALL( SQLGetStmtOption, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1087,13 +1296,23 @@ SQLRETURN WINAPI SQLGetStmtOption(SQLHSTMT StatementHandle, SQLUSMALLINT Option,
  */
 SQLRETURN WINAPI SQLGetTypeInfo(SQLHSTMT StatementHandle, SQLSMALLINT DataType)
 {
-    struct SQLGetTypeInfo_params params = { StatementHandle, DataType };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, DataType %d)\n", StatementHandle, DataType);
 
-    ret = ODBC_CALL( SQLGetTypeInfo, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLGetTypeInfo)
+    {
+        ret = statement->connection->pSQLGetTypeInfo(statement->driver_stmt, DataType);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1102,13 +1321,23 @@ SQLRETURN WINAPI SQLGetTypeInfo(SQLHSTMT StatementHandle, SQLSMALLINT DataType)
  */
 SQLRETURN WINAPI SQLNumResultCols(SQLHSTMT StatementHandle, SQLSMALLINT *ColumnCount)
 {
-    struct SQLNumResultCols_params params = { StatementHandle, ColumnCount };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, ColumnCount %p)\n", StatementHandle, ColumnCount);
 
-    ret = ODBC_CALL( SQLNumResultCols, &params );
-    TRACE("Returning %d ColumnCount %d\n", ret, *ColumnCount);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLNumResultCols)
+    {
+        ret = statement->connection->pSQLNumResultCols(statement->driver_stmt, ColumnCount);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1117,13 +1346,10 @@ SQLRETURN WINAPI SQLNumResultCols(SQLHSTMT StatementHandle, SQLSMALLINT *ColumnC
  */
 SQLRETURN WINAPI SQLParamData(SQLHSTMT StatementHandle, SQLPOINTER *Value)
 {
-    struct SQLParamData_params params = { StatementHandle, Value };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, Value %p)\n", StatementHandle, Value);
+    FIXME("(StatementHandle %p, Value %p)\n", StatementHandle, Value);
 
-    ret = ODBC_CALL( SQLParamData, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1132,14 +1358,25 @@ SQLRETURN WINAPI SQLParamData(SQLHSTMT StatementHandle, SQLPOINTER *Value)
  */
 SQLRETURN WINAPI SQLPrepare(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQLINTEGER TextLength)
 {
-    struct SQLPrepare_params params = { StatementHandle, StatementText, TextLength };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, StatementText %s, TextLength %d)\n", StatementHandle,
-          debugstr_an((const char *)StatementText, TextLength), TextLength);
+    FIXME("(StatementHandle %p, StatementText %s, TextLength %d)\n", StatementHandle,
+          TextLength > 0 ? debugstr_an((const char *)StatementText, TextLength) : debugstr_a((const char *)StatementText),
+          TextLength);
+
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
 
-    ret = ODBC_CALL( SQLPrepare, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->connection->pSQLPrepare)
+    {
+        ret = statement->connection->pSQLPrepare(statement->driver_stmt, StatementText, TextLength);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1148,13 +1385,10 @@ SQLRETURN WINAPI SQLPrepare(SQLHSTMT StatementHandle, SQLCHAR *StatementText, SQ
  */
 SQLRETURN WINAPI SQLPutData(SQLHSTMT StatementHandle, SQLPOINTER Data, SQLLEN StrLen_or_Ind)
 {
-    struct SQLPutData_params params = { StatementHandle, Data, StrLen_or_Ind };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, Data %p, StrLen_or_Ind %s)\n", StatementHandle, Data, debugstr_sqllen(StrLen_or_Ind));
+    FIXME("(StatementHandle %p, Data %p, StrLen_or_Ind %s)\n", StatementHandle, Data, debugstr_sqllen(StrLen_or_Ind));
 
-    ret = ODBC_CALL( SQLPutData, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1163,14 +1397,23 @@ SQLRETURN WINAPI SQLPutData(SQLHSTMT StatementHandle, SQLPOINTER Data, SQLLEN St
  */
 SQLRETURN WINAPI SQLRowCount(SQLHSTMT StatementHandle, SQLLEN *RowCount)
 {
-    struct SQLRowCount_params params = { StatementHandle, RowCount };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, RowCount %p)\n", StatementHandle, RowCount);
 
-    ret = ODBC_CALL( SQLRowCount, &params );
-    if (ret == SQL_SUCCESS && RowCount) TRACE(" RowCount %s\n", debugstr_sqllen(*RowCount));
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLRowCount)
+    {
+        ret = statement->connection->pSQLRowCount(statement->driver_stmt, RowCount);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1180,14 +1423,11 @@ SQLRETURN WINAPI SQLRowCount(SQLHSTMT StatementHandle, SQLLEN *RowCount)
 SQLRETURN WINAPI SQLSetConnectAttr(SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                    SQLINTEGER StringLength)
 {
-    struct SQLSetConnectAttr_params params = { ConnectionHandle, Attribute, Value, StringLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(ConnectionHandle %p, Attribute %d, Value %p, StringLength %d)\n", ConnectionHandle, Attribute, Value,
+    FIXME("(ConnectionHandle %p, Attribute %d, Value %p, StringLength %d)\n", ConnectionHandle, Attribute, Value,
           StringLength);
 
-    ret = ODBC_CALL( SQLSetConnectAttr, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1196,13 +1436,10 @@ SQLRETURN WINAPI SQLSetConnectAttr(SQLHDBC ConnectionHandle, SQLINTEGER Attribut
  */
 SQLRETURN WINAPI SQLSetConnectOption(SQLHDBC ConnectionHandle, SQLUSMALLINT Option, SQLULEN Value)
 {
-    struct SQLSetConnectOption_params params = { ConnectionHandle, Option, Value };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(ConnectionHandle %p, Option %d, Value %s)\n", ConnectionHandle, Option, debugstr_sqlulen(Value));
+    FIXME("(ConnectionHandle %p, Option %d, Value %s)\n", ConnectionHandle, Option, debugstr_sqlulen(Value));
 
-    ret = ODBC_CALL( SQLSetConnectOption, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1211,14 +1448,11 @@ SQLRETURN WINAPI SQLSetConnectOption(SQLHDBC ConnectionHandle, SQLUSMALLINT Opti
  */
 SQLRETURN WINAPI SQLSetCursorName(SQLHSTMT StatementHandle, SQLCHAR *CursorName, SQLSMALLINT NameLength)
 {
-    struct SQLSetCursorName_params params = { StatementHandle, CursorName, NameLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CursorName %s, NameLength %d)\n", StatementHandle,
+    FIXME("(StatementHandle %p, CursorName %s, NameLength %d)\n", StatementHandle,
           debugstr_an((const char *)CursorName, NameLength), NameLength);
 
-    ret = ODBC_CALL( SQLSetCursorName, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1228,14 +1462,11 @@ SQLRETURN WINAPI SQLSetCursorName(SQLHSTMT StatementHandle, SQLCHAR *CursorName,
 SQLRETURN WINAPI SQLSetDescField(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier,
                                  SQLPOINTER Value, SQLINTEGER BufferLength)
 {
-    struct SQLSetDescField_params params = { DescriptorHandle, RecNumber, FieldIdentifier, Value, BufferLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(DescriptorHandle %p, RecNumber %d, FieldIdentifier %d, Value %p, BufferLength %d)\n", DescriptorHandle,
+    FIXME("(DescriptorHandle %p, RecNumber %d, FieldIdentifier %d, Value %p, BufferLength %d)\n", DescriptorHandle,
           RecNumber, FieldIdentifier, Value, BufferLength);
 
-    ret = ODBC_CALL( SQLSetDescField, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1246,15 +1477,12 @@ SQLRETURN WINAPI SQLSetDescRec(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber,
                                SQLSMALLINT SubType, SQLLEN Length, SQLSMALLINT Precision, SQLSMALLINT Scale,
                                SQLPOINTER Data, SQLLEN *StringLength, SQLLEN *Indicator)
 {
-    struct SQLSetDescRec_params params = { DescriptorHandle, RecNumber, Type, SubType, Length, Precision, Scale, Data, StringLength, Indicator };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(DescriptorHandle %p, RecNumber %d, Type %d, SubType %d, Length %s, Precision %d, Scale %d, Data %p,"
+    FIXME("(DescriptorHandle %p, RecNumber %d, Type %d, SubType %d, Length %s, Precision %d, Scale %d, Data %p,"
           " StringLength %p, Indicator %p)\n", DescriptorHandle, RecNumber, Type, SubType, debugstr_sqllen(Length),
           Precision, Scale, Data, StringLength, Indicator);
 
-    ret = ODBC_CALL( SQLSetDescRec, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1264,15 +1492,37 @@ SQLRETURN WINAPI SQLSetDescRec(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber,
 SQLRETURN WINAPI SQLSetEnvAttr(SQLHENV EnvironmentHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                SQLINTEGER StringLength)
 {
-    struct SQLSetEnvAttr_params params = { EnvironmentHandle, Attribute, Value, StringLength };
-    SQLRETURN ret;
+    struct SQLHENV_data *data = EnvironmentHandle;
 
     TRACE("(EnvironmentHandle %p, Attribute %d, Value %p, StringLength %d)\n", EnvironmentHandle, Attribute, Value,
           StringLength);
 
-    ret = ODBC_CALL( SQLSetEnvAttr, &params );
-    TRACE("Returning %d\n", ret);
-    return ret;
+    if(!data || data->type != SQL_HANDLE_ENV)
+    {
+        WARN("Wrong handle type %d\n", data->type);
+        return SQL_ERROR;
+    }
+
+    switch(Attribute)
+    {
+        case SQL_ATTR_CONNECTION_POOLING:
+            if (Value)
+                data->pooling = (uintptr_t)Value;
+            else
+                data->pooling = SQL_CP_OFF;
+            break;
+        case SQL_ATTR_ODBC_VERSION:
+            if (Value)
+                data->version = (uintptr_t)Value;
+            else
+                data->version = SQL_OV_ODBC2;
+            break;
+        default:
+            FIXME("Unhandle attribute %d\n", Attribute);
+            return SQL_ERROR;
+    }
+
+    return SQL_SUCCESS;
 }
 
 /*************************************************************************
@@ -1282,16 +1532,12 @@ SQLRETURN WINAPI SQLSetParam(SQLHSTMT StatementHandle, SQLUSMALLINT ParameterNum
                              SQLSMALLINT ParameterType, SQLULEN LengthPrecision, SQLSMALLINT ParameterScale,
                              SQLPOINTER ParameterValue, SQLLEN *StrLen_or_Ind)
 {
-    struct SQLSetParam_params params = { StatementHandle, ParameterNumber, ValueType, ParameterType,
-                                         LengthPrecision, ParameterScale, ParameterValue, StrLen_or_Ind };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, ParameterNumber %d, ValueType %d, ParameterType %d, LengthPrecision %s,"
+    FIXME("(StatementHandle %p, ParameterNumber %d, ValueType %d, ParameterType %d, LengthPrecision %s,"
           " ParameterScale %d, ParameterValue %p, StrLen_or_Ind %p)\n", StatementHandle, ParameterNumber, ValueType,
           ParameterType, debugstr_sqlulen(LengthPrecision), ParameterScale, ParameterValue, StrLen_or_Ind);
 
-    ret = ODBC_CALL( SQLSetParam, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1301,14 +1547,24 @@ SQLRETURN WINAPI SQLSetParam(SQLHSTMT StatementHandle, SQLUSMALLINT ParameterNum
 SQLRETURN WINAPI SQLSetStmtAttr(SQLHSTMT StatementHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                 SQLINTEGER StringLength)
 {
-    struct SQLSetStmtAttr_params params = { StatementHandle, Attribute, Value, StringLength };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, Attribute %d, Value %p, StringLength %d)\n", StatementHandle, Attribute, Value,
           StringLength);
 
-    ret = ODBC_CALL( SQLSetStmtAttr, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLSetStmtAttr)
+    {
+        ret = statement->connection->pSQLSetStmtAttr(statement->driver_stmt, Attribute, Value, StringLength);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1317,13 +1573,10 @@ SQLRETURN WINAPI SQLSetStmtAttr(SQLHSTMT StatementHandle, SQLINTEGER Attribute,
  */
 SQLRETURN WINAPI SQLSetStmtOption(SQLHSTMT StatementHandle, SQLUSMALLINT Option, SQLULEN Value)
 {
-    struct SQLSetStmtOption_params params = { StatementHandle, Option, Value };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, Option %d, Value %s)\n", StatementHandle, Option, debugstr_sqlulen(Value));
+    FIXME("(StatementHandle %p, Option %d, Value %s)\n", StatementHandle, Option, debugstr_sqlulen(Value));
 
-    ret = ODBC_CALL( SQLSetStmtOption, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1335,18 +1588,14 @@ SQLRETURN WINAPI SQLSpecialColumns(SQLHSTMT StatementHandle, SQLUSMALLINT Identi
                                    SQLCHAR *TableName, SQLSMALLINT NameLength3, SQLUSMALLINT Scope,
                                    SQLUSMALLINT Nullable)
 {
-    struct SQLSpecialColumns_params params = { StatementHandle, IdentifierType, CatalogName, NameLength1,
-                                               SchemaName, NameLength2, TableName, NameLength3, Scope, Nullable };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, IdentifierType %d, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d,"
+    FIXME("(StatementHandle %p, IdentifierType %d, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d,"
           " TableName %s, NameLength3 %d, Scope %d, Nullable %d)\n", StatementHandle, IdentifierType,
           debugstr_an((const char *)CatalogName, NameLength1), NameLength1,
           debugstr_an((const char *)SchemaName, NameLength2), NameLength2,
           debugstr_an((const char *)TableName, NameLength3), NameLength3, Scope, Nullable);
 
-    ret = ODBC_CALL( SQLSpecialColumns, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1357,18 +1606,14 @@ SQLRETURN WINAPI SQLStatistics(SQLHSTMT StatementHandle, SQLCHAR *CatalogName, S
                                SQLCHAR *SchemaName, SQLSMALLINT NameLength2, SQLCHAR *TableName,
                                SQLSMALLINT NameLength3, SQLUSMALLINT Unique, SQLUSMALLINT Reserved)
 {
-    struct SQLStatistics_params params = { StatementHandle, CatalogName, NameLength1, SchemaName,
-                                           NameLength2, TableName, NameLength3, Unique, Reserved };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CatalogName %s, NameLength1 %d SchemaName %s, NameLength2 %d, TableName %s"
+    FIXME("(StatementHandle %p, CatalogName %s, NameLength1 %d SchemaName %s, NameLength2 %d, TableName %s"
           " NameLength3 %d, Unique %d, Reserved %d)\n", StatementHandle,
           debugstr_an((const char *)CatalogName, NameLength1), NameLength1,
           debugstr_an((const char *)SchemaName, NameLength2), NameLength2,
           debugstr_an((const char *)TableName, NameLength3), NameLength3, Unique, Reserved);
 
-    ret = ODBC_CALL( SQLStatistics, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1379,19 +1624,15 @@ SQLRETURN WINAPI SQLTables(SQLHSTMT StatementHandle, SQLCHAR *CatalogName, SQLSM
                            SQLCHAR *SchemaName, SQLSMALLINT NameLength2, SQLCHAR *TableName,
                            SQLSMALLINT NameLength3, SQLCHAR *TableType, SQLSMALLINT NameLength4)
 {
-    struct SQLTables_params params = { StatementHandle, CatalogName, NameLength1, SchemaName, NameLength2,
-                                       TableName, NameLength3, TableType, NameLength4 };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d, TableName %s,"
+    FIXME("(StatementHandle %p, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d, TableName %s,"
           " NameLength3 %d, TableType %s, NameLength4 %d)\n", StatementHandle,
           debugstr_an((const char *)CatalogName, NameLength1), NameLength1,
           debugstr_an((const char *)SchemaName, NameLength2), NameLength2,
           debugstr_an((const char *)TableName, NameLength3), NameLength3,
           debugstr_an((const char *)TableType, NameLength4), NameLength4);
 
-    ret = ODBC_CALL( SQLTables, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1400,14 +1641,24 @@ SQLRETURN WINAPI SQLTables(SQLHSTMT StatementHandle, SQLCHAR *CatalogName, SQLSM
  */
 SQLRETURN WINAPI SQLTransact(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle, SQLUSMALLINT CompletionType)
 {
-    struct SQLTransact_params params = { EnvironmentHandle, ConnectionHandle, CompletionType };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(EnvironmentHandle %p, ConnectionHandle %p, CompletionType %d)\n", EnvironmentHandle, ConnectionHandle,
           CompletionType);
 
-    ret = ODBC_CALL( SQLTransact, &params );
-    TRACE("Returning %d\n", ret);
+    if (connection->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong connection handle type %d\n", connection->type);
+        return SQL_ERROR;
+    }
+
+    if (connection->pSQLTransact)
+    {
+        ret = connection->pSQLTransact(connection->driver_env, connection->driver_hdbc, CompletionType);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1418,16 +1669,12 @@ SQLRETURN WINAPI SQLBrowseConnect(SQLHDBC hdbc, SQLCHAR *szConnStrIn, SQLSMALLIN
                                   SQLCHAR *szConnStrOut, SQLSMALLINT cbConnStrOutMax,
                                   SQLSMALLINT *pcbConnStrOut)
 {
-    struct SQLBrowseConnect_params params = { hdbc, szConnStrIn, cbConnStrIn, szConnStrOut,
-                                              cbConnStrOutMax, pcbConnStrOut };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hdbc %p, szConnStrIn %s, cbConnStrIn %d, szConnStrOut %p, cbConnStrOutMax %d, pcbConnStrOut %p)\n",
+    FIXME("(hdbc %p, szConnStrIn %s, cbConnStrIn %d, szConnStrOut %p, cbConnStrOutMax %d, pcbConnStrOut %p)\n",
           hdbc, debugstr_an((const char *)szConnStrIn, cbConnStrIn), cbConnStrIn, szConnStrOut, cbConnStrOutMax,
           pcbConnStrOut);
 
-    ret = ODBC_CALL( SQLBrowseConnect, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1436,13 +1683,10 @@ SQLRETURN WINAPI SQLBrowseConnect(SQLHDBC hdbc, SQLCHAR *szConnStrIn, SQLSMALLIN
  */
 SQLRETURN WINAPI SQLBulkOperations(SQLHSTMT StatementHandle, SQLSMALLINT Operation)
 {
-    struct SQLBulkOperations_params params = { StatementHandle, Operation };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, Operation %d)\n", StatementHandle, Operation);
+    FIXME("(StatementHandle %p, Operation %d)\n", StatementHandle, Operation);
 
-    ret = ODBC_CALL( SQLBulkOperations, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1453,14 +1697,26 @@ SQLRETURN WINAPI SQLColAttributes(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLUSMALLIN
                                   SQLPOINTER rgbDesc, SQLSMALLINT cbDescMax, SQLSMALLINT *pcbDesc,
                                   SQLLEN *pfDesc)
 {
-    struct SQLColAttributes_params params = { hstmt, icol, fDescType, rgbDesc, cbDescMax, pcbDesc, pfDesc };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = hstmt;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(hstmt %p, icol %d, fDescType %d, rgbDesc %p, cbDescMax %d, pcbDesc %p, pfDesc %p)\n", hstmt, icol,
           fDescType, rgbDesc, cbDescMax, pcbDesc, pfDesc);
 
-    ret = ODBC_CALL( SQLColAttributes, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLColAttributes)
+    {
+        ret = statement->connection->pSQLColAttributes(statement->driver_stmt, icol, fDescType,
+                                   rgbDesc, cbDescMax, pcbDesc, pfDesc);
+    }
+
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -1471,19 +1727,15 @@ SQLRETURN WINAPI SQLColumnPrivileges(SQLHSTMT hstmt, SQLCHAR *szCatalogName, SQL
                                      SQLCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR *szTableName,
                                      SQLSMALLINT cbTableName, SQLCHAR *szColumnName, SQLSMALLINT cbColumnName)
 {
-    struct SQLColumnPrivileges_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                                 cbSchemaName, szTableName, cbTableName, szColumnName, cbColumnName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
           " cbTableName %d, szColumnName %s, cbColumnName %d)\n", hstmt,
           debugstr_an((const char *)szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_an((const char *)szSchemaName, cbSchemaName), cbSchemaName,
           debugstr_an((const char *)szTableName, cbTableName), cbTableName,
           debugstr_an((const char *)szColumnName, cbColumnName), cbColumnName);
 
-    ret = ODBC_CALL( SQLColumnPrivileges, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1493,14 +1745,11 @@ SQLRETURN WINAPI SQLColumnPrivileges(SQLHSTMT hstmt, SQLCHAR *szCatalogName, SQL
 SQLRETURN WINAPI SQLDescribeParam(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT *pfSqlType,
                                   SQLULEN *pcbParamDef, SQLSMALLINT *pibScale, SQLSMALLINT *pfNullable)
 {
-    struct SQLDescribeParam_params params = { hstmt, ipar, pfSqlType, pcbParamDef, pibScale, pfNullable };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, ipar %d, pfSqlType %p, pcbParamDef %p, pibScale %p, pfNullable %p)\n", hstmt, ipar,
+    FIXME("(hstmt %p, ipar %d, pfSqlType %p, pcbParamDef %p, pibScale %p, pfNullable %p)\n", hstmt, ipar,
           pfSqlType, pcbParamDef, pibScale, pfNullable);
 
-    ret = ODBC_CALL( SQLDescribeParam, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1510,14 +1759,25 @@ SQLRETURN WINAPI SQLDescribeParam(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT
 SQLRETURN WINAPI SQLExtendedFetch(SQLHSTMT hstmt, SQLUSMALLINT fFetchType, SQLLEN irow, SQLULEN *pcrow,
                                   SQLUSMALLINT *rgfRowStatus)
 {
-    struct SQLExtendedFetch_params params = { hstmt, fFetchType, irow, pcrow, rgfRowStatus };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = hstmt;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(hstmt %p, fFetchType %d, irow %s, pcrow %p, rgfRowStatus %p)\n", hstmt, fFetchType, debugstr_sqllen(irow),
           pcrow, rgfRowStatus);
 
-    ret = ODBC_CALL( SQLExtendedFetch, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLExtendedFetch)
+    {
+        ret = statement->connection->pSQLExtendedFetch(statement->driver_stmt, fFetchType, irow,
+                                  pcrow, rgfRowStatus);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1530,13 +1790,9 @@ SQLRETURN WINAPI SQLForeignKeys(SQLHSTMT hstmt, SQLCHAR *szPkCatalogName, SQLSMA
                                 SQLSMALLINT cbFkCatalogName, SQLCHAR *szFkSchemaName,
                                 SQLSMALLINT cbFkSchemaName, SQLCHAR *szFkTableName, SQLSMALLINT cbFkTableName)
 {
-    struct SQLForeignKeys_params params = { hstmt, szPkCatalogName, cbPkCatalogName, szPkSchemaName,
-                                            cbPkSchemaName, szPkTableName, cbPkTableName, szFkCatalogName,
-                                            cbFkCatalogName, szFkSchemaName, cbFkSchemaName,
-                                            szFkTableName, cbFkTableName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szPkCatalogName %s, cbPkCatalogName %d, szPkSchemaName %s, cbPkSchemaName %d,"
+    FIXME("(hstmt %p, szPkCatalogName %s, cbPkCatalogName %d, szPkSchemaName %s, cbPkSchemaName %d,"
           " szPkTableName %s, cbPkTableName %d, szFkCatalogName %s, cbFkCatalogName %d, szFkSchemaName %s,"
           " cbFkSchemaName %d, szFkTableName %s, cbFkTableName %d)\n", hstmt,
           debugstr_an((const char *)szPkCatalogName, cbPkCatalogName), cbPkCatalogName,
@@ -1546,8 +1802,6 @@ SQLRETURN WINAPI SQLForeignKeys(SQLHSTMT hstmt, SQLCHAR *szPkCatalogName, SQLSMA
           debugstr_an((const char *)szFkSchemaName, cbFkSchemaName), cbFkSchemaName,
           debugstr_an((const char *)szFkTableName, cbFkTableName), cbFkTableName);
 
-    ret = ODBC_CALL( SQLForeignKeys, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1556,13 +1810,23 @@ SQLRETURN WINAPI SQLForeignKeys(SQLHSTMT hstmt, SQLCHAR *szPkCatalogName, SQLSMA
  */
 SQLRETURN WINAPI SQLMoreResults(SQLHSTMT StatementHandle)
 {
-    struct SQLMoreResults_params params = { StatementHandle };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(%p)\n", StatementHandle);
 
-    ret = ODBC_CALL( SQLMoreResults, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLMoreResults)
+    {
+        ret = statement->connection->pSQLMoreResults(statement->driver_stmt);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1572,14 +1836,25 @@ SQLRETURN WINAPI SQLMoreResults(SQLHSTMT StatementHandle)
 SQLRETURN WINAPI SQLNativeSql(SQLHDBC hdbc, SQLCHAR *szSqlStrIn, SQLINTEGER cbSqlStrIn, SQLCHAR *szSqlStr,
                               SQLINTEGER cbSqlStrMax, SQLINTEGER *pcbSqlStr)
 {
-    struct SQLNativeSql_params params = { hdbc, szSqlStrIn, cbSqlStrIn, szSqlStr, cbSqlStrMax, pcbSqlStr };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = hdbc;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(hdbc %p, szSqlStrIn %s, cbSqlStrIn %d, szSqlStr %p, cbSqlStrMax %d, pcbSqlStr %p)\n", hdbc,
           debugstr_an((const char *)szSqlStrIn, cbSqlStrIn), cbSqlStrIn, szSqlStr, cbSqlStrMax, pcbSqlStr);
 
-    ret = ODBC_CALL( SQLNativeSql, &params );
-    TRACE("Returning %d\n", ret);
+    if (connection->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", connection->type);
+        return SQL_ERROR;
+    }
+
+    if (connection->pSQLNativeSql)
+    {
+        ret = connection->pSQLNativeSql(connection->driver_hdbc, szSqlStrIn, cbSqlStrIn,
+                               szSqlStr, cbSqlStrMax, pcbSqlStr);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1588,13 +1863,10 @@ SQLRETURN WINAPI SQLNativeSql(SQLHDBC hdbc, SQLCHAR *szSqlStrIn, SQLINTEGER cbSq
  */
 SQLRETURN WINAPI SQLNumParams(SQLHSTMT hstmt, SQLSMALLINT *pcpar)
 {
-    struct SQLNumParams_params params = { hstmt, pcpar };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, pcpar %p)\n", hstmt, pcpar);
+    FIXME("(hstmt %p, pcpar %p)\n", hstmt, pcpar);
 
-    ret = ODBC_CALL( SQLNumParams, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1603,13 +1875,23 @@ SQLRETURN WINAPI SQLNumParams(SQLHSTMT hstmt, SQLSMALLINT *pcpar)
  */
 SQLRETURN WINAPI SQLParamOptions(SQLHSTMT hstmt, SQLULEN crow, SQLULEN *pirow)
 {
-    struct SQLParamOptions_params params = { hstmt, crow, pirow };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = hstmt;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(hstmt %p, crow %s, pirow %p)\n", hstmt, debugstr_sqlulen(crow), pirow);
 
-    ret = ODBC_CALL( SQLParamOptions, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLParamOptions)
+    {
+        ret = statement->connection->pSQLParamOptions(statement->driver_stmt, crow, pirow);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1620,18 +1902,14 @@ SQLRETURN WINAPI SQLPrimaryKeys(SQLHSTMT hstmt, SQLCHAR *szCatalogName, SQLSMALL
                                 SQLCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR *szTableName,
                                 SQLSMALLINT cbTableName)
 {
-    struct SQLPrimaryKeys_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                            cbSchemaName, szTableName, cbTableName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
           " cbTableName %d)\n", hstmt,
           debugstr_an((const char *)szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_an((const char *)szSchemaName, cbSchemaName), cbSchemaName,
           debugstr_an((const char *)szTableName, cbTableName), cbTableName);
 
-    ret = ODBC_CALL( SQLPrimaryKeys, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1642,20 +1920,15 @@ SQLRETURN WINAPI SQLProcedureColumns(SQLHSTMT hstmt, SQLCHAR *szCatalogName, SQL
                                      SQLCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR *szProcName,
                                      SQLSMALLINT cbProcName, SQLCHAR *szColumnName, SQLSMALLINT cbColumnName)
 {
-    struct SQLProcedureColumns_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                                 cbSchemaName, szProcName, cbProcName,
-                                                 szColumnName, cbColumnName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szProcName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szProcName %s,"
           " cbProcName %d, szColumnName %s, cbColumnName %d)\n", hstmt,
           debugstr_an((const char *)szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_an((const char *)szSchemaName, cbSchemaName), cbSchemaName,
           debugstr_an((const char *)szProcName, cbProcName), cbProcName,
           debugstr_an((const char *)szColumnName, cbColumnName), cbColumnName);
 
-    ret = ODBC_CALL( SQLProcedureColumns, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1666,18 +1939,14 @@ SQLRETURN WINAPI SQLProcedures(SQLHSTMT hstmt, SQLCHAR *szCatalogName, SQLSMALLI
                                SQLCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR *szProcName,
                                SQLSMALLINT cbProcName)
 {
-    struct SQLProcedures_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                           cbSchemaName, szProcName, cbProcName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szProcName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szProcName %s,"
           " cbProcName %d)\n", hstmt,
           debugstr_an((const char *)szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_an((const char *)szSchemaName, cbSchemaName), cbSchemaName,
           debugstr_an((const char *)szProcName, cbProcName), cbProcName);
 
-    ret = ODBC_CALL( SQLProcedures, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1686,13 +1955,10 @@ SQLRETURN WINAPI SQLProcedures(SQLHSTMT hstmt, SQLCHAR *szCatalogName, SQLSMALLI
  */
 SQLRETURN WINAPI SQLSetPos(SQLHSTMT hstmt, SQLSETPOSIROW irow, SQLUSMALLINT fOption, SQLUSMALLINT fLock)
 {
-    struct SQLSetPos_params params = { hstmt, irow, fOption, fLock };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, irow %s, fOption %d, fLock %d)\n", hstmt, debugstr_sqlulen(irow), fOption, fLock);
+    FIXME("(hstmt %p, irow %s, fOption %d, fLock %d)\n", hstmt, debugstr_sqlulen(irow), fOption, fLock);
 
-    ret = ODBC_CALL( SQLSetPos, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1703,18 +1969,14 @@ SQLRETURN WINAPI SQLTablePrivileges(SQLHSTMT hstmt, SQLCHAR *szCatalogName, SQLS
                                     SQLCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR *szTableName,
                                     SQLSMALLINT cbTableName)
 {
-    struct SQLTablePrivileges_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                                cbSchemaName, szTableName, cbTableName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
           " cbTableName %d)\n", hstmt,
           debugstr_an((const char *)szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_an((const char *)szSchemaName, cbSchemaName), cbSchemaName,
           debugstr_an((const char *)szTableName, cbTableName), cbTableName);
 
-    ret = ODBC_CALL( SQLTablePrivileges, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1726,20 +1988,12 @@ SQLRETURN WINAPI SQLDrivers(SQLHENV EnvironmentHandle, SQLUSMALLINT fDirection,
                             SQLCHAR *szDriverAttributes, SQLSMALLINT cbDriverAttrMax,
                             SQLSMALLINT *pcbDriverAttr)
 {
-    struct SQLDrivers_params params = { EnvironmentHandle, fDirection, szDriverDesc, cbDriverDescMax,
-                                        pcbDriverDesc, szDriverAttributes, cbDriverAttrMax, pcbDriverAttr };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(EnvironmentHandle %p, Direction %d, szDriverDesc %p, cbDriverDescMax %d, pcbDriverDesc %p,"
+    FIXME("(EnvironmentHandle %p, Direction %d, szDriverDesc %p, cbDriverDescMax %d, pcbDriverDesc %p,"
           " DriverAttributes %p, cbDriverAttrMax %d, pcbDriverAttr %p)\n", EnvironmentHandle, fDirection,
           szDriverDesc, cbDriverDescMax, pcbDriverDesc, szDriverAttributes, cbDriverAttrMax, pcbDriverAttr);
 
-    ret = ODBC_CALL( SQLDrivers, &params );
-
-    if (ret == SQL_NO_DATA && fDirection == SQL_FETCH_FIRST)
-        ERR_(winediag)("No ODBC drivers could be found. Check the settings for your libodbc provider.\n");
-
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1751,16 +2005,26 @@ SQLRETURN WINAPI SQLBindParameter(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT
                                   SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLLEN cbValueMax,
                                   SQLLEN *pcbValue)
 {
-    struct SQLBindParameter_params params = { hstmt, ipar, fParamType, fCType, fSqlType, cbColDef,
-                                              ibScale, rgbValue, cbValueMax, pcbValue };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = hstmt;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(hstmt %p, ipar %d, fParamType %d, fCType %d, fSqlType %d, cbColDef %s, ibScale %d, rgbValue %p,"
           " cbValueMax %s, pcbValue %p)\n", hstmt, ipar, fParamType, fCType, fSqlType, debugstr_sqlulen(cbColDef),
           ibScale, rgbValue, debugstr_sqllen(cbValueMax), pcbValue);
 
-    ret = ODBC_CALL( SQLBindParameter, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLBindParameter)
+    {
+        ret = statement->connection->pSQLBindParameter(statement->driver_stmt, ipar, fParamType,
+                                  fCType, fSqlType, cbColDef, ibScale, rgbValue, cbValueMax, pcbValue);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1771,17 +2035,13 @@ SQLRETURN WINAPI SQLDriverConnect(SQLHDBC hdbc, SQLHWND hwnd, SQLCHAR *Connectio
                                   SQLCHAR *conn_str_out, SQLSMALLINT conn_str_out_max,
                                   SQLSMALLINT *ptr_conn_str_out, SQLUSMALLINT driver_completion)
 {
-    struct SQLDriverConnect_params params = { hdbc, hwnd, ConnectionString, Length, conn_str_out,
-                                              conn_str_out_max, ptr_conn_str_out, driver_completion };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hdbc %p, hwnd %p, ConnectionString %s, Length %d, conn_str_out %p, conn_str_out_max %d,"
+    FIXME("(hdbc %p, hwnd %p, ConnectionString %s, Length %d, conn_str_out %p, conn_str_out_max %d,"
           " ptr_conn_str_out %p, driver_completion %d)\n", hdbc, hwnd,
           debugstr_an((const char *)ConnectionString, Length), Length, conn_str_out, conn_str_out_max,
           ptr_conn_str_out, driver_completion);
 
-    ret = ODBC_CALL( SQLDriverConnect, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1791,45 +2051,27 @@ SQLRETURN WINAPI SQLDriverConnect(SQLHDBC hdbc, SQLHWND hwnd, SQLCHAR *Connectio
 SQLRETURN WINAPI SQLSetScrollOptions(SQLHSTMT statement_handle, SQLUSMALLINT f_concurrency, SQLLEN crow_keyset,
                                      SQLUSMALLINT crow_rowset)
 {
-    struct SQLSetScrollOptions_params params = { statement_handle, f_concurrency, crow_keyset, crow_rowset };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(statement_handle %p, f_concurrency %d, crow_keyset %s, crow_rowset %d)\n", statement_handle,
+    FIXME("(statement_handle %p, f_concurrency %d, crow_keyset %s, crow_rowset %d)\n", statement_handle,
           f_concurrency, debugstr_sqllen(crow_keyset), crow_rowset);
 
-    ret = ODBC_CALL( SQLSetScrollOptions, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
-static BOOL SQLColAttributes_KnownStringAttribute(SQLUSMALLINT fDescType)
+static SQLINTEGER map_odbc2_to_3(SQLINTEGER fieldid)
 {
-    static const SQLUSMALLINT attrList[] =
+    switch( fieldid )
     {
-        SQL_COLUMN_OWNER_NAME,
-        SQL_COLUMN_QUALIFIER_NAME,
-        SQL_COLUMN_LABEL,
-        SQL_COLUMN_NAME,
-        SQL_COLUMN_TABLE_NAME,
-        SQL_COLUMN_TYPE_NAME,
-        SQL_DESC_BASE_COLUMN_NAME,
-        SQL_DESC_BASE_TABLE_NAME,
-        SQL_DESC_CATALOG_NAME,
-        SQL_DESC_LABEL,
-        SQL_DESC_LITERAL_PREFIX,
-        SQL_DESC_LITERAL_SUFFIX,
-        SQL_DESC_LOCAL_TYPE_NAME,
-        SQL_DESC_NAME,
-        SQL_DESC_SCHEMA_NAME,
-        SQL_DESC_TABLE_NAME,
-        SQL_DESC_TYPE_NAME,
-    };
-    unsigned int i;
-
-    for (i = 0; i < ARRAY_SIZE(attrList); i++) {
-        if (attrList[i] == fDescType) return TRUE;
+        case SQL_COLUMN_COUNT:
+            return SQL_DESC_COUNT;
+        case SQL_COLUMN_NULLABLE:
+            return SQL_DESC_NULLABLE;
+        case SQL_COLUMN_NAME:
+            return SQL_DESC_NAME;
+        default:
+            return fieldid;
     }
-    return FALSE;
 }
 
 /*************************************************************************
@@ -1839,22 +2081,32 @@ SQLRETURN WINAPI SQLColAttributesW(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLUSMALLI
                                    SQLPOINTER rgbDesc, SQLSMALLINT cbDescMax, SQLSMALLINT *pcbDesc,
                                    SQLLEN *pfDesc)
 {
-    struct SQLColAttributesW_params params = { hstmt, icol, fDescType, rgbDesc, cbDescMax, pcbDesc, pfDesc };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = hstmt;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(hstmt %p, icol %d, fDescType %d, rgbDesc %p, cbDescMax %d, pcbDesc %p, pfDesc %p)\n", hstmt, icol,
           fDescType, rgbDesc, cbDescMax, pcbDesc, pfDesc);
 
-    ret = ODBC_CALL( SQLColAttributesW, &params );
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
 
-    if (ret == SQL_SUCCESS && SQLColAttributes_KnownStringAttribute(fDescType) && rgbDesc && pcbDesc &&
-        *pcbDesc != lstrlenW(rgbDesc) * 2)
+    /* Default to ODBC 3.x */
+    if (statement->connection->pSQLColAttributeW)
+    {
+        fDescType = map_odbc2_to_3(fDescType);
+        ret = statement->connection->pSQLColAttributeW(statement->driver_stmt, icol, fDescType,
+                                   rgbDesc, cbDescMax, pcbDesc, pfDesc);
+    }
+    else if (statement->connection->pSQLColAttributesW)
     {
-        TRACE("CHEAT: resetting name length for ADO\n");
-        *pcbDesc = lstrlenW(rgbDesc) * 2;
+        ret = statement->connection->pSQLColAttributesW(statement->driver_stmt, icol, fDescType,
+                                   rgbDesc, cbDescMax, pcbDesc, pfDesc);
     }
 
-    TRACE("Returning %d\n", ret);
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1865,16 +2117,28 @@ SQLRETURN WINAPI SQLConnectW(SQLHDBC ConnectionHandle, WCHAR *ServerName, SQLSMA
                              WCHAR *UserName, SQLSMALLINT NameLength2, WCHAR *Authentication,
                              SQLSMALLINT NameLength3)
 {
-    struct SQLConnectW_params params = { ConnectionHandle, ServerName, NameLength1, UserName, NameLength2,
-                                         Authentication, NameLength3 };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(ConnectionHandle %p, ServerName %s, NameLength1 %d, UserName %s, NameLength2 %d, Authentication %s,"
-          " NameLength3 %d)\n", ConnectionHandle, debugstr_wn(ServerName, NameLength1), NameLength1,
-          debugstr_wn(UserName, NameLength2), NameLength2, debugstr_wn(Authentication, NameLength3), NameLength3);
+          " NameLength3 %d)\n", ConnectionHandle,
+          NameLength1 > 0 ? debugstr_wn(ServerName, NameLength1) : debugstr_w(ServerName), NameLength1,
+          NameLength2 > 0 ? debugstr_wn(UserName, NameLength2) : debugstr_w(UserName), NameLength2,
+          NameLength3 > 0 ? debugstr_wn(Authentication, NameLength3) : debugstr_w(Authentication), NameLength3);
+
+    if (!connection || connection->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", connection ? connection->type : 0);
+        return SQL_ERROR;
+    }
+
+    if (connection->pSQLConnectW)
+    {
+        ret = connection->pSQLConnectW(connection->driver_hdbc, ServerName, NameLength1,
+                             UserName, NameLength2, Authentication, NameLength3);
+    }
 
-    ret = ODBC_CALL( SQLConnectW, &params );
-    TRACE("Returning %d\n", ret);
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1885,10 +2149,9 @@ SQLRETURN WINAPI SQLDescribeColW(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNu
                                  SQLSMALLINT BufferLength, SQLSMALLINT *NameLength, SQLSMALLINT *DataType,
                                  SQLULEN *ColumnSize, SQLSMALLINT *DecimalDigits, SQLSMALLINT *Nullable)
 {
-    struct SQLDescribeColW_params params = { StatementHandle, ColumnNumber, ColumnName, BufferLength,
-                                             NameLength, DataType, ColumnSize, DecimalDigits, Nullable };
+    struct SQLHSTMT_data *statement = StatementHandle;
     SQLSMALLINT dummy;
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, ColumnNumber %d, ColumnName %p, BufferLength %d, NameLength %p, DataType %p,"
           " ColumnSize %p, DecimalDigits %p, Nullable %p)\n", StatementHandle, ColumnNumber, ColumnName,
@@ -1896,17 +2159,19 @@ SQLRETURN WINAPI SQLDescribeColW(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnNu
 
     if (!NameLength) NameLength = &dummy; /* workaround for drivers that don't accept NULL NameLength */
 
-    ret = ODBC_CALL( SQLDescribeColW, &params );
-    if (ret >= 0)
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLDescribeColW)
     {
-        if (ColumnName && NameLength) TRACE("ColumnName %s\n", debugstr_wn(ColumnName, *NameLength));
-        if (DataType) TRACE("DataType %d\n", *DataType);
-        if (ColumnSize) TRACE("ColumnSize %s\n", debugstr_sqlulen(*ColumnSize));
-        if (DecimalDigits) TRACE("DecimalDigits %d\n", *DecimalDigits);
-        if (Nullable) TRACE("Nullable %d\n", *Nullable);
+        ret = statement->connection->pSQLDescribeColW(statement->driver_stmt, ColumnNumber, ColumnName,
+                                 BufferLength, NameLength, DataType, ColumnSize, DecimalDigits, Nullable);
     }
 
-    TRACE("Returning %d\n", ret);
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1917,24 +2182,12 @@ SQLRETURN WINAPI SQLErrorW(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle,
                            WCHAR *Sqlstate, SQLINTEGER *NativeError, WCHAR *MessageText,
                            SQLSMALLINT BufferLength, SQLSMALLINT *TextLength)
 {
-    struct SQLErrorW_params params = { EnvironmentHandle, ConnectionHandle, StatementHandle, Sqlstate,
-                                       NativeError, MessageText, BufferLength, TextLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(EnvironmentHandle %p, ConnectionHandle %p, StatementHandle %p, Sqlstate %p, NativeError %p,"
+    FIXME("(EnvironmentHandle %p, ConnectionHandle %p, StatementHandle %p, Sqlstate %p, NativeError %p,"
           " MessageText %p, BufferLength %d, TextLength %p)\n", EnvironmentHandle, ConnectionHandle,
           StatementHandle, Sqlstate, NativeError, MessageText, BufferLength, TextLength);
 
-    ret = ODBC_CALL( SQLErrorW, &params );
-
-    if (ret == SQL_SUCCESS)
-    {
-        TRACE(" SQLState %s\n", debugstr_wn(Sqlstate, 5));
-        TRACE(" Error %d\n", *NativeError);
-        TRACE(" MessageText %s\n", debugstr_wn(MessageText, *TextLength));
-    }
-
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1943,14 +2196,25 @@ SQLRETURN WINAPI SQLErrorW(SQLHENV EnvironmentHandle, SQLHDBC ConnectionHandle,
  */
 SQLRETURN WINAPI SQLExecDirectW(SQLHSTMT StatementHandle, WCHAR *StatementText, SQLINTEGER TextLength)
 {
-    struct SQLExecDirectW_params params = { StatementHandle, StatementText, TextLength };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, StatementText %s, TextLength %d)\n", StatementHandle,
-          debugstr_wn(StatementText, TextLength), TextLength);
+          TextLength > 0 ? debugstr_wn(StatementText, TextLength) : debugstr_w(StatementText),
+          TextLength);
+
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLExecDirectW)
+    {
+        ret = statement->connection->pSQLExecDirectW(statement->driver_stmt, StatementText, TextLength);
+    }
 
-    ret = ODBC_CALL( SQLExecDirectW, &params );
-    TRACE("Returning %d\n", ret);
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1960,14 +2224,11 @@ SQLRETURN WINAPI SQLExecDirectW(SQLHSTMT StatementHandle, WCHAR *StatementText,
 SQLRETURN WINAPI SQLGetCursorNameW(SQLHSTMT StatementHandle, WCHAR *CursorName, SQLSMALLINT BufferLength,
                                    SQLSMALLINT *NameLength)
 {
-    struct SQLGetCursorNameW_params params = { StatementHandle, CursorName, BufferLength, NameLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CursorName %p, BufferLength %d, NameLength %p)\n", StatementHandle, CursorName,
+    FIXME("(StatementHandle %p, CursorName %p, BufferLength %d, NameLength %p)\n", StatementHandle, CursorName,
           BufferLength, NameLength);
 
-    ret = ODBC_CALL( SQLGetCursorNameW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -1976,14 +2237,25 @@ SQLRETURN WINAPI SQLGetCursorNameW(SQLHSTMT StatementHandle, WCHAR *CursorName,
  */
 SQLRETURN WINAPI SQLPrepareW(SQLHSTMT StatementHandle, WCHAR *StatementText, SQLINTEGER TextLength)
 {
-    struct SQLPrepareW_params params = { StatementHandle, StatementText, TextLength };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, StatementText %s, TextLength %d)\n", StatementHandle,
-          debugstr_wn(StatementText, TextLength), TextLength);
+          TextLength > 0 ? debugstr_wn(StatementText, TextLength) : debugstr_w(StatementText),
+          TextLength);
+
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLPrepareW)
+    {
+        ret = statement->connection->pSQLPrepareW(statement->driver_stmt, StatementText, TextLength);
+    }
 
-    ret = ODBC_CALL( SQLPrepareW, &params );
-    TRACE("Returning %d\n", ret);
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -1992,14 +2264,11 @@ SQLRETURN WINAPI SQLPrepareW(SQLHSTMT StatementHandle, WCHAR *StatementText, SQL
  */
 SQLRETURN WINAPI SQLSetCursorNameW(SQLHSTMT StatementHandle, WCHAR *CursorName, SQLSMALLINT NameLength)
 {
-    struct SQLSetCursorNameW_params params = { StatementHandle, CursorName, NameLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CursorName %s, NameLength %d)\n", StatementHandle,
+    FIXME("(StatementHandle %p, CursorName %s, NameLength %d)\n", StatementHandle,
           debugstr_wn(CursorName, NameLength), NameLength);
 
-    ret = ODBC_CALL( SQLSetCursorNameW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2011,25 +2280,26 @@ SQLRETURN WINAPI SQLColAttributeW(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnN
                                   SQLSMALLINT BufferLength, SQLSMALLINT *StringLength,
                                   SQLLEN *NumericAttribute)
 {
-    struct SQLColAttributeW_params params = { StatementHandle, ColumnNumber, FieldIdentifier,
-                                              CharacterAttribute, BufferLength, StringLength,
-                                              NumericAttribute };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("StatementHandle %p ColumnNumber %d FieldIdentifier %d CharacterAttribute %p BufferLength %d"
           " StringLength %p NumericAttribute %p\n", StatementHandle, ColumnNumber, FieldIdentifier,
           CharacterAttribute, BufferLength, StringLength, NumericAttribute);
 
-    ret = ODBC_CALL( SQLColAttributeW, &params );
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
 
-    if (ret == SQL_SUCCESS && CharacterAttribute != NULL && SQLColAttributes_KnownStringAttribute(FieldIdentifier) &&
-        StringLength && *StringLength != lstrlenW(CharacterAttribute) * 2)
+    if (statement->connection->pSQLColAttributeW)
     {
-        TRACE("CHEAT: resetting name length for ADO\n");
-        *StringLength = lstrlenW(CharacterAttribute) * 2;
+        ret = statement->connection->pSQLColAttributeW(statement->driver_stmt, ColumnNumber, FieldIdentifier,
+                                 CharacterAttribute, BufferLength, StringLength, NumericAttribute);
     }
 
-    TRACE("Returning %d\n", ret);
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -2039,15 +2309,26 @@ SQLRETURN WINAPI SQLColAttributeW(SQLHSTMT StatementHandle, SQLUSMALLINT ColumnN
 SQLRETURN WINAPI SQLGetConnectAttrW(SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                     SQLINTEGER BufferLength, SQLINTEGER *StringLength)
 {
-    struct SQLGetConnectAttrW_params params = { ConnectionHandle, Attribute, Value,
-                                                BufferLength, StringLength };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(ConnectionHandle %p, Attribute %d, Value %p, BufferLength %d, StringLength %p)\n", ConnectionHandle,
           Attribute, Value, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetConnectAttrW, &params );
-    TRACE("Returning %d\n", ret);
+    if (connection->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", connection->type);
+        return SQL_ERROR;
+    }
+
+    if (connection->pSQLGetConnectAttrW)
+    {
+        ret = connection->pSQLGetConnectAttrW(connection->driver_hdbc, Attribute, Value,
+                                    BufferLength, StringLength);
+    }
+
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -2057,15 +2338,11 @@ SQLRETURN WINAPI SQLGetConnectAttrW(SQLHDBC ConnectionHandle, SQLINTEGER Attribu
 SQLRETURN WINAPI SQLGetDescFieldW(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier,
                                   SQLPOINTER Value, SQLINTEGER BufferLength, SQLINTEGER *StringLength)
 {
-    struct SQLGetDescFieldW_params params = { DescriptorHandle, RecNumber, FieldIdentifier, Value,
-                                              BufferLength, StringLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(DescriptorHandle %p, RecNumber %d, FieldIdentifier %d, Value %p, BufferLength %d, StringLength %p)\n",
+    FIXME("(DescriptorHandle %p, RecNumber %d, FieldIdentifier %d, Value %p, BufferLength %d, StringLength %p)\n",
           DescriptorHandle, RecNumber, FieldIdentifier, Value, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetDescFieldW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2077,16 +2354,12 @@ SQLRETURN WINAPI SQLGetDescRecW(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber
                                 SQLSMALLINT *SubType, SQLLEN *Length, SQLSMALLINT *Precision,
                                 SQLSMALLINT *Scale, SQLSMALLINT *Nullable)
 {
-    struct SQLGetDescRecW_params params = { DescriptorHandle, RecNumber, Name, BufferLength, StringLength,
-                                            Type, SubType, Length, Precision, Scale, Nullable };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(DescriptorHandle %p, RecNumber %d, Name %p, BufferLength %d, StringLength %p, Type %p, SubType %p,"
+    FIXME("(DescriptorHandle %p, RecNumber %d, Name %p, BufferLength %d, StringLength %p, Type %p, SubType %p,"
           " Length %p, Precision %p, Scale %p, Nullable %p)\n", DescriptorHandle, RecNumber, Name, BufferLength,
           StringLength, Type, SubType, Length, Precision, Scale, Nullable);
 
-    ret = ODBC_CALL( SQLGetDescRecW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2097,15 +2370,33 @@ SQLRETURN WINAPI SQLGetDiagFieldW(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLS
                                   SQLSMALLINT DiagIdentifier, SQLPOINTER DiagInfo, SQLSMALLINT BufferLength,
                                   SQLSMALLINT *StringLength)
 {
-    struct SQLGetDiagFieldW_params params = { HandleType, Handle, RecNumber, DiagIdentifier, DiagInfo,
-                                              BufferLength, StringLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(HandleType %d, Handle %p, RecNumber %d, DiagIdentifier %d, DiagInfo %p, BufferLength %d,"
           " StringLength %p)\n", HandleType, Handle, RecNumber, DiagIdentifier, DiagInfo, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetDiagFieldW, &params );
-    TRACE("Returning %d\n", ret);
+    if (HandleType == SQL_HANDLE_ENV)
+    {
+        FIXME("Unhandled SQL_HANDLE_ENV records\n");
+    }
+    else if (HandleType == SQL_HANDLE_DBC)
+    {
+        struct SQLHDBC_data *hdbc = Handle;
+
+        if (hdbc->pSQLGetDiagFieldW)
+            ret = hdbc->pSQLGetDiagFieldW(HandleType, hdbc->driver_hdbc, RecNumber, DiagIdentifier,
+                                     DiagInfo, BufferLength, StringLength);
+    }
+    else if (HandleType == SQL_HANDLE_STMT)
+    {
+        struct SQLHSTMT_data *statement = Handle;
+
+        if (statement->connection->pSQLGetDiagFieldW)
+            ret = statement->connection->pSQLGetDiagFieldW(HandleType, statement->driver_stmt, RecNumber,
+                                     DiagIdentifier, DiagInfo, BufferLength, StringLength);
+    }
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -2116,16 +2407,38 @@ SQLRETURN WINAPI SQLGetDiagRecW(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMA
                                 WCHAR *Sqlstate, SQLINTEGER *NativeError, WCHAR *MessageText,
                                 SQLSMALLINT BufferLength, SQLSMALLINT *TextLength)
 {
-    struct SQLGetDiagRecW_params params = { HandleType, Handle, RecNumber, Sqlstate, NativeError,
-                                            MessageText, BufferLength, TextLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(HandleType %d, Handle %p, RecNumber %d, Sqlstate %p, NativeError %p, MessageText %p, BufferLength %d,"
           " TextLength %p)\n", HandleType, Handle, RecNumber, Sqlstate, NativeError, MessageText, BufferLength,
           TextLength);
 
-    ret = ODBC_CALL( SQLGetDiagRecW, &params );
-    TRACE("Returning %d\n", ret);
+    if (HandleType == SQL_HANDLE_ENV)
+    {
+        FIXME("Unhandled SQL_HANDLE_ENV records\n");
+    }
+    else if (HandleType == SQL_HANDLE_DBC)
+    {
+        struct SQLHDBC_data *hdbc = Handle;
+
+        if (hdbc->pSQLGetDiagRecW)
+            ret = hdbc->pSQLGetDiagRecW(HandleType, hdbc->driver_hdbc, RecNumber, Sqlstate,
+                                NativeError, MessageText, BufferLength, TextLength);
+    }
+    else if (HandleType == SQL_HANDLE_STMT)
+    {
+        struct SQLHSTMT_data *statement = Handle;
+
+        if (statement->connection->pSQLGetDiagRecW)
+            ret = statement->connection->pSQLGetDiagRecW(HandleType, statement->driver_stmt, RecNumber,
+                                Sqlstate, NativeError, MessageText, BufferLength, TextLength);
+    }
+
+    if (ret != SQL_ERROR)
+    {
+        TRACE("%d: %s %s\n", RecNumber, debugstr_w(Sqlstate), debugstr_w(MessageText));
+    }
+
     return ret;
 }
 
@@ -2135,20 +2448,63 @@ SQLRETURN WINAPI SQLGetDiagRecW(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMA
 SQLRETURN WINAPI SQLGetStmtAttrW(SQLHSTMT StatementHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                  SQLINTEGER BufferLength, SQLINTEGER *StringLength)
 {
-    struct SQLGetStmtAttrW_params params = { StatementHandle, Attribute, Value, BufferLength, StringLength };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, Attribute %d, Value %p, BufferLength %d, StringLength %p)\n", StatementHandle,
           Attribute, Value, BufferLength, StringLength);
 
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
     if (!Value)
     {
         WARN("Unexpected NULL Value return address\n");
         return SQL_ERROR;
     }
 
-    ret = ODBC_CALL( SQLGetStmtAttrW, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->connection->pSQLGetStmtAttrW)
+    {
+        switch(Attribute)
+        {
+            case SQL_ATTR_APP_ROW_DESC:
+                statement->app_row_desc.parent = statement;
+                ret = statement->connection->pSQLGetStmtAttrW(statement->driver_stmt, Attribute,
+                                                             &statement->app_row_desc.driver_hdesc,
+                                                             BufferLength, StringLength);
+                *((SQLHDESC*)Value) = &statement->app_row_desc;
+                break;
+            case SQL_ATTR_IMP_ROW_DESC:
+                statement->imp_row_desc.parent = statement;
+                ret = statement->connection->pSQLGetStmtAttrW(statement->driver_stmt, Attribute,
+                                                             &statement->imp_row_desc.driver_hdesc,
+                                                             BufferLength, StringLength);
+                *((SQLHDESC*)Value) = &statement->imp_row_desc;
+                break;
+            case SQL_ATTR_APP_PARAM_DESC:
+                statement->app_param_desc.parent = statement;
+                ret = statement->connection->pSQLGetStmtAttrW(statement->driver_stmt, Attribute,
+                                                             &statement->app_param_desc.driver_hdesc,
+                                                             BufferLength, StringLength);
+                *((SQLHDESC*)Value) = &statement->app_param_desc;
+                break;
+            case SQL_ATTR_IMP_PARAM_DESC:
+                statement->imp_param_desc.parent = statement;
+                ret = statement->connection->pSQLGetStmtAttrW(statement->driver_stmt, Attribute,
+                                                             &statement->imp_param_desc.driver_hdesc,
+                                                             BufferLength, StringLength);
+                *((SQLHDESC*)Value) = &statement->imp_param_desc;
+                break;
+            default:
+                ret = statement->connection->pSQLGetStmtAttrW(statement->driver_stmt, Attribute, Value,
+                                BufferLength, StringLength);
+        }
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -2158,14 +2514,38 @@ SQLRETURN WINAPI SQLGetStmtAttrW(SQLHSTMT StatementHandle, SQLINTEGER Attribute,
 SQLRETURN WINAPI SQLSetConnectAttrW(SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                     SQLINTEGER StringLength)
 {
-    struct SQLSetConnectAttrW_params params = { ConnectionHandle, Attribute, Value, StringLength };
-    SQLRETURN ret;
+    struct SQLHDBC_data *hdbc = ConnectionHandle;
+    SQLRETURN ret = SQL_SUCCESS;
 
     TRACE("(ConnectionHandle %p, Attribute %d, Value %p, StringLength %d)\n", ConnectionHandle, Attribute, Value,
           StringLength);
 
-    ret = ODBC_CALL( SQLSetConnectAttrW, &params );
-    TRACE("Returning %d\n", ret);
+    if (hdbc->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", hdbc->type);
+        return SQL_ERROR;
+    }
+
+    switch(Attribute)
+    {
+        case SQL_ATTR_LOGIN_TIMEOUT:
+            if (Value)
+                hdbc->login_timeout = (intptr_t)Value;
+            else
+                hdbc->login_timeout = 0;
+            break;
+        default:
+            if (hdbc->pSQLSetConnectAttrW)
+                ret = hdbc->pSQLSetConnectAttrW(hdbc->driver_hdbc, Attribute, Value, StringLength);
+            else
+            {
+                FIXME("Unsupported Attribute %d\n", Attribute);
+                ret = SQL_ERROR;
+            }
+    }
+
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -2176,20 +2556,73 @@ SQLRETURN WINAPI SQLColumnsW(SQLHSTMT StatementHandle, WCHAR *CatalogName, SQLSM
                              WCHAR *SchemaName, SQLSMALLINT NameLength2, WCHAR *TableName,
                              SQLSMALLINT NameLength3, WCHAR *ColumnName, SQLSMALLINT NameLength4)
 {
-    struct SQLColumnsW_params params = { StatementHandle, CatalogName, NameLength1, SchemaName,
-                                         NameLength2, TableName, NameLength3, ColumnName, NameLength4 };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d, TableName %s,"
+    FIXME("(StatementHandle %p, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d, TableName %s,"
           " NameLength3 %d, ColumnName %s, NameLength4 %d)\n", StatementHandle,
           debugstr_wn(CatalogName, NameLength1), NameLength1, debugstr_wn(SchemaName, NameLength2), NameLength2,
           debugstr_wn(TableName, NameLength3), NameLength3, debugstr_wn(ColumnName, NameLength4), NameLength4);
 
-    ret = ODBC_CALL( SQLColumnsW, &params );
-    TRACE("Returning %d\n", ret);
+    FIXME("Returning %d\n", ret);
     return ret;
 }
 
+static HMODULE load_odbc_driver(const WCHAR *driver)
+{
+    long ret;
+    HMODULE hmod;
+    WCHAR *filename = NULL;
+    HKEY hkey;
+    WCHAR regpath[256];
+
+    wcscpy(regpath, L"Software\\ODBC\\ODBC.INI\\");
+    wcscat(regpath, driver);
+
+    if ((ret = RegOpenKeyW(HKEY_CURRENT_USER, regpath, &hkey)) != ERROR_SUCCESS)
+    {
+        ret = RegOpenKeyW(HKEY_LOCAL_MACHINE, regpath, &hkey);
+    }
+
+    if (ret == ERROR_SUCCESS)
+    {
+        DWORD size = 0, type;
+        ret = RegGetValueW(hkey, NULL, L"Driver", RRF_RT_REG_SZ, &type, NULL, &size);
+        if(ret != ERROR_SUCCESS || type != REG_SZ)
+        {
+            RegCloseKey(hkey);
+            WARN("Invalid DSN %s\n", debugstr_w(driver));
+
+            return NULL;
+        }
+
+        filename = malloc(size);
+        if(!filename)
+        {
+            RegCloseKey(hkey);
+            ERR("Out of memory\n");
+
+            return NULL;
+        }
+        ret = RegGetValueW(hkey, NULL, L"Driver", RRF_RT_REG_SZ, &type, filename, &size);
+
+        RegCloseKey(hkey);
+    }
+
+    if(ret != ERROR_SUCCESS)
+    {
+        free(filename);
+        ERR("Failed to open Registry Key\n");
+        return NULL;
+    }
+
+    hmod = LoadLibraryExW(filename, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
+    free(filename);
+
+    if(!hmod)
+        ERR("Failed to load driver\n");
+
+    return hmod;
+}
 /*************************************************************************
  *				SQLDriverConnectW          [ODBC32.141]
  */
@@ -2197,17 +2630,54 @@ SQLRETURN WINAPI SQLDriverConnectW(SQLHDBC ConnectionHandle, SQLHWND WindowHandl
                                    SQLSMALLINT Length, WCHAR *OutConnectionString, SQLSMALLINT BufferLength,
                                    SQLSMALLINT *Length2, SQLUSMALLINT DriverCompletion)
 {
-    struct SQLDriverConnectW_params params = { ConnectionHandle, WindowHandle, InConnectionString, Length,
-                                               OutConnectionString, BufferLength, Length2, DriverCompletion };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    HMODULE driver;
+    SQLRETURN ret = SQL_ERROR;
+    WCHAR dsn[128];
+    WCHAR *p;
 
     TRACE("(ConnectionHandle %p, WindowHandle %p, InConnectionString %s, Length %d, OutConnectionString %p,"
           " BufferLength %d, Length2 %p, DriverCompletion %d)\n", ConnectionHandle, WindowHandle,
           debugstr_wn(InConnectionString, Length), Length, OutConnectionString, BufferLength, Length2,
           DriverCompletion);
 
-    ret = ODBC_CALL( SQLDriverConnectW, &params );
-    TRACE("Returning %d\n", ret);
+    p = wcsstr(InConnectionString, L"DSN=");
+    if (p)
+    {
+        WCHAR *end = wcsstr(p, L";");
+
+        lstrcpynW(dsn, p+4, end - (p + 3));
+    }
+
+    driver = load_odbc_driver(dsn);
+    if (!driver)
+        return SQL_ERROR;
+
+    connection->module = driver;
+    connection_bind_sql_funcs(connection);
+
+    if (connection->pSQLAllocHandle)
+    {
+        connection->pSQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &connection->driver_env);
+
+        if (connection->pSQLSetEnvAttr)
+            connection->pSQLSetEnvAttr(connection->driver_env, SQL_ATTR_ODBC_VERSION,
+                                        (SQLPOINTER)connection->environment->version, 0);
+
+        connection->pSQLAllocHandle(SQL_HANDLE_DBC, connection->driver_env, &connection->driver_hdbc);
+    }
+
+    if(!connection->pSQLDriverConnectW)
+    {
+        ERR("Failed to find pSQLDriverConnectW\n");
+        return SQL_ERROR;
+    }
+
+    ret = connection->pSQLDriverConnectW(connection->driver_hdbc, WindowHandle, InConnectionString, Length,
+                OutConnectionString, BufferLength, Length2, DriverCompletion);
+
+    TRACE("Driver returned %d\n", ret);
+
     return ret;
 }
 
@@ -2216,13 +2686,10 @@ SQLRETURN WINAPI SQLDriverConnectW(SQLHDBC ConnectionHandle, SQLHWND WindowHandl
  */
 SQLRETURN WINAPI SQLGetConnectOptionW(SQLHDBC ConnectionHandle, SQLUSMALLINT Option, SQLPOINTER Value)
 {
-    struct SQLGetConnectOptionW_params params = { ConnectionHandle, Option, Value };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(ConnectionHandle %p, Option %d, Value %p)\n", ConnectionHandle, Option, Value);
+    FIXME("(ConnectionHandle %p, Option %d, Value %p)\n", ConnectionHandle, Option, Value);
 
-    ret = ODBC_CALL( SQLGetConnectOptionW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2232,14 +2699,33 @@ SQLRETURN WINAPI SQLGetConnectOptionW(SQLHDBC ConnectionHandle, SQLUSMALLINT Opt
 SQLRETURN WINAPI SQLGetInfoW(SQLHDBC ConnectionHandle, SQLUSMALLINT InfoType, SQLPOINTER InfoValue,
                              SQLSMALLINT BufferLength, SQLSMALLINT *StringLength)
 {
-    struct SQLGetInfoW_params params = { ConnectionHandle, InfoType, InfoValue, BufferLength, StringLength };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = ConnectionHandle;
+    WCHAR *ptr = InfoValue;
+    SQLRETURN ret = SQL_SUCCESS;
 
     TRACE("(ConnectionHandle, %p, InfoType %d, InfoValue %p, BufferLength %d, StringLength %p)\n", ConnectionHandle,
           InfoType, InfoValue, BufferLength, StringLength);
 
-    ret = ODBC_CALL( SQLGetInfoW, &params );
-    TRACE("Returning %d\n", ret);
+    switch(InfoType)
+    {
+        case SQL_ODBC_VER:
+            lstrcpynW(ptr, L"03.80.0000", BufferLength);
+            if (StringLength)
+                *StringLength = wcslen(ptr);
+            break;
+        default:
+            if (connection->pSQLGetInfoW)
+                ret = connection->pSQLGetInfoW(connection->driver_hdbc, InfoType, InfoValue,
+                             BufferLength, StringLength);
+            else
+            {
+                FIXME("Unsupported type %d\n", InfoType);
+                ret = SQL_ERROR;
+            }
+    }
+
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -2248,13 +2734,23 @@ SQLRETURN WINAPI SQLGetInfoW(SQLHDBC ConnectionHandle, SQLUSMALLINT InfoType, SQ
  */
 SQLRETURN WINAPI SQLGetTypeInfoW(SQLHSTMT StatementHandle, SQLSMALLINT DataType)
 {
-    struct SQLGetTypeInfoW_params params = { StatementHandle, DataType };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, DataType %d)\n", StatementHandle, DataType);
 
-    ret = ODBC_CALL( SQLGetTypeInfoW, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLGetTypeInfoW)
+    {
+        ret = statement->connection->pSQLGetTypeInfoW(statement->driver_stmt, DataType);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -2263,13 +2759,10 @@ SQLRETURN WINAPI SQLGetTypeInfoW(SQLHSTMT StatementHandle, SQLSMALLINT DataType)
  */
 SQLRETURN WINAPI SQLSetConnectOptionW(SQLHDBC ConnectionHandle, SQLUSMALLINT Option, SQLLEN Value)
 {
-    struct SQLSetConnectOptionW_params params = { ConnectionHandle, Option, Value };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(ConnectionHandle %p, Option %d, Value %s)\n", ConnectionHandle, Option, debugstr_sqllen(Value));
+    FIXME("(ConnectionHandle %p, Option %d, Value %s)\n", ConnectionHandle, Option, debugstr_sqllen(Value));
 
-    ret = ODBC_CALL( SQLSetConnectOptionW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2281,17 +2774,13 @@ SQLRETURN WINAPI SQLSpecialColumnsW(SQLHSTMT StatementHandle, SQLUSMALLINT Ident
                                     SQLSMALLINT NameLength2, SQLWCHAR *TableName, SQLSMALLINT NameLength3,
                                     SQLUSMALLINT Scope, SQLUSMALLINT Nullable)
 {
-    struct SQLSpecialColumnsW_params params = { StatementHandle, IdentifierType, CatalogName, NameLength1,
-                                                SchemaName, NameLength2, TableName, NameLength3, Scope, Nullable };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, IdentifierType %d, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d,"
+    FIXME("(StatementHandle %p, IdentifierType %d, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d,"
           " TableName %s, NameLength3 %d, Scope %d, Nullable %d)\n", StatementHandle, IdentifierType,
           debugstr_wn(CatalogName, NameLength1), NameLength1, debugstr_wn(SchemaName, NameLength2), NameLength2,
           debugstr_wn(TableName, NameLength3), NameLength3, Scope, Nullable);
 
-    ret = ODBC_CALL( SQLSpecialColumnsW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2302,17 +2791,30 @@ SQLRETURN WINAPI SQLStatisticsW(SQLHSTMT StatementHandle, SQLWCHAR *CatalogName,
                                 SQLWCHAR *SchemaName, SQLSMALLINT NameLength2, SQLWCHAR *TableName,
                                 SQLSMALLINT NameLength3, SQLUSMALLINT Unique, SQLUSMALLINT Reserved)
 {
-    struct SQLStatisticsW_params params = { StatementHandle, CatalogName, NameLength1, SchemaName,
-                                            NameLength2, TableName, NameLength3, Unique, Reserved };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, CatalogName %s, NameLength1 %d SchemaName %s, NameLength2 %d, TableName %s"
           " NameLength3 %d, Unique %d, Reserved %d)\n", StatementHandle,
           debugstr_wn(CatalogName, NameLength1), NameLength1, debugstr_wn(SchemaName, NameLength2), NameLength2,
           debugstr_wn(TableName, NameLength3), NameLength3, Unique, Reserved);
 
-    ret = ODBC_CALL( SQLStatisticsW, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLStatisticsW)
+    {
+        ret = statement->connection->pSQLStatisticsW(statement->driver_stmt, CatalogName,
+                                NameLength1, SchemaName, NameLength2, TableName, NameLength3,
+                                Unique, Reserved);
+    }
+
+    TRACE("ret %d\n", ret);
+    return ret;
+
     return ret;
 }
 
@@ -2323,17 +2825,13 @@ SQLRETURN WINAPI SQLTablesW(SQLHSTMT StatementHandle, SQLWCHAR *CatalogName, SQL
                             SQLWCHAR *SchemaName, SQLSMALLINT NameLength2, SQLWCHAR *TableName,
                             SQLSMALLINT NameLength3, SQLWCHAR *TableType, SQLSMALLINT NameLength4)
 {
-    struct SQLTablesW_params params = { StatementHandle, CatalogName, NameLength1, SchemaName, NameLength2,
-                                        TableName, NameLength3, TableType, NameLength4 };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(StatementHandle %p, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d, TableName %s,"
+    FIXME("(StatementHandle %p, CatalogName %s, NameLength1 %d, SchemaName %s, NameLength2 %d, TableName %s,"
           " NameLength3 %d, TableType %s, NameLength4 %d)\n", StatementHandle,
           debugstr_wn(CatalogName, NameLength1), NameLength1, debugstr_wn(SchemaName, NameLength2), NameLength2,
           debugstr_wn(TableName, NameLength3), NameLength3, debugstr_wn(TableType, NameLength4), NameLength4);
 
-    ret = ODBC_CALL( SQLTablesW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2344,15 +2842,11 @@ SQLRETURN WINAPI SQLBrowseConnectW(SQLHDBC hdbc, SQLWCHAR *szConnStrIn, SQLSMALL
                                    SQLWCHAR *szConnStrOut, SQLSMALLINT cbConnStrOutMax,
                                    SQLSMALLINT *pcbConnStrOut)
 {
-    struct SQLBrowseConnectW_params params = { hdbc, szConnStrIn, cbConnStrIn, szConnStrOut,
-                                               cbConnStrOutMax, pcbConnStrOut };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hdbc %p, szConnStrIn %s, cbConnStrIn %d, szConnStrOut %p, cbConnStrOutMax %d, pcbConnStrOut %p)\n",
+    FIXME("(hdbc %p, szConnStrIn %s, cbConnStrIn %d, szConnStrOut %p, cbConnStrOutMax %d, pcbConnStrOut %p)\n",
           hdbc, debugstr_wn(szConnStrIn, cbConnStrIn), cbConnStrIn, szConnStrOut, cbConnStrOutMax, pcbConnStrOut);
 
-    ret = ODBC_CALL( SQLBrowseConnectW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2363,20 +2857,15 @@ SQLRETURN WINAPI SQLColumnPrivilegesW(SQLHSTMT hstmt, SQLWCHAR *szCatalogName, S
                                       SQLWCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR *szTableName,
                                       SQLSMALLINT cbTableName, SQLWCHAR *szColumnName, SQLSMALLINT cbColumnName)
 {
-    struct SQLColumnPrivilegesW_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                                  cbSchemaName, szTableName, cbTableName, szColumnName,
-                                                  cbColumnName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
           " cbTableName %d, szColumnName %s, cbColumnName %d)\n", hstmt,
           debugstr_wn(szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_wn(szSchemaName, cbSchemaName), cbSchemaName,
           debugstr_wn(szTableName, cbTableName), cbTableName,
           debugstr_wn(szColumnName, cbColumnName), cbColumnName);
 
-    ret = ODBC_CALL( SQLColumnPrivilegesW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2387,26 +2876,12 @@ SQLRETURN WINAPI SQLDataSourcesW(SQLHENV EnvironmentHandle, SQLUSMALLINT Directi
                                  SQLSMALLINT BufferLength1, SQLSMALLINT *NameLength1, WCHAR *Description,
                                  SQLSMALLINT BufferLength2, SQLSMALLINT *NameLength2)
 {
-    struct SQLDataSourcesW_params params = { EnvironmentHandle, Direction, ServerName, BufferLength1,
-                                             NameLength1, Description, BufferLength2, NameLength2 };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(EnvironmentHandle %p, Direction %d, ServerName %p, BufferLength1 %d, NameLength1 %p, Description %p,"
+    FIXME("(EnvironmentHandle %p, Direction %d, ServerName %p, BufferLength1 %d, NameLength1 %p, Description %p,"
           " BufferLength2 %d, NameLength2 %p)\n", EnvironmentHandle, Direction, ServerName, BufferLength1,
           NameLength1, Description, BufferLength2, NameLength2);
 
-    ret = ODBC_CALL( SQLDataSourcesW, &params );
-
-    if (ret >= 0 && TRACE_ON(odbc))
-    {
-        if (ServerName && NameLength1 && *NameLength1 > 0)
-            TRACE(" DataSource %s", debugstr_wn(ServerName, *NameLength1));
-        if (Description && NameLength2 && *NameLength2 > 0)
-            TRACE(" Description %s", debugstr_wn(Description, *NameLength2));
-        TRACE("\n");
-    }
-
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2419,13 +2894,9 @@ SQLRETURN WINAPI SQLForeignKeysW(SQLHSTMT hstmt, SQLWCHAR *szPkCatalogName, SQLS
                                  SQLSMALLINT cbFkCatalogName, SQLWCHAR *szFkSchemaName,
                                  SQLSMALLINT cbFkSchemaName, SQLWCHAR *szFkTableName, SQLSMALLINT cbFkTableName)
 {
-    struct SQLForeignKeysW_params params = { hstmt, szPkCatalogName, cbPkCatalogName, szPkSchemaName,
-                                             cbPkSchemaName, szPkTableName, cbPkTableName, szFkCatalogName,
-                                             cbFkCatalogName, szFkSchemaName, cbFkSchemaName, szFkTableName,
-                                             cbFkTableName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szPkCatalogName %s, cbPkCatalogName %d, szPkSchemaName %s, cbPkSchemaName %d,"
+    FIXME("(hstmt %p, szPkCatalogName %s, cbPkCatalogName %d, szPkSchemaName %s, cbPkSchemaName %d,"
           " szPkTableName %s, cbPkTableName %d, szFkCatalogName %s, cbFkCatalogName %d, szFkSchemaName %s,"
           " cbFkSchemaName %d, szFkTableName %s, cbFkTableName %d)\n", hstmt,
           debugstr_wn(szPkCatalogName, cbPkCatalogName), cbPkCatalogName,
@@ -2435,8 +2906,6 @@ SQLRETURN WINAPI SQLForeignKeysW(SQLHSTMT hstmt, SQLWCHAR *szPkCatalogName, SQLS
           debugstr_wn(szFkSchemaName, cbFkSchemaName), cbFkSchemaName,
           debugstr_wn(szFkTableName, cbFkTableName), cbFkTableName);
 
-    ret = ODBC_CALL( SQLForeignKeysW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2446,14 +2915,25 @@ SQLRETURN WINAPI SQLForeignKeysW(SQLHSTMT hstmt, SQLWCHAR *szPkCatalogName, SQLS
 SQLRETURN WINAPI SQLNativeSqlW(SQLHDBC hdbc, SQLWCHAR *szSqlStrIn, SQLINTEGER cbSqlStrIn, SQLWCHAR *szSqlStr,
                                SQLINTEGER cbSqlStrMax, SQLINTEGER *pcbSqlStr)
 {
-    struct SQLNativeSqlW_params params = { hdbc, szSqlStrIn, cbSqlStrIn, szSqlStr, cbSqlStrMax, pcbSqlStr };
-    SQLRETURN ret;
+    struct SQLHDBC_data *connection = hdbc;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(hdbc %p, szSqlStrIn %s, cbSqlStrIn %d, szSqlStr %p, cbSqlStrMax %d, pcbSqlStr %p)\n", hdbc,
           debugstr_wn(szSqlStrIn, cbSqlStrIn), cbSqlStrIn, szSqlStr, cbSqlStrMax, pcbSqlStr);
 
-    ret = ODBC_CALL( SQLNativeSqlW, &params );
-    TRACE("Returning %d\n", ret);
+    if (connection->type != SQL_HANDLE_DBC)
+    {
+        WARN("Wrong handle type %d\n", connection->type);
+        return SQL_ERROR;
+    }
+
+    if (connection->pSQLNativeSqlW)
+    {
+        ret = connection->pSQLNativeSqlW(connection->driver_hdbc, szSqlStrIn, cbSqlStrIn,
+                               szSqlStr, cbSqlStrMax, pcbSqlStr);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -2464,9 +2944,8 @@ SQLRETURN WINAPI SQLPrimaryKeysW(SQLHSTMT hstmt, SQLWCHAR *szCatalogName, SQLSMA
                                  SQLWCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR *szTableName,
                                  SQLSMALLINT cbTableName)
 {
-    struct SQLPrimaryKeysW_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                             cbSchemaName, szTableName, cbTableName };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = hstmt;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
           " cbTableName %d)\n", hstmt,
@@ -2474,8 +2953,19 @@ SQLRETURN WINAPI SQLPrimaryKeysW(SQLHSTMT hstmt, SQLWCHAR *szCatalogName, SQLSMA
           debugstr_wn(szSchemaName, cbSchemaName), cbSchemaName,
           debugstr_wn(szTableName, cbTableName), cbTableName);
 
-    ret = ODBC_CALL( SQLPrimaryKeysW, &params );
-    TRACE("Returning %d\n", ret);
+    if (statement->type != SQL_HANDLE_STMT)
+    {
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLPrimaryKeysW)
+    {
+        ret = statement->connection->pSQLPrimaryKeysW(statement->driver_stmt, szCatalogName,
+                    cbCatalogName, szSchemaName, cbSchemaName, szTableName, cbTableName);
+    }
+
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -2486,20 +2976,15 @@ SQLRETURN WINAPI SQLProcedureColumnsW(SQLHSTMT hstmt, SQLWCHAR *szCatalogName, S
                                       SQLWCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR *szProcName,
                                       SQLSMALLINT cbProcName, SQLWCHAR *szColumnName, SQLSMALLINT cbColumnName)
 {
-    struct SQLProcedureColumnsW_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                                  cbSchemaName, szProcName, cbProcName,
-                                                  szColumnName, cbColumnName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szProcName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szProcName %s,"
           " cbProcName %d, szColumnName %s, cbColumnName %d)\n", hstmt,
           debugstr_wn(szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_wn(szSchemaName, cbSchemaName), cbSchemaName,
           debugstr_wn(szProcName, cbProcName), cbProcName,
           debugstr_wn(szColumnName, cbColumnName), cbColumnName);
 
-    ret = ODBC_CALL( SQLProcedureColumnsW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2510,16 +2995,12 @@ SQLRETURN WINAPI SQLProceduresW(SQLHSTMT hstmt, SQLWCHAR *szCatalogName, SQLSMAL
                                 SQLWCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR *szProcName,
                                 SQLSMALLINT cbProcName)
 {
-    struct SQLProceduresW_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                            cbSchemaName, szProcName, cbProcName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szProcName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szProcName %s,"
           " cbProcName %d)\n", hstmt, debugstr_wn(szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_wn(szSchemaName, cbSchemaName), cbSchemaName, debugstr_wn(szProcName, cbProcName), cbProcName);
 
-    ret = ODBC_CALL( SQLProceduresW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2530,16 +3011,12 @@ SQLRETURN WINAPI SQLTablePrivilegesW(SQLHSTMT hstmt, SQLWCHAR *szCatalogName, SQ
                                      SQLWCHAR *szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR *szTableName,
                                      SQLSMALLINT cbTableName)
 {
-    struct SQLTablePrivilegesW_params params = { hstmt, szCatalogName, cbCatalogName, szSchemaName,
-                                                 cbSchemaName, szTableName, cbTableName };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
+    FIXME("(hstmt %p, szCatalogName %s, cbCatalogName %d, szSchemaName %s, cbSchemaName %d, szTableName %s,"
           " cbTableName %d)\n", hstmt, debugstr_wn(szCatalogName, cbCatalogName), cbCatalogName,
           debugstr_wn(szSchemaName, cbSchemaName), cbSchemaName, debugstr_wn(szTableName, cbTableName), cbTableName);
 
-    ret = ODBC_CALL( SQLTablePrivilegesW, &params );
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2551,20 +3028,12 @@ SQLRETURN WINAPI SQLDriversW(SQLHENV EnvironmentHandle, SQLUSMALLINT fDirection,
                              SQLWCHAR *szDriverAttributes, SQLSMALLINT cbDriverAttrMax,
                              SQLSMALLINT *pcbDriverAttr)
 {
-    struct SQLDriversW_params params = { EnvironmentHandle, fDirection, szDriverDesc, cbDriverDescMax,
-                                         pcbDriverDesc, szDriverAttributes, cbDriverAttrMax, pcbDriverAttr };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
-    TRACE("(EnvironmentHandle %p, Direction %d, szDriverDesc %p, cbDriverDescMax %d, pcbDriverDesc %p,"
+    FIXME("(EnvironmentHandle %p, Direction %d, szDriverDesc %p, cbDriverDescMax %d, pcbDriverDesc %p,"
           " DriverAttributes %p, cbDriverAttrMax %d, pcbDriverAttr %p)\n", EnvironmentHandle, fDirection,
           szDriverDesc, cbDriverDescMax, pcbDriverDesc, szDriverAttributes, cbDriverAttrMax, pcbDriverAttr);
 
-    ret = ODBC_CALL( SQLDriversW, &params );
-
-    if (ret == SQL_NO_DATA && fDirection == SQL_FETCH_FIRST)
-        ERR_(winediag)("No ODBC drivers could be found. Check the settings for your libodbc provider.\n");
-
-    TRACE("Returning %d\n", ret);
     return ret;
 }
 
@@ -2574,14 +3043,17 @@ SQLRETURN WINAPI SQLDriversW(SQLHENV EnvironmentHandle, SQLUSMALLINT fDirection,
 SQLRETURN WINAPI SQLSetDescFieldW(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier,
                                   SQLPOINTER Value, SQLINTEGER BufferLength)
 {
-    struct SQLSetDescFieldW_params params = { DescriptorHandle, RecNumber, FieldIdentifier, Value, BufferLength };
-    SQLRETURN ret;
+    struct SQLHDESC_data *hdesc = DescriptorHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(DescriptorHandle %p, RecNumber %d, FieldIdentifier %d, Value %p, BufferLength %d)\n", DescriptorHandle,
           RecNumber, FieldIdentifier, Value, BufferLength);
 
-    ret = ODBC_CALL( SQLSetDescFieldW, &params );
-    TRACE("Returning %d\n", ret);
+    if (hdesc->parent->connection->pSQLSetDescFieldW)
+        ret = hdesc->parent->connection->pSQLSetDescFieldW(hdesc->driver_hdesc, RecNumber, FieldIdentifier,
+                                  Value, BufferLength);
+    TRACE("ret %d\n", ret);
+
     return ret;
 }
 
@@ -2591,20 +3063,24 @@ SQLRETURN WINAPI SQLSetDescFieldW(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumb
 SQLRETURN WINAPI SQLSetStmtAttrW(SQLHSTMT StatementHandle, SQLINTEGER Attribute, SQLPOINTER Value,
                                  SQLINTEGER StringLength)
 {
-    struct SQLSetStmtAttrW_params params = { StatementHandle, Attribute, Value, StringLength };
-    SQLRETURN ret;
+    struct SQLHSTMT_data *statement = StatementHandle;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(StatementHandle %p, Attribute %d, Value %p, StringLength %d)\n", StatementHandle, Attribute, Value,
           StringLength);
 
-    ret = ODBC_CALL( SQLSetStmtAttrW, &params );
-    if (ret == SQL_ERROR && (Attribute == SQL_ROWSET_SIZE || Attribute == SQL_ATTR_ROW_ARRAY_SIZE))
+    if (statement->type != SQL_HANDLE_STMT)
     {
-        TRACE("CHEAT: returning SQL_SUCCESS to ADO\n");
-        return SQL_SUCCESS;
+        WARN("Wrong handle type %d\n", statement->type);
+        return SQL_ERROR;
+    }
+
+    if (statement->connection->pSQLSetStmtAttrW)
+    {
+        ret = statement->connection->pSQLSetStmtAttrW(statement->driver_stmt, Attribute, Value, StringLength);
     }
 
-    TRACE("Returning %d\n", ret);
+    TRACE("ret %d\n", ret);
     return ret;
 }
 
@@ -2615,41 +3091,37 @@ SQLRETURN WINAPI SQLGetDiagRecA(SQLSMALLINT HandleType, SQLHANDLE Handle, SQLSMA
                                 SQLCHAR *Sqlstate, SQLINTEGER *NativeError, SQLCHAR *MessageText,
                                 SQLSMALLINT BufferLength, SQLSMALLINT *TextLength)
 {
-    struct SQLGetDiagRecA_params params = { HandleType, Handle, RecNumber, Sqlstate, NativeError,
-                                            MessageText, BufferLength, TextLength };
-    SQLRETURN ret;
+    SQLRETURN ret = SQL_ERROR;
 
     TRACE("(HandleType %d, Handle %p, RecNumber %d, Sqlstate %p, NativeError %p, MessageText %p, BufferLength %d,"
           " TextLength %p)\n", HandleType, Handle, RecNumber, Sqlstate, NativeError, MessageText, BufferLength,
           TextLength);
 
-    ret = ODBC_CALL( SQLGetDiagRecA, &params );
-    TRACE("Returning %d\n", ret);
-    return ret;
-}
+    if (HandleType == SQL_HANDLE_ENV)
+    {
+        FIXME("Unhandled SQL_HANDLE_ENV records\n");
+    }
+    else if (HandleType == SQL_HANDLE_DBC)
+    {
+        struct SQLHDBC_data *hdbc = Handle;
 
+        if (hdbc->pSQLGetDiagRecA)
+            ret = hdbc->pSQLGetDiagRecA(HandleType, hdbc->driver_hdbc, RecNumber, Sqlstate,
+                                NativeError, MessageText, BufferLength, TextLength);
+    }
+    else if (HandleType == SQL_HANDLE_STMT)
+    {
+        struct SQLHSTMT_data *statement = Handle;
 
-/***********************************************************************
- * DllMain [Internal] Initializes the internal 'ODBC32.DLL'.
- */
-BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD reason, LPVOID reserved)
-{
-    TRACE("proxy ODBC: %p,%lx,%p\n", hinstDLL, reason, reserved);
+        if (statement->connection->pSQLGetDiagRecA)
+            ret = statement->connection->pSQLGetDiagRecA(HandleType, statement->driver_stmt, RecNumber,
+                                Sqlstate, NativeError, MessageText, BufferLength, TextLength);
+    }
 
-    switch (reason)
+    if (ret != SQL_ERROR)
     {
-    case DLL_PROCESS_ATTACH:
-        DisableThreadLibraryCalls(hinstDLL);
-        if (!__wine_init_unix_call() && !WINE_UNIX_CALL( process_attach, NULL ))
-        {
-            ODBC_ReplicateToRegistry();
-        }
-        break;
-
-    case DLL_PROCESS_DETACH:
-        if (reserved) break;
-        WINE_UNIX_CALL( process_detach, NULL );
+        TRACE("%d: %s %s\n", RecNumber, Sqlstate, MessageText);
     }
 
-    return TRUE;
+    return ret;
 }
diff --git a/dlls/odbc32/unixlib.c b/dlls/odbc32/unixlib.c
deleted file mode 100644
index 2883a5f..0000000
--- a/dlls/odbc32/unixlib.c
+++ /dev/null
@@ -1,1501 +0,0 @@
-/*
- * Win32 ODBC functions
- *
- * Copyright 1999 Xiang Li, Corel Corporation
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- *
- * NOTES:
- *   Proxy ODBC driver manager.  This manager delegates all ODBC
- *   calls to a real ODBC driver manager named by the environment
- *   variable LIB_ODBC_DRIVER_MANAGER, or to libodbc.so if the
- *   variable is not set.
- */
-
-#if 0
-#pragma makedep unix
-#endif
-
-#include "config.h"
-
-#include <stdarg.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <dlfcn.h>
-
-#include "ntstatus.h"
-#define WIN32_NO_STATUS
-#include "windef.h"
-#include "winbase.h"
-#include "winternl.h"
-#include "wine/debug.h"
-#include "sql.h"
-#include "sqltypes.h"
-#include "sqlext.h"
-
-#include "unixlib.h"
-#include "wine/debug.h"
-
-WINE_DECLARE_DEBUG_CHANNEL(winediag);
-
-static void *libodbc;
-
-static SQLRETURN (*pSQLAllocConnect)(SQLHENV,SQLHDBC*);
-static SQLRETURN (*pSQLAllocEnv)(SQLHENV*);
-static SQLRETURN (*pSQLAllocHandle)(SQLSMALLINT,SQLHANDLE,SQLHANDLE*);
-static SQLRETURN (*pSQLAllocHandleStd)(SQLSMALLINT,SQLHANDLE,SQLHANDLE*);
-static SQLRETURN (*pSQLAllocStmt)(SQLHDBC,SQLHSTMT*);
-static SQLRETURN (*pSQLBindCol)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLPOINTER,SQLLEN,SQLLEN*);
-static SQLRETURN (*pSQLBindParam)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLULEN,SQLSMALLINT,SQLPOINTER,SQLLEN*);
-static SQLRETURN (*pSQLBindParameter)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLULEN,SQLSMALLINT,SQLPOINTER,SQLLEN,SQLLEN*);
-static SQLRETURN (*pSQLBrowseConnect)(SQLHDBC,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLBrowseConnectW)(SQLHDBC,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLBulkOperations)(SQLHSTMT,SQLSMALLINT);
-static SQLRETURN (*pSQLCancel)(SQLHSTMT);
-static SQLRETURN (*pSQLCloseCursor)(SQLHSTMT);
-static SQLRETURN (*pSQLColAttribute)(SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*,SQLLEN*);
-static SQLRETURN (*pSQLColAttributeW)(SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*,SQLLEN*);
-static SQLRETURN (*pSQLColAttributes)(SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*,SQLLEN*);
-static SQLRETURN (*pSQLColAttributesW)(SQLHSTMT,SQLUSMALLINT,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*,SQLLEN*);
-static SQLRETURN (*pSQLColumnPrivileges)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLColumnPrivilegesW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLColumns)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLColumnsW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLConnect)(SQLHDBC,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLConnectW)(SQLHDBC,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLCopyDesc)(SQLHDESC,SQLHDESC);
-static SQLRETURN (*pSQLDataSources)(SQLHENV,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLDataSourcesA)(SQLHENV,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLDataSourcesW)(SQLHENV,SQLUSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLDescribeCol)(SQLHSTMT,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLSMALLINT*,SQLULEN*,SQLSMALLINT*,SQLSMALLINT*);
-static SQLRETURN (*pSQLDescribeColW)(SQLHSTMT,SQLUSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLSMALLINT*,SQLULEN*,SQLSMALLINT*,SQLSMALLINT*);
-static SQLRETURN (*pSQLDescribeParam)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT*,SQLULEN*,SQLSMALLINT*,SQLSMALLINT*);
-static SQLRETURN (*pSQLDisconnect)(SQLHDBC);
-static SQLRETURN (*pSQLDriverConnect)(SQLHDBC,SQLHWND,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLUSMALLINT);
-static SQLRETURN (*pSQLDriverConnectW)(SQLHDBC,SQLHWND,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLUSMALLINT);
-static SQLRETURN (*pSQLDrivers)(SQLHENV,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLDriversW)(SQLHENV,SQLUSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLEndTran)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT);
-static SQLRETURN (*pSQLError)(SQLHENV,SQLHDBC,SQLHSTMT,SQLCHAR*,SQLINTEGER*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLErrorW)(SQLHENV,SQLHDBC,SQLHSTMT,SQLWCHAR*,SQLINTEGER*,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLExecDirect)(SQLHSTMT,SQLCHAR*,SQLINTEGER);
-static SQLRETURN (*pSQLExecDirectW)(SQLHSTMT,SQLWCHAR*,SQLINTEGER);
-static SQLRETURN (*pSQLExecute)(SQLHSTMT);
-static SQLRETURN (*pSQLExtendedFetch)(SQLHSTMT,SQLUSMALLINT,SQLLEN,SQLULEN*,SQLUSMALLINT*);
-static SQLRETURN (*pSQLFetch)(SQLHSTMT);
-static SQLRETURN (*pSQLFetchScroll)(SQLHSTMT,SQLSMALLINT,SQLLEN);
-static SQLRETURN (*pSQLForeignKeys)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLForeignKeysW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLFreeConnect)(SQLHDBC);
-static SQLRETURN (*pSQLFreeEnv)(SQLHENV);
-static SQLRETURN (*pSQLFreeHandle)(SQLSMALLINT,SQLHANDLE);
-static SQLRETURN (*pSQLFreeStmt)(SQLHSTMT,SQLUSMALLINT);
-static SQLRETURN (*pSQLGetConnectAttr)(SQLHDBC,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLGetConnectAttrW)(SQLHDBC,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLGetConnectOption)(SQLHDBC,SQLUSMALLINT,SQLPOINTER);
-static SQLRETURN (*pSQLGetConnectOptionW)(SQLHDBC,SQLUSMALLINT,SQLPOINTER);
-static SQLRETURN (*pSQLGetCursorName)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetCursorNameW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetData)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLPOINTER,SQLLEN,SQLLEN*);
-static SQLRETURN (*pSQLGetDescField)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLGetDescFieldW)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLGetDescRec)(SQLHDESC,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLSMALLINT*,SQLSMALLINT*,SQLLEN*,SQLSMALLINT*,SQLSMALLINT*,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetDescRecW)(SQLHDESC,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*,SQLSMALLINT*,SQLSMALLINT*,SQLLEN*,SQLSMALLINT*,SQLSMALLINT*,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetDiagField)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetDiagFieldW)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetDiagRec)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLCHAR*,SQLINTEGER*,SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetDiagRecA)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLCHAR*,SQLINTEGER*, SQLCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetDiagRecW)(SQLSMALLINT,SQLHANDLE,SQLSMALLINT,SQLWCHAR*,SQLINTEGER*,SQLWCHAR*,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetEnvAttr)(SQLHENV,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLGetFunctions)(SQLHDBC,SQLUSMALLINT,SQLUSMALLINT*);
-static SQLRETURN (*pSQLGetInfo)(SQLHDBC,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetInfoW)(SQLHDBC,SQLUSMALLINT,SQLPOINTER,SQLSMALLINT,SQLSMALLINT*);
-static SQLRETURN (*pSQLGetStmtAttr)(SQLHSTMT,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLGetStmtAttrW)(SQLHSTMT,SQLINTEGER,SQLPOINTER,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLGetStmtOption)(SQLHSTMT,SQLUSMALLINT,SQLPOINTER);
-static SQLRETURN (*pSQLGetTypeInfo)(SQLHSTMT,SQLSMALLINT);
-static SQLRETURN (*pSQLGetTypeInfoW)(SQLHSTMT,SQLSMALLINT);
-static SQLRETURN (*pSQLMoreResults)(SQLHSTMT);
-static SQLRETURN (*pSQLNativeSql)(SQLHDBC,SQLCHAR*,SQLINTEGER,SQLCHAR*,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLNativeSqlW)(SQLHDBC,SQLWCHAR*,SQLINTEGER,SQLWCHAR*,SQLINTEGER,SQLINTEGER*);
-static SQLRETURN (*pSQLNumParams)(SQLHSTMT,SQLSMALLINT*);
-static SQLRETURN (*pSQLNumResultCols)(SQLHSTMT,SQLSMALLINT*);
-static SQLRETURN (*pSQLParamData)(SQLHSTMT,SQLPOINTER*);
-static SQLRETURN (*pSQLParamOptions)(SQLHSTMT,SQLULEN,SQLULEN*);
-static SQLRETURN (*pSQLPrepare)(SQLHSTMT,SQLCHAR*,SQLINTEGER);
-static SQLRETURN (*pSQLPrepareW)(SQLHSTMT,SQLWCHAR*,SQLINTEGER);
-static SQLRETURN (*pSQLPrimaryKeys)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLPrimaryKeysW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLProcedureColumns)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLProcedureColumnsW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLProcedures)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLProceduresW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLPutData)(SQLHSTMT,SQLPOINTER,SQLLEN);
-static SQLRETURN (*pSQLRowCount)(SQLHSTMT,SQLLEN*);
-static SQLRETURN (*pSQLSetConnectAttr)(SQLHDBC,SQLINTEGER,SQLPOINTER,SQLINTEGER);
-static SQLRETURN (*pSQLSetConnectAttrW)(SQLHDBC,SQLINTEGER,SQLPOINTER,SQLINTEGER);
-static SQLRETURN (*pSQLSetConnectOption)(SQLHDBC,SQLUSMALLINT,SQLULEN);
-static SQLRETURN (*pSQLSetConnectOptionW)(SQLHDBC,SQLUSMALLINT,SQLULEN);
-static SQLRETURN (*pSQLSetCursorName)(SQLHSTMT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLSetCursorNameW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLSetDescField)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER);
-static SQLRETURN (*pSQLSetDescFieldW)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLINTEGER);
-static SQLRETURN (*pSQLSetDescRec)(SQLHDESC,SQLSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLLEN,SQLSMALLINT,SQLSMALLINT,SQLPOINTER,SQLLEN*,SQLLEN*);
-static SQLRETURN (*pSQLSetEnvAttr)(SQLHENV,SQLINTEGER,SQLPOINTER,SQLINTEGER);
-static SQLRETURN (*pSQLSetParam)(SQLHSTMT,SQLUSMALLINT,SQLSMALLINT,SQLSMALLINT,SQLULEN,SQLSMALLINT,SQLPOINTER,SQLLEN*);
-static SQLRETURN (*pSQLSetPos)(SQLHSTMT,SQLSETPOSIROW,SQLUSMALLINT,SQLUSMALLINT);
-static SQLRETURN (*pSQLSetScrollOptions)(SQLHSTMT,SQLUSMALLINT,SQLLEN,SQLUSMALLINT);
-static SQLRETURN (*pSQLSetStmtAttr)(SQLHSTMT,SQLINTEGER,SQLPOINTER,SQLINTEGER);
-static SQLRETURN (*pSQLSetStmtAttrW)(SQLHSTMT,SQLINTEGER,SQLPOINTER,SQLINTEGER);
-static SQLRETURN (*pSQLSetStmtOption)(SQLHSTMT,SQLUSMALLINT,SQLULEN);
-static SQLRETURN (*pSQLSpecialColumns)(SQLHSTMT,SQLUSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
-static SQLRETURN (*pSQLSpecialColumnsW)(SQLHSTMT,SQLUSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
-static SQLRETURN (*pSQLStatistics)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
-static SQLRETURN (*pSQLStatisticsW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLUSMALLINT,SQLUSMALLINT);
-static SQLRETURN (*pSQLTablePrivileges)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLTablePrivilegesW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLTables)(SQLHSTMT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT,SQLCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLTablesW)(SQLHSTMT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT,SQLWCHAR*,SQLSMALLINT);
-static SQLRETURN (*pSQLTransact)(SQLHENV,SQLHDBC,SQLUSMALLINT);
-
-
-static NTSTATUS load_odbc(void);
-
-static NTSTATUS odbc_process_attach( void *args )
-{
-    if (!load_odbc()) return STATUS_DLL_NOT_FOUND;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS odbc_process_detach( void *args )
-{
-    if (libodbc) dlclose( libodbc );
-    libodbc = NULL;
-    return STATUS_SUCCESS;
-}
-
-static NTSTATUS wrap_SQLAllocConnect( void *args )
-{
-    struct SQLAllocConnect_params *params = args;
-
-    if (!pSQLAllocConnect) return SQL_ERROR;
-    return pSQLAllocConnect(params->EnvironmentHandle, params->ConnectionHandle);
-}
-
-static NTSTATUS wrap_SQLAllocEnv( void *args )
-{
-    struct SQLAllocEnv_params *params = args;
-
-    if (!pSQLAllocEnv) return SQL_ERROR;
-    return pSQLAllocEnv(params->EnvironmentHandle);
-}
-
-static NTSTATUS wrap_SQLAllocHandle( void *args )
-{
-    struct SQLAllocHandle_params *params = args;
-
-    if (!pSQLAllocHandle) return SQL_ERROR;
-    return pSQLAllocHandle(params->HandleType, params->InputHandle, params->OutputHandle);
-}
-
-static NTSTATUS wrap_SQLAllocHandleStd( void *args )
-{
-    struct SQLAllocHandleStd_params *params = args;
-
-    if (!pSQLAllocHandleStd) return SQL_ERROR;
-    return pSQLAllocHandleStd(params->HandleType, params->InputHandle, params->OutputHandle);
-}
-
-static NTSTATUS wrap_SQLAllocStmt( void *args )
-{
-    struct SQLAllocStmt_params *params = args;
-
-    if (!pSQLAllocStmt) return SQL_ERROR;
-    return pSQLAllocStmt(params->ConnectionHandle, params->StatementHandle);
-}
-
-static NTSTATUS wrap_SQLBindCol( void *args )
-{
-    struct SQLBindCol_params *params = args;
-
-    if (!pSQLBindCol) return SQL_ERROR;
-    return pSQLBindCol(params->StatementHandle, params->ColumnNumber, params->TargetType,
-                       params->TargetValue, params->BufferLength, params->StrLen_or_Ind);
-}
-
-static NTSTATUS wrap_SQLBindParam( void *args )
-{
-    struct SQLBindParam_params *params = args;
-
-    if (!pSQLBindParam) return SQL_ERROR;
-    return pSQLBindParam(params->StatementHandle, params->ParameterNumber, params->ValueType,
-                         params->ParameterType, params->LengthPrecision, params->ParameterScale,
-                         params->ParameterValue, params->StrLen_or_Ind);
-}
-
-static NTSTATUS wrap_SQLBindParameter( void *args )
-{
-    struct SQLBindParameter_params *params = args;
-
-    if (!pSQLBindParameter) return SQL_ERROR;
-    return pSQLBindParameter(params->hstmt, params->ipar, params->fParamType, params->fCType,
-                             params->fSqlType, params->cbColDef, params->ibScale, params->rgbValue,
-                             params->cbValueMax, params->pcbValue);
-}
-
-static NTSTATUS wrap_SQLBrowseConnect( void *args )
-{
-    struct SQLBrowseConnect_params *params = args;
-
-    if (!pSQLBrowseConnect) return SQL_ERROR;
-    return pSQLBrowseConnect(params->hdbc, params->szConnStrIn, params->cbConnStrIn, params->szConnStrOut,
-                             params->cbConnStrOutMax, params->pcbConnStrOut);
-}
-
-static NTSTATUS wrap_SQLBrowseConnectW( void *args )
-{
-    struct SQLBrowseConnectW_params *params = args;
-
-    if (!pSQLBrowseConnectW) return SQL_ERROR;
-    return pSQLBrowseConnectW(params->hdbc, params->szConnStrIn, params->cbConnStrIn, params->szConnStrOut,
-                              params->cbConnStrOutMax, params->pcbConnStrOut);
-}
-
-static NTSTATUS wrap_SQLBulkOperations( void *args )
-{
-    struct SQLBulkOperations_params *params = args;
-
-    if (!pSQLBulkOperations) return SQL_ERROR;
-    return pSQLBulkOperations(params->StatementHandle, params->Operation);
-}
-
-static NTSTATUS wrap_SQLCancel( void *args )
-{
-    struct SQLCancel_params *params = args;
-
-    if (!pSQLCancel) return SQL_ERROR;
-    return pSQLCancel(params->StatementHandle);
-}
-
-static NTSTATUS wrap_SQLCloseCursor( void *args )
-{
-    struct SQLCloseCursor_params *params = args;
-
-    if (!pSQLCloseCursor) return SQL_ERROR;
-    return pSQLCloseCursor(params->StatementHandle);
-}
-
-static NTSTATUS wrap_SQLColAttribute( void *args )
-{
-    struct SQLColAttribute_params *params = args;
-
-    if (!pSQLColAttribute) return SQL_ERROR;
-    return pSQLColAttribute(params->StatementHandle, params->ColumnNumber, params->FieldIdentifier,
-                            params->CharacterAttribute, params->BufferLength, params->StringLength,
-                            params->NumericAttribute);
-}
-
-static NTSTATUS wrap_SQLColAttributeW( void *args )
-{
-    struct SQLColAttributeW_params *params = args;
-
-    if (!pSQLColAttributeW) return SQL_ERROR;
-    return pSQLColAttributeW(params->StatementHandle, params->ColumnNumber, params->FieldIdentifier,
-                             params->CharacterAttribute, params->BufferLength, params->StringLength,
-                             params->NumericAttribute);
-}
-
-static NTSTATUS wrap_SQLColAttributes( void *args )
-{
-    struct SQLColAttributes_params *params = args;
-
-    if (!pSQLColAttributes) return SQL_ERROR;
-    return pSQLColAttributes(params->hstmt, params->icol, params->fDescType, params->rgbDesc,
-                             params->cbDescMax, params->pcbDesc, params->pfDesc);
-}
-
-static NTSTATUS wrap_SQLColAttributesW( void *args )
-{
-    struct SQLColAttributesW_params *params = args;
-
-    if (!pSQLColAttributesW) return SQL_ERROR;
-    return pSQLColAttributesW(params->hstmt, params->icol, params->fDescType, params->rgbDesc,
-                              params->cbDescMax, params->pcbDesc, params->pfDesc);
-}
-
-static NTSTATUS wrap_SQLColumnPrivileges( void *args )
-{
-    struct SQLColumnPrivileges_params *params = args;
-
-    if (!pSQLColumnPrivileges) return SQL_ERROR;
-    return pSQLColumnPrivileges(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                                params->szSchemaName, params->cbSchemaName, params->szTableName,
-                                params->cbTableName, params->szColumnName, params->cbColumnName);
-}
-
-static NTSTATUS wrap_SQLColumnPrivilegesW( void *args )
-{
-    struct SQLColumnPrivilegesW_params *params = args;
-
-    if (!pSQLColumnPrivilegesW) return SQL_ERROR;
-    return pSQLColumnPrivilegesW(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                                 params->szSchemaName, params->cbSchemaName, params->szTableName,
-                                 params->cbTableName, params->szColumnName, params->cbColumnName);
-}
-
-static NTSTATUS wrap_SQLColumns( void *args )
-{
-    struct SQLColumns_params *params = args;
-
-    if (!pSQLColumns) return SQL_ERROR;
-    return pSQLColumns(params->StatementHandle, params->CatalogName, params->NameLength1,
-                       params->SchemaName, params->NameLength2, params->TableName, params->NameLength3,
-                       params->ColumnName, params->NameLength4);
-}
-
-static NTSTATUS wrap_SQLColumnsW( void *args )
-{
-    struct SQLColumnsW_params *params = args;
-
-    if (!pSQLColumnsW) return SQL_ERROR;
-    return pSQLColumnsW(params->StatementHandle, params->CatalogName, params->NameLength1,
-                        params->SchemaName, params->NameLength2, params->TableName, params->NameLength3,
-                        params->ColumnName, params->NameLength4);
-}
-
-static NTSTATUS wrap_SQLConnect( void *args )
-{
-    struct SQLConnect_params *params = args;
-
-    if (!pSQLConnect) return SQL_ERROR;
-    return pSQLConnect(params->ConnectionHandle, params->ServerName, params->NameLength1, params->UserName,
-                       params->NameLength2, params->Authentication, params->NameLength3);
-}
-
-static NTSTATUS wrap_SQLConnectW( void *args )
-{
-    struct SQLConnectW_params *params = args;
-
-    if (!pSQLConnectW) return SQL_ERROR;
-    return pSQLConnectW(params->ConnectionHandle, params->ServerName, params->NameLength1,
-                        params->UserName, params->NameLength2, params->Authentication, params->NameLength3);
-}
-
-static NTSTATUS wrap_SQLCopyDesc( void *args )
-{
-    struct SQLCopyDesc_params *params = args;
-
-    if (!pSQLCopyDesc) return SQL_ERROR;
-    return pSQLCopyDesc(params->SourceDescHandle, params->TargetDescHandle);
-}
-
-static NTSTATUS wrap_SQLDataSources( void *args )
-{
-    struct SQLDataSources_params *params = args;
-
-    if (!pSQLDataSources) return SQL_ERROR;
-    return pSQLDataSources(params->EnvironmentHandle, params->Direction, params->ServerName,
-                           params->BufferLength1, params->NameLength1, params->Description,
-                           params->BufferLength2, params->NameLength2);
-}
-
-static NTSTATUS wrap_SQLDataSourcesA( void *args )
-{
-    struct SQLDataSourcesA_params *params = args;
-
-    if (!pSQLDataSourcesA) return SQL_ERROR;
-    return pSQLDataSourcesA(params->EnvironmentHandle, params->Direction, params->ServerName,
-                            params->BufferLength1, params->NameLength1, params->Description,
-                            params->BufferLength2, params->NameLength2);
-}
-
-static NTSTATUS wrap_SQLDataSourcesW( void *args )
-{
-    struct SQLDataSourcesW_params *params = args;
-
-    if (!pSQLDataSourcesW) return SQL_ERROR;
-    return pSQLDataSourcesW(params->EnvironmentHandle, params->Direction, params->ServerName,
-                            params->BufferLength1, params->NameLength1, params->Description,
-                            params->BufferLength2, params->NameLength2);
-}
-
-static NTSTATUS wrap_SQLDescribeCol( void *args )
-{
-    struct SQLDescribeCol_params *params = args;
-
-    if (!pSQLDescribeCol) return SQL_ERROR;
-    return pSQLDescribeCol(params->StatementHandle, params->ColumnNumber, params->ColumnName,
-                           params->BufferLength, params->NameLength, params->DataType,
-                           params->ColumnSize, params->DecimalDigits, params->Nullable);
-}
-
-static NTSTATUS wrap_SQLDescribeColW( void *args )
-{
-    struct SQLDescribeColW_params *params = args;
-
-    if (!pSQLDescribeColW) return SQL_ERROR;
-    return pSQLDescribeColW(params->StatementHandle, params->ColumnNumber, params->ColumnName,
-                            params->BufferLength, params->NameLength, params->DataType,
-                            params->ColumnSize, params->DecimalDigits, params->Nullable);
-}
-
-static NTSTATUS wrap_SQLDescribeParam( void *args )
-{
-    struct SQLDescribeParam_params *params = args;
-
-    if (!pSQLDescribeParam) return SQL_ERROR;
-    return pSQLDescribeParam(params->hstmt, params->ipar, params->pfSqlType, params->pcbParamDef,
-                             params->pibScale, params->pfNullable);
-}
-
-static NTSTATUS wrap_SQLDisconnect( void *args )
-{
-    struct SQLDisconnect_params *params = args;
-
-    if (!pSQLDisconnect) return SQL_ERROR;
-    return pSQLDisconnect(params->ConnectionHandle);
-}
-
-static NTSTATUS wrap_SQLDriverConnect( void *args )
-{
-    struct SQLDriverConnect_params *params = args;
-
-    if (!pSQLDriverConnect) return SQL_ERROR;
-    return pSQLDriverConnect(params->hdbc, params->hwnd, params->ConnectionString, params->Length,
-                             params->conn_str_out, params->conn_str_out_max,
-                             params->ptr_conn_str_out, params->driver_completion);
-}
-
-static NTSTATUS wrap_SQLDriverConnectW( void *args )
-{
-    struct SQLDriverConnectW_params *params = args;
-
-    if (!pSQLDriverConnectW) return SQL_ERROR;
-    return pSQLDriverConnectW(params->ConnectionHandle, params->WindowHandle, params->InConnectionString,
-                              params->Length, params->OutConnectionString, params->BufferLength,
-                              params->Length2, params->DriverCompletion);
-}
-
-static NTSTATUS wrap_SQLDrivers( void *args )
-{
-    struct SQLDrivers_params *params = args;
-
-    if (!pSQLDrivers) return SQL_ERROR;
-    return pSQLDrivers(params->EnvironmentHandle, params->fDirection, params->szDriverDesc,
-                       params->cbDriverDescMax, params->pcbDriverDesc, params->szDriverAttributes,
-                       params->cbDriverAttrMax, params->pcbDriverAttr);
-}
-
-static NTSTATUS wrap_SQLDriversW( void *args )
-{
-    struct SQLDriversW_params *params = args;
-
-    if (!pSQLDriversW) return SQL_ERROR;
-    return pSQLDriversW(params->EnvironmentHandle, params->fDirection, params->szDriverDesc,
-                        params->cbDriverDescMax, params->pcbDriverDesc, params->szDriverAttributes,
-                        params->cbDriverAttrMax, params->pcbDriverAttr);
-}
-
-static NTSTATUS wrap_SQLEndTran( void *args )
-{
-    struct SQLEndTran_params *params = args;
-
-    if (!pSQLEndTran) return SQL_ERROR;
-    return pSQLEndTran(params->HandleType, params->Handle, params->CompletionType);
-}
-
-static NTSTATUS wrap_SQLError( void *args )
-{
-    struct SQLError_params *params = args;
-
-    if (!pSQLError) return SQL_ERROR;
-    return pSQLError(params->EnvironmentHandle, params->ConnectionHandle, params->StatementHandle,
-                     params->Sqlstate, params->NativeError, params->MessageText,
-                     params->BufferLength, params->TextLength);
-}
-
-static NTSTATUS wrap_SQLErrorW( void *args )
-{
-    struct SQLErrorW_params *params = args;
-
-    if (!pSQLErrorW) return SQL_ERROR;
-    return pSQLErrorW(params->EnvironmentHandle, params->ConnectionHandle, params->StatementHandle,
-                      params->Sqlstate, params->NativeError, params->MessageText,
-                      params->BufferLength, params->TextLength);
-}
-
-static NTSTATUS wrap_SQLExecDirect( void *args )
-{
-    struct SQLExecDirect_params *params = args;
-
-    if (!pSQLExecDirect) return SQL_ERROR;
-    return pSQLExecDirect(params->StatementHandle, params->StatementText, params->TextLength);
-}
-
-static NTSTATUS wrap_SQLExecDirectW( void *args )
-{
-    struct SQLExecDirectW_params *params = args;
-
-    if (!pSQLExecDirectW) return SQL_ERROR;
-    return pSQLExecDirectW(params->StatementHandle, params->StatementText, params->TextLength);
-}
-
-static NTSTATUS wrap_SQLExecute( void *args )
-{
-    struct SQLExecute_params *params = args;
-
-    if (!pSQLExecute) return SQL_ERROR;
-    return pSQLExecute(params->StatementHandle);
-}
-
-static NTSTATUS wrap_SQLExtendedFetch( void *args )
-{
-    struct SQLExtendedFetch_params *params = args;
-
-    if (!pSQLExtendedFetch) return SQL_ERROR;
-    return pSQLExtendedFetch(params->hstmt, params->fFetchType, params->irow,
-                             params->pcrow, params->rgfRowStatus);
-}
-
-static NTSTATUS wrap_SQLFetch( void *args )
-{
-    struct SQLFetch_params *params = args;
-
-    if (!pSQLFetch) return SQL_ERROR;
-    return pSQLFetch(params->StatementHandle);
-}
-
-static NTSTATUS wrap_SQLFetchScroll( void *args )
-{
-    struct SQLFetchScroll_params *params = args;
-
-    if (!pSQLFetchScroll) return SQL_ERROR;
-    return pSQLFetchScroll(params->StatementHandle, params->FetchOrientation, params->FetchOffset);
-}
-
-static NTSTATUS wrap_SQLForeignKeys( void *args )
-{
-    struct SQLForeignKeys_params *params = args;
-
-    if (!pSQLForeignKeys) return SQL_ERROR;
-    return pSQLForeignKeys(params->hstmt, params->szPkCatalogName, params->cbPkCatalogName,
-                           params->szPkSchemaName, params->cbPkSchemaName, params->szPkTableName,
-                           params->cbPkTableName, params->szFkCatalogName, params->cbFkCatalogName,
-                           params->szFkSchemaName, params->cbFkSchemaName, params->szFkTableName,
-                           params->cbFkTableName);
-}
-
-static NTSTATUS wrap_SQLForeignKeysW( void *args )
-{
-    struct SQLForeignKeysW_params *params = args;
-
-    if (!pSQLForeignKeysW) return SQL_ERROR;
-    return pSQLForeignKeysW(params->hstmt, params->szPkCatalogName, params->cbPkCatalogName,
-                            params->szPkSchemaName, params->cbPkSchemaName, params->szPkTableName,
-                            params->cbPkTableName, params->szFkCatalogName, params->cbFkCatalogName,
-                            params->szFkSchemaName, params->cbFkSchemaName, params->szFkTableName,
-                            params->cbFkTableName);
-}
-
-static NTSTATUS wrap_SQLFreeConnect( void *args )
-{
-    struct SQLFreeConnect_params *params = args;
-
-    if (!pSQLFreeConnect) return SQL_ERROR;
-    return pSQLFreeConnect(params->ConnectionHandle);
-}
-
-static NTSTATUS wrap_SQLFreeEnv( void *args )
-{
-    struct SQLFreeEnv_params *params = args;
-
-    if (!pSQLFreeEnv) return SQL_ERROR;
-    return pSQLFreeEnv(params->EnvironmentHandle);
-}
-
-static NTSTATUS wrap_SQLFreeHandle( void *args )
-{
-    struct SQLFreeHandle_params *params = args;
-
-    if (!pSQLFreeHandle) return SQL_ERROR;
-    return pSQLFreeHandle(params->HandleType, params->Handle);
-}
-
-static NTSTATUS wrap_SQLFreeStmt( void *args )
-{
-    struct SQLFreeStmt_params *params = args;
-
-    if (!pSQLFreeStmt) return SQL_ERROR;
-    return pSQLFreeStmt(params->StatementHandle, params->Option);
-}
-
-static NTSTATUS wrap_SQLGetConnectAttr( void *args )
-{
-    struct SQLGetConnectAttr_params *params = args;
-
-    if (!pSQLGetConnectAttr) return SQL_ERROR;
-    return pSQLGetConnectAttr(params->ConnectionHandle, params->Attribute, params->Value,
-                              params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetConnectAttrW( void *args )
-{
-    struct SQLGetConnectAttrW_params *params = args;
-
-    if (!pSQLGetConnectAttrW) return SQL_ERROR;
-    return pSQLGetConnectAttrW(params->ConnectionHandle, params->Attribute, params->Value,
-                               params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetConnectOption( void *args )
-{
-    struct SQLGetConnectOption_params *params = args;
-
-    if (!pSQLGetConnectOption) return SQL_ERROR;
-    return pSQLGetConnectOption(params->ConnectionHandle, params->Option, params->Value);
-}
-
-static NTSTATUS wrap_SQLGetConnectOptionW( void *args )
-{
-    struct SQLGetConnectOptionW_params *params = args;
-
-    if (!pSQLGetConnectOptionW) return SQL_ERROR;
-    return pSQLGetConnectOptionW(params->ConnectionHandle, params->Option, params->Value);
-}
-
-static NTSTATUS wrap_SQLGetCursorName( void *args )
-{
-    struct SQLGetCursorName_params *params = args;
-
-    if (!pSQLGetCursorName) return SQL_ERROR;
-    return pSQLGetCursorName(params->StatementHandle, params->CursorName, params->BufferLength,
-                             params->NameLength);
-}
-
-static NTSTATUS wrap_SQLGetCursorNameW( void *args )
-{
-    struct SQLGetCursorNameW_params *params = args;
-
-    if (!pSQLGetCursorNameW) return SQL_ERROR;
-    return pSQLGetCursorNameW(params->StatementHandle, params->CursorName, params->BufferLength,
-                              params->NameLength);
-}
-
-static NTSTATUS wrap_SQLGetData( void *args )
-{
-    struct SQLGetData_params *params = args;
-
-    if (!pSQLGetData) return SQL_ERROR;
-    return pSQLGetData(params->StatementHandle, params->ColumnNumber, params->TargetType,
-                       params->TargetValue, params->BufferLength, params->StrLen_or_Ind);
-}
-
-static NTSTATUS wrap_SQLGetDescField( void *args )
-{
-    struct SQLGetDescField_params *params = args;
-
-    if (!pSQLGetDescField) return SQL_ERROR;
-    return pSQLGetDescField(params->DescriptorHandle, params->RecNumber, params->FieldIdentifier,
-                            params->Value, params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetDescFieldW( void *args )
-{
-    struct SQLGetDescFieldW_params *params = args;
-
-    if (!pSQLGetDescFieldW) return SQL_ERROR;
-    return pSQLGetDescFieldW(params->DescriptorHandle, params->RecNumber, params->FieldIdentifier,
-                             params->Value, params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetDescRec( void *args )
-{
-    struct SQLGetDescRec_params *params = args;
-
-    if (!pSQLGetDescRec) return SQL_ERROR;
-    return pSQLGetDescRec(params->DescriptorHandle, params->RecNumber, params->Name, params->BufferLength,
-                          params->StringLength, params->Type, params->SubType, params->Length,
-                          params->Precision, params->Scale, params->Nullable);
-}
-
-static NTSTATUS wrap_SQLGetDescRecW( void *args )
-{
-    struct SQLGetDescRecW_params *params = args;
-
-    if (!pSQLGetDescRecW) return SQL_ERROR;
-    return pSQLGetDescRecW(params->DescriptorHandle, params->RecNumber, params->Name, params->BufferLength,
-                           params->StringLength, params->Type, params->SubType, params->Length,
-                           params->Precision, params->Scale, params->Nullable);
-}
-
-static NTSTATUS wrap_SQLGetDiagField( void *args )
-{
-    struct SQLGetDiagField_params *params = args;
-
-    if (!pSQLGetDiagField) return SQL_ERROR;
-    return pSQLGetDiagField(params->HandleType, params->Handle, params->RecNumber, params->DiagIdentifier,
-                            params->DiagInfo, params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetDiagFieldW( void *args )
-{
-    struct SQLGetDiagFieldW_params *params = args;
-
-    if (!pSQLGetDiagFieldW) return SQL_ERROR;
-    return pSQLGetDiagFieldW(params->HandleType, params->Handle, params->RecNumber, params->DiagIdentifier,
-                             params->DiagInfo, params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetDiagRec( void *args )
-{
-    struct SQLGetDiagRec_params *params = args;
-
-    if (!pSQLGetDiagRec) return SQL_ERROR;
-    return pSQLGetDiagRec(params->HandleType, params->Handle, params->RecNumber, params->Sqlstate,
-                          params->NativeError, params->MessageText, params->BufferLength,
-                          params->TextLength);
-}
-
-static NTSTATUS wrap_SQLGetDiagRecA( void *args )
-{
-    struct SQLGetDiagRecA_params *params = args;
-
-    if (!pSQLGetDiagRecA) return SQL_ERROR;
-    return pSQLGetDiagRecA(params->HandleType, params->Handle, params->RecNumber, params->Sqlstate,
-                           params->NativeError, params->MessageText, params->BufferLength,
-                           params->TextLength);
-}
-
-static NTSTATUS wrap_SQLGetDiagRecW( void *args )
-{
-    struct SQLGetDiagRecW_params *params = args;
-
-    if (!pSQLGetDiagRecW) return SQL_ERROR;
-    return pSQLGetDiagRecW(params->HandleType, params->Handle, params->RecNumber, params->Sqlstate,
-                           params->NativeError, params->MessageText, params->BufferLength,
-                           params->TextLength);
-}
-
-static NTSTATUS wrap_SQLGetEnvAttr( void *args )
-{
-    struct SQLGetEnvAttr_params *params = args;
-
-    if (!pSQLGetEnvAttr) return SQL_ERROR;
-    return pSQLGetEnvAttr(params->EnvironmentHandle, params->Attribute, params->Value,
-                          params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetFunctions( void *args )
-{
-    struct SQLGetFunctions_params *params = args;
-
-    if (!pSQLGetFunctions) return SQL_ERROR;
-    return pSQLGetFunctions(params->ConnectionHandle, params->FunctionId, params->Supported);
-}
-
-static NTSTATUS wrap_SQLGetInfo( void *args )
-{
-    struct SQLGetInfo_params *params = args;
-
-    if (!pSQLGetInfo) return SQL_ERROR;
-    return pSQLGetInfo(params->ConnectionHandle, params->InfoType, params->InfoValue,
-                       params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetInfoW( void *args )
-{
-    struct SQLGetInfoW_params *params = args;
-
-    if (!pSQLGetInfoW) return SQL_ERROR;
-    return pSQLGetInfoW(params->ConnectionHandle, params->InfoType, params->InfoValue,
-                        params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetStmtAttr( void *args )
-{
-    struct SQLGetStmtAttr_params *params = args;
-
-    if (!pSQLGetStmtAttr) return SQL_ERROR;
-    return pSQLGetStmtAttr(params->StatementHandle, params->Attribute, params->Value,
-                           params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetStmtAttrW( void *args )
-{
-    struct SQLGetStmtAttrW_params *params = args;
-
-    if (!pSQLGetStmtAttrW) return SQL_ERROR;
-    return pSQLGetStmtAttrW(params->StatementHandle, params->Attribute, params->Value,
-                            params->BufferLength, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLGetStmtOption( void *args )
-{
-    struct SQLGetStmtOption_params *params = args;
-
-    if (!pSQLGetStmtOption) return SQL_ERROR;
-    return pSQLGetStmtOption(params->StatementHandle, params->Option, params->Value);
-}
-
-static NTSTATUS wrap_SQLGetTypeInfo( void *args )
-{
-    struct SQLGetTypeInfo_params *params = args;
-
-    if (!pSQLGetTypeInfo) return SQL_ERROR;
-    return pSQLGetTypeInfo(params->StatementHandle, params->DataType);
-}
-
-static NTSTATUS wrap_SQLGetTypeInfoW( void *args )
-{
-    struct SQLGetTypeInfoW_params *params = args;
-
-    if (!pSQLGetTypeInfoW) return SQL_ERROR;
-    return pSQLGetTypeInfoW(params->StatementHandle, params->DataType);
-}
-
-static NTSTATUS wrap_SQLMoreResults( void *args )
-{
-    struct SQLMoreResults_params *params = args;
-
-    if (!pSQLMoreResults) return SQL_ERROR;
-    return pSQLMoreResults(params->StatementHandle);
-}
-
-static NTSTATUS wrap_SQLNativeSql( void *args )
-{
-    struct SQLNativeSql_params *params = args;
-
-    if (!pSQLNativeSql) return SQL_ERROR;
-    return pSQLNativeSql(params->hdbc, params->szSqlStrIn, params->cbSqlStrIn, params->szSqlStr,
-                         params->cbSqlStrMax, params->pcbSqlStr);
-}
-
-static NTSTATUS wrap_SQLNativeSqlW( void *args )
-{
-    struct SQLNativeSqlW_params *params = args;
-
-    if (!pSQLNativeSqlW) return SQL_ERROR;
-    return pSQLNativeSqlW(params->hdbc, params->szSqlStrIn, params->cbSqlStrIn, params->szSqlStr,
-                          params->cbSqlStrMax, params->pcbSqlStr);
-}
-
-static NTSTATUS wrap_SQLNumParams( void *args )
-{
-    struct SQLNumParams_params *params = args;
-
-    if (!pSQLNumParams) return SQL_ERROR;
-    return pSQLNumParams(params->hstmt, params->pcpar);
-}
-
-static NTSTATUS wrap_SQLNumResultCols( void *args )
-{
-    struct SQLNumResultCols_params *params = args;
-
-    if (!pSQLNumResultCols) return SQL_ERROR;
-    return pSQLNumResultCols(params->StatementHandle, params->ColumnCount);
-}
-
-static NTSTATUS wrap_SQLParamData( void *args )
-{
-    struct SQLParamData_params *params = args;
-
-    if (!pSQLParamData) return SQL_ERROR;
-    return pSQLParamData(params->StatementHandle, params->Value);
-}
-
-static NTSTATUS wrap_SQLParamOptions( void *args )
-{
-    struct SQLParamOptions_params *params = args;
-
-    if (!pSQLParamOptions) return SQL_ERROR;
-    return pSQLParamOptions(params->hstmt, params->crow, params->pirow);
-}
-
-static NTSTATUS wrap_SQLPrepare( void *args )
-{
-    struct SQLPrepare_params *params = args;
-
-    if (!pSQLPrepare) return SQL_ERROR;
-    return pSQLPrepare(params->StatementHandle, params->StatementText, params->TextLength);
-}
-
-static NTSTATUS wrap_SQLPrepareW( void *args )
-{
-    struct SQLPrepareW_params *params = args;
-
-    if (!pSQLPrepareW) return SQL_ERROR;
-    return pSQLPrepareW(params->StatementHandle, params->StatementText, params->TextLength);
-}
-
-static NTSTATUS wrap_SQLPrimaryKeys( void *args )
-{
-    struct SQLPrimaryKeys_params *params = args;
-
-    if (!pSQLPrimaryKeys) return SQL_ERROR;
-    return pSQLPrimaryKeys(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                           params->szSchemaName, params->cbSchemaName,
-                           params->szTableName, params->cbTableName);
-}
-
-static NTSTATUS wrap_SQLPrimaryKeysW( void *args )
-{
-    struct SQLPrimaryKeysW_params *params = args;
-
-    if (!pSQLPrimaryKeysW) return SQL_ERROR;
-    return pSQLPrimaryKeysW(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                            params->szSchemaName, params->cbSchemaName,
-                            params->szTableName, params->cbTableName);
-}
-
-static NTSTATUS wrap_SQLProcedureColumns( void *args )
-{
-    struct SQLProcedureColumns_params *params = args;
-
-    if (!pSQLProcedureColumns) return SQL_ERROR;
-    return pSQLProcedureColumns(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                                params->szSchemaName, params->cbSchemaName, params->szProcName,
-                                params->cbProcName, params->szColumnName, params->cbColumnName);
-}
-
-static NTSTATUS wrap_SQLProcedureColumnsW( void *args )
-{
-    struct SQLProcedureColumnsW_params *params = args;
-
-    if (!pSQLProcedureColumnsW) return SQL_ERROR;
-    return pSQLProcedureColumnsW(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                                 params->szSchemaName, params->cbSchemaName, params->szProcName,
-                                 params->cbProcName, params->szColumnName, params->cbColumnName);
-}
-
-static NTSTATUS wrap_SQLProcedures( void *args )
-{
-    struct SQLProcedures_params *params = args;
-
-    if (!pSQLProcedures) return SQL_ERROR;
-    return pSQLProcedures(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                          params->szSchemaName, params->cbSchemaName, params->szProcName,
-                          params->cbProcName);
-}
-
-static NTSTATUS wrap_SQLProceduresW( void *args )
-{
-    struct SQLProceduresW_params *params = args;
-
-    if (!pSQLProceduresW) return SQL_ERROR;
-    return pSQLProceduresW(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                           params->szSchemaName, params->cbSchemaName, params->szProcName,
-                           params->cbProcName);
-}
-
-static NTSTATUS wrap_SQLPutData( void *args )
-{
-    struct SQLPutData_params *params = args;
-
-    if (!pSQLPutData) return SQL_ERROR;
-    return pSQLPutData(params->StatementHandle, params->Data, params->StrLen_or_Ind);
-}
-
-static NTSTATUS wrap_SQLRowCount( void *args )
-{
-    struct SQLRowCount_params *params = args;
-
-    if (!pSQLRowCount) return SQL_ERROR;
-    return pSQLRowCount(params->StatementHandle, params->RowCount);
-}
-
-static NTSTATUS wrap_SQLSetConnectAttr( void *args )
-{
-    struct SQLSetConnectAttr_params *params = args;
-
-    if (!pSQLSetConnectAttr) return SQL_ERROR;
-    return pSQLSetConnectAttr(params->ConnectionHandle, params->Attribute, params->Value,
-                              params->StringLength);
-}
-
-static NTSTATUS wrap_SQLSetConnectAttrW( void *args )
-{
-    struct SQLSetConnectAttrW_params *params = args;
-
-    if (!pSQLSetConnectAttrW) return SQL_ERROR;
-    return pSQLSetConnectAttrW(params->ConnectionHandle, params->Attribute, params->Value,
-                               params->StringLength);
-}
-
-static NTSTATUS wrap_SQLSetConnectOption( void *args )
-{
-    struct SQLSetConnectOption_params *params = args;
-
-    if (!pSQLSetConnectOption) return SQL_ERROR;
-    return pSQLSetConnectOption(params->ConnectionHandle, params->Option, params->Value);
-}
-
-static NTSTATUS wrap_SQLSetConnectOptionW( void *args )
-{
-    struct SQLSetConnectOptionW_params *params = args;
-
-    if (!pSQLSetConnectOptionW) return SQL_ERROR;
-    return pSQLSetConnectOptionW(params->ConnectionHandle, params->Option, params->Value);
-}
-
-static NTSTATUS wrap_SQLSetCursorName( void *args )
-{
-    struct SQLSetCursorName_params *params = args;
-
-    if (!pSQLSetCursorName) return SQL_ERROR;
-    return pSQLSetCursorName(params->StatementHandle, params->CursorName, params->NameLength);
-}
-
-static NTSTATUS wrap_SQLSetCursorNameW( void *args )
-{
-    struct SQLSetCursorNameW_params *params = args;
-
-    if (!pSQLSetCursorNameW) return SQL_ERROR;
-    return pSQLSetCursorNameW(params->StatementHandle, params->CursorName, params->NameLength);
-}
-
-static NTSTATUS wrap_SQLSetDescField( void *args )
-{
-    struct SQLSetDescField_params *params = args;
-
-    if (!pSQLSetDescField) return SQL_ERROR;
-    return pSQLSetDescField(params->DescriptorHandle, params->RecNumber, params->FieldIdentifier,
-                            params->Value, params->BufferLength);
-}
-
-static NTSTATUS wrap_SQLSetDescFieldW( void *args )
-{
-    struct SQLSetDescFieldW_params *params = args;
-
-    if (!pSQLSetDescFieldW) return SQL_ERROR;
-    return pSQLSetDescFieldW(params->DescriptorHandle, params->RecNumber, params->FieldIdentifier,
-                             params->Value, params->BufferLength);
-}
-
-static NTSTATUS wrap_SQLSetDescRec( void *args )
-{
-    struct SQLSetDescRec_params *params = args;
-
-    if (!pSQLSetDescRec) return SQL_ERROR;
-    return pSQLSetDescRec(params->DescriptorHandle, params->RecNumber, params->Type, params->SubType,
-                          params->Length, params->Precision, params->Scale, params->Data,
-                          params->StringLength, params->Indicator);
-}
-
-static NTSTATUS wrap_SQLSetEnvAttr( void *args )
-{
-    struct SQLSetEnvAttr_params *params = args;
-
-    if (!pSQLSetEnvAttr) return SQL_ERROR;
-    return pSQLSetEnvAttr(params->EnvironmentHandle, params->Attribute, params->Value, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLSetParam( void *args )
-{
-    struct SQLSetParam_params *params = args;
-
-    if (!pSQLSetParam) return SQL_ERROR;
-    return pSQLSetParam(params->StatementHandle, params->ParameterNumber, params->ValueType,
-                        params->ParameterType, params->LengthPrecision, params->ParameterScale,
-                        params->ParameterValue, params->StrLen_or_Ind);
-}
-
-static NTSTATUS wrap_SQLSetPos( void *args )
-{
-    struct SQLSetPos_params *params = args;
-
-    if (!pSQLSetPos) return SQL_ERROR;
-    return pSQLSetPos(params->hstmt, params->irow, params->fOption, params->fLock);
-}
-
-static NTSTATUS wrap_SQLSetScrollOptions( void *args )
-{
-    struct SQLSetScrollOptions_params *params = args;
-
-    if (!pSQLSetScrollOptions) return SQL_ERROR;
-    return pSQLSetScrollOptions(params->statement_handle, params->f_concurrency,
-                                params->crow_keyset, params->crow_rowset);
-}
-
-static NTSTATUS wrap_SQLSetStmtAttr( void *args )
-{
-    struct SQLSetStmtAttr_params *params = args;
-
-    if (!pSQLSetStmtAttr) return SQL_ERROR;
-    return pSQLSetStmtAttr(params->StatementHandle, params->Attribute, params->Value, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLSetStmtAttrW( void *args )
-{
-    struct SQLSetStmtAttrW_params *params = args;
-
-    if (!pSQLSetStmtAttrW) return SQL_ERROR;
-    return pSQLSetStmtAttrW(params->StatementHandle, params->Attribute, params->Value, params->StringLength);
-}
-
-static NTSTATUS wrap_SQLSetStmtOption( void *args )
-{
-    struct SQLSetStmtOption_params *params = args;
-
-    if (!pSQLSetStmtOption) return SQL_ERROR;
-    return pSQLSetStmtOption(params->StatementHandle, params->Option, params->Value);
-}
-
-static NTSTATUS wrap_SQLSpecialColumns( void *args )
-{
-    struct SQLSpecialColumns_params *params = args;
-
-    if (!pSQLSpecialColumns) return SQL_ERROR;
-    return pSQLSpecialColumns(params->StatementHandle, params->IdentifierType, params->CatalogName,
-                              params->NameLength1, params->SchemaName, params->NameLength2,
-                              params->TableName, params->NameLength3, params->Scope, params->Nullable);
-}
-
-static NTSTATUS wrap_SQLSpecialColumnsW( void *args )
-{
-    struct SQLSpecialColumnsW_params *params = args;
-
-    if (!pSQLSpecialColumnsW) return SQL_ERROR;
-    return pSQLSpecialColumnsW(params->StatementHandle, params->IdentifierType, params->CatalogName,
-                               params->NameLength1, params->SchemaName, params->NameLength2,
-                               params->TableName, params->NameLength3, params->Scope, params->Nullable);
-}
-
-static NTSTATUS wrap_SQLStatistics( void *args )
-{
-    struct SQLStatistics_params *params = args;
-
-    if (!pSQLStatistics) return SQL_ERROR;
-    return pSQLStatistics(params->StatementHandle, params->CatalogName, params->NameLength1,
-                          params->SchemaName, params->NameLength2, params->TableName,
-                          params->NameLength3, params->Unique, params->Reserved);
-}
-
-static NTSTATUS wrap_SQLStatisticsW( void *args )
-{
-    struct SQLStatisticsW_params *params = args;
-
-    if (!pSQLStatisticsW) return SQL_ERROR;
-    return pSQLStatisticsW(params->StatementHandle, params->CatalogName, params->NameLength1,
-                           params->SchemaName, params->NameLength2, params->TableName,
-                           params->NameLength3, params->Unique, params->Reserved);
-}
-
-static NTSTATUS wrap_SQLTablePrivileges( void *args )
-{
-    struct SQLTablePrivileges_params *params = args;
-
-    if (!pSQLTablePrivileges) return SQL_ERROR;
-    return pSQLTablePrivileges(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                               params->szSchemaName, params->cbSchemaName, params->szTableName,
-                               params->cbTableName);
-}
-
-static NTSTATUS wrap_SQLTablePrivilegesW( void *args )
-{
-    struct SQLTablePrivilegesW_params *params = args;
-
-    if (!pSQLTablePrivilegesW) return SQL_ERROR;
-    return pSQLTablePrivilegesW(params->hstmt, params->szCatalogName, params->cbCatalogName,
-                                params->szSchemaName, params->cbSchemaName, params->szTableName,
-                                params->cbTableName);
-}
-
-static NTSTATUS wrap_SQLTables( void *args )
-{
-    struct SQLTables_params *params = args;
-
-    if (!pSQLTables) return SQL_ERROR;
-    return pSQLTables(params->StatementHandle, params->CatalogName, params->NameLength1,
-                      params->SchemaName, params->NameLength2, params->TableName,
-                      params->NameLength3, params->TableType, params->NameLength4);
-}
-
-static NTSTATUS wrap_SQLTablesW( void *args )
-{
-    struct SQLTablesW_params *params = args;
-
-    if (!pSQLTablesW) return SQL_ERROR;
-    return pSQLTablesW(params->StatementHandle, params->CatalogName, params->NameLength1,
-                       params->SchemaName, params->NameLength2, params->TableName,
-                       params->NameLength3, params->TableType, params->NameLength4);
-}
-
-static NTSTATUS wrap_SQLTransact( void *args )
-{
-    struct SQLTransact_params *params = args;
-
-    if (!pSQLTransact) return SQL_ERROR;
-    return pSQLTransact(params->EnvironmentHandle, params->ConnectionHandle, params->CompletionType);
-}
-
-const unixlib_entry_t __wine_unix_call_funcs[NB_ODBC_FUNCS] =
-{
-    odbc_process_attach,
-    odbc_process_detach,
-    wrap_SQLAllocConnect,
-    wrap_SQLAllocEnv,
-    wrap_SQLAllocHandle,
-    wrap_SQLAllocHandleStd,
-    wrap_SQLAllocStmt,
-    wrap_SQLBindCol,
-    wrap_SQLBindParam,
-    wrap_SQLBindParameter,
-    wrap_SQLBrowseConnect,
-    wrap_SQLBrowseConnectW,
-    wrap_SQLBulkOperations,
-    wrap_SQLCancel,
-    wrap_SQLCloseCursor,
-    wrap_SQLColAttribute,
-    wrap_SQLColAttributeW,
-    wrap_SQLColAttributes,
-    wrap_SQLColAttributesW,
-    wrap_SQLColumnPrivileges,
-    wrap_SQLColumnPrivilegesW,
-    wrap_SQLColumns,
-    wrap_SQLColumnsW,
-    wrap_SQLConnect,
-    wrap_SQLConnectW,
-    wrap_SQLCopyDesc,
-    wrap_SQLDataSources,
-    wrap_SQLDataSourcesA,
-    wrap_SQLDataSourcesW,
-    wrap_SQLDescribeCol,
-    wrap_SQLDescribeColW,
-    wrap_SQLDescribeParam,
-    wrap_SQLDisconnect,
-    wrap_SQLDriverConnect,
-    wrap_SQLDriverConnectW,
-    wrap_SQLDrivers,
-    wrap_SQLDriversW,
-    wrap_SQLEndTran,
-    wrap_SQLError,
-    wrap_SQLErrorW,
-    wrap_SQLExecDirect,
-    wrap_SQLExecDirectW,
-    wrap_SQLExecute,
-    wrap_SQLExtendedFetch,
-    wrap_SQLFetch,
-    wrap_SQLFetchScroll,
-    wrap_SQLForeignKeys,
-    wrap_SQLForeignKeysW,
-    wrap_SQLFreeConnect,
-    wrap_SQLFreeEnv,
-    wrap_SQLFreeHandle,
-    wrap_SQLFreeStmt,
-    wrap_SQLGetConnectAttr,
-    wrap_SQLGetConnectAttrW,
-    wrap_SQLGetConnectOption,
-    wrap_SQLGetConnectOptionW,
-    wrap_SQLGetCursorName,
-    wrap_SQLGetCursorNameW,
-    wrap_SQLGetData,
-    wrap_SQLGetDescField,
-    wrap_SQLGetDescFieldW,
-    wrap_SQLGetDescRec,
-    wrap_SQLGetDescRecW,
-    wrap_SQLGetDiagField,
-    wrap_SQLGetDiagFieldW,
-    wrap_SQLGetDiagRec,
-    wrap_SQLGetDiagRecA,
-    wrap_SQLGetDiagRecW,
-    wrap_SQLGetEnvAttr,
-    wrap_SQLGetFunctions,
-    wrap_SQLGetInfo,
-    wrap_SQLGetInfoW,
-    wrap_SQLGetStmtAttr,
-    wrap_SQLGetStmtAttrW,
-    wrap_SQLGetStmtOption,
-    wrap_SQLGetTypeInfo,
-    wrap_SQLGetTypeInfoW,
-    wrap_SQLMoreResults,
-    wrap_SQLNativeSql,
-    wrap_SQLNativeSqlW,
-    wrap_SQLNumParams,
-    wrap_SQLNumResultCols,
-    wrap_SQLParamData,
-    wrap_SQLParamOptions,
-    wrap_SQLPrepare,
-    wrap_SQLPrepareW,
-    wrap_SQLPrimaryKeys,
-    wrap_SQLPrimaryKeysW,
-    wrap_SQLProcedureColumns,
-    wrap_SQLProcedureColumnsW,
-    wrap_SQLProcedures,
-    wrap_SQLProceduresW,
-    wrap_SQLPutData,
-    wrap_SQLRowCount,
-    wrap_SQLSetConnectAttr,
-    wrap_SQLSetConnectAttrW,
-    wrap_SQLSetConnectOption,
-    wrap_SQLSetConnectOptionW,
-    wrap_SQLSetCursorName,
-    wrap_SQLSetCursorNameW,
-    wrap_SQLSetDescField,
-    wrap_SQLSetDescFieldW,
-    wrap_SQLSetDescRec,
-    wrap_SQLSetEnvAttr,
-    wrap_SQLSetParam,
-    wrap_SQLSetPos,
-    wrap_SQLSetScrollOptions,
-    wrap_SQLSetStmtAttr,
-    wrap_SQLSetStmtAttrW,
-    wrap_SQLSetStmtOption,
-    wrap_SQLSpecialColumns,
-    wrap_SQLSpecialColumnsW,
-    wrap_SQLStatistics,
-    wrap_SQLStatisticsW,
-    wrap_SQLTablePrivileges,
-    wrap_SQLTablePrivilegesW,
-    wrap_SQLTables,
-    wrap_SQLTablesW,
-    wrap_SQLTransact,
-};
-
-static NTSTATUS load_odbc(void)
-{
-   const char *s = getenv("LIB_ODBC_DRIVER_MANAGER");
-
-#ifdef SONAME_LIBODBC
-   if (!s || !s[0]) s = SONAME_LIBODBC;
-#endif
-   if (!s || !s[0] || !(libodbc = dlopen( s, RTLD_LAZY | RTLD_GLOBAL )))
-   {
-       ERR_(winediag)("failed to open library %s: %s\n", debugstr_a(s), dlerror());
-       return STATUS_DLL_NOT_FOUND;
-   }
-
-#define LOAD_FUNC(name) \
-    p##name = dlsym( libodbc, #name );
-
-    LOAD_FUNC(SQLAllocConnect);
-    LOAD_FUNC(SQLAllocEnv);
-    LOAD_FUNC(SQLAllocHandle);
-    LOAD_FUNC(SQLAllocHandleStd);
-    LOAD_FUNC(SQLAllocStmt);
-    LOAD_FUNC(SQLBindCol);
-    LOAD_FUNC(SQLBindParam);
-    LOAD_FUNC(SQLBindParameter);
-    LOAD_FUNC(SQLBrowseConnect);
-    LOAD_FUNC(SQLBrowseConnectW);
-    LOAD_FUNC(SQLBulkOperations);
-    LOAD_FUNC(SQLCancel);
-    LOAD_FUNC(SQLCloseCursor);
-    LOAD_FUNC(SQLColAttribute);
-    LOAD_FUNC(SQLColAttributeW);
-    LOAD_FUNC(SQLColAttributes);
-    LOAD_FUNC(SQLColAttributesW);
-    LOAD_FUNC(SQLColumnPrivileges);
-    LOAD_FUNC(SQLColumnPrivilegesW);
-    LOAD_FUNC(SQLColumns);
-    LOAD_FUNC(SQLColumnsW);
-    LOAD_FUNC(SQLConnect);
-    LOAD_FUNC(SQLConnectW);
-    LOAD_FUNC(SQLCopyDesc);
-    LOAD_FUNC(SQLDataSources);
-    LOAD_FUNC(SQLDataSourcesA);
-    LOAD_FUNC(SQLDataSourcesW);
-    LOAD_FUNC(SQLDescribeCol);
-    LOAD_FUNC(SQLDescribeColW);
-    LOAD_FUNC(SQLDescribeParam);
-    LOAD_FUNC(SQLDisconnect);
-    LOAD_FUNC(SQLDriverConnect);
-    LOAD_FUNC(SQLDriverConnectW);
-    LOAD_FUNC(SQLDrivers);
-    LOAD_FUNC(SQLDriversW);
-    LOAD_FUNC(SQLEndTran);
-    LOAD_FUNC(SQLError);
-    LOAD_FUNC(SQLErrorW);
-    LOAD_FUNC(SQLExecDirect);
-    LOAD_FUNC(SQLExecDirectW);
-    LOAD_FUNC(SQLExecute);
-    LOAD_FUNC(SQLExtendedFetch);
-    LOAD_FUNC(SQLFetch);
-    LOAD_FUNC(SQLFetchScroll);
-    LOAD_FUNC(SQLForeignKeys);
-    LOAD_FUNC(SQLForeignKeysW);
-    LOAD_FUNC(SQLFreeConnect);
-    LOAD_FUNC(SQLFreeEnv);
-    LOAD_FUNC(SQLFreeHandle);
-    LOAD_FUNC(SQLFreeStmt);
-    LOAD_FUNC(SQLGetConnectAttr);
-    LOAD_FUNC(SQLGetConnectAttrW);
-    LOAD_FUNC(SQLGetConnectOption);
-    LOAD_FUNC(SQLGetConnectOptionW);
-    LOAD_FUNC(SQLGetCursorName);
-    LOAD_FUNC(SQLGetCursorNameW);
-    LOAD_FUNC(SQLGetData);
-    LOAD_FUNC(SQLGetDescField);
-    LOAD_FUNC(SQLGetDescFieldW);
-    LOAD_FUNC(SQLGetDescRec);
-    LOAD_FUNC(SQLGetDescRecW);
-    LOAD_FUNC(SQLGetDiagField);
-    LOAD_FUNC(SQLGetDiagFieldW);
-    LOAD_FUNC(SQLGetDiagRec);
-    LOAD_FUNC(SQLGetDiagRecA);
-    LOAD_FUNC(SQLGetDiagRecW);
-    LOAD_FUNC(SQLGetEnvAttr);
-    LOAD_FUNC(SQLGetFunctions);
-    LOAD_FUNC(SQLGetInfo);
-    LOAD_FUNC(SQLGetInfoW);
-    LOAD_FUNC(SQLGetStmtAttr);
-    LOAD_FUNC(SQLGetStmtAttrW);
-    LOAD_FUNC(SQLGetStmtOption);
-    LOAD_FUNC(SQLGetTypeInfo);
-    LOAD_FUNC(SQLGetTypeInfoW);
-    LOAD_FUNC(SQLMoreResults);
-    LOAD_FUNC(SQLNativeSql);
-    LOAD_FUNC(SQLNativeSqlW);
-    LOAD_FUNC(SQLNumParams);
-    LOAD_FUNC(SQLNumResultCols);
-    LOAD_FUNC(SQLParamData);
-    LOAD_FUNC(SQLParamOptions);
-    LOAD_FUNC(SQLPrepare);
-    LOAD_FUNC(SQLPrepareW);
-    LOAD_FUNC(SQLPrimaryKeys);
-    LOAD_FUNC(SQLPrimaryKeysW);
-    LOAD_FUNC(SQLProcedureColumns);
-    LOAD_FUNC(SQLProcedureColumnsW);
-    LOAD_FUNC(SQLProcedures);
-    LOAD_FUNC(SQLProceduresW);
-    LOAD_FUNC(SQLPutData);
-    LOAD_FUNC(SQLRowCount);
-    LOAD_FUNC(SQLSetConnectAttr);
-    LOAD_FUNC(SQLSetConnectAttrW);
-    LOAD_FUNC(SQLSetConnectOption);
-    LOAD_FUNC(SQLSetConnectOptionW);
-    LOAD_FUNC(SQLSetCursorName);
-    LOAD_FUNC(SQLSetCursorNameW);
-    LOAD_FUNC(SQLSetDescField);
-    LOAD_FUNC(SQLSetDescFieldW);
-    LOAD_FUNC(SQLSetDescRec);
-    LOAD_FUNC(SQLSetEnvAttr);
-    LOAD_FUNC(SQLSetParam);
-    LOAD_FUNC(SQLSetPos);
-    LOAD_FUNC(SQLSetScrollOptions);
-    LOAD_FUNC(SQLSetStmtAttr);
-    LOAD_FUNC(SQLSetStmtAttrW);
-    LOAD_FUNC(SQLSetStmtOption);
-    LOAD_FUNC(SQLSpecialColumns);
-    LOAD_FUNC(SQLSpecialColumnsW);
-    LOAD_FUNC(SQLStatistics);
-    LOAD_FUNC(SQLStatisticsW);
-    LOAD_FUNC(SQLTablePrivileges);
-    LOAD_FUNC(SQLTablePrivilegesW);
-    LOAD_FUNC(SQLTables);
-    LOAD_FUNC(SQLTablesW);
-    LOAD_FUNC(SQLTransact);
-#undef LOAD_FUNC
-    return STATUS_SUCCESS;
-}
diff --git a/dlls/odbc32/unixlib.h b/dlls/odbc32/unixlib.h
deleted file mode 100644
index 13ce8d0..0000000
--- a/dlls/odbc32/unixlib.h
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
- * Win32 ODBC functions
- *
- * Copyright 1999 Xiang Li, Corel Corporation
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- *
- * NOTES:
- *   Proxy ODBC driver manager.  This manager delegates all ODBC
- *   calls to a real ODBC driver manager named by the environment
- *   variable LIB_ODBC_DRIVER_MANAGER, or to libodbc.so if the
- *   variable is not set.
- */
-
-#include <stdarg.h>
-
-#include "windef.h"
-#include "winbase.h"
-
-#include "sql.h"
-#include "sqltypes.h"
-#include "sqlext.h"
-
-#include "wine/unixlib.h"
-
-enum sql_funcs
-{
-    process_attach,
-    process_detach,
-    unix_SQLAllocConnect,
-    unix_SQLAllocEnv,
-    unix_SQLAllocHandle,
-    unix_SQLAllocHandleStd,
-    unix_SQLAllocStmt,
-    unix_SQLBindCol,
-    unix_SQLBindParam,
-    unix_SQLBindParameter,
-    unix_SQLBrowseConnect,
-    unix_SQLBrowseConnectW,
-    unix_SQLBulkOperations,
-    unix_SQLCancel,
-    unix_SQLCloseCursor,
-    unix_SQLColAttribute,
-    unix_SQLColAttributeW,
-    unix_SQLColAttributes,
-    unix_SQLColAttributesW,
-    unix_SQLColumnPrivileges,
-    unix_SQLColumnPrivilegesW,
-    unix_SQLColumns,
-    unix_SQLColumnsW,
-    unix_SQLConnect,
-    unix_SQLConnectW,
-    unix_SQLCopyDesc,
-    unix_SQLDataSources,
-    unix_SQLDataSourcesA,
-    unix_SQLDataSourcesW,
-    unix_SQLDescribeCol,
-    unix_SQLDescribeColW,
-    unix_SQLDescribeParam,
-    unix_SQLDisconnect,
-    unix_SQLDriverConnect,
-    unix_SQLDriverConnectW,
-    unix_SQLDrivers,
-    unix_SQLDriversW,
-    unix_SQLEndTran,
-    unix_SQLError,
-    unix_SQLErrorW,
-    unix_SQLExecDirect,
-    unix_SQLExecDirectW,
-    unix_SQLExecute,
-    unix_SQLExtendedFetch,
-    unix_SQLFetch,
-    unix_SQLFetchScroll,
-    unix_SQLForeignKeys,
-    unix_SQLForeignKeysW,
-    unix_SQLFreeConnect,
-    unix_SQLFreeEnv,
-    unix_SQLFreeHandle,
-    unix_SQLFreeStmt,
-    unix_SQLGetConnectAttr,
-    unix_SQLGetConnectAttrW,
-    unix_SQLGetConnectOption,
-    unix_SQLGetConnectOptionW,
-    unix_SQLGetCursorName,
-    unix_SQLGetCursorNameW,
-    unix_SQLGetData,
-    unix_SQLGetDescField,
-    unix_SQLGetDescFieldW,
-    unix_SQLGetDescRec,
-    unix_SQLGetDescRecW,
-    unix_SQLGetDiagField,
-    unix_SQLGetDiagFieldW,
-    unix_SQLGetDiagRec,
-    unix_SQLGetDiagRecA,
-    unix_SQLGetDiagRecW,
-    unix_SQLGetEnvAttr,
-    unix_SQLGetFunctions,
-    unix_SQLGetInfo,
-    unix_SQLGetInfoW,
-    unix_SQLGetStmtAttr,
-    unix_SQLGetStmtAttrW,
-    unix_SQLGetStmtOption,
-    unix_SQLGetTypeInfo,
-    unix_SQLGetTypeInfoW,
-    unix_SQLMoreResults,
-    unix_SQLNativeSql,
-    unix_SQLNativeSqlW,
-    unix_SQLNumParams,
-    unix_SQLNumResultCols,
-    unix_SQLParamData,
-    unix_SQLParamOptions,
-    unix_SQLPrepare,
-    unix_SQLPrepareW,
-    unix_SQLPrimaryKeys,
-    unix_SQLPrimaryKeysW,
-    unix_SQLProcedureColumns,
-    unix_SQLProcedureColumnsW,
-    unix_SQLProcedures,
-    unix_SQLProceduresW,
-    unix_SQLPutData,
-    unix_SQLRowCount,
-    unix_SQLSetConnectAttr,
-    unix_SQLSetConnectAttrW,
-    unix_SQLSetConnectOption,
-    unix_SQLSetConnectOptionW,
-    unix_SQLSetCursorName,
-    unix_SQLSetCursorNameW,
-    unix_SQLSetDescField,
-    unix_SQLSetDescFieldW,
-    unix_SQLSetDescRec,
-    unix_SQLSetEnvAttr,
-    unix_SQLSetParam,
-    unix_SQLSetPos,
-    unix_SQLSetScrollOptions,
-    unix_SQLSetStmtAttr,
-    unix_SQLSetStmtAttrW,
-    unix_SQLSetStmtOption,
-    unix_SQLSpecialColumns,
-    unix_SQLSpecialColumnsW,
-    unix_SQLStatistics,
-    unix_SQLStatisticsW,
-    unix_SQLTablePrivileges,
-    unix_SQLTablePrivilegesW,
-    unix_SQLTables,
-    unix_SQLTablesW,
-    unix_SQLTransact,
-    NB_ODBC_FUNCS
-};
-
-struct SQLAllocConnect_params { SQLHENV EnvironmentHandle; SQLHDBC *ConnectionHandle; };
-struct SQLAllocEnv_params { SQLHENV *EnvironmentHandle; };
-struct SQLAllocHandle_params { SQLSMALLINT HandleType; SQLHANDLE InputHandle; SQLHANDLE *OutputHandle; };
-struct SQLAllocHandleStd_params { SQLSMALLINT HandleType; SQLHANDLE InputHandle; SQLHANDLE *OutputHandle; };
-struct SQLAllocStmt_params { SQLHDBC ConnectionHandle; SQLHSTMT *StatementHandle; };
-struct SQLBindCol_params { SQLHSTMT StatementHandle; SQLUSMALLINT ColumnNumber; SQLSMALLINT TargetType; SQLPOINTER TargetValue; SQLLEN BufferLength; SQLLEN *StrLen_or_Ind; };
-struct SQLBindParam_params { SQLHSTMT StatementHandle; SQLUSMALLINT ParameterNumber; SQLSMALLINT ValueType; SQLSMALLINT ParameterType; SQLULEN LengthPrecision; SQLSMALLINT ParameterScale; SQLPOINTER ParameterValue; SQLLEN *StrLen_or_Ind; };
-struct SQLBindParameter_params { SQLHSTMT hstmt; SQLUSMALLINT ipar; SQLSMALLINT fParamType; SQLSMALLINT fCType; SQLSMALLINT fSqlType; SQLULEN cbColDef; SQLSMALLINT ibScale; SQLPOINTER rgbValue; SQLLEN cbValueMax; SQLLEN *pcbValue; };
-struct SQLBrowseConnect_params { SQLHDBC hdbc; SQLCHAR *szConnStrIn; SQLSMALLINT cbConnStrIn; SQLCHAR *szConnStrOut; SQLSMALLINT cbConnStrOutMax; SQLSMALLINT *pcbConnStrOut; };
-struct SQLBrowseConnectW_params { SQLHDBC hdbc; SQLWCHAR *szConnStrIn; SQLSMALLINT cbConnStrIn; SQLWCHAR *szConnStrOut; SQLSMALLINT cbConnStrOutMax; SQLSMALLINT *pcbConnStrOut; };
-struct SQLBulkOperations_params { SQLHSTMT StatementHandle; SQLSMALLINT Operation; };
-struct SQLCancel_params { SQLHSTMT StatementHandle; };
-struct SQLCloseCursor_params { SQLHSTMT StatementHandle; };
-struct SQLColAttribute_params { SQLHSTMT StatementHandle; SQLUSMALLINT ColumnNumber; SQLUSMALLINT FieldIdentifier; SQLPOINTER CharacterAttribute; SQLSMALLINT BufferLength; SQLSMALLINT *StringLength; SQLLEN *NumericAttribute; };
-struct SQLColAttributeW_params { SQLHSTMT StatementHandle; SQLUSMALLINT ColumnNumber; SQLUSMALLINT FieldIdentifier; SQLPOINTER CharacterAttribute; SQLSMALLINT BufferLength; SQLSMALLINT *StringLength; SQLLEN *NumericAttribute; };
-struct SQLColAttributes_params { SQLHSTMT hstmt; SQLUSMALLINT icol; SQLUSMALLINT fDescType; SQLPOINTER rgbDesc; SQLSMALLINT cbDescMax; SQLSMALLINT *pcbDesc; SQLLEN *pfDesc; };
-struct SQLColAttributesW_params { SQLHSTMT hstmt; SQLUSMALLINT icol; SQLUSMALLINT fDescType; SQLPOINTER rgbDesc; SQLSMALLINT cbDescMax; SQLSMALLINT *pcbDesc; SQLLEN *pfDesc; };
-struct SQLColumnPrivileges_params { SQLHSTMT hstmt; SQLCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLCHAR *szTableName; SQLSMALLINT cbTableName; SQLCHAR *szColumnName; SQLSMALLINT cbColumnName; };
-struct SQLColumnPrivilegesW_params { SQLHSTMT hstmt; SQLWCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLWCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLWCHAR *szTableName; SQLSMALLINT cbTableName; SQLWCHAR *szColumnName; SQLSMALLINT cbColumnName; };
-struct SQLColumns_params { SQLHSTMT StatementHandle; SQLCHAR *CatalogName; SQLSMALLINT NameLength1; SQLCHAR *SchemaName; SQLSMALLINT NameLength2; SQLCHAR *TableName; SQLSMALLINT NameLength3; SQLCHAR *ColumnName; SQLSMALLINT NameLength4; };
-struct SQLColumnsW_params { SQLHSTMT StatementHandle; WCHAR *CatalogName; SQLSMALLINT NameLength1; WCHAR *SchemaName; SQLSMALLINT NameLength2; WCHAR *TableName; SQLSMALLINT NameLength3; WCHAR *ColumnName; SQLSMALLINT NameLength4; };
-struct SQLConnect_params { SQLHDBC ConnectionHandle; SQLCHAR *ServerName; SQLSMALLINT NameLength1; SQLCHAR *UserName; SQLSMALLINT NameLength2; SQLCHAR *Authentication; SQLSMALLINT NameLength3; };
-struct SQLConnectW_params { SQLHDBC ConnectionHandle; WCHAR *ServerName; SQLSMALLINT NameLength1; WCHAR *UserName; SQLSMALLINT NameLength2; WCHAR *Authentication; SQLSMALLINT NameLength3; };
-struct SQLCopyDesc_params { SQLHDESC SourceDescHandle; SQLHDESC TargetDescHandle; };
-struct SQLDataSources_params { SQLHENV EnvironmentHandle; SQLUSMALLINT Direction; SQLCHAR *ServerName; SQLSMALLINT BufferLength1; SQLSMALLINT *NameLength1; SQLCHAR *Description; SQLSMALLINT BufferLength2; SQLSMALLINT *NameLength2; };
-struct SQLDataSourcesA_params { SQLHENV EnvironmentHandle; SQLUSMALLINT Direction; SQLCHAR *ServerName; SQLSMALLINT BufferLength1; SQLSMALLINT *NameLength1; SQLCHAR *Description; SQLSMALLINT BufferLength2; SQLSMALLINT *NameLength2; };
-struct SQLDataSourcesW_params { SQLHENV EnvironmentHandle; SQLUSMALLINT Direction; WCHAR *ServerName; SQLSMALLINT BufferLength1; SQLSMALLINT *NameLength1; WCHAR *Description; SQLSMALLINT BufferLength2; SQLSMALLINT *NameLength2; };
-struct SQLDescribeCol_params { SQLHSTMT StatementHandle; SQLUSMALLINT ColumnNumber; SQLCHAR *ColumnName; SQLSMALLINT BufferLength; SQLSMALLINT *NameLength; SQLSMALLINT *DataType; SQLULEN *ColumnSize; SQLSMALLINT *DecimalDigits; SQLSMALLINT *Nullable; };
-struct SQLDescribeColW_params { SQLHSTMT StatementHandle; SQLUSMALLINT ColumnNumber; WCHAR *ColumnName; SQLSMALLINT BufferLength; SQLSMALLINT *NameLength; SQLSMALLINT *DataType; SQLULEN *ColumnSize; SQLSMALLINT *DecimalDigits; SQLSMALLINT *Nullable; };
-struct SQLDescribeParam_params { SQLHSTMT hstmt; SQLUSMALLINT ipar; SQLSMALLINT *pfSqlType; SQLULEN *pcbParamDef; SQLSMALLINT *pibScale; SQLSMALLINT *pfNullable; };
-struct SQLDisconnect_params { SQLHDBC ConnectionHandle; };
-struct SQLDriverConnect_params { SQLHDBC hdbc; SQLHWND hwnd; SQLCHAR *ConnectionString; SQLSMALLINT Length; SQLCHAR *conn_str_out; SQLSMALLINT conn_str_out_max; SQLSMALLINT *ptr_conn_str_out; SQLUSMALLINT driver_completion; };
-struct SQLDriverConnectW_params { SQLHDBC ConnectionHandle; SQLHWND WindowHandle; WCHAR *InConnectionString; SQLSMALLINT Length; WCHAR *OutConnectionString; SQLSMALLINT BufferLength; SQLSMALLINT *Length2; SQLUSMALLINT DriverCompletion; };
-struct SQLDrivers_params { SQLHENV EnvironmentHandle; SQLUSMALLINT fDirection; SQLCHAR *szDriverDesc; SQLSMALLINT cbDriverDescMax; SQLSMALLINT *pcbDriverDesc; SQLCHAR *szDriverAttributes; SQLSMALLINT cbDriverAttrMax; SQLSMALLINT *pcbDriverAttr; };
-struct SQLDriversW_params { SQLHENV EnvironmentHandle; SQLUSMALLINT fDirection; SQLWCHAR *szDriverDesc; SQLSMALLINT cbDriverDescMax; SQLSMALLINT *pcbDriverDesc; SQLWCHAR *szDriverAttributes; SQLSMALLINT cbDriverAttrMax; SQLSMALLINT *pcbDriverAttr; };
-struct SQLEndTran_params { SQLSMALLINT HandleType; SQLHANDLE Handle; SQLSMALLINT CompletionType; };
-struct SQLError_params { SQLHENV EnvironmentHandle; SQLHDBC ConnectionHandle; SQLHSTMT StatementHandle; SQLCHAR *Sqlstate; SQLINTEGER *NativeError; SQLCHAR *MessageText; SQLSMALLINT BufferLength; SQLSMALLINT *TextLength; };
-struct SQLErrorW_params { SQLHENV EnvironmentHandle; SQLHDBC ConnectionHandle; SQLHSTMT StatementHandle; WCHAR *Sqlstate; SQLINTEGER *NativeError; WCHAR *MessageText; SQLSMALLINT BufferLength; SQLSMALLINT *TextLength; };
-struct SQLExecDirect_params { SQLHSTMT StatementHandle; SQLCHAR *StatementText; SQLINTEGER TextLength; };
-struct SQLExecDirectW_params { SQLHSTMT StatementHandle; WCHAR *StatementText; SQLINTEGER TextLength; };
-struct SQLExecute_params { SQLHSTMT StatementHandle; };
-struct SQLExtendedFetch_params { SQLHSTMT hstmt; SQLUSMALLINT fFetchType; SQLLEN irow; SQLULEN *pcrow; SQLUSMALLINT *rgfRowStatus; };
-struct SQLFetch_params { SQLHSTMT StatementHandle; };
-struct SQLFetchScroll_params { SQLHSTMT StatementHandle; SQLSMALLINT FetchOrientation; SQLLEN FetchOffset; };
-struct SQLForeignKeys_params { SQLHSTMT hstmt; SQLCHAR *szPkCatalogName; SQLSMALLINT cbPkCatalogName; SQLCHAR *szPkSchemaName; SQLSMALLINT cbPkSchemaName; SQLCHAR *szPkTableName; SQLSMALLINT cbPkTableName; SQLCHAR *szFkCatalogName; SQLSMALLINT cbFkCatalogName; SQLCHAR *szFkSchemaName; SQLSMALLINT cbFkSchemaName; SQLCHAR *szFkTableName; SQLSMALLINT cbFkTableName; };
-struct SQLForeignKeysW_params { SQLHSTMT hstmt; SQLWCHAR *szPkCatalogName; SQLSMALLINT cbPkCatalogName; SQLWCHAR *szPkSchemaName; SQLSMALLINT cbPkSchemaName; SQLWCHAR *szPkTableName; SQLSMALLINT cbPkTableName; SQLWCHAR *szFkCatalogName; SQLSMALLINT cbFkCatalogName; SQLWCHAR *szFkSchemaName; SQLSMALLINT cbFkSchemaName; SQLWCHAR *szFkTableName; SQLSMALLINT cbFkTableName; };
-struct SQLFreeConnect_params { SQLHDBC ConnectionHandle; };
-struct SQLFreeEnv_params { SQLHENV EnvironmentHandle; };
-struct SQLFreeHandle_params { SQLSMALLINT HandleType; SQLHANDLE Handle; };
-struct SQLFreeStmt_params { SQLHSTMT StatementHandle; SQLUSMALLINT Option; };
-struct SQLGetConnectAttr_params { SQLHDBC ConnectionHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER BufferLength; SQLINTEGER *StringLength; };
-struct SQLGetConnectAttrW_params { SQLHDBC ConnectionHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER BufferLength; SQLINTEGER *StringLength; };
-struct SQLGetConnectOption_params { SQLHDBC ConnectionHandle; SQLUSMALLINT Option; SQLPOINTER Value; };
-struct SQLGetConnectOptionW_params { SQLHDBC ConnectionHandle; SQLUSMALLINT Option; SQLPOINTER Value; };
-struct SQLGetCursorName_params { SQLHSTMT StatementHandle; SQLCHAR *CursorName; SQLSMALLINT BufferLength; SQLSMALLINT *NameLength; };
-struct SQLGetCursorNameW_params { SQLHSTMT StatementHandle; WCHAR *CursorName; SQLSMALLINT BufferLength; SQLSMALLINT *NameLength; };
-struct SQLGetData_params { SQLHSTMT StatementHandle; SQLUSMALLINT ColumnNumber; SQLSMALLINT TargetType; SQLPOINTER TargetValue; SQLLEN BufferLength; SQLLEN *StrLen_or_Ind; };
-struct SQLGetDescField_params { SQLHDESC DescriptorHandle; SQLSMALLINT RecNumber; SQLSMALLINT FieldIdentifier; SQLPOINTER Value; SQLINTEGER BufferLength; SQLINTEGER *StringLength; };
-struct SQLGetDescFieldW_params { SQLHDESC DescriptorHandle; SQLSMALLINT RecNumber; SQLSMALLINT FieldIdentifier; SQLPOINTER Value; SQLINTEGER BufferLength; SQLINTEGER *StringLength; };
-struct SQLGetDescRec_params { SQLHDESC DescriptorHandle; SQLSMALLINT RecNumber; SQLCHAR *Name; SQLSMALLINT BufferLength; SQLSMALLINT *StringLength; SQLSMALLINT *Type; SQLSMALLINT *SubType; SQLLEN *Length; SQLSMALLINT *Precision; SQLSMALLINT *Scale; SQLSMALLINT *Nullable; };
-struct SQLGetDescRecW_params { SQLHDESC DescriptorHandle; SQLSMALLINT RecNumber; WCHAR *Name; SQLSMALLINT BufferLength; SQLSMALLINT *StringLength; SQLSMALLINT *Type; SQLSMALLINT *SubType; SQLLEN *Length; SQLSMALLINT *Precision; SQLSMALLINT *Scale; SQLSMALLINT *Nullable; };
-struct SQLGetDiagField_params { SQLSMALLINT HandleType; SQLHANDLE Handle; SQLSMALLINT RecNumber; SQLSMALLINT DiagIdentifier; SQLPOINTER DiagInfo; SQLSMALLINT BufferLength; SQLSMALLINT *StringLength; };
-struct SQLGetDiagFieldW_params { SQLSMALLINT HandleType; SQLHANDLE Handle; SQLSMALLINT RecNumber; SQLSMALLINT DiagIdentifier; SQLPOINTER DiagInfo; SQLSMALLINT BufferLength; SQLSMALLINT *StringLength; };
-struct SQLGetDiagRec_params { SQLSMALLINT HandleType; SQLHANDLE Handle; SQLSMALLINT RecNumber; SQLCHAR *Sqlstate; SQLINTEGER *NativeError; SQLCHAR *MessageText; SQLSMALLINT BufferLength; SQLSMALLINT *TextLength; };
-struct SQLGetDiagRecA_params { SQLSMALLINT HandleType; SQLHANDLE Handle; SQLSMALLINT RecNumber; SQLCHAR *Sqlstate; SQLINTEGER *NativeError; SQLCHAR *MessageText; SQLSMALLINT BufferLength; SQLSMALLINT *TextLength; };
-struct SQLGetDiagRecW_params { SQLSMALLINT HandleType; SQLHANDLE Handle; SQLSMALLINT RecNumber; WCHAR *Sqlstate; SQLINTEGER *NativeError; WCHAR *MessageText; SQLSMALLINT BufferLength; SQLSMALLINT *TextLength; };
-struct SQLGetEnvAttr_params { SQLHENV EnvironmentHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER BufferLength; SQLINTEGER *StringLength; };
-struct SQLGetFunctions_params { SQLHDBC ConnectionHandle; SQLUSMALLINT FunctionId; SQLUSMALLINT *Supported; };
-struct SQLGetInfo_params { SQLHDBC ConnectionHandle; SQLUSMALLINT InfoType; SQLPOINTER InfoValue; SQLSMALLINT BufferLength; SQLSMALLINT *StringLength; };
-struct SQLGetInfoW_params { SQLHDBC ConnectionHandle; SQLUSMALLINT InfoType; SQLPOINTER InfoValue; SQLSMALLINT BufferLength; SQLSMALLINT *StringLength; };
-struct SQLGetStmtAttr_params { SQLHSTMT StatementHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER BufferLength; SQLINTEGER *StringLength; };
-struct SQLGetStmtAttrW_params { SQLHSTMT StatementHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER BufferLength; SQLINTEGER *StringLength; };
-struct SQLGetStmtOption_params { SQLHSTMT StatementHandle; SQLUSMALLINT Option; SQLPOINTER Value; };
-struct SQLGetTypeInfo_params { SQLHSTMT StatementHandle; SQLSMALLINT DataType; };
-struct SQLGetTypeInfoW_params { SQLHSTMT StatementHandle; SQLSMALLINT DataType; };
-struct SQLMoreResults_params { SQLHSTMT StatementHandle; };
-struct SQLNativeSql_params { SQLHDBC hdbc; SQLCHAR *szSqlStrIn; SQLINTEGER cbSqlStrIn; SQLCHAR *szSqlStr; SQLINTEGER cbSqlStrMax; SQLINTEGER *pcbSqlStr; };
-struct SQLNativeSqlW_params { SQLHDBC hdbc; SQLWCHAR *szSqlStrIn; SQLINTEGER cbSqlStrIn; SQLWCHAR *szSqlStr; SQLINTEGER cbSqlStrMax; SQLINTEGER *pcbSqlStr; };
-struct SQLNumParams_params { SQLHSTMT hstmt; SQLSMALLINT *pcpar; };
-struct SQLNumResultCols_params { SQLHSTMT StatementHandle; SQLSMALLINT *ColumnCount; };
-struct SQLParamData_params { SQLHSTMT StatementHandle; SQLPOINTER *Value; };
-struct SQLParamOptions_params { SQLHSTMT hstmt; SQLULEN crow; SQLULEN *pirow; };
-struct SQLPrepare_params { SQLHSTMT StatementHandle; SQLCHAR *StatementText; SQLINTEGER TextLength; };
-struct SQLPrepareW_params { SQLHSTMT StatementHandle; WCHAR *StatementText; SQLINTEGER TextLength; };
-struct SQLPrimaryKeys_params { SQLHSTMT hstmt; SQLCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLCHAR *szTableName; SQLSMALLINT cbTableName; };
-struct SQLPrimaryKeysW_params { SQLHSTMT hstmt; SQLWCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLWCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLWCHAR *szTableName; SQLSMALLINT cbTableName; };
-struct SQLProcedureColumns_params { SQLHSTMT hstmt; SQLCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLCHAR *szProcName; SQLSMALLINT cbProcName; SQLCHAR *szColumnName; SQLSMALLINT cbColumnName; };
-struct SQLProcedureColumnsW_params { SQLHSTMT hstmt; SQLWCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLWCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLWCHAR *szProcName; SQLSMALLINT cbProcName; SQLWCHAR *szColumnName; SQLSMALLINT cbColumnName; };
-struct SQLProcedures_params { SQLHSTMT hstmt; SQLCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLCHAR *szProcName; SQLSMALLINT cbProcName; };
-struct SQLProceduresW_params { SQLHSTMT hstmt; SQLWCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLWCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLWCHAR *szProcName; SQLSMALLINT cbProcName; };
-struct SQLPutData_params { SQLHSTMT StatementHandle; SQLPOINTER Data; SQLLEN StrLen_or_Ind; };
-struct SQLRowCount_params { SQLHSTMT StatementHandle; SQLLEN *RowCount; };
-struct SQLSetConnectAttr_params { SQLHDBC ConnectionHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER StringLength; };
-struct SQLSetConnectAttrW_params { SQLHDBC ConnectionHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER StringLength; };
-struct SQLSetConnectOption_params { SQLHDBC ConnectionHandle; SQLUSMALLINT Option; SQLULEN Value; };
-struct SQLSetConnectOptionW_params { SQLHDBC ConnectionHandle; SQLUSMALLINT Option; SQLULEN Value; };
-struct SQLSetCursorName_params { SQLHSTMT StatementHandle; SQLCHAR *CursorName; SQLSMALLINT NameLength; };
-struct SQLSetCursorNameW_params { SQLHSTMT StatementHandle; WCHAR *CursorName; SQLSMALLINT NameLength; };
-struct SQLSetDescField_params { SQLHDESC DescriptorHandle; SQLSMALLINT RecNumber; SQLSMALLINT FieldIdentifier; SQLPOINTER Value; SQLINTEGER BufferLength; };
-struct SQLSetDescFieldW_params { SQLHDESC DescriptorHandle; SQLSMALLINT RecNumber; SQLSMALLINT FieldIdentifier; SQLPOINTER Value; SQLINTEGER BufferLength; };
-struct SQLSetDescRec_params { SQLHDESC DescriptorHandle; SQLSMALLINT RecNumber; SQLSMALLINT Type; SQLSMALLINT SubType; SQLLEN Length; SQLSMALLINT Precision; SQLSMALLINT Scale; SQLPOINTER Data; SQLLEN *StringLength; SQLLEN *Indicator; };
-struct SQLSetEnvAttr_params { SQLHENV EnvironmentHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER StringLength; };
-struct SQLSetParam_params { SQLHSTMT StatementHandle; SQLUSMALLINT ParameterNumber; SQLSMALLINT ValueType; SQLSMALLINT ParameterType; SQLULEN LengthPrecision; SQLSMALLINT ParameterScale; SQLPOINTER ParameterValue; SQLLEN *StrLen_or_Ind; };
-struct SQLSetPos_params { SQLHSTMT hstmt; SQLSETPOSIROW irow; SQLUSMALLINT fOption; SQLUSMALLINT fLock; };
-struct SQLSetScrollOptions_params { SQLHSTMT statement_handle; SQLUSMALLINT f_concurrency; SQLLEN crow_keyset; SQLUSMALLINT crow_rowset; };
-struct SQLSetStmtAttr_params { SQLHSTMT StatementHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER StringLength; };
-struct SQLSetStmtAttrW_params { SQLHSTMT StatementHandle; SQLINTEGER Attribute; SQLPOINTER Value; SQLINTEGER StringLength; };
-struct SQLSetStmtOption_params { SQLHSTMT StatementHandle; SQLUSMALLINT Option; SQLULEN Value; };
-struct SQLSpecialColumns_params { SQLHSTMT StatementHandle; SQLUSMALLINT IdentifierType; SQLCHAR *CatalogName; SQLSMALLINT NameLength1; SQLCHAR *SchemaName; SQLSMALLINT NameLength2; SQLCHAR *TableName; SQLSMALLINT NameLength3; SQLUSMALLINT Scope; SQLUSMALLINT Nullable; };
-struct SQLSpecialColumnsW_params { SQLHSTMT StatementHandle; SQLUSMALLINT IdentifierType; SQLWCHAR *CatalogName; SQLSMALLINT NameLength1; SQLWCHAR *SchemaName; SQLSMALLINT NameLength2; SQLWCHAR *TableName; SQLSMALLINT NameLength3; SQLUSMALLINT Scope; SQLUSMALLINT Nullable; };
-struct SQLStatistics_params { SQLHSTMT StatementHandle; SQLCHAR *CatalogName; SQLSMALLINT NameLength1; SQLCHAR *SchemaName; SQLSMALLINT NameLength2; SQLCHAR *TableName; SQLSMALLINT NameLength3; SQLUSMALLINT Unique; SQLUSMALLINT Reserved; };
-struct SQLStatisticsW_params { SQLHSTMT StatementHandle; SQLWCHAR *CatalogName; SQLSMALLINT NameLength1; SQLWCHAR *SchemaName; SQLSMALLINT NameLength2; SQLWCHAR *TableName; SQLSMALLINT NameLength3; SQLUSMALLINT Unique; SQLUSMALLINT Reserved; };
-struct SQLTablePrivileges_params { SQLHSTMT hstmt; SQLCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLCHAR *szTableName; SQLSMALLINT cbTableName; };
-struct SQLTablePrivilegesW_params { SQLHSTMT hstmt; SQLWCHAR *szCatalogName; SQLSMALLINT cbCatalogName; SQLWCHAR *szSchemaName; SQLSMALLINT cbSchemaName; SQLWCHAR *szTableName; SQLSMALLINT cbTableName; };
-struct SQLTables_params { SQLHSTMT StatementHandle; SQLCHAR *CatalogName; SQLSMALLINT NameLength1; SQLCHAR *SchemaName; SQLSMALLINT NameLength2; SQLCHAR *TableName; SQLSMALLINT NameLength3; SQLCHAR *TableType; SQLSMALLINT NameLength4; };
-struct SQLTablesW_params { SQLHSTMT StatementHandle; SQLWCHAR *CatalogName; SQLSMALLINT NameLength1; SQLWCHAR *SchemaName; SQLSMALLINT NameLength2; SQLWCHAR *TableName; SQLSMALLINT NameLength3; SQLWCHAR *TableType; SQLSMALLINT NameLength4; };
-struct SQLTransact_params { SQLHENV EnvironmentHandle; SQLHDBC ConnectionHandle; SQLUSMALLINT CompletionType; };
diff --git a/dlls/oleaut32/oleaut.c b/dlls/oleaut32/oleaut.c
index 1ba6385..44979ea 100644
--- a/dlls/oleaut32/oleaut.c
+++ b/dlls/oleaut32/oleaut.c
@@ -117,7 +117,7 @@ static inline size_t bstr_alloc_size(size_t size)
 
 static inline bstr_t *bstr_from_str(BSTR str)
 {
-    return CONTAINING_RECORD(str, bstr_t, u.str);
+    return CONTAINING_RECORD((void *)str, bstr_t, u.str);
 }
 
 static inline bstr_cache_entry_t *get_cache_entry_from_idx(unsigned cache_idx)
diff --git a/dlls/oleaut32/olepicture.c b/dlls/oleaut32/olepicture.c
index 36de9c3..f30b3d0 100644
--- a/dlls/oleaut32/olepicture.c
+++ b/dlls/oleaut32/olepicture.c
@@ -149,6 +149,8 @@ typedef struct OLEPictureImpl {
     BOOL bIsDirty;                  /* Set to TRUE if picture has changed */
     unsigned int loadtime_magic;    /* If a length header was found, saves value */
     unsigned int loadtime_format;   /* for PICTYPE_BITMAP only, keeps track of image format (GIF/BMP/JPEG) */
+    DWORD desiredWidth;
+    DWORD desiredHeight;
 } OLEPictureImpl;
 
 static inline OLEPictureImpl *impl_from_IPicture(IPicture *iface)
@@ -256,6 +258,18 @@ static void OLEPictureImpl_SetIcon(OLEPictureImpl * This)
     }
 }
 
+static void OLEPictureImpl_SetEMF(OLEPictureImpl *This)
+{
+    ENHMETAHEADER emh;
+
+    GetEnhMetaFileHeader(This->desc.emf.hemf, sizeof(emh), &emh);
+
+    This->origWidth = 0;
+    This->origHeight = 0;
+    This->himetricWidth = emh.rclFrame.right - emh.rclFrame.left;
+    This->himetricHeight = emh.rclFrame.bottom - emh.rclFrame.top;
+}
+
 /************************************************************************
  * OLEPictureImpl_Construct
  *
@@ -339,8 +353,7 @@ static HRESULT OLEPictureImpl_Construct(LPPICTDESC pictDesc, BOOL fOwn, OLEPictu
         break;
 
       case PICTYPE_ENHMETAFILE:
-        FIXME("EMF is not supported\n");
-        newObject->himetricWidth = newObject->himetricHeight = 0;
+        OLEPictureImpl_SetEMF(newObject);
         break;
 
       default:
@@ -819,19 +832,6 @@ static HRESULT WINAPI OLEPictureImpl_PictureChanged(IPicture *iface)
   return S_OK;
 }
 
-/************************************************************************
- * OLEPictureImpl_SaveAsFile
- */
-static HRESULT WINAPI OLEPictureImpl_SaveAsFile(IPicture *iface,
-						IStream *pstream,
-						BOOL SaveMemCopy,
-						LONG *pcbSize)
-{
-  OLEPictureImpl *This = impl_from_IPicture(iface);
-  FIXME("(%p)->(%p, %d, %p), hacked stub.\n", This, pstream, SaveMemCopy, pcbSize);
-  return IStream_Write(pstream,This->data,This->datalen,(ULONG*)pcbSize);
-}
-
 /************************************************************************
  * OLEPictureImpl_get_Attributes
  */
@@ -981,40 +981,13 @@ static HRESULT WINAPI OLEPictureImpl_IsDirty(
   return E_NOTIMPL;
 }
 
-static HRESULT OLEPictureImpl_LoadDIB(OLEPictureImpl *This, BYTE *xbuf, ULONG xread)
-{
-    BITMAPFILEHEADER	*bfh = (BITMAPFILEHEADER*)xbuf;
-    BITMAPINFO		*bi = (BITMAPINFO*)(bfh+1);
-    HDC			hdcref;
-
-    /* Does not matter whether this is a coreheader or not, we only use
-     * components which are in both
-     */
-    hdcref = GetDC(0);
-    This->desc.bmp.hbitmap = CreateDIBitmap(
-	hdcref,
-	&(bi->bmiHeader),
-	CBM_INIT,
-	xbuf+bfh->bfOffBits,
-	bi,
-       DIB_RGB_COLORS
-    );
-    ReleaseDC(0, hdcref);
-    if (This->desc.bmp.hbitmap == 0)
-        return E_FAIL;
-    This->desc.picType = PICTYPE_BITMAP;
-    OLEPictureImpl_SetBitmap(This);
-    return S_OK;
-}
-
 static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSource *src)
 {
     HRESULT hr;
     BITMAPINFOHEADER bih;
-    HDC hdcref;
     UINT width, height;
     UINT stride, buffersize;
-    LPBYTE bits=NULL;
+    BYTE *bits, *mask = NULL;
     WICRect rc;
     IWICBitmapSource *real_source;
     UINT x, y;
@@ -1042,34 +1015,28 @@ static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSour
     stride = 4 * width;
     buffersize = stride * height;
 
-    bits = malloc(buffersize);
-    if (!bits)
+    mask = malloc(buffersize);
+    if (!mask)
     {
         hr = E_OUTOFMEMORY;
         goto end;
     }
 
+    This->desc.bmp.hbitmap = CreateDIBSection(0, (BITMAPINFO*)&bih, DIB_RGB_COLORS, (void **)&bits, NULL, 0);
+    if (This->desc.bmp.hbitmap == 0)
+    {
+        hr = E_FAIL;
+        goto end;
+    }
+
     rc.X = 0;
     rc.Y = 0;
     rc.Width = width;
     rc.Height = height;
     hr = IWICBitmapSource_CopyPixels(real_source, &rc, stride, buffersize, bits);
     if (FAILED(hr))
-        goto end;
-
-    hdcref = GetDC(0);
-    This->desc.bmp.hbitmap = CreateDIBitmap(
-        hdcref,
-        &bih,
-        CBM_INIT,
-        bits,
-        (BITMAPINFO*)&bih,
-        DIB_RGB_COLORS);
-
-    if (This->desc.bmp.hbitmap == 0)
     {
-        hr = E_FAIL;
-        ReleaseDC(0, hdcref);
+        DeleteObject(This->desc.bmp.hbitmap);
         goto end;
     }
 
@@ -1083,23 +1050,25 @@ static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSour
             if((*pixel & 0x80000000) == 0)
             {
                 has_alpha = TRUE;
-                *pixel = black;
+                *(DWORD *)(mask + stride * y + 4 * x) = black;
             }
             else
-                *pixel = white;
+                *(DWORD *)(mask + stride * y + 4 * x) = white;
         }
     }
 
     if (has_alpha)
     {
-        HDC hdcBmp, hdcXor, hdcMask;
+        HDC hdcref, hdcBmp, hdcXor, hdcMask;
         HBITMAP hbmoldBmp, hbmoldXor, hbmoldMask;
 
+        hdcref = GetDC(0);
+
         This->hbmXor = CreateDIBitmap(
             hdcref,
             &bih,
             CBM_INIT,
-            bits,
+            mask,
             (BITMAPINFO*)&bih,
             DIB_RGB_COLORS
         );
@@ -1124,12 +1093,11 @@ static HRESULT OLEPictureImpl_LoadWICSource(OLEPictureImpl *This, IWICBitmapSour
         DeleteDC(hdcBmp);
         DeleteDC(hdcXor);
         DeleteDC(hdcMask);
+        ReleaseDC(0, hdcref);
     }
 
-    ReleaseDC(0, hdcref);
-
 end:
-    free(bits);
+    free(mask);
     IWICBitmapSource_Release(real_source);
     return hr;
 }
@@ -1222,14 +1190,20 @@ static HRESULT OLEPictureImpl_LoadIcon(OLEPictureImpl *This, BYTE *xbuf, ULONG x
         return E_FAIL;
     }
     i=0;
-    /* If we have more than one icon, try to find the best.
-     * this currently means '32 pixel wide'.
-     */
     if (cifd->idCount!=1) {
+	/* First try exact match on the desired dimensions */
 	for (i=0;i<cifd->idCount;i++) {
-	    if (cifd->idEntries[i].bWidth == 32)
+	    if (cifd->idEntries[i].bWidth == This->desiredWidth &&
+		cifd->idEntries[i].bHeight == This->desiredHeight)
 		break;
 	}
+	/* Otherwise, try to find the best. This currently means '32 pixel wide'. */
+	if (i==cifd->idCount) {
+	    for (i=0;i<cifd->idCount;i++) {
+		if (cifd->idEntries[i].bWidth == 32)
+		    break;
+	    }
+	}
 	if (i==cifd->idCount) i=0;
     }
     if (xread < cifd->idEntries[i].dwDIBOffset + cifd->idEntries[i].dwDIBSize)
@@ -1494,7 +1468,7 @@ static HRESULT WINAPI OLEPictureImpl_Load(IPersistStream* iface, IStream *pStm)
     hr = OLEPictureImpl_LoadWICDecoder(This, &CLSID_WICJpegDecoder, xbuf, xread);
     break;
   case BITMAP_FORMAT_BMP: /* Bitmap */
-    hr = OLEPictureImpl_LoadDIB(This, xbuf, xread);
+    hr = OLEPictureImpl_LoadWICDecoder(This, &CLSID_WICBmpDecoder, xbuf, xread);
     break;
   case BITMAP_FORMAT_PNG: /* PNG */
     hr = OLEPictureImpl_LoadWICDecoder(This, &CLSID_WICPngDecoder, xbuf, xread);
@@ -1747,6 +1721,17 @@ static BOOL serializeIcon(HICON hIcon, void ** ppBuffer, unsigned int * pLength)
         return success;
 }
 
+static BOOL serializeEMF(HENHMETAFILE hemf, void **buf, unsigned *size)
+{
+    *size = GetEnhMetaFileBits(hemf, 0, NULL);
+    if (!*size) return FALSE;
+
+    *buf = HeapAlloc(GetProcessHeap(), 0, *size);
+    if (!*buf) return FALSE;
+
+    return GetEnhMetaFileBits(hemf, *size, *buf) != 0;
+}
+
 static HRESULT WINAPI OLEPictureImpl_Save(
   IPersistStream* iface,IStream*pStm,BOOL fClearDirty)
 {
@@ -1822,12 +1807,31 @@ static HRESULT WINAPI OLEPictureImpl_Save(
         IStream_Write(pStm, This->data, This->datalen, &dummy);
         hResult = S_OK;
         break;
+
+    case PICTYPE_ENHMETAFILE:
+        if (This->bIsDirty || !This->data)
+        {
+            serializeResult = serializeEMF(This->desc.emf.hemf, &pIconData, &iDataSize);
+            if (!serializeResult)
+            {
+                hResult = E_FAIL;
+                break;
+            }
+
+            HeapFree(GetProcessHeap(), 0, This->data);
+            This->data = pIconData;
+            This->datalen = iDataSize;
+        }
+        header[0] = 0x0000746c;
+        header[1] = This->datalen;
+        IStream_Write(pStm, header, 2 * sizeof(DWORD), &dummy);
+        IStream_Write(pStm, This->data, This->datalen, &dummy);
+        hResult = S_OK;
+        break;
+
     case PICTYPE_METAFILE:
         FIXME("(%p,%p,%d), PICTYPE_METAFILE not implemented!\n",This,pStm,fClearDirty);
         break;
-    case PICTYPE_ENHMETAFILE:
-        FIXME("(%p,%p,%d),PICTYPE_ENHMETAFILE not implemented!\n",This,pStm,fClearDirty);
-        break;
     default:
         FIXME("(%p,%p,%d), [unknown type] not implemented!\n",This,pStm,fClearDirty);
         break;
@@ -1844,6 +1848,98 @@ static HRESULT WINAPI OLEPictureImpl_GetSizeMax(
   return E_NOTIMPL;
 }
 
+/************************************************************************
+ * OLEPictureImpl_SaveAsFile
+ */
+static HRESULT WINAPI OLEPictureImpl_SaveAsFile(IPicture *iface,
+    IStream *stream, BOOL mem_copy, LONG *size)
+{
+    OLEPictureImpl *This = impl_from_IPicture(iface);
+    void *data;
+    unsigned data_size;
+    ULONG written;
+    HRESULT hr;
+
+    FIXME("(%p)->(%p,%d,%p): semi-stub\n", This, stream, mem_copy, size);
+
+    switch (This->desc.picType)
+    {
+    case PICTYPE_NONE:
+        return S_OK;
+
+    case PICTYPE_ICON:
+        if (!mem_copy) return E_FAIL;
+
+        if (This->bIsDirty || !This->data)
+        {
+            if (!serializeIcon(This->desc.icon.hicon, &data, &data_size))
+                return E_FAIL;
+            HeapFree(GetProcessHeap(), 0, This->data);
+            This->data = data;
+            This->datalen = data_size;
+        }
+        hr = IStream_Write(stream, This->data, This->datalen, &written);
+        if (hr == S_OK && size) *size = written;
+        return hr;
+
+    case PICTYPE_BITMAP:
+        if (!mem_copy) return E_FAIL;
+
+        if (This->bIsDirty || !This->data)
+        {
+            switch (This->keepOrigFormat ? This->loadtime_format : BITMAP_FORMAT_BMP)
+            {
+            case BITMAP_FORMAT_BMP:
+                if (!serializeBMP(This->desc.bmp.hbitmap, &data, &data_size))
+                    return E_FAIL;
+                break;
+            case BITMAP_FORMAT_JPEG:
+                FIXME("BITMAP_FORMAT_JPEG is not implemented\n");
+                return E_NOTIMPL;
+            case BITMAP_FORMAT_GIF:
+                FIXME("BITMAP_FORMAT_GIF is not implemented\n");
+                return E_NOTIMPL;
+            case BITMAP_FORMAT_PNG:
+                FIXME("BITMAP_FORMAT_PNG is not implemented\n");
+                return E_NOTIMPL;
+            default:
+                FIXME("PICTYPE_BITMAP/%#x is not implemented\n", This->loadtime_format);
+                return E_NOTIMPL;
+            }
+
+            HeapFree(GetProcessHeap(), 0, This->data);
+            This->data = data;
+            This->datalen = data_size;
+        }
+        hr = IStream_Write(stream, This->data, This->datalen, &written);
+        if (hr == S_OK && size) *size = written;
+        return hr;
+
+    case PICTYPE_METAFILE:
+        FIXME("PICTYPE_METAFILE is not implemented\n");
+        return E_NOTIMPL;
+
+    case PICTYPE_ENHMETAFILE:
+        if (!mem_copy) return E_FAIL;
+
+        if (This->bIsDirty || !This->data)
+        {
+            if (!serializeEMF(This->desc.emf.hemf, &data, &data_size))
+                return E_FAIL;
+            HeapFree(GetProcessHeap(), 0, This->data);
+            This->data = data;
+            This->datalen = data_size;
+        }
+        hr = IStream_Write(stream, This->data, This->datalen, &written);
+        if (hr == S_OK && size) *size = written;
+        return hr;
+
+    default:
+        FIXME("%#x is not implemented\n", This->desc.picType);
+        break;
+    }
+    return E_NOTIMPL;
+}
 
 /************************************************************************
  *    IDispatch
@@ -2266,6 +2362,7 @@ HRESULT WINAPI OleLoadPictureEx( LPSTREAM lpstream, LONG lSize, BOOL fRunmode,
 {
   LPPERSISTSTREAM ps;
   IPicture	*newpic;
+  OLEPictureImpl *pictureImpl;
   HRESULT hr;
 
   FIXME("%p, %ld, %d, %s, %lu, %lu, %#lx, %p, partially implemented.\n",
@@ -2274,6 +2371,11 @@ HRESULT WINAPI OleLoadPictureEx( LPSTREAM lpstream, LONG lSize, BOOL fRunmode,
   hr = OleCreatePictureIndirect(NULL,riid,!fRunmode,(LPVOID*)&newpic);
   if (hr != S_OK)
     return hr;
+  if (xsiz == LP_DEFAULT && ysiz == LP_DEFAULT)
+      xsiz = ysiz = 32;
+  pictureImpl = impl_from_IPicture(newpic);
+  pictureImpl->desiredWidth = xsiz;
+  pictureImpl->desiredHeight = ysiz;
   hr = IPicture_QueryInterface(newpic,&IID_IPersistStream, (LPVOID*)&ps);
   if (hr != S_OK) {
       ERR("Could not get IPersistStream iface from Ole Picture?\n");
diff --git a/dlls/oleaut32/tests/olepicture.c b/dlls/oleaut32/tests/olepicture.c
index c6ab4ed..35111f6 100644
--- a/dlls/oleaut32/tests/olepicture.c
+++ b/dlls/oleaut32/tests/olepicture.c
@@ -97,7 +97,7 @@ static const unsigned char pngimage[285] = {
 0xe7,0x00,0x00,0x00,0x00,0x49,0x45,0x4e,0x44,0xae,0x42,0x60,0x82
 };
 
-/* 1x1 pixel bmp */
+/* 1bpp BI_RGB 1x1 pixel bmp */
 static const unsigned char bmpimage[66] = {
 0x42,0x4d,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x00,0x28,0x00,
 0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x01,0x00,0x00,0x00,
@@ -106,6 +106,15 @@ static const unsigned char bmpimage[66] = {
 0x00,0x00
 };
 
+/* 8bpp BI_RLE8 1x1 pixel bmp */
+static const unsigned char bmpimage_rle8[] = {
+0x42,0x4d,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x00,0x28,0x00,
+0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x01,0x00,0x08,0x00,0x01,0x00,
+0x00,0x00,0x04,0x00,0x00,0x00,0x12,0x0b,0x00,0x00,0x12,0x0b,0x00,0x00,0x02,0x00,
+0x00,0x00,0x02,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0xff,0xff,0xff,0x00,0x00,0x01,
+0x00,0x00
+};
+
 /* 2x2 pixel gif */
 static const unsigned char gif4pixel[42] = {
 0x47,0x49,0x46,0x38,0x37,0x61,0x02,0x00,0x02,0x00,0xa1,0x00,0x00,0x00,0x00,0x00,
@@ -239,7 +248,7 @@ test_pic_with_stream(LPSTREAM stream, unsigned int imgsize)
         {
             BITMAP bmp;
             GetObjectA(UlongToHandle(handle), sizeof(BITMAP), &bmp);
-            todo_wine ok(bmp.bmBits != 0, "not a dib\n");
+            ok(bmp.bmBits != 0, "not a dib\n");
         }
 
 	width = 0;
@@ -1230,18 +1239,14 @@ static void test_load_save_bmp(void)
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, TRUE, &size);
     ok(hr == S_OK, "IPicture_SaveasFile error %#lx\n", hr);
-    todo_wine
     ok(size == 66, "expected 66, got %ld\n", size);
     mem = GlobalLock(hmem);
-    todo_wine
     ok(!memcmp(&mem[0], "BM", 2), "got wrong bmp header %04lx\n", mem[0]);
     GlobalUnlock(hmem);
 
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
-    todo_wine
     ok(hr == E_FAIL, "expected E_FAIL, got %#lx\n", hr);
-    todo_wine
     ok(size == -1, "expected -1, got %ld\n", size);
 
     offset.QuadPart = 0;
@@ -1308,15 +1313,12 @@ static void test_load_save_icon(void)
     todo_wine
     ok(size == 766, "expected 766, got %ld\n", size);
     mem = GlobalLock(hmem);
-    todo_wine
     ok(mem[0] == 0x00010000, "got wrong icon header %04lx\n", mem[0]);
     GlobalUnlock(hmem);
 
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
-    todo_wine
     ok(hr == E_FAIL, "expected E_FAIL, got %#lx\n", hr);
-    todo_wine
     ok(size == -1, "expected -1, got %ld\n", size);
 
     offset.QuadPart = 0;
@@ -1382,13 +1384,11 @@ static void test_load_save_empty_picture(void)
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, TRUE, &size);
     ok(hr == S_OK, "IPicture_SaveasFile error %#lx\n", hr);
-    todo_wine
     ok(size == -1, "expected -1, got %ld\n", size);
 
     size = -1;
     hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
     ok(hr == S_OK, "IPicture_SaveasFile error %#lx\n", hr);
-    todo_wine
     ok(size == -1, "expected -1, got %ld\n", size);
 
     hr = IPicture_QueryInterface(pic, &IID_IPersistStream, (void **)&src_stream);
@@ -1456,6 +1456,89 @@ static void test_load_save_empty_picture(void)
     IStream_Release(stream);
 }
 
+static void test_load_save_emf(void)
+{
+    HDC hdc;
+    IPicture *pic;
+    PICTDESC desc;
+    short type;
+    OLE_HANDLE handle;
+    HGLOBAL hmem;
+    DWORD *mem;
+    ENHMETAHEADER *emh;
+    IPersistStream *src_stream;
+    IStream *dst_stream;
+    LARGE_INTEGER offset;
+    HRESULT hr;
+    LONG size;
+
+    hdc = CreateEnhMetaFileA(0, NULL, NULL, NULL);
+    ok(hdc != 0, "CreateEnhMetaFileA failed\n");
+
+    desc.cbSizeofstruct = sizeof(desc);
+    desc.picType = PICTYPE_ENHMETAFILE;
+    desc.emf.hemf = CloseEnhMetaFile(hdc);
+    ok(desc.emf.hemf != 0, "CloseEnhMetaFile failed\n");
+    hr = OleCreatePictureIndirect(&desc, &IID_IPicture, FALSE, (void**)&pic);
+    ok(hr == S_OK, "OleCreatePictureIndirect error %#x\n", hr);
+
+    type = -1;
+    hr = IPicture_get_Type(pic, &type);
+    ok(hr == S_OK,"get_Type error %#8x\n", hr);
+    ok(type == PICTYPE_ENHMETAFILE,"expected PICTYPE_ENHMETAFILE, got %d\n", type);
+
+    hr = IPicture_get_Handle(pic, &handle);
+    ok(hr == S_OK,"get_Handle error %#8x\n", hr);
+    ok(IntToPtr(handle) == desc.emf.hemf, "get_Handle returned wrong handle %#x\n", handle);
+
+    hmem = GlobalAlloc(GMEM_MOVEABLE, 0);
+    hr = CreateStreamOnHGlobal(hmem, FALSE, &dst_stream);
+    ok(hr == S_OK, "createstreamonhglobal error %#x\n", hr);
+
+    size = -1;
+    hr = IPicture_SaveAsFile(pic, dst_stream, TRUE, &size);
+    ok(hr == S_OK, "IPicture_SaveasFile error %#x\n", hr);
+    ok(size == 128, "expected 128, got %d\n", size);
+    emh = GlobalLock(hmem);
+if (size)
+{
+    ok(emh->iType == EMR_HEADER, "wrong iType %04x\n", emh->iType);
+    ok(emh->dSignature == ENHMETA_SIGNATURE, "wrong dSignature %08x\n", emh->dSignature);
+}
+    GlobalUnlock(hmem);
+
+    size = -1;
+    hr = IPicture_SaveAsFile(pic, dst_stream, FALSE, &size);
+    ok(hr == E_FAIL, "expected E_FAIL, got %#x\n", hr);
+    ok(size == -1, "expected -1, got %d\n", size);
+
+    offset.QuadPart = 0;
+    hr = IStream_Seek(dst_stream, offset, SEEK_SET, NULL);
+    ok(hr == S_OK, "IStream_Seek %#x\n", hr);
+
+    hr = IPicture_QueryInterface(pic, &IID_IPersistStream, (void **)&src_stream);
+    ok(hr == S_OK, "QueryInterface error %#x\n", hr);
+
+    hr = IPersistStream_Save(src_stream, dst_stream, TRUE);
+    ok(hr == S_OK, "Save error %#x\n", hr);
+
+    IPersistStream_Release(src_stream);
+    IStream_Release(dst_stream);
+
+    mem = GlobalLock(hmem);
+    ok(!memcmp(mem, "lt\0\0", 4), "got wrong stream header %04x\n", mem[0]);
+    ok(mem[1] == 128, "expected 128, got %u\n", mem[1]);
+    emh = (ENHMETAHEADER *)(mem + 2);
+    ok(emh->iType == EMR_HEADER, "wrong iType %04x\n", emh->iType);
+    ok(emh->dSignature == ENHMETA_SIGNATURE, "wrong dSignature %08x\n", emh->dSignature);
+
+    GlobalUnlock(hmem);
+    GlobalFree(hmem);
+
+    DeleteEnhMetaFile(desc.emf.hemf);
+    IPicture_Release(pic);
+}
+
 START_TEST(olepicture)
 {
     hOleaut32 = GetModuleHandleA("oleaut32.dll");
@@ -1471,6 +1554,7 @@ START_TEST(olepicture)
     test_pic(gifimage, sizeof(gifimage));
     test_pic(jpgimage, sizeof(jpgimage));
     test_pic(bmpimage, sizeof(bmpimage));
+    test_pic(bmpimage_rle8, sizeof(bmpimage_rle8));
     test_pic(gif4pixel, sizeof(gif4pixel));
     /* FIXME: No PNG support in Windows... */
     if (0) test_pic(pngimage, sizeof(pngimage));
@@ -1495,6 +1579,7 @@ START_TEST(olepicture)
     test_load_save_bmp();
     test_load_save_icon();
     test_load_save_empty_picture();
+    test_load_save_emf();
 }
 
 
diff --git a/dlls/oleaut32/typelib.c b/dlls/oleaut32/typelib.c
index d920ee7..f2f1a0f 100644
--- a/dlls/oleaut32/typelib.c
+++ b/dlls/oleaut32/typelib.c
@@ -408,11 +408,21 @@ HRESULT WINAPI QueryPathOfRegTypeLib( REFGUID guid, WORD wMaj, WORD wMin, LCID l
  *    Success: S_OK
  *    Failure: Status
  */
-HRESULT WINAPI CreateTypeLib(
-	SYSKIND syskind, LPCOLESTR szFile, ICreateTypeLib** ppctlib
-) {
-    FIXME("(%d,%s,%p), stub!\n",syskind,debugstr_w(szFile),ppctlib);
-    return E_FAIL;
+HRESULT WINAPI CreateTypeLib(SYSKIND syskind, LPCOLESTR file, ICreateTypeLib **ctlib)
+{
+    ICreateTypeLib2 *typelib2;
+    HRESULT hres;
+
+    FIXME("(%d, %s, %p): forwarding to CreateTypeLib2\n", syskind, debugstr_w(file), ctlib);
+
+    hres = CreateTypeLib2(syskind, file, &typelib2);
+    if(SUCCEEDED(hres))
+    {
+        hres = ICreateTypeLib2_QueryInterface(typelib2, &IID_ICreateTypeLib, (void **)ctlib);
+        ICreateTypeLib2_Release(typelib2);
+    }
+
+    return hres;
 }
 
 /******************************************************************************
@@ -3667,6 +3677,87 @@ static BOOL TLB_GUIDFromString(const char *str, GUID *guid)
   return TRUE;
 }
 
+struct bitstream
+{
+    const BYTE *buffer;
+    DWORD       length;
+    WORD        current;
+};
+
+static const char *lookup_code(const BYTE *table, DWORD table_size, struct bitstream *bits)
+{
+    const BYTE *p = table;
+
+    while (p < table + table_size && *p == 0x80)
+    {
+        if (p + 2 >= table + table_size) return NULL;
+
+        if (!(bits->current & 0xff))
+        {
+            if (!bits->length) return NULL;
+            bits->current = (*bits->buffer << 8) | 1;
+            bits->buffer++;
+            bits->length--;
+        }
+
+        if (bits->current & 0x8000)
+        {
+            p += 3;
+        }
+        else
+        {
+            p = table + (*(p + 2) | (*(p + 1) << 8));
+        }
+
+        bits->current <<= 1;
+    }
+
+    if (p + 1 < table + table_size && *(p + 1))
+    {
+        /* FIXME: Whats the meaning of *p? */
+        const BYTE *q = p + 1;
+        while (q < table + table_size && *q) q++;
+        return (q < table + table_size) ? (const char *)(p + 1) : NULL;
+    }
+
+    return NULL;
+}
+
+static const TLBString *decode_string(const BYTE *table, const char *stream, DWORD stream_length, ITypeLibImpl *lib)
+{
+    DWORD buf_size, table_size;
+    const char *p;
+    struct bitstream bits;
+    BSTR buf;
+    TLBString *tlbstr;
+
+    if (!stream_length) return NULL;
+
+    bits.buffer = (const BYTE *)stream;
+    bits.length = stream_length;
+    bits.current = 0;
+
+    buf_size = *(const WORD *)table;
+    table += sizeof(WORD);
+    table_size = *(const DWORD *)table;
+    table += sizeof(DWORD);
+
+    buf = SysAllocStringLen(NULL, buf_size);
+    buf[0] = 0;
+
+    while ((p = lookup_code(table, table_size, &bits)))
+    {
+        static const WCHAR spaceW[] = { ' ',0 };
+        if (buf[0]) lstrcatW(buf, spaceW);
+        MultiByteToWideChar(CP_ACP, 0, p, -1, buf + lstrlenW(buf), buf_size - lstrlenW(buf));
+    }
+
+    tlbstr = TLB_append_str(&lib->string_list, buf);
+    SysFreeString(buf);
+
+    return tlbstr;
+}
+
 static WORD SLTG_ReadString(const char *ptr, const TLBString **pStr, ITypeLibImpl *lib)
 {
     WORD bytelen;
@@ -3998,7 +4089,7 @@ static char *SLTG_DoImpls(char *pBlk, ITypeInfoImpl *pTI,
 }
 
 static void SLTG_DoVars(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI, unsigned short cVars,
-			const char *pNameTable, const sltg_ref_lookup_t *ref_lookup)
+			const char *pNameTable, const sltg_ref_lookup_t *ref_lookup, const BYTE *hlp_strings)
 {
   TLBVarDesc *pVarDesc;
   const TLBString *prevName = NULL;
@@ -4028,6 +4119,12 @@ static void SLTG_DoVars(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI, unsign
       TRACE_(typelib)("byte_offs = 0x%x\n", pItem->byte_offs);
       TRACE_(typelib)("memid = %#lx\n", pItem->memid);
 
+      if (pItem->helpstring != 0xffff)
+      {
+          pVarDesc->HelpString = decode_string(hlp_strings, pBlk + pItem->helpstring, pNameTable - pBlk, pTI->pTypeLib);
+          TRACE_(typelib)("helpstring = %s\n", debugstr_w(pVarDesc->HelpString->str));
+      }
+
       if(pItem->flags & 0x02)
 	  pType = &pItem->type;
       else
@@ -4109,7 +4206,8 @@ static void SLTG_DoVars(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI, unsign
 }
 
 static void SLTG_DoFuncs(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI,
-			 unsigned short cFuncs, char *pNameTable, const sltg_ref_lookup_t *ref_lookup)
+			 unsigned short cFuncs, char *pNameTable, const sltg_ref_lookup_t *ref_lookup,
+			 const BYTE *hlp_strings)
 {
     SLTG_Function *pFunc;
     unsigned short i;
@@ -4150,6 +4248,9 @@ static void SLTG_DoFuncs(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI,
         else
 	    pFuncDesc->funcdesc.oVft = (unsigned short)(pFunc->vtblpos & ~1) * sizeof(void *) / pTI->pTypeLib->ptr_size;
 
+	if (pFunc->helpstring != 0xffff)
+		pFuncDesc->HelpString = decode_string(hlp_strings, pBlk + pFunc->helpstring, pNameTable - pBlk, pTI->pTypeLib);
+
 	if(pFunc->magic & SLTG_FUNCTION_FLAGS_PRESENT)
 	    pFuncDesc->funcdesc.wFuncFlags = pFunc->funcflags;
 
@@ -4167,7 +4268,7 @@ static void SLTG_DoFuncs(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI,
 	pArg = (WORD*)(pBlk + pFunc->arg_off);
 
 	for(param = 0; param < pFuncDesc->funcdesc.cParams; param++) {
-	    char *paramName = pNameTable + *pArg;
+	    char *paramName = pNameTable + (*pArg & ~1);
 	    BOOL HaveOffs;
 	    /* If arg type follows then paramName points to the 2nd
 	       letter of the name, else the next WORD is an offset to
@@ -4178,26 +4279,21 @@ static void SLTG_DoFuncs(char *pBlk, char *pFirstItem, ITypeInfoImpl *pTI,
 	       meaning that the next WORD is the type, the latter
 	       meaning that the next WORD is an offset to the type. */
 
-	    HaveOffs = FALSE;
-	    if(*pArg == 0xffff)
+	    if(*pArg == 0xffff || *pArg == 0xfffe)
 	        paramName = NULL;
-	    else if(*pArg == 0xfffe) {
-	        paramName = NULL;
-		HaveOffs = TRUE;
-	    }
-	    else if(paramName[-1] && !isalnum(paramName[-1]))
-	        HaveOffs = TRUE;
 
+	    HaveOffs = !(*pArg & 1);
 	    pArg++;
 
+            TRACE_(typelib)("param %d: paramName %s, *pArg %#x\n",
+                param, debugstr_a(paramName), *pArg);
+
 	    if(HaveOffs) { /* the next word is an offset to type */
 	        pType = (WORD*)(pBlk + *pArg);
 		SLTG_DoElem(pType, pBlk,
 			    &pFuncDesc->funcdesc.lprgelemdescParam[param], ref_lookup);
 		pArg++;
 	    } else {
-		if(paramName)
-		  paramName--;
 		pArg = SLTG_DoElem(pArg, pBlk,
                                    &pFuncDesc->funcdesc.lprgelemdescParam[param], ref_lookup);
 	    }
@@ -4241,7 +4337,7 @@ static void SLTG_ProcessCoClass(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessInterface(char *pBlk, ITypeInfoImpl *pTI,
 				  char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-				  const SLTG_TypeInfoTail *pTITail)
+				  const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
     char *pFirstItem;
     sltg_ref_lookup_t *ref_lookup = NULL;
@@ -4258,7 +4354,7 @@ static void SLTG_ProcessInterface(char *pBlk, ITypeInfoImpl *pTI,
     }
 
     if (pTITail->funcs_off != 0xffff)
-        SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup);
+        SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup, hlp_strings);
 
     free(ref_lookup);
 
@@ -4268,9 +4364,9 @@ static void SLTG_ProcessInterface(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessRecord(char *pBlk, ITypeInfoImpl *pTI,
 			       const char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-			       const SLTG_TypeInfoTail *pTITail)
+			       const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
-  SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, NULL);
+  SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, NULL, hlp_strings);
 }
 
 static void SLTG_ProcessAlias(char *pBlk, ITypeInfoImpl *pTI,
@@ -4303,7 +4399,7 @@ static void SLTG_ProcessAlias(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessDispatch(char *pBlk, ITypeInfoImpl *pTI,
 				 char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-				 const SLTG_TypeInfoTail *pTITail)
+				 const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
   sltg_ref_lookup_t *ref_lookup = NULL;
   if (pTIHeader->href_table != 0xffffffff)
@@ -4311,10 +4407,10 @@ static void SLTG_ProcessDispatch(char *pBlk, ITypeInfoImpl *pTI,
                                   pNameTable);
 
   if (pTITail->vars_off != 0xffff)
-    SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup);
+    SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup, hlp_strings);
 
   if (pTITail->funcs_off != 0xffff)
-    SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup);
+    SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup, hlp_strings);
 
   if (pTITail->impls_off != 0xffff)
     SLTG_DoImpls(pBlk + pTITail->impls_off, pTI, FALSE, ref_lookup);
@@ -4331,14 +4427,14 @@ static void SLTG_ProcessDispatch(char *pBlk, ITypeInfoImpl *pTI,
 
 static void SLTG_ProcessEnum(char *pBlk, ITypeInfoImpl *pTI,
 			     const char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-			     const SLTG_TypeInfoTail *pTITail)
+			     const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
-  SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, NULL);
+  SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, NULL, hlp_strings);
 }
 
 static void SLTG_ProcessModule(char *pBlk, ITypeInfoImpl *pTI,
 			       char *pNameTable, SLTG_TypeInfoHeader *pTIHeader,
-			       const SLTG_TypeInfoTail *pTITail)
+			       const SLTG_TypeInfoTail *pTITail, const BYTE *hlp_strings)
 {
   sltg_ref_lookup_t *ref_lookup = NULL;
   if (pTIHeader->href_table != 0xffffffff)
@@ -4346,10 +4442,10 @@ static void SLTG_ProcessModule(char *pBlk, ITypeInfoImpl *pTI,
                                   pNameTable);
 
   if (pTITail->vars_off != 0xffff)
-    SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup);
+    SLTG_DoVars(pBlk, pBlk + pTITail->vars_off, pTI, pTITail->cVars, pNameTable, ref_lookup, hlp_strings);
 
   if (pTITail->funcs_off != 0xffff)
-    SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup);
+    SLTG_DoFuncs(pBlk, pBlk + pTITail->funcs_off, pTI, pTITail->cFuncs, pNameTable, ref_lookup, hlp_strings);
   free(ref_lookup);
   if (TRACE_ON(typelib))
     dump_TypeInfo(pTI);
@@ -4358,17 +4454,17 @@ static void SLTG_ProcessModule(char *pBlk, ITypeInfoImpl *pTI,
 /* Because SLTG_OtherTypeInfo is such a painful struct, we make a more
    manageable copy of it into this */
 typedef struct {
-  WORD small_no;
   char *index_name;
   char *other_name;
   WORD res1a;
   WORD name_offs;
-  WORD more_bytes;
+  WORD hlpstr_len;
   char *extra;
   WORD res20;
   DWORD helpcontext;
   WORD res26;
   GUID uuid;
+  WORD typekind;
 } SLTG_InternalOtherTypeInfo;
 
 /****************************************************************************
@@ -4387,8 +4483,8 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
     LPVOID pBlk, pFirstBlk;
     SLTG_LibBlk *pLibBlk;
     SLTG_InternalOtherTypeInfo *pOtherTypeInfoBlks;
-    char *pAfterOTIBlks = NULL;
     char *pNameTable, *ptr;
+    const BYTE *hlp_strings;
     int i;
     DWORD len, order;
     ITypeInfoImpl **ppTypeInfoImpl;
@@ -4454,53 +4550,55 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
     len += 0x40;
 
     /* And now TypeInfoCount of SLTG_OtherTypeInfo */
+    pTypeLibImpl->TypeInfoCount = *(WORD *)((char *)pLibBlk + len);
+    len += sizeof(WORD);
 
     pOtherTypeInfoBlks = calloc(pTypeLibImpl->TypeInfoCount, sizeof(*pOtherTypeInfoBlks));
 
-
     ptr = (char*)pLibBlk + len;
 
     for(i = 0; i < pTypeLibImpl->TypeInfoCount; i++) {
 	WORD w, extra;
 	len = 0;
 
-	pOtherTypeInfoBlks[i].small_no = *(WORD*)ptr;
-
-	w = *(WORD*)(ptr + 2);
+	w = *(WORD*)ptr;
 	if(w != 0xffff) {
 	    len += w;
-	    pOtherTypeInfoBlks[i].index_name = malloc(w + 1);
-	    memcpy(pOtherTypeInfoBlks[i].index_name, ptr + 4, w);
+	    pOtherTypeInfoBlks[i].index_name = malloc(w+1);
+	    memcpy(pOtherTypeInfoBlks[i].index_name, ptr + 2, w);
 	    pOtherTypeInfoBlks[i].index_name[w] = '\0';
 	}
-	w = *(WORD*)(ptr + 4 + len);
+	w = *(WORD*)(ptr + 2 + len);
 	if(w != 0xffff) {
-	    TRACE_(typelib)("\twith %s\n", debugstr_an(ptr + 6 + len, w));
-	    len += w;
-	    pOtherTypeInfoBlks[i].other_name = malloc(w + 1);
-	    memcpy(pOtherTypeInfoBlks[i].other_name, ptr + 6 + len, w);
+	    TRACE_(typelib)("\twith %s\n", debugstr_an(ptr + 4 + len, w));
+	    pOtherTypeInfoBlks[i].other_name = malloc(w+1);
+	    memcpy(pOtherTypeInfoBlks[i].other_name, ptr + 4 + len, w);
 	    pOtherTypeInfoBlks[i].other_name[w] = '\0';
+	    len += w;
 	}
-	pOtherTypeInfoBlks[i].res1a = *(WORD*)(ptr + len + 6);
-	pOtherTypeInfoBlks[i].name_offs = *(WORD*)(ptr + len + 8);
-	extra = pOtherTypeInfoBlks[i].more_bytes = *(WORD*)(ptr + 10 + len);
+	pOtherTypeInfoBlks[i].res1a = *(WORD*)(ptr + 4 + len);
+	pOtherTypeInfoBlks[i].name_offs = *(WORD*)(ptr + 6 + len);
+	extra = pOtherTypeInfoBlks[i].hlpstr_len = *(WORD*)(ptr + 8 + len);
 	if(extra) {
 	    pOtherTypeInfoBlks[i].extra = malloc(extra);
-	    memcpy(pOtherTypeInfoBlks[i].extra, ptr + 12, extra);
+	    memcpy(pOtherTypeInfoBlks[i].extra, ptr + 10 + len, extra);
 	    len += extra;
 	}
-	pOtherTypeInfoBlks[i].res20 = *(WORD*)(ptr + 12 + len);
-	pOtherTypeInfoBlks[i].helpcontext = *(DWORD*)(ptr + 14 + len);
-	pOtherTypeInfoBlks[i].res26 = *(WORD*)(ptr + 18 + len);
-	memcpy(&pOtherTypeInfoBlks[i].uuid, ptr + 20 + len, sizeof(GUID));
+	pOtherTypeInfoBlks[i].res20 = *(WORD*)(ptr + 10 + len);
+	pOtherTypeInfoBlks[i].helpcontext = *(DWORD*)(ptr + 12 + len);
+	pOtherTypeInfoBlks[i].res26 = *(WORD*)(ptr + 16 + len);
+	memcpy(&pOtherTypeInfoBlks[i].uuid, ptr + 18 + len, sizeof(GUID));
+	pOtherTypeInfoBlks[i].typekind = *(WORD*)(ptr + 18 + sizeof(GUID) + len);
 	len += sizeof(SLTG_OtherTypeInfo);
 	ptr += len;
     }
 
-    pAfterOTIBlks = ptr;
+    /* Get the next DWORD */
+    len = *(DWORD*)ptr;
 
-    /* Skip this WORD and get the next DWORD */
-    len = *(DWORD*)(pAfterOTIBlks + 2);
+    hlp_strings = (const BYTE *)ptr + sizeof(DWORD);
+    TRACE("max help string length %#x, help strings length %#lx\n",
+        *(WORD *)hlp_strings, *(DWORD *)(hlp_strings + 2));
 
     /* Now add this to pLibBLk look at what we're pointing at and
        possibly add 0x20, then add 0x216, sprinkle a bit a magic
@@ -4566,6 +4664,7 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
       (*ppTypeInfoImpl)->index = i;
       (*ppTypeInfoImpl)->Name = SLTG_ReadName(pNameTable, pOtherTypeInfoBlks[i].name_offs, pTypeLibImpl);
       (*ppTypeInfoImpl)->dwHelpContext = pOtherTypeInfoBlks[i].helpcontext;
+      (*ppTypeInfoImpl)->DocString = decode_string(hlp_strings, pOtherTypeInfoBlks[i].extra, pOtherTypeInfoBlks[i].hlpstr_len, pTypeLibImpl);
       (*ppTypeInfoImpl)->guid = TLB_append_guid(&pTypeLibImpl->guid_list, &pOtherTypeInfoBlks[i].uuid, 2);
       (*ppTypeInfoImpl)->typeattr.typekind = pTIHeader->typekind;
       (*ppTypeInfoImpl)->typeattr.wMajorVerNum = pTIHeader->major_version;
@@ -4598,17 +4697,17 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
       switch(pTIHeader->typekind) {
       case TKIND_ENUM:
 	SLTG_ProcessEnum((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                         pTIHeader, pTITail);
+                         pTIHeader, pTITail, hlp_strings);
 	break;
 
       case TKIND_RECORD:
 	SLTG_ProcessRecord((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                           pTIHeader, pTITail);
+                           pTIHeader, pTITail, hlp_strings);
 	break;
 
       case TKIND_INTERFACE:
 	SLTG_ProcessInterface((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                              pTIHeader, pTITail);
+                              pTIHeader, pTITail, hlp_strings);
 	break;
 
       case TKIND_COCLASS:
@@ -4623,12 +4722,12 @@ static ITypeLib2* ITypeLib2_Constructor_SLTG(LPVOID pLib, DWORD dwTLBLength)
 
       case TKIND_DISPATCH:
 	SLTG_ProcessDispatch((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                             pTIHeader, pTITail);
+                             pTIHeader, pTITail, hlp_strings);
 	break;
 
       case TKIND_MODULE:
 	SLTG_ProcessModule((char *)(pMemHeader + 1), *ppTypeInfoImpl, pNameTable,
-                           pTIHeader, pTITail);
+                           pTIHeader, pTITail, hlp_strings);
 	break;
 
       default:
diff --git a/dlls/oleaut32/typelib.h b/dlls/oleaut32/typelib.h
index 515d4b5..bfe908c 100644
--- a/dlls/oleaut32/typelib.h
+++ b/dlls/oleaut32/typelib.h
@@ -382,18 +382,18 @@ typedef struct {
 /* we then get 0x40 bytes worth of 0xffff or small numbers followed by
    nrOfFileBlks - 2 of these */
 typedef struct {
-	WORD small_no;
 	SLTG_Name index_name; /* This refers to a name in the directory */
 	SLTG_Name other_name; /* Another one of these weird names */
 	WORD res1a;	      /* 0xffff */
 	WORD name_offs;	      /* offset to name in name table */
-	WORD more_bytes;      /* if this is non-zero we get this many
+	WORD hlpstr_len;      /* if this is non-zero we get this many
 				 bytes before the next element, which seem
 				 to reference the docstring of the type ? */
 	WORD res20;	      /* 0xffff */
 	DWORD helpcontext;
 	WORD res26;	      /* 0xffff */
         GUID uuid;
+        WORD typekind;
 } SLTG_OtherTypeInfo;
 
 /* Next we get WORD 0x0003 followed by a DWORD which if we add to
diff --git a/dlls/packager/Makefile.in b/dlls/packager/Makefile.in
index 5fc89d8..3589b37 100644
--- a/dlls/packager/Makefile.in
+++ b/dlls/packager/Makefile.in
@@ -1,5 +1,6 @@
 MODULE = packager.dll
 IMPORTS = uuid shell32 shlwapi user32
+EXTRADLLFLAGS = -Wb,--prefer-native
 
 SOURCES = \
 	packager.rc \
diff --git a/dlls/psapi/tests/psapi_main.c b/dlls/psapi/tests/psapi_main.c
index e7e5e5f..3a3f9b3 100644
--- a/dlls/psapi/tests/psapi_main.c
+++ b/dlls/psapi/tests/psapi_main.c
@@ -1208,6 +1208,9 @@ static void test_QueryWorkingSetEx(void)
     check_QueryWorkingSetEx(addr, "exe,readonly1", 0, 0, 1, TRUE);
 
     *(volatile char *)addr;
+    check_QueryWorkingSetEx(addr, "exe,readonly2", 1, PAGE_READONLY, 1, FALSE);
+
+    ret = VirtualProtect(addr, 0x1000, PAGE_EXECUTE_READWRITE, &prot);
     ok(ret, "VirtualProtect failed with %ld\n", GetLastError());
     check_QueryWorkingSetEx(addr, "exe,readonly2", 1, PAGE_READONLY, 1, FALSE);
 
diff --git a/dlls/riched20/richole.c b/dlls/riched20/richole.c
index 51ae41d..85e7cea 100644
--- a/dlls/riched20/richole.c
+++ b/dlls/riched20/richole.c
@@ -3562,6 +3562,16 @@ static ULONG WINAPI TextPara_Release(ITextPara *iface)
     return ref;
 }
 
+static struct text_services *para_get_reole(ITextParaImpl *This)
+{
+    if (This->range)
+    {
+        ITextRangeImpl *rng = impl_from_ITextRange(This->range);
+        return rng->child.reole;
+    }
+    return NULL;
+}
+
 static HRESULT WINAPI TextPara_GetTypeInfoCount(ITextPara *iface, UINT *pctinfo)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
@@ -3629,6 +3639,10 @@ static HRESULT WINAPI TextPara_GetDuplicate(ITextPara *iface, ITextPara **ret)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, ret);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3636,6 +3650,10 @@ static HRESULT WINAPI TextPara_SetDuplicate(ITextPara *iface, ITextPara *para)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, para);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3643,6 +3661,10 @@ static HRESULT WINAPI TextPara_CanChange(ITextPara *iface, LONG *ret)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, ret);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3650,6 +3672,10 @@ static HRESULT WINAPI TextPara_IsEqual(ITextPara *iface, ITextPara *para, LONG *
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p %p)\n", This, para, ret);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3657,6 +3683,10 @@ static HRESULT WINAPI TextPara_Reset(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3664,6 +3694,10 @@ static HRESULT WINAPI TextPara_GetStyle(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3671,6 +3705,10 @@ static HRESULT WINAPI TextPara_SetStyle(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3678,6 +3716,10 @@ static HRESULT WINAPI TextPara_GetAlignment(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3685,6 +3727,10 @@ static HRESULT WINAPI TextPara_SetAlignment(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3692,6 +3738,10 @@ static HRESULT WINAPI TextPara_GetHyphenation(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3699,6 +3749,10 @@ static HRESULT WINAPI TextPara_SetHyphenation(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3706,6 +3760,10 @@ static HRESULT WINAPI TextPara_GetFirstLineIndent(ITextPara *iface, FLOAT *value
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3713,6 +3771,10 @@ static HRESULT WINAPI TextPara_GetKeepTogether(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3720,6 +3782,10 @@ static HRESULT WINAPI TextPara_SetKeepTogether(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3727,6 +3793,10 @@ static HRESULT WINAPI TextPara_GetKeepWithNext(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3734,6 +3804,10 @@ static HRESULT WINAPI TextPara_SetKeepWithNext(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3741,6 +3815,10 @@ static HRESULT WINAPI TextPara_GetLeftIndent(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3748,6 +3826,10 @@ static HRESULT WINAPI TextPara_GetLineSpacing(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3755,6 +3837,10 @@ static HRESULT WINAPI TextPara_GetLineSpacingRule(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3762,6 +3848,10 @@ static HRESULT WINAPI TextPara_GetListAlignment(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3769,6 +3859,10 @@ static HRESULT WINAPI TextPara_SetListAlignment(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3776,6 +3870,10 @@ static HRESULT WINAPI TextPara_GetListLevelIndex(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3783,6 +3881,10 @@ static HRESULT WINAPI TextPara_SetListLevelIndex(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3790,6 +3892,10 @@ static HRESULT WINAPI TextPara_GetListStart(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3797,6 +3903,10 @@ static HRESULT WINAPI TextPara_SetListStart(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3804,6 +3914,10 @@ static HRESULT WINAPI TextPara_GetListTab(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3811,6 +3925,10 @@ static HRESULT WINAPI TextPara_SetListTab(ITextPara *iface, FLOAT value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3818,6 +3936,10 @@ static HRESULT WINAPI TextPara_GetListType(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3825,6 +3947,10 @@ static HRESULT WINAPI TextPara_SetListType(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3832,6 +3958,10 @@ static HRESULT WINAPI TextPara_GetNoLineNumber(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3839,6 +3969,10 @@ static HRESULT WINAPI TextPara_SetNoLineNumber(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3846,6 +3980,10 @@ static HRESULT WINAPI TextPara_GetPageBreakBefore(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3853,6 +3991,10 @@ static HRESULT WINAPI TextPara_SetPageBreakBefore(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3860,6 +4002,10 @@ static HRESULT WINAPI TextPara_GetRightIndent(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3867,6 +4013,10 @@ static HRESULT WINAPI TextPara_SetRightIndent(ITextPara *iface, FLOAT value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3874,6 +4024,10 @@ static HRESULT WINAPI TextPara_SetIndents(ITextPara *iface, FLOAT StartIndent, F
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f %.2f %.2f)\n", This, StartIndent, LeftIndent, RightIndent);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3881,6 +4035,10 @@ static HRESULT WINAPI TextPara_SetLineSpacing(ITextPara *iface, LONG LineSpacing
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld %.2f)\n", This, LineSpacingRule, LineSpacing);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3888,6 +4046,10 @@ static HRESULT WINAPI TextPara_GetSpaceAfter(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3895,6 +4057,10 @@ static HRESULT WINAPI TextPara_SetSpaceAfter(ITextPara *iface, FLOAT value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3902,6 +4068,10 @@ static HRESULT WINAPI TextPara_GetSpaceBefore(ITextPara *iface, FLOAT *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3909,6 +4079,10 @@ static HRESULT WINAPI TextPara_SetSpaceBefore(ITextPara *iface, FLOAT value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3916,6 +4090,10 @@ static HRESULT WINAPI TextPara_GetWidowControl(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3923,6 +4101,10 @@ static HRESULT WINAPI TextPara_SetWidowControl(ITextPara *iface, LONG value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3930,6 +4112,10 @@ static HRESULT WINAPI TextPara_GetTabCount(ITextPara *iface, LONG *value)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%p)\n", This, value);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3937,6 +4123,10 @@ static HRESULT WINAPI TextPara_AddTab(ITextPara *iface, FLOAT tbPos, LONG tbAlig
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f %ld %ld)\n", This, tbPos, tbAlign, tbLeader);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3944,6 +4134,10 @@ static HRESULT WINAPI TextPara_ClearAllTabs(ITextPara *iface)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)\n", This);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3951,6 +4145,10 @@ static HRESULT WINAPI TextPara_DeleteTab(ITextPara *iface, FLOAT pos)
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%.2f)\n", This, pos);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
@@ -3958,6 +4156,10 @@ static HRESULT WINAPI TextPara_GetTab(ITextPara *iface, LONG iTab, FLOAT *ptbPos
 {
     ITextParaImpl *This = impl_from_ITextPara(iface);
     FIXME("(%p)->(%ld %p %p %p)\n", This, iTab, ptbPos, ptbAlign, ptbLeader);
+
+    if (!para_get_reole(This))
+        return CO_E_RELEASED;
+
     return E_NOTIMPL;
 }
 
diff --git a/dlls/riched20/tests/richole.c b/dlls/riched20/tests/richole.c
index fb5177b..cde2a9a 100644
--- a/dlls/riched20/tests/richole.c
+++ b/dlls/riched20/tests/richole.c
@@ -5565,6 +5565,274 @@ static void test_freeze(void)
   release_interfaces(&hwnd, &reole, &doc, &selection);
 }
 
+static void test_ITextRange_SetStart(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  hres = ITextRange_SetStart(txtRge, first);
+  ok(hres == S_FALSE, "ITextRange_SetStart\n");
+
+#define TEST_TXTRGE_SETSTART(cp, expected_start, expected_end)  \
+  hres = ITextRange_SetStart(txtRge, cp);                       \
+  ok(hres == S_OK, "ITextRange_SetStart\n");                    \
+  ITextRange_GetStart(txtRge, &start);                          \
+  ITextRange_GetEnd(txtRge, &end);                              \
+  ok(start == expected_start, "got wrong start value: %ld\n", start);  \
+  ok(end == expected_end, "got wrong end value: %ld\n", end);
+
+  TEST_TXTRGE_SETSTART(2, 2, 8)
+  TEST_TXTRGE_SETSTART(-1, 0, 8)
+  TEST_TXTRGE_SETSTART(13, 12, 12)
+
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextRange_SetEnd(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  hres = ITextRange_SetEnd(txtRge, lim);
+  ok(hres == S_FALSE, "ITextRange_SetEnd\n");
+
+#define TEST_TXTRGE_SETEND(cp, expected_start, expected_end)    \
+  hres = ITextRange_SetEnd(txtRge, cp);                         \
+  ok(hres == S_OK, "ITextRange_SetEnd\n");                      \
+  ITextRange_GetStart(txtRge, &start);                          \
+  ITextRange_GetEnd(txtRge, &end);                              \
+  ok(start == expected_start, "got wrong start value: %ld\n", start);  \
+  ok(end == expected_end, "got wrong end value: %ld\n", end);
+
+  TEST_TXTRGE_SETEND(6, 4, 6)
+  TEST_TXTRGE_SETEND(14, 4, 13)
+  TEST_TXTRGE_SETEND(-1, 0, 0)
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextSelection_SetStart(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  hres = ITextSelection_SetStart(txtSel, first);
+  ok(hres == S_FALSE, "ITextSelection_SetStart\n");
+
+#define TEST_TXTSEL_SETSTART(cp, expected_start, expected_end)        \
+  hres = ITextSelection_SetStart(txtSel, cp);                         \
+  ok(hres == S_OK, "ITextSelection_SetStart\n");                      \
+  SendMessageA(w, EM_GETSEL, (LPARAM)&start, (WPARAM)&end);           \
+  ok(start == expected_start, "got wrong start value: %ld\n", start);  \
+  ok(end == expected_end, "got wrong end value: %ld\n", end);
+
+  TEST_TXTSEL_SETSTART(2, 2, 8)
+  TEST_TXTSEL_SETSTART(-1, 0, 8)
+  TEST_TXTSEL_SETSTART(13, 12, 12)
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+}
+
+static void test_ITextSelection_SetEnd(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  hres = ITextSelection_SetEnd(txtSel, lim);
+  ok(hres == S_FALSE, "ITextSelection_SetEnd\n");
+
+#define TEST_TXTSEL_SETEND(cp, expected_start, expected_end)          \
+  hres = ITextSelection_SetEnd(txtSel, cp);                           \
+  ok(hres == S_OK, "ITextSelection_SetEnd\n");                        \
+  SendMessageA(w, EM_GETSEL, (LPARAM)&start, (WPARAM)&end);           \
+  ok(start == expected_start, "got wrong start value: %ld\n", start);  \
+  ok(end == expected_end, "got wrong end value: %ld\n", end);
+
+  TEST_TXTSEL_SETEND(6, 4, 6)
+  TEST_TXTSEL_SETEND(14, 4, 13)
+  TEST_TXTSEL_SETEND(-1, 0, 0)
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+}
+
+static void test_ITextRange_GetFont(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  ITextFont *txtFont = NULL, *txtFont1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetFont(txtRge, &txtFont);
+  ok(hres == S_OK, "ITextRange_GetFont\n");
+  refcount = get_refcount((IUnknown *)txtFont);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetFont(txtRge, &txtFont1);
+  ok(hres == S_OK, "ITextRange_GetFont\n");
+  ok(txtFont1 != txtFont, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtFont1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextFont_Release(txtFont1);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+
+  hres = ITextFont_GetOutline(txtFont, &value);
+  ok(hres == CO_E_RELEASED, "ITextFont after ITextDocument destroyed\n");
+
+  ITextFont_Release(txtFont);
+}
+
+static void test_ITextSelection_GetFont(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  ITextFont *txtFont = NULL, *txtFont1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextSelection_GetFont(txtSel, &txtFont);
+  ok(hres == S_OK, "ITextSelection_GetFont\n");
+  refcount = get_refcount((IUnknown *)txtFont);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 3, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextSelection_GetFont(txtSel, &txtFont1);
+  ok(hres == S_OK, "ITextSelection_GetFont\n");
+  ok(txtFont1 != txtFont, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtFont1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextFont_Release(txtFont1);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 3, "got wrong ref count: %d\n", refcount);
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+
+  hres = ITextFont_GetOutline(txtFont, &value);
+  ok(hres == CO_E_RELEASED, "ITextFont after ITextDocument destroyed\n");
+
+  ITextFont_Release(txtFont);
+}
+
+static void test_ITextRange_GetPara(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  ITextPara *txtPara = NULL, *txtPara1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetPara(txtRge, &txtPara);
+  ok(hres == S_OK, "ITextRange_GetPara\n");
+  refcount = get_refcount((IUnknown *)txtPara);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetPara(txtRge, &txtPara1);
+  ok(hres == S_OK, "ITextRange_GetPara\n");
+  ok(txtPara1 != txtPara, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtPara1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextPara_Release(txtPara1);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+
+  hres = ITextPara_GetStyle(txtPara, &value);
+  ok(hres == CO_E_RELEASED, "ITextPara after ITextDocument destroyed\n");
+
+  ITextPara_Release(txtPara);
+}
+
 START_TEST(richole)
 {
   /* Must explicitly LoadLibrary(). The test has no references to functions in
@@ -5585,6 +5853,13 @@ START_TEST(richole)
   test_ITextRange_SetRange();
   test_ITextRange_GetDuplicate();
   test_ITextRange_Collapse();
+  test_ITextRange_GetFont();
+  test_ITextRange_SetEnd();
+  test_ITextSelection_GetFont();
+  test_ITextRange_SetStart();
+  test_ITextSelection_SetStart();
+  test_ITextSelection_SetEnd();
+  test_ITextRange_GetPara();
   test_GetClientSite();
   test_IOleWindow_GetWindow();
   test_IOleInPlaceSite_GetWindow();
diff --git a/dlls/rpcrt4/ndr_marshall.c b/dlls/rpcrt4/ndr_marshall.c
index 5ed6b63..50eb42b 100644
--- a/dlls/rpcrt4/ndr_marshall.c
+++ b/dlls/rpcrt4/ndr_marshall.c
@@ -6998,7 +6998,7 @@ static unsigned char *WINAPI NdrContextHandleMarshall(
     }
     else
     {
-        NDR_SCONTEXT ctxt = CONTAINING_RECORD(pMemory, struct _NDR_SCONTEXT, userContext);
+        NDR_SCONTEXT ctxt = CONTAINING_RECORD((void * const*)pMemory, struct _NDR_SCONTEXT, userContext);
         NDR_RUNDOWN rundown = pStubMsg->StubDesc->apfnNdrRundownRoutines[pFormat[2]];
         NdrServerContextNewMarshall(pStubMsg, ctxt, rundown, pFormat);
     }
diff --git a/dlls/rpcrt4/ndr_typelib.c b/dlls/rpcrt4/ndr_typelib.c
index 352f71f..508d208 100644
--- a/dlls/rpcrt4/ndr_typelib.c
+++ b/dlls/rpcrt4/ndr_typelib.c
@@ -1451,7 +1451,7 @@ struct typelib_stub
 
 static ULONG WINAPI typelib_stub_Release(IRpcStubBuffer *iface)
 {
-    struct typelib_stub *stub = CONTAINING_RECORD(iface, struct typelib_stub, stub.stub_buffer);
+    struct typelib_stub *stub = CONTAINING_RECORD((CStdStubBuffer *)iface, struct typelib_stub, stub.stub_buffer);
     ULONG refcount = InterlockedDecrement(&stub->stub.stub_buffer.RefCount);
 
     TRACE("(%p) decreasing refs to %ld\n", stub, refcount);
diff --git a/dlls/rpcrt4/rpc_server.c b/dlls/rpcrt4/rpc_server.c
index 41431eb..77b5d83 100644
--- a/dlls/rpcrt4/rpc_server.c
+++ b/dlls/rpcrt4/rpc_server.c
@@ -701,10 +701,6 @@ static DWORD CALLBACK RPCRT4_server_thread(LPVOID the_arg)
   }
   LeaveCriticalSection(&cps->cs);
 
-  EnterCriticalSection(&listen_cs);
-  CloseHandle(cps->server_thread);
-  cps->server_thread = NULL;
-  LeaveCriticalSection(&listen_cs);
   TRACE("done\n");
   return 0;
 }
@@ -1570,7 +1566,10 @@ RPC_STATUS WINAPI RpcMgmtWaitServerListen( void )
       LIST_FOR_EACH_ENTRY(protseq, &protseqs, RpcServerProtseq, entry)
       {
           if ((wait_thread = protseq->server_thread))
+          {
+              protseq->server_thread = NULL;
               break;
+          }
       }
       LeaveCriticalSection(&server_cs);
       if (!wait_thread)
@@ -1579,6 +1578,7 @@ RPC_STATUS WINAPI RpcMgmtWaitServerListen( void )
       TRACE("waiting for thread %lu\n", GetThreadId(wait_thread));
       LeaveCriticalSection(&listen_cs);
       WaitForSingleObject(wait_thread, INFINITE);
+      CloseHandle(wait_thread);
       EnterCriticalSection(&listen_cs);
   }
   if (listen_done_event == event)
diff --git a/dlls/sapi/token.c b/dlls/sapi/token.c
index f599bdb..30a9f13 100644
--- a/dlls/sapi/token.c
+++ b/dlls/sapi/token.c
@@ -1367,6 +1367,276 @@ static HRESULT WINAPI token_GetCategory( ISpObjectToken *iface,
     return E_NOTIMPL;
 }
 
+struct speech_audio
+{
+    ISpAudio ISpAudio_iface;
+    LONG ref;
+};
+
+static inline struct speech_audio *impl_from_ISpAudio(ISpAudio *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_audio, ISpAudio_iface);
+}
+
+static HRESULT WINAPI spaudio_QueryInterface(ISpAudio *iface, REFIID iid, void **obj)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+
+    TRACE("(%p, %s %p).\n", audio, debugstr_guid(iid), obj);
+
+    if (IsEqualIID(iid, &IID_IUnknown) ||
+        IsEqualIID(iid, &IID_ISequentialStream) ||
+        IsEqualIID(iid, &IID_IStream) ||
+        IsEqualIID(iid, &IID_ISpStreamFormat) ||
+        IsEqualIID(iid, &IID_ISpAudio))
+        *obj = &audio->ISpAudio_iface;
+    else
+    {
+        *obj = NULL;
+        FIXME("interface %s not implemented.\n", debugstr_guid(iid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*obj);
+    return S_OK;
+}
+
+static ULONG WINAPI spaudio_AddRef(ISpAudio *iface)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    ULONG ref = InterlockedIncrement(&audio->ref);
+
+    TRACE("(%p): ref=%lu.\n", audio, ref);
+
+    return ref;
+}
+
+static ULONG WINAPI spaudio_Release(ISpAudio *iface)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    ULONG ref = InterlockedDecrement(&audio->ref);
+
+    TRACE("(%p): ref=%lu.\n", audio, ref);
+
+    if (!ref)
+    {
+        free(audio);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI spaudio_Read(ISpAudio *iface,void *pv, ULONG cb, ULONG *pcbRead)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+
+    FIXME("%p, %p, %ld %p\n", audio, pv, cb, pcbRead);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Write(ISpAudio *iface, const void *pv, ULONG cb, ULONG *pcbWritten)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+
+    FIXME("%p, %p, %ld %p\n", audio, pv, cb, pcbWritten);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Seek(ISpAudio *iface, LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %s, %ld, %p\n", audio, wine_dbgstr_longlong(dlibMove.QuadPart), dwOrigin, plibNewPosition);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetSize(ISpAudio *iface, ULARGE_INTEGER libNewSize)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %s)\n", audio, wine_dbgstr_longlong(libNewSize.QuadPart));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_CopyTo(ISpAudio *iface, IStream *pstm, ULARGE_INTEGER cb,
+        ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %p, %s, %p, %p)\n", audio, pstm, wine_dbgstr_longlong(cb.QuadPart), pcbRead, pcbWritten);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Commit(ISpAudio *iface, DWORD grfCommitFlags)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %#lx)\n", audio, grfCommitFlags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Revert(ISpAudio *iface)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p)\n", audio);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_LockRegion(ISpAudio *iface, ULARGE_INTEGER offset, ULARGE_INTEGER cb, DWORD dwLockType)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %s, %s, %ld)\n", audio, wine_dbgstr_longlong(offset.QuadPart),
+        wine_dbgstr_longlong(cb.QuadPart), dwLockType);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_UnlockRegion(ISpAudio *iface,ULARGE_INTEGER offset, ULARGE_INTEGER cb, DWORD dwLockType)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("(%p, %s, %s, %ld)\n", audio, wine_dbgstr_longlong(offset.QuadPart),
+        wine_dbgstr_longlong(cb.QuadPart), dwLockType);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Stat(ISpAudio *iface, STATSTG *stg, DWORD flag)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p, %lx\n", audio, stg, flag);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_Clone(ISpAudio *iface, IStream **ppstm)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, ppstm);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetFormat(ISpAudio *iface, GUID *format, WAVEFORMATEX **wave)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p, %p\n", audio, format, wave);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetState(ISpAudio *iface, SPAUDIOSTATE state, ULONGLONG reserved)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %d, %s\n", audio, state, wine_dbgstr_longlong(reserved));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetFormat(ISpAudio *iface, REFGUID guid, const WAVEFORMATEX *wave)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %s, %p\n", audio, debugstr_guid(guid), wave);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetStatus(ISpAudio *iface, SPAUDIOSTATUS *status)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, status);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetBufferInfo(ISpAudio *iface,const SPAUDIOBUFFERINFO *buffer)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, buffer);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetBufferInfo(ISpAudio *iface, SPAUDIOBUFFERINFO *buffer)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, buffer);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetDefaultFormat(ISpAudio *iface, GUID *guid, WAVEFORMATEX **wave)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p, %p\n", audio, guid, wave);
+    return E_NOTIMPL;
+}
+
+static HANDLE WINAPI spaudio_EventHandle(ISpAudio *iface)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p\n", audio);
+    return NULL;
+}
+
+static HRESULT WINAPI spaudio_GetVolumeLevel(ISpAudio *iface, ULONG *level)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, level);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetVolumeLevel(ISpAudio *iface, ULONG level)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %lu\n", audio, level);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_GetBufferNotifySize(ISpAudio *iface, ULONG *size)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %p\n", audio, size);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI spaudio_SetBufferNotifySize(ISpAudio *iface, ULONG size)
+{
+    struct speech_audio *audio = impl_from_ISpAudio(iface);
+    FIXME("%p, %lu\n", audio, size);
+    return E_NOTIMPL;
+}
+
+const struct ISpAudioVtbl spaudio_vtbl =
+{
+    spaudio_QueryInterface,
+    spaudio_AddRef,
+    spaudio_Release,
+    spaudio_Read,
+    spaudio_Write,
+    spaudio_Seek,
+    spaudio_SetSize,
+    spaudio_CopyTo,
+    spaudio_Commit,
+    spaudio_Revert,
+    spaudio_LockRegion,
+    spaudio_UnlockRegion,
+    spaudio_Stat,
+    spaudio_Clone,
+    spaudio_GetFormat,
+    spaudio_SetState,
+    spaudio_SetFormat,
+    spaudio_GetStatus,
+    spaudio_SetBufferInfo,
+    spaudio_GetBufferInfo,
+    spaudio_GetDefaultFormat,
+    spaudio_EventHandle,
+    spaudio_GetVolumeLevel,
+    spaudio_SetVolumeLevel,
+    spaudio_GetBufferNotifySize,
+    spaudio_SetBufferNotifySize
+};
+
+static HRESULT speech_audio_create(void **obj)
+{
+    struct speech_audio *This = malloc(sizeof(*This));
+
+    if (!This)
+        return E_OUTOFMEMORY;
+    This->ISpAudio_iface.lpVtbl = &spaudio_vtbl;
+    This->ref = 1;
+
+    *obj = &This->ISpAudio_iface;
+    return S_OK;
+}
+
 static HRESULT WINAPI token_CreateInstance( ISpObjectToken *iface,
                                             IUnknown *outer,
                                             DWORD class_context,
@@ -1381,6 +1651,12 @@ static HRESULT WINAPI token_CreateInstance( ISpObjectToken *iface,
 
     TRACE( "%p, %p, %#lx, %s, %p\n", iface, outer, class_context, debugstr_guid( riid ), object );
 
+    /* Ubtil the Enum class is implemented correctly. */
+    if (IsEqualIID(riid, &IID_ISpAudio))
+    {
+        return speech_audio_create(object);
+    }
+
     if (FAILED(hr = ISpObjectToken_GetStringValue( iface, L"CLSID", &clsid_str )))
         return hr;
 
diff --git a/dlls/scrrun/filesystem.c b/dlls/scrrun/filesystem.c
index e533552..af45218 100644
--- a/dlls/scrrun/filesystem.c
+++ b/dlls/scrrun/filesystem.c
@@ -3803,12 +3803,84 @@ static HRESULT WINAPI filesys_MoveFile(IFileSystem3 *iface, BSTR source, BSTR de
     return MoveFileW(source, destination) ? S_OK : create_error(GetLastError());
 }
 
-static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface,BSTR Source,
-                                            BSTR Destination)
+static inline HRESULT create_movefolder_error(DWORD err)
 {
-    FIXME("%p %s %s\n", iface, debugstr_w(Source), debugstr_w(Destination));
+    switch(err) {
+    case ERROR_INVALID_NAME:
+    case ERROR_FILE_NOT_FOUND:
+    case ERROR_PATH_NOT_FOUND: return CTL_E_PATHNOTFOUND;
+    case ERROR_ACCESS_DENIED: return CTL_E_PERMISSIONDENIED;
+    case ERROR_FILE_EXISTS: return CTL_E_FILEALREADYEXISTS;
+    case ERROR_ALREADY_EXISTS: return CTL_E_FILEALREADYEXISTS;
+    default:
+        FIXME("Unsupported error code: %ld\n", err);
+        return E_FAIL;
+    }
+}
 
-    return E_NOTIMPL;
+static HRESULT WINAPI filesys_MoveFolder(IFileSystem3 *iface, BSTR source, BSTR destination)
+{
+    int src_len, dst_len, name_len;
+    WCHAR src_path[MAX_PATH], dst_path[MAX_PATH];
+    WCHAR *filename;
+    WIN32_FIND_DATAW ffd;
+    HANDLE f;
+    BOOL wildcard = FALSE, separator = FALSE, success = FALSE;
+
+    TRACE("%p %s %s\n", iface, debugstr_w(source), debugstr_w(destination));
+
+    if(!source || !source[0] || !destination || !destination[0])
+        return E_INVALIDARG;
+
+    src_len = SysStringLen(source);
+    if (source[src_len-1] == '\\' || source[src_len-1] == '/')
+        return CTL_E_PATHNOTFOUND;
+
+    if (!GetFullPathNameW(source, MAX_PATH, src_path, &filename))
+        return E_FAIL;
+
+    if (wcspbrk(filename,L"*?"))
+        wildcard = TRUE;
+
+    dst_len = lstrlenW(destination);
+    if (destination[dst_len-1] == '\\' || destination[dst_len-1] == '/')
+        separator = TRUE;
+
+    if (!wildcard && !separator) {
+        src_len = SysStringLen(src_path);
+        if (src_path[src_len-1] != '\\' && src_path[src_len-1] != '/')
+            wcscat(src_path, L"\\");
+        TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(destination));
+        return MoveFileW(src_path, destination) ? S_OK : create_movefolder_error(GetLastError());
+    }
+
+    memcpy(dst_path, destination, dst_len*sizeof(WCHAR));
+    if (!separator)
+        dst_path[dst_len++] = '\\';
+    src_len = filename - src_path;
+    f = FindFirstFileW(source, &ffd);
+    if(f == INVALID_HANDLE_VALUE)
+        return create_error(GetLastError());
+
+    do {
+        name_len = lstrlenW(ffd.cFileName);
+        if(src_len+name_len+2 >= MAX_PATH || dst_len+name_len+1 >= MAX_PATH) {
+            FindClose(f);
+            return E_FAIL;
+        }
+        memcpy(filename, ffd.cFileName, (name_len+1)*sizeof(WCHAR));
+        wcscat(filename, L"\\");
+        memcpy(dst_path + dst_len, ffd.cFileName, (name_len+1)*sizeof(WCHAR));
+        TRACE("move %s to %s\n",  debugstr_w(src_path), debugstr_w(dst_path));
+        if (!MoveFileW(src_path, dst_path)) {
+            if (GetLastError() == ERROR_INVALID_NAME) continue;
+            return create_movefolder_error(GetLastError());
+        }
+        success = TRUE;
+    } while(FindNextFileW(f, &ffd));
+    FindClose(f);
+
+    return success ? S_OK : CTL_E_PATHNOTFOUND;
 }
 
 static inline HRESULT copy_file(const WCHAR *source, DWORD source_len,
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index e53bd09..8cd465f 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -2639,6 +2639,184 @@ static void test_MoveFile(void)
     SysFreeString(str);
 }
 
+static void test_MoveFolder(void)
+{
+    BSTR src, dst, str, empty;
+    WCHAR buffW1[MAX_PATH], buffW2[MAX_PATH], buffW3[MAX_PATH], pathW[MAX_PATH], srcW[MAX_PATH];
+    HRESULT hr;
+    HANDLE file;
+
+    get_temp_path(L"foo", buffW1);
+    get_temp_path(L"bar", buffW2);
+
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    str = SysAllocString(L"null.dir");
+    empty = SysAllocString(L"");
+    hr = IFileSystem3_MoveFolder(fs3, str, NULL);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    hr = IFileSystem3_MoveFolder(fs3, NULL, str);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    hr = IFileSystem3_MoveFolder(fs3, str, empty);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    hr = IFileSystem3_MoveFolder(fs3, empty, str);
+    ok(hr == E_INVALIDARG, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(str);
+    SysFreeString(empty);
+
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst); /* dst already exists */
+    ok(hr == CTL_E_FILEALREADYEXISTS, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    ok(RemoveDirectoryW(buffW1), "can't remove %s directory\n", wine_dbgstr_w(buffW1));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst); /* src nonexistant */
+    ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+
+    file = CreateFileW(buffW1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+                       FILE_ATTRIBUTE_NORMAL, NULL);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile failed\n");
+    CloseHandle(file);
+
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst); /* src is regular file */
+    ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    DeleteFileW(buffW1);
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"bar");
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    lstrcpyW(pathW,buffW2);
+    lstrcatW(pathW,L"\\");
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(pathW);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    lstrcatW(pathW,L"foo");
+    ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"bar");
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    lstrcpyW(pathW,buffW1);
+    lstrcatW(pathW,L"\\");
+    src = SysAllocString(pathW);
+    dst = SysAllocString(buffW2);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    ok(RemoveDirectoryW(buffW1), "can't remove %s directory\n", wine_dbgstr_w(buffW1));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"bar");
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    lstrcpyW(pathW,buffW2);
+    lstrcatW(pathW,L"/");
+    src = SysAllocString(buffW1);
+    dst = SysAllocString(pathW);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    lstrcatW(pathW,L"foo");
+    ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo1");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"foo2");
+    GetTempPathW(MAX_PATH, buffW3);
+    lstrcatW(buffW3,L"foo3");
+    GetTempPathW(MAX_PATH, srcW);
+    lstrcatW(srcW,L"foo?");
+    GetTempPathW(MAX_PATH, pathW);
+    lstrcatW(pathW,L"bar");
+    ok(CreateDirectoryW(buffW1, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW1));
+    ok(CreateDirectoryW(buffW2, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(buffW2));
+    ok(CreateDirectoryW(pathW, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(pathW));
+    /* create a file, should not be moved by MoveFolder() */
+    file = CreateFileW(buffW3, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+                       FILE_ATTRIBUTE_NORMAL, NULL);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile failed\n");
+    CloseHandle(file);
+    src = SysAllocString(srcW);
+    dst = SysAllocString(pathW);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == S_OK, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    lstrcpyW(buffW1,pathW);
+    lstrcatW(buffW1,L"\\foo1");
+    lstrcpyW(buffW2,pathW);
+    lstrcatW(buffW2,L"\\foo2");
+    ok(RemoveDirectoryW(buffW1), "can't remove %s directory\n", wine_dbgstr_w(buffW1));
+    ok(RemoveDirectoryW(buffW2), "can't remove %s directory\n", wine_dbgstr_w(buffW2));
+    ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
+    ok(DeleteFileW(buffW3), "can't remove %s\n", wine_dbgstr_w(buffW3));
+
+    GetTempPathW(MAX_PATH, buffW1);
+    lstrcatW(buffW1,L"foo1");
+    GetTempPathW(MAX_PATH, buffW2);
+    lstrcatW(buffW2,L"foo2");
+    GetTempPathW(MAX_PATH, srcW);
+    lstrcatW(srcW,L"foo*");
+    GetTempPathW(MAX_PATH, pathW);
+    lstrcatW(pathW,L"bar");
+    ok(CreateDirectoryW(pathW, NULL), "CreateDirectory(%s) failed\n", wine_dbgstr_w(pathW));
+    /* create two files, should not be moved by MoveFolder() */
+    file = CreateFileW(buffW1, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+                       FILE_ATTRIBUTE_NORMAL, NULL);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile failed\n");
+    CloseHandle(file);
+    file = CreateFileW(buffW2, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
+                       FILE_ATTRIBUTE_NORMAL, NULL);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile failed\n");
+    CloseHandle(file);
+    src = SysAllocString(srcW);
+    dst = SysAllocString(pathW);
+    hr = IFileSystem3_MoveFolder(fs3, src, dst);
+    ok(hr == CTL_E_PATHNOTFOUND, "Unexpected hr %#lx.\n", hr);
+    SysFreeString(src);
+    SysFreeString(dst);
+    ok(RemoveDirectoryW(pathW), "can't remove %s directory\n", wine_dbgstr_w(pathW));
+    ok(DeleteFileW(buffW1), "can't remove %s\n", wine_dbgstr_w(buffW1));
+    ok(DeleteFileW(buffW2), "can't remove %s\n", wine_dbgstr_w(buffW2));
+}
+
 static void test_DoOpenPipeStream(void)
 {
     static const char testdata[] = "test";
@@ -2772,6 +2950,7 @@ START_TEST(filesystem)
     test_GetExtensionName();
     test_GetSpecialFolder();
     test_MoveFile();
+    test_MoveFolder();
     test_DoOpenPipeStream();
 
     IFileSystem3_Release(fs3);
diff --git a/dlls/setupapi/diskspace.c b/dlls/setupapi/diskspace.c
index 5b89fd5..39663aa 100644
--- a/dlls/setupapi/diskspace.c
+++ b/dlls/setupapi/diskspace.c
@@ -1,6 +1,7 @@
 /*
  * SetupAPI DiskSpace functions
  *
+ * Copyright 2016 Michael MÃ¼ller
  * Copyright 2004 CodeWeavers (Aric Stewart)
  *
  * This library is free software; you can redistribute it and/or
@@ -19,6 +20,7 @@
  */
 
 #include <stdarg.h>
+#include <stdlib.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -27,69 +29,81 @@
 #include "winnls.h"
 #include "winreg.h"
 #include "setupapi.h"
+#include "wine/list.h"
 #include "wine/debug.h"
+#include "setupapi_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(setupapi);
 
-typedef struct {
-    WCHAR   lpzName[20];
-    LONGLONG dwFreeSpace;
-    LONGLONG dwWantedSpace;
-} DRIVE_ENTRY, *LPDRIVE_ENTRY;
+struct file_entry
+{
+    struct list entry;
+    WCHAR *path;
+    UINT operation;
+    LONGLONG size;
+};
+
+struct space_list
+{
+    struct list files;
+    UINT flags;
+};
+
+static LONGLONG get_file_size(WCHAR *path)
+{
+    HANDLE file;
+    LARGE_INTEGER size;
+
+    file = CreateFileW(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (file == INVALID_HANDLE_VALUE) return 0;
+
+    if (!GetFileSizeEx(file, &size))
+        size.QuadPart = 0;
+
+    CloseHandle(file);
+    return size.QuadPart;
+}
+
+static BOOL get_size_from_inf(HINF layoutinf, WCHAR *filename, LONGLONG *size)
+{
+    static const WCHAR SourceDisksFiles[]  = {'S','o','u','r','c','e','D','i','s','k','s','F','i','l','e','s',0};
+    INFCONTEXT context;
+    WCHAR buffer[20];
+
+    if (!SetupFindFirstLineW(layoutinf, SourceDisksFiles, filename, &context))
+        return FALSE;
 
-typedef struct {
-    DWORD   dwDriveCount;
-    DRIVE_ENTRY Drives[26];
-} DISKSPACELIST, *LPDISKSPACELIST;
+    if (!SetupGetStringFieldW(&context, 3, buffer, sizeof(buffer), NULL))
+        return FALSE;
 
+    /* FIXME: is there a atollW ? */
+    *size = wcstol(buffer, NULL, 10);
+    return TRUE;
+}
 
 /***********************************************************************
  *		SetupCreateDiskSpaceListW  (SETUPAPI.@)
  */
-HDSKSPC WINAPI SetupCreateDiskSpaceListW(PVOID Reserved1, DWORD Reserved2, UINT Flags)
+HDSKSPC WINAPI SetupCreateDiskSpaceListW(PVOID reserved1, DWORD reserved2, UINT flags)
 {
-    WCHAR drives[255];
-    DWORD rc;
-    WCHAR *ptr;
-    LPDISKSPACELIST list=NULL;
+    struct space_list *list;
 
-    TRACE("(%p, %lu, 0x%08x)\n", Reserved1, Reserved2, Flags);
+    TRACE("(%p, %lu, 0x%08x)\n", reserved1, reserved2, flags);
 
-    if (Reserved1 || Reserved2 || Flags & ~SPDSL_IGNORE_DISK)
+    if (reserved1 || reserved2 || flags & ~SPDSL_IGNORE_DISK)
     {
         SetLastError(ERROR_INVALID_PARAMETER);
         return NULL;
     }
 
-    rc = GetLogicalDriveStringsW(255,drives);
-
-    if (rc == 0)
-        return NULL;
-
-    list = malloc(sizeof(DISKSPACELIST));
-
-    list->dwDriveCount = 0;
-    
-    ptr = drives;
-    
-    while (*ptr)
+    list = malloc(sizeof(*list));
+    if (list)
     {
-        DWORD type = GetDriveTypeW(ptr);
-        if (type == DRIVE_FIXED)
-        {
-            DWORD clusters;
-            DWORD sectors;
-            DWORD bytes;
-            DWORD total;
-            lstrcpyW(list->Drives[list->dwDriveCount].lpzName,ptr);
-            GetDiskFreeSpaceW(ptr,&sectors,&bytes,&clusters,&total);
-            list->Drives[list->dwDriveCount].dwFreeSpace = clusters * sectors *
-                                                           bytes;
-            list->Drives[list->dwDriveCount].dwWantedSpace = 0;
-            list->dwDriveCount++;
-        }
-       ptr += lstrlenW(ptr) + 1;
+        list->flags = flags;
+        list_init(&list->files);
     }
+
     return list;
 }
 
@@ -105,32 +119,58 @@ HDSKSPC WINAPI SetupCreateDiskSpaceListA(PVOID Reserved1, DWORD Reserved2, UINT
 /***********************************************************************
  *		SetupDuplicateDiskSpaceListW  (SETUPAPI.@)
  */
-HDSKSPC WINAPI SetupDuplicateDiskSpaceListW(HDSKSPC DiskSpace, PVOID Reserved1, DWORD Reserved2, UINT Flags)
+HDSKSPC WINAPI SetupDuplicateDiskSpaceListW(HDSKSPC diskspace, PVOID reserved1, DWORD reserved2, UINT flags)
 {
-    DISKSPACELIST *list_copy, *list_original = DiskSpace;
+    struct space_list *list_copy, *list = diskspace;
+    struct file_entry *file, *file_copy;
+
+    TRACE("(%p, %p, %lu, %u)\n", diskspace, reserved1, reserved2, flags);
 
-    if (Reserved1 || Reserved2 || Flags)
+    if (reserved1 || reserved2 || flags)
     {
         SetLastError(ERROR_INVALID_PARAMETER);
         return NULL;
     }
 
-    if (!DiskSpace)
+    if (!diskspace)
     {
         SetLastError(ERROR_INVALID_HANDLE);
         return NULL;
     }
 
-    list_copy = malloc(sizeof(DISKSPACELIST));
+    list_copy = malloc(sizeof(*list_copy));
     if (!list_copy)
     {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
         return NULL;
     }
 
-    *list_copy = *list_original;
+    list_copy->flags = list->flags;
+    list_init(&list_copy->files);
+
+    LIST_FOR_EACH_ENTRY(file, &list->files, struct file_entry, entry)
+    {
+        file_copy = malloc(sizeof(*file_copy));
+        if (!file_copy) goto error;
+
+        file_copy->path = wcsdup(file->path);
+        if (!file_copy->path)
+        {
+            free(file_copy);
+            goto error;
+        }
+
+        file_copy->operation = file->operation;
+        file_copy->size = file->size;
+        list_add_head(&list_copy->files, &file->entry);
+    }
 
     return list_copy;
+
+error:
+    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+    SetupDestroyDiskSpaceList(list_copy);
+    return NULL;
 }
 
 /***********************************************************************
@@ -142,68 +182,254 @@ HDSKSPC WINAPI SetupDuplicateDiskSpaceListA(HDSKSPC DiskSpace, PVOID Reserved1,
 }
 
 /***********************************************************************
- *		SetupAddInstallSectionToDiskSpaceListA  (SETUPAPI.@)
+ *      SetupAddSectionToDiskSpaceListW  (SETUPAPI.@)
  */
-BOOL WINAPI SetupAddInstallSectionToDiskSpaceListA(HDSKSPC DiskSpace, 
-                        HINF InfHandle, HINF LayoutInfHandle, 
-                        LPCSTR SectionName, PVOID Reserved1, UINT Reserved2)
+BOOL WINAPI SetupAddSectionToDiskSpaceListW(HDSKSPC diskspace, HINF hinf, HINF hlist,
+                                            PCWSTR section, UINT operation, PVOID reserved1,
+                                            UINT reserved2)
 {
-    FIXME ("Stub\n");
-    return TRUE;
+    static const WCHAR sepW[] = {'\\',0};
+    WCHAR dest[MAX_PATH], src[MAX_PATH], *dest_dir, *full_path;
+    INFCONTEXT context;
+    BOOL ret = FALSE;
+
+    TRACE("(%p, %p, %p, %s, %u, %p, %u)\n", diskspace, hinf, hlist, debugstr_w(section),
+                                            operation, reserved1, reserved2);
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return FALSE;
+    }
+
+    if (!section)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    if (!hlist) hlist = hinf;
+
+    if (!SetupFindFirstLineW(hlist, section, NULL, &context))
+    {
+        SetLastError(ERROR_SECTION_NOT_FOUND);
+        return FALSE;
+    }
+
+    dest_dir = get_destination_dir(hinf, section);
+    if (!dest_dir)
+    {
+        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+        return FALSE;
+    }
+
+    do
+    {
+        LONGLONG filesize;
+        int path_size;
+        BOOL tmp_ret;
+
+        if (!SetupGetStringFieldW(&context, 1, dest, sizeof(dest) / sizeof(WCHAR), NULL))
+            goto end;
+        if (!SetupGetStringFieldW(&context, 2, src, sizeof(src) / sizeof(WCHAR), NULL))
+            *src = 0;
+        if (!get_size_from_inf(hinf, src[0] ? src : dest, &filesize))
+            goto end;
+
+        path_size = lstrlenW(dest_dir) + lstrlenW(dest) + 2;
+        full_path = HeapAlloc(GetProcessHeap(), 0, path_size * sizeof(WCHAR));
+        if (!full_path)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            goto end;
+        }
+
+        lstrcpyW(full_path, dest_dir);
+        lstrcatW(full_path, sepW);
+        lstrcatW(full_path, dest);
+
+        tmp_ret = SetupAddToDiskSpaceListW(diskspace, full_path, filesize, operation, 0, 0);
+        HeapFree(GetProcessHeap(), 0, full_path);
+        if (!tmp_ret) goto end;
+    }
+    while (SetupFindNextLine(&context, &context));
+
+    ret = TRUE;
+
+end:
+    HeapFree(GetProcessHeap(), 0, dest_dir);
+    return ret;
 }
 
 /***********************************************************************
-*		SetupQuerySpaceRequiredOnDriveW  (SETUPAPI.@)
-*/
-BOOL WINAPI SetupQuerySpaceRequiredOnDriveW(HDSKSPC DiskSpace,
-                        LPCWSTR DriveSpec, LONGLONG *SpaceRequired,
-                        PVOID Reserved1, UINT Reserved2)
+ *      SetupAddInstallSectionToDiskSpaceListA  (SETUPAPI.@)
+ */
+BOOL WINAPI SetupAddSectionToDiskSpaceListA(HDSKSPC diskspace, HINF hinf, HINF hlist,
+                                            PCSTR section, UINT operation, PVOID reserved1,
+                                            UINT reserved2)
 {
-    WCHAR *driveW;
-    unsigned int i;
-    LPDISKSPACELIST list = DiskSpace;
-    BOOL rc = FALSE;
-    static const WCHAR bkslsh[]= {'\\',0};
+    LPWSTR sectionW = NULL;
+    DWORD len;
+    BOOL ret;
 
-    if (!DiskSpace)
+    if (section)
+    {
+        len = MultiByteToWideChar(CP_ACP, 0, section, -1, NULL, 0);
+
+        sectionW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+        if (!sectionW)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, section, -1, sectionW, len);
+    }
+
+    ret = SetupAddSectionToDiskSpaceListW(diskspace, hinf, hlist, sectionW, operation,
+                                          reserved1, reserved2);
+    if (sectionW) HeapFree(GetProcessHeap(), 0, sectionW);
+    return ret;
+}
+
+/***********************************************************************
+ *      SetupAddInstallSectionToDiskSpaceListW  (SETUPAPI.@)
+ */
+BOOL WINAPI SetupAddInstallSectionToDiskSpaceListW(HDSKSPC diskspace,
+                        HINF inf, HINF layoutinf, LPCWSTR section,
+                        PVOID reserved1, UINT reserved2)
+{
+    static const WCHAR CopyFiles[]  = {'C','o','p','y','F','i','l','e','s',0};
+    static const WCHAR DelFiles[]   = {'D','e','l','F','i','l','e','s',0};
+    WCHAR section_name[MAX_PATH];
+    INFCONTEXT context;
+    BOOL ret;
+    int i;
+
+    TRACE("(%p, %p, %p, %s, %p, %u)\n", diskspace, inf, layoutinf, debugstr_w(section),
+                                        reserved1, reserved2);
+
+    if (!diskspace)
     {
         SetLastError(ERROR_INVALID_HANDLE);
         return FALSE;
     }
 
-    if (!DriveSpec)
+    if (!section)
     {
         SetLastError(ERROR_INVALID_PARAMETER);
         return FALSE;
     }
 
-    driveW = malloc((wcslen(DriveSpec) + 2) * sizeof(WCHAR));
-    if (!driveW)
+    if (!inf) return TRUE;
+    if (!layoutinf) layoutinf = inf;
+
+    ret = SetupFindFirstLineW(inf, section, CopyFiles, &context);
+    while (ret)
     {
-        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
-        return FALSE;
+        for (i = 1;; i++)
+        {
+            if (!SetupGetStringFieldW(&context, i, section_name, sizeof(section_name) / sizeof(WCHAR), NULL))
+                break;
+            SetupAddSectionToDiskSpaceListW(diskspace, layoutinf, inf, section_name, FILEOP_COPY, 0, 0);
+        }
+        ret = SetupFindNextLine(&context, &context);
     }
 
-    lstrcpyW(driveW,DriveSpec);
-    lstrcatW(driveW,bkslsh);
+    ret = SetupFindFirstLineW(inf, section, DelFiles, &context);
+    while (ret)
+    {
+        for (i = 1;; i++)
+        {
+            if (!SetupGetStringFieldW(&context, i, section_name, sizeof(section_name) / sizeof(WCHAR), NULL))
+                break;
+            SetupAddSectionToDiskSpaceListW(diskspace, layoutinf, inf, section_name, FILEOP_DELETE, 0, 0);
+        }
+        ret = SetupFindNextLine(&context, &context);
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *		SetupAddInstallSectionToDiskSpaceListA  (SETUPAPI.@)
+ */
+BOOL WINAPI SetupAddInstallSectionToDiskSpaceListA(HDSKSPC diskspace,
+                        HINF inf, HINF layoutinf, LPCSTR section,
+                        PVOID reserved1, UINT reserved2)
+{
+    LPWSTR sectionW = NULL;
+    DWORD len;
+    BOOL ret;
 
-    TRACE("Looking for drive %s\n",debugstr_w(driveW));
- 
-    for (i = 0; i < list->dwDriveCount; i++)
+    if (section)
     {
-        TRACE("checking drive %s\n",debugstr_w(list->Drives[i].lpzName));
-        if (wcscmp(driveW,list->Drives[i].lpzName)==0)
+        len = MultiByteToWideChar(CP_ACP, 0, section, -1, NULL, 0);
+
+        sectionW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+        if (!sectionW)
         {
-            rc = TRUE;
-            *SpaceRequired = list->Drives[i].dwWantedSpace;
-            break;
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
         }
+
+        MultiByteToWideChar(CP_ACP, 0, section, -1, sectionW, len);
     }
 
-    free(driveW);
+    ret = SetupAddInstallSectionToDiskSpaceListW(diskspace, inf, layoutinf,
+                                                 sectionW, reserved1, reserved2);
+    if (sectionW) HeapFree(GetProcessHeap(), 0, sectionW);
+    return ret;
+}
+
+/***********************************************************************
+*		SetupQuerySpaceRequiredOnDriveW  (SETUPAPI.@)
+*/
+BOOL WINAPI SetupQuerySpaceRequiredOnDriveW(HDSKSPC diskspace,
+                        LPCWSTR drivespec, LONGLONG *required,
+                        PVOID reserved1, UINT reserved2)
+{
+    struct space_list *list = diskspace;
+    struct file_entry *file;
+    LONGLONG sum = 0;
+
+    TRACE("(%p, %s, %p, %p, %u)\n", diskspace, debugstr_w(drivespec), required, reserved1, reserved2);
 
-    if (!rc) SetLastError(ERROR_INVALID_DRIVE);
-    return rc;
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return FALSE;
+    }
+
+    if (!drivespec || !drivespec[0])
+    {
+        SetLastError(drivespec ? ERROR_INVALID_DRIVE : ERROR_INVALID_DRIVE);
+        return FALSE;
+    }
+
+    if (!required)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    if (towlower(drivespec[0]) < 'a' || towlower(drivespec[0]) > 'z' ||
+        drivespec[1] != ':' || drivespec[2] != 0)
+    {
+        FIXME("UNC paths not yet supported (%s)\n", debugstr_w(drivespec));
+        SetLastError((GetVersion() & 0x80000000) ? ERROR_INVALID_DRIVE : ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    LIST_FOR_EACH_ENTRY(file, &list->files, struct file_entry, entry)
+    {
+        if (towlower(file->path[0]) == towlower(drivespec[0]) &&
+            file->path[1] == ':' && file->path[2] == '\\')
+            sum += file->size;
+    }
+
+    *required = sum;
+    return TRUE;
 }
 
 /***********************************************************************
@@ -253,33 +479,242 @@ BOOL WINAPI SetupQuerySpaceRequiredOnDriveA(HDSKSPC DiskSpace,
 /***********************************************************************
 *		SetupDestroyDiskSpaceList  (SETUPAPI.@)
 */
-BOOL WINAPI SetupDestroyDiskSpaceList(HDSKSPC DiskSpace)
+BOOL WINAPI SetupDestroyDiskSpaceList(HDSKSPC diskspace)
 {
-    LPDISKSPACELIST list = DiskSpace;
+    struct space_list *list = diskspace;
+    struct file_entry *file, *file2;
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    LIST_FOR_EACH_ENTRY_SAFE(file, file2, &list->files, struct file_entry, entry)
+    {
+        free(file->path);
+        list_remove(&file->entry);
+        free(file);
+    }
+
     free(list);
     return TRUE;
 }
 
 /***********************************************************************
-*		SetupAddToDiskSpaceListA  (SETUPAPI.@)
+*		SetupAddToDiskSpaceListW  (SETUPAPI.@)
 */
-BOOL WINAPI SetupAddToDiskSpaceListA(HDSKSPC diskspace, PCSTR targetfile,
+BOOL WINAPI SetupAddToDiskSpaceListW(HDSKSPC diskspace, PCWSTR targetfile,
                                     LONGLONG filesize, UINT operation,
                                     PVOID reserved1, UINT reserved2)
 {
-    FIXME(": stub\n");
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    struct space_list *list = diskspace;
+    struct file_entry *file;
+    WCHAR *fullpathW;
+    BOOL ret = FALSE;
+    DWORD size;
+
+    TRACE("(%p, %s, %s, %u, %p, %u)\n", diskspace, debugstr_w(targetfile),
+          wine_dbgstr_longlong(filesize), operation, reserved1, reserved2);
+
+    if (!targetfile)
+        return TRUE;
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_HANDLE);
+        return FALSE;
+    }
+
+    if (operation != FILEOP_COPY && operation != FILEOP_DELETE)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    size = GetFullPathNameW(targetfile, 0, NULL, NULL);
+    if (!size)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    size = (size+1) * sizeof(WCHAR);
+    fullpathW = HeapAlloc(GetProcessHeap(), 0, size);
+
+    if (!GetFullPathNameW(targetfile, size, fullpathW, NULL))
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        goto done;
+    }
+
+    if (fullpathW[1] != ':' && fullpathW[2] != '\\')
+    {
+        FIXME("UNC paths not yet supported\n");
+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+        goto done;
+    }
+
+    LIST_FOR_EACH_ENTRY(file, &list->files, struct file_entry, entry)
+    {
+        if (!lstrcmpiW(file->path, fullpathW))
+            break;
+    }
+
+    if (&file->entry == &list->files)
+    {
+        file = HeapAlloc(GetProcessHeap(), 0, sizeof(*file));
+        if (!file)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            goto done;
+        }
+
+        file->path = wcsdup(fullpathW);
+        if (!file->path)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            HeapFree(GetProcessHeap(), 0, file);
+            goto done;
+        }
+
+        list_add_tail(&list->files, &file->entry);
+    }
+    else if (operation == FILEOP_DELETE)
+    {
+        /* delete operations for added files are ignored */
+        ret = TRUE;
+        goto done;
+    }
+
+    file->operation = operation;
+    if (operation == FILEOP_COPY)
+        file->size = filesize;
+    else
+        file->size = 0;
+
+    if (!(list->flags & SPDSL_IGNORE_DISK))
+        file->size -= get_file_size(fullpathW);
+
+    ret = TRUE;
+
+done:
+    HeapFree(GetProcessHeap(), 0, fullpathW);
+    return ret;
 }
 
 /***********************************************************************
-*		SetupAddToDiskSpaceListW  (SETUPAPI.@)
+*       SetupAddToDiskSpaceListA  (SETUPAPI.@)
 */
-BOOL WINAPI SetupAddToDiskSpaceListW(HDSKSPC diskspace, PCWSTR targetfile,
+BOOL WINAPI SetupAddToDiskSpaceListA(HDSKSPC diskspace, PCSTR targetfile,
                                     LONGLONG filesize, UINT operation,
                                     PVOID reserved1, UINT reserved2)
 {
-    FIXME(": stub\n");
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    LPWSTR targetfileW = NULL;
+    DWORD len;
+    BOOL ret;
+
+    if (targetfile)
+    {
+        len = MultiByteToWideChar(CP_ACP, 0, targetfile, -1, NULL, 0);
+
+        targetfileW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+        if (!targetfileW)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
+        }
+
+        MultiByteToWideChar(CP_ACP, 0, targetfile, -1, targetfileW, len);
+    }
+
+    ret = SetupAddToDiskSpaceListW(diskspace, targetfileW, filesize,
+                                   operation, reserved1, reserved2);
+    if (targetfileW) HeapFree(GetProcessHeap(), 0, targetfileW);
+    return ret;
+}
+
+/***********************************************************************
+ *      SetupQueryDrivesInDiskSpaceListW (SETUPAPI.@)
+ */
+BOOL WINAPI SetupQueryDrivesInDiskSpaceListW(HDSKSPC diskspace, PWSTR buffer, DWORD size, PDWORD required_size)
+{
+    struct space_list *list = diskspace;
+    struct file_entry *file;
+    DWORD cur_size = 1;
+    BOOL used[26];
+
+    TRACE("(%p, %p, %ld, %p)\n", diskspace, buffer, size, required_size);
+
+    if (!diskspace)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    memset(&used, 0, sizeof(used));
+    LIST_FOR_EACH_ENTRY(file, &list->files, struct file_entry, entry)
+    {
+        int device;
+
+        /* UNC paths are not yet supported by this function */
+        if (towlower(file->path[0]) < 'a' || towlower(file->path[0]) > 'z' || file->path[1] != ':')
+            continue;
+
+        device = towlower(file->path[0]) - 'a';
+        if (used[device]) continue;
+
+        cur_size += 3;
+
+        if (buffer)
+        {
+            if (cur_size > size)
+            {
+                if (required_size) *required_size = cur_size;
+                SetLastError(ERROR_INSUFFICIENT_BUFFER);
+                return FALSE;
+            }
+            *buffer++ = towlower(file->path[0]);
+            *buffer++ = ':';
+            *buffer++ = 0;
+        }
+
+        used[device] = TRUE;
+    }
+
+    if (buffer && size) *buffer = 0;
+    if (required_size)  *required_size = cur_size;
+    return TRUE;
+}
+
+/***********************************************************************
+ *      SetupQueryDrivesInDiskSpaceListA (SETUPAPI.@)
+ */
+BOOL WINAPI SetupQueryDrivesInDiskSpaceListA(HDSKSPC diskspace, PSTR buffer, DWORD size, PDWORD required_size)
+{
+    WCHAR *bufferW = NULL;
+    BOOL ret;
+    int i;
+
+    if (buffer && size)
+    {
+        bufferW = HeapAlloc(GetProcessHeap(), 0, size * sizeof(WCHAR));
+        if (!bufferW)
+        {
+            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
+            return FALSE;
+        }
+    }
+
+    ret = SetupQueryDrivesInDiskSpaceListW(diskspace, bufferW ? bufferW : (WCHAR *)buffer,
+                                           size, required_size);
+
+    if (bufferW)
+    {
+        for (i = 0; i < size; i++)
+            buffer[i] = bufferW[i];
+        HeapFree(GetProcessHeap(), 0, bufferW);
+    }
+
+    return ret;
 }
diff --git a/dlls/setupapi/query.c b/dlls/setupapi/query.c
index 88efea1..24f0537 100644
--- a/dlls/setupapi/query.c
+++ b/dlls/setupapi/query.c
@@ -732,6 +732,16 @@ BOOL WINAPI SetupGetInfDriverStoreLocationW(
     return FALSE;
 }
 
+HRESULT WINAPI DriverStoreFindDriverPackageW(const WCHAR *path_in, void *unk2, void *unk3, DWORD flags, void *unk5, WCHAR *path_out, DWORD *path_size)
+{
+    FIXME("%s, %p, %p, %lu, %p, %p, %p, %lu stub!\n", debugstr_w(path_in), unk2, unk3, flags, unk5, path_out, path_size, path_size ? *path_size : 0);
+    if (!path_in || !path_out || !path_size || *path_size < MAX_PATH)
+        return E_INVALIDARG;
+
+    wcscpy(path_out, path_in);
+    return S_OK;
+}
+
 BOOL WINAPI SetupQueryInfVersionInformationA(SP_INF_INFORMATION *info, UINT index, const char *key, char *buff,
     DWORD size, DWORD *req_size)
 {
diff --git a/dlls/setupapi/queue.c b/dlls/setupapi/queue.c
index 40e106f..53053e8 100644
--- a/dlls/setupapi/queue.c
+++ b/dlls/setupapi/queue.c
@@ -337,7 +337,7 @@ static void get_source_info( HINF hinf, const WCHAR *src_file, SP_FILE_COPY_PARA
  *
  * Retrieve the destination dir for a given section.
  */
-static WCHAR *get_destination_dir( HINF hinf, const WCHAR *section )
+WCHAR *get_destination_dir( HINF hinf, const WCHAR *section )
 {
     INFCONTEXT context;
     WCHAR systemdir[MAX_PATH], *dir;
diff --git a/dlls/setupapi/setupapi.spec b/dlls/setupapi/setupapi.spec
index 4d144fe..6a392f6 100644
--- a/dlls/setupapi/setupapi.spec
+++ b/dlls/setupapi/setupapi.spec
@@ -208,6 +208,7 @@
 @ stub DelimStringToMultiSz
 @ stub DestroyTextFileReadBuffer
 @ stdcall DoesUserHavePrivilege(wstr)
+@ stdcall DriverStoreFindDriverPackageW(ptr ptr ptr long ptr ptr ptr)
 @ stdcall DuplicateString(wstr)
 @ stdcall EnablePrivilege(wstr long)
 @ stub ExtensionPropSheetPageProc
@@ -245,9 +246,9 @@
 @ stub SearchForInfFile
 @ stub SetArrayToMultiSzValue
 @ stdcall SetupAddInstallSectionToDiskSpaceListA(long long long str ptr long)
-@ stub SetupAddInstallSectionToDiskSpaceListW
-@ stub SetupAddSectionToDiskSpaceListA
-@ stub SetupAddSectionToDiskSpaceListW
+@ stdcall SetupAddInstallSectionToDiskSpaceListW(long long long wstr ptr long)
+@ stdcall SetupAddSectionToDiskSpaceListA(long long long str long ptr long)
+@ stdcall SetupAddSectionToDiskSpaceListW(long long long wstr long ptr long)
 @ stdcall SetupAddToDiskSpaceListA(long str int64 long ptr long)
 @ stdcall SetupAddToDiskSpaceListW(long wstr int64 long ptr long)
 @ stdcall SetupAddToSourceListA(long str)
diff --git a/dlls/setupapi/setupapi_private.h b/dlls/setupapi/setupapi_private.h
index 9d3d19c..c93cfd6 100644
--- a/dlls/setupapi/setupapi_private.h
+++ b/dlls/setupapi/setupapi_private.h
@@ -86,6 +86,8 @@ extern const WCHAR *DIRID_get_string( int dirid );
 extern const WCHAR *PARSER_get_inf_filename( HINF hinf );
 extern WCHAR *PARSER_get_dest_dir( INFCONTEXT *context );
 
+extern WCHAR *get_destination_dir( HINF hinf, const WCHAR *section );
+
 /* support for ANSI queue callback functions */
 
 struct callback_WtoA_context
diff --git a/dlls/setupapi/stubs.c b/dlls/setupapi/stubs.c
index 75185de..7f7aed6 100644
--- a/dlls/setupapi/stubs.c
+++ b/dlls/setupapi/stubs.c
@@ -230,24 +230,6 @@ INT WINAPI SetupPromptReboot( HSPFILEQ file_queue, HWND owner, BOOL scan_only )
     return 0;
 }
 
-/***********************************************************************
- *      SetupQueryDrivesInDiskSpaceListA (SETUPAPI.@)
- */
-BOOL WINAPI SetupQueryDrivesInDiskSpaceListA(HDSKSPC disk_space, PSTR return_buffer, DWORD return_buffer_size, PDWORD required_size)
-{
-    FIXME("%p, %p, %ld, %p: stub\n", disk_space, return_buffer, return_buffer_size, required_size);
-    return FALSE;
-}
-
-/***********************************************************************
- *      SetupQueryDrivesInDiskSpaceListW (SETUPAPI.@)
- */
-BOOL WINAPI SetupQueryDrivesInDiskSpaceListW(HDSKSPC disk_space, PWSTR return_buffer, DWORD return_buffer_size, PDWORD required_size)
-{
-    FIXME("%p, %p, %ld, %p: stub\n", disk_space, return_buffer, return_buffer_size, required_size);
-    return FALSE;
-}
-
 /***********************************************************************
  *      SetupAddToSourceListA (SETUPAPI.@)
  */
diff --git a/dlls/setupapi/tests/diskspace.c b/dlls/setupapi/tests/diskspace.c
index 577b1f8..5643f93 100644
--- a/dlls/setupapi/tests/diskspace.c
+++ b/dlls/setupapi/tests/diskspace.c
@@ -19,6 +19,7 @@
  */
 
 #include <stdarg.h>
+#include <stdio.h>
 
 #include "windef.h"
 #include "winbase.h"
@@ -29,6 +30,30 @@
 
 #include "wine/test.h"
 
+#define STD_HEADER "[Version]\r\nSignature=\"$CHICAGO$\"\r\n"
+
+static inline const char* debugstr_longlong(ULONGLONG ll)
+{
+    static char string[17];
+    if (sizeof(ll) > sizeof(unsigned long) && ll >> 32)
+        sprintf(string, "%lx%08lx", (unsigned long)(ll >> 32), (unsigned long)ll);
+    else
+        sprintf(string, "%lx", (unsigned long)ll);
+    return string;
+}
+
+/* create a new file with specified contents and open it */
+static HINF inf_open_file_content(const char * tmpfilename, const char *data, UINT *err_line)
+{
+    DWORD res;
+    HANDLE handle = CreateFileA(tmpfilename, GENERIC_READ|GENERIC_WRITE,
+                                FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0, 0);
+    if (handle == INVALID_HANDLE_VALUE) return 0;
+    if (!WriteFile( handle, data, strlen(data), &res, NULL )) trace( "write error\n" );
+    CloseHandle( handle );
+    return SetupOpenInfFileA( tmpfilename, 0, INF_STYLE_WIN4, err_line );
+}
+
 static void test_SetupCreateDiskSpaceListA(void)
 {
     HDSKSPC ret;
@@ -293,11 +318,31 @@ static void test_SetupDuplicateDiskSpaceListW(void)
     ok(SetupDestroyDiskSpaceList(handle), "Expected SetupDestroyDiskSpaceList to succeed\n");
 }
 
+static LONGLONG get_file_size(char *path)
+{
+    HANDLE file;
+    LARGE_INTEGER size;
+
+    file = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (file == INVALID_HANDLE_VALUE) return 0;
+
+    if (!GetFileSizeEx(file, &size))
+        size.QuadPart = 0;
+
+    CloseHandle(file);
+    return size.QuadPart;
+}
+
 static void test_SetupQuerySpaceRequiredOnDriveA(void)
 {
     BOOL ret;
     HDSKSPC handle;
     LONGLONG space;
+    char windir[MAX_PATH];
+    char drive[3];
+    char tmp[MAX_PATH];
+    LONGLONG size;
 
     SetLastError(0xdeadbeef);
     ret = SetupQuerySpaceRequiredOnDriveA(NULL, NULL, NULL, NULL, 0);
@@ -357,7 +402,7 @@ static void test_SetupQuerySpaceRequiredOnDriveA(void)
     ret = SetupQuerySpaceRequiredOnDriveA(handle, "", NULL, NULL, 0);
     ok(!ret, "Expected SetupQuerySpaceRequiredOnDriveA to return FALSE, got %d\n", ret);
     ok(GetLastError() == ERROR_INVALID_DRIVE,
-       "Expected GetLastError() to return ERROR_INVALID_PARAMETER, got %lu\n",
+       "Expected GetLastError() to return ERROR_INVALID_DRIVE, got %lu\n",
        GetLastError());
 
     SetLastError(0xdeadbeef);
@@ -369,6 +414,155 @@ static void test_SetupQuerySpaceRequiredOnDriveA(void)
        "Expected GetLastError() to return ERROR_INVALID_PARAMETER, got %lu\n",
        GetLastError());
 
+    GetWindowsDirectoryA(windir, MAX_PATH);
+    drive[0] = windir[0]; drive[1] = windir[1]; drive[2] = 0;
+
+    snprintf(tmp, MAX_PATH, "%c:\\wine-test-should-not-exist.txt", drive[0]);
+    ret = SetupAddToDiskSpaceListA(handle, tmp, 0x100000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x100000, "Expected 0x100000 as required space, got %s\n", debugstr_longlong(space));
+
+    /* adding the same file again doesn't sum up the size */
+    ret = SetupAddToDiskSpaceListA(handle, tmp, 0x200000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x200000, "Expected 0x200000 as required space, got %s\n", debugstr_longlong(space));
+
+    /* the device doesn't need to exist */
+    snprintf(tmp, MAX_PATH, "F:\\wine-test-should-not-exist.txt");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, 0x200000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, "F:", &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x200000, "Expected 0x200000 as required space, got %s\n", debugstr_longlong(space));
+
+    snprintf(tmp, MAX_PATH, "F:\\wine-test-should-not-exist.txt");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, 0x200000, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, "F:", &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x200000, "Expected 0x200000 as required space, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    /* the real size is subtracted unless SPDSL_IGNORE_DISK is specified */
+    snprintf(tmp, MAX_PATH, "%s\\regedit.exe", windir);
+
+    size = get_file_size(tmp);
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0 || broken(space == -0x5000) || broken(space == -0x7000),
+       "Expected 0x0 as required space, got %s\n", debugstr_longlong(space));
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size + 0x100000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0x100000 || broken(space == 0xf9000) || broken(space == 0xfb000),
+       "Expected 0x100000 as required space, got %s\n", debugstr_longlong(space));
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size - 0x1000, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == -0x1000 || broken(space == -0x6000) || broken(space == -0x8000),
+       "Expected -0x1000 as required space, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    /* test FILEOP_DELETE, then FILEOP_COPY */
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0 || broken(space == -0x5000) || broken(space == -0x7000),
+       "Expected 0x0 as required space, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    /* test FILEOP_COPY, then FILEOP_DELETE */
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0 || broken(space == -0x5000) || broken(space == -0x7000),
+       "Expected 0x0 as required space, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    /* test FILEOP_DELETE without SPDSL_IGNORE_DISK */
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space <= -size, "Expected space <= -size, got %s\n", debugstr_longlong(space));
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    /* test FILEOP_COPY and FILEOP_DELETE with SPDSL_IGNORE_DISK */
+    handle = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+    ok(handle != NULL,
+       "Expected SetupCreateDiskSpaceListA to return a valid handle, got NULL\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space == 0, "Expected size = 0, got %s\n", debugstr_longlong(space));
+
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+    ret = SetupAddToDiskSpaceListA(handle, tmp, size, FILEOP_DELETE, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    space = 0;
+    ret = SetupQuerySpaceRequiredOnDriveA(handle, drive, &space, NULL, 0);
+    ok(ret, "Expected SetupQuerySpaceRequiredOnDriveA to succeed\n");
+    ok(space >= size, "Expected size >= %s\n", debugstr_longlong(space));
+
     ok(SetupDestroyDiskSpaceList(handle),
        "Expected SetupDestroyDiskSpaceList to succeed\n");
 }
@@ -460,6 +654,456 @@ static void test_SetupQuerySpaceRequiredOnDriveW(void)
        "Expected SetupDestroyDiskSpaceList to succeed\n");
 }
 
+static void test_SetupAddToDiskSpaceListA(void)
+{
+    HDSKSPC handle;
+    BOOL ret;
+
+    ret = SetupAddToDiskSpaceListA(NULL, "C:\\some-file.dat", 0, FILEOP_COPY, 0, 0);
+    ok(!ret, "Expected SetupAddToDiskSpaceListA to return FALSE, got %d\n", ret);
+    ok(GetLastError() == ERROR_INVALID_HANDLE,
+       "Expected GetLastError() to return ERROR_INVALID_HANDLE, got %lu\n", GetLastError());
+
+    handle = SetupCreateDiskSpaceListA(NULL, 0, 0);
+    ok(handle != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, NULL, 0, FILEOP_COPY, 0, 0);
+    ok(ret || broken(!ret) /* >= Vista */, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "C:\\some-file.dat", -20, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "C:\\some-file.dat", 0, FILEOP_RENAME, 0, 0);
+    ok(!ret, "Expected SetupAddToDiskSpaceListA to return FALSE\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER,
+       "Expected GetLastError() to return ERROR_INVALID_PARAMETER, got %lu\n", GetLastError());
+
+    ret = SetupAddToDiskSpaceListA(handle, NULL, 0, FILEOP_RENAME, 0, 0);
+    ok(ret || broken(!ret) /* >= Vista */, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(NULL, NULL, 0, FILEOP_RENAME, 0, 0);
+    ok(ret || broken(!ret) /* >= Vista */, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+}
+
+static void test_SetupQueryDrivesInDiskSpaceListA(void)
+{
+    char buffer[MAX_PATH];
+    HDSKSPC handle;
+    DWORD size;
+    BOOL ret;
+
+    handle = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+    ok(handle != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, NULL, 0, NULL);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, NULL, 0, &size);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+    ok(size == 1, "Expected size 1, got %lu\n", size);
+
+    ret = SetupAddToDiskSpaceListA(handle, "F:\\random-file.dat", 0, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "G:\\random-file.dat", 0, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "G:\\random-file2.dat", 0, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddToDiskSpaceListA(handle, "X:\\random-file.dat", 0, FILEOP_COPY, 0, 0);
+    ok(ret, "Expected SetupAddToDiskSpaceListA to succeed\n");
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, NULL, 0, &size);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+    ok(size == 10, "Expected size 10, got %lu\n", size);
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, 0, &size);
+    ok(!ret, "Expected SetupQueryDrivesInDiskSpaceListA to fail\n");
+    ok(size == 4, "Expected size 4, got %lu\n", size);
+    ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER,
+       "Expected GetLastError() to return ERROR_INSUFFICIENT_BUFFER, got %lu\n", GetLastError());
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, 4, &size);
+    ok(!ret, "Expected SetupQueryDrivesInDiskSpaceListA to fail\n");
+    ok(size == 7, "Expected size 7, got %lu\n", size);
+    ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER,
+       "Expected GetLastError() to return ERROR_INSUFFICIENT_BUFFER, got %lu\n", GetLastError());
+
+    size = 0;
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, 7, &size);
+    ok(!ret, "Expected SetupQueryDrivesInDiskSpaceListA to fail\n");
+    ok(size == 10, "Expected size 10, got %lu\n", size);
+    ok(GetLastError() == ERROR_INSUFFICIENT_BUFFER,
+       "Expected GetLastError() to return ERROR_INSUFFICIENT_BUFFER, got %lu\n", GetLastError());
+
+    size = 0;
+    memset(buffer, 0xff, sizeof(buffer));
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, sizeof(buffer), &size);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+    ok(size == 10, "Expected size 10, got %lu\n", size);
+    ok(!memcmp("f:\0g:\0x:\0\0", buffer, 10), "Device list does not match\n");
+
+    memset(buffer, 0xff, sizeof(buffer));
+    ret = SetupQueryDrivesInDiskSpaceListA(handle, buffer, sizeof(buffer), NULL);
+    ok(ret, "Expected SetupQueryDrivesInDiskSpaceListA to succeed\n");
+    ok(!memcmp("f:\0g:\0x:\0\0", buffer, 10), "Device list does not match\n");
+
+    ok(SetupDestroyDiskSpaceList(handle),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+}
+
+struct device_usage
+{
+    const char *dev;
+    LONGLONG usage;
+};
+
+struct section
+{
+    const char *name;
+    UINT fileop;
+    BOOL result;
+    DWORD error_code;
+};
+
+static const struct
+{
+    const char *data;
+    struct section sections[2];
+    const char *devices;
+    int device_length;
+    struct device_usage usage[2];
+}
+section_test[] =
+{
+    /* 0 */
+    {STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {NULL, 0, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 1 */
+    {STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", FILEOP_DELETE, TRUE, 0}, {NULL, 0, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 0}, {NULL, 0}}},
+    /* 2 */
+    {STD_HEADER "[a]\ntest,,,\n\r\n",
+     {{"a", FILEOP_COPY, FALSE, ERROR_LINE_NOT_FOUND}, {NULL, 0, TRUE, 0}},
+     "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 3 */
+    {STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\n[DestinationDirs]\nDefaultDestDir=-1,F:\\test\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {NULL, 0, TRUE, 0}},
+     "f:\00", sizeof("f:\00"), {{"f:", 4096}, {NULL, 0}}},
+    /* 4 */
+    {STD_HEADER "[a]\ntest,test2,,\n[SourceDisksFiles]\ntest2=1,,4096\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {NULL, 0, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 5 */
+    {STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"b", FILEOP_COPY, FALSE, ERROR_SECTION_NOT_FOUND}, {NULL, 0, TRUE, 0}},
+     "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 6 */
+    {STD_HEADER "[a]\ntest,,,\n[b]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {"b", FILEOP_COPY, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 7 */
+    {STD_HEADER "[a]\ntest,,,\n[b]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\n[DestinationDirs]\nb=-1,F:\\test\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {"b", FILEOP_COPY, TRUE, 0}},
+     "c:\00f:\00", sizeof("c:\00f:\00"), {{"c:", 4096}, {"f:", 4096}}},
+    /* 8 */
+    {STD_HEADER "[a]\ntest,test1,,\n[b]\ntest,test2,,\n[SourceDisksFiles]\ntest1=1,,4096\ntest2=1,,8192\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {"b", FILEOP_COPY, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 8192}, {NULL, 0}}},
+    /* 9 */
+    {STD_HEADER "[a]\ntest1,test,,\n[b]\ntest2,test,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", FILEOP_COPY, TRUE, 0}, {"b", FILEOP_COPY, TRUE, 0}},
+     "c:\00", sizeof("c:\00"), {{"c:", 8192}, {NULL, 0}}},
+};
+
+static void test_SetupAddSectionToDiskSpaceListA(void)
+{
+    char tmp[MAX_PATH];
+    char tmpfilename[MAX_PATH];
+    char buffer[MAX_PATH];
+    HDSKSPC diskspace;
+    UINT err_line;
+    LONGLONG space;
+    BOOL ret;
+    int i, j;
+    HINF inf;
+
+    if (!GetTempPathA(MAX_PATH, tmp))
+    {
+        win_skip("GetTempPath failed with error %lu\n", GetLastError());
+        return;
+    }
+
+    if (!GetTempFileNameA(tmp, "inftest", 0, tmpfilename))
+    {
+        win_skip("GetTempFileNameA failed with error %lu\n", GetLastError());
+        return;
+    }
+
+    inf = inf_open_file_content(tmpfilename, STD_HEADER "[a]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n", &err_line);
+    ok(!!inf, "Failed to open inf file (%lu, line %d)\n", GetLastError(), err_line);
+
+    diskspace = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+    ok(diskspace != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+    ret = SetupAddSectionToDiskSpaceListA(diskspace, NULL, NULL, "a", FILEOP_COPY, 0, 0);
+    ok(!ret, "Expected SetupAddSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_SECTION_NOT_FOUND, "Expected ERROR_SECTION_NOT_FOUND as error, got %lu\n",
+       GetLastError());
+
+    ret = SetupAddSectionToDiskSpaceListA(NULL, inf, NULL, "a", FILEOP_COPY, 0, 0);
+    ok(!ret, "Expected SetupAddSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "Expected ERROR_INVALID_HANDLE as error, got %lu\n",
+       GetLastError());
+
+    ret = SetupAddSectionToDiskSpaceListA(NULL, inf, NULL, "b", FILEOP_COPY, 0, 0);
+    ok(!ret, "Expected SetupAddSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "Expected ERROR_INVALID_HANDLE as error, got %lu\n",
+       GetLastError());
+
+    ret = SetupAddSectionToDiskSpaceListA(diskspace, inf, NULL, "a", 0, 0, 0);
+    ok(ret, "Expected SetupAddSectionToDiskSpaceListA to succeed (%lu)\n", GetLastError());
+
+    ok(SetupDestroyDiskSpaceList(diskspace),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    for (i = 0; i < sizeof(section_test) / sizeof(section_test[0]); i++)
+    {
+        err_line = 0;
+
+        inf = inf_open_file_content(tmpfilename, section_test[i].data, &err_line);
+        ok(!!inf, "test %d: Failed to open inf file (%lu, line %d)\n", i, GetLastError(), err_line);
+        if (!inf) continue;
+
+        diskspace = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+        ok(diskspace != NULL, "Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+        for (j = 0; j < 2; j++)
+        {
+            const struct section *section = &section_test[i].sections[j];
+            if (!section->name)
+                continue;
+
+            SetLastError(0xdeadbeef);
+            ret = SetupAddSectionToDiskSpaceListA(diskspace, inf, NULL, section->name, section->fileop, 0, 0);
+            if (section->result)
+                ok(ret, "test %d: Expected adding section %d to succeed (%lu)\n", i, j, GetLastError());
+            else
+            {
+                ok(!ret, "test %d: Expected adding section %d to fail\n", i, j);
+                ok(GetLastError() == section->error_code, "test %d: Expected %lu as error, got %lu\n",
+                   i, section->error_code, GetLastError());
+            }
+        }
+
+        memset(buffer, 0x0, sizeof(buffer));
+        ret = SetupQueryDrivesInDiskSpaceListA(diskspace, buffer, sizeof(buffer), NULL);
+        ok(ret, "test %d: Expected SetupQueryDrivesInDiskSpaceListA to succeed (%lu)\n", i, GetLastError());
+        ok(!memcmp(section_test[i].devices, buffer, section_test[i].device_length),
+           "test %d: Device list (%s) does not match\n", i, buffer);
+
+        for (j = 0; j < 2; j++)
+        {
+            const struct device_usage *usage = &section_test[i].usage[j];
+            if (!usage->dev)
+                continue;
+
+            space = 0;
+            ret = SetupQuerySpaceRequiredOnDriveA(diskspace, usage->dev, &space, NULL, 0);
+            ok(ret, "test %d: Expected SetupQuerySpaceRequiredOnDriveA to succeed for device %s (%lu)\n",
+               i, usage->dev, GetLastError());
+            ok(space == usage->usage, "test %d: Expected size %lu for device %s, got %lu\n",
+               i, (DWORD)usage->usage, usage->dev, (DWORD)space);
+        }
+
+        ok(SetupDestroyDiskSpaceList(diskspace),
+           "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+        SetupCloseInfFile(inf);
+    }
+
+    DeleteFileA(tmpfilename);
+}
+
+struct section_i
+{
+    const char *name;
+    BOOL result;
+    DWORD error_code;
+};
+
+static const struct
+{
+    const char *data;
+    struct section_i sections[2];
+    const char *devices;
+    int device_length;
+    struct device_usage usage[2];
+}
+section_test_i[] =
+{
+    /* 0 */
+    {STD_HEADER "[a.Install]\nCopyFiles=a.CopyFiles\n"
+                "[a.CopyFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a.Install", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 1 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles\n"
+                "[a.CopyFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 2 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles\nCopyFiles=a.CopyFiles2\n"
+                "[a.CopyFiles]\ntest,,,\n[a.CopyFiles2]\ntest2,,,\n"
+                "[SourceDisksFiles]\ntest=1,,4096\ntest2=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 8192}, {NULL, 0}}},
+    /* 3 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles,a.CopyFiles2\n"
+                "[a.CopyFiles]\ntest,,,\n[a.CopyFiles2]\ntest2,,,\n"
+                "[SourceDisksFiles]\ntest=1,,4096\ntest2=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 8192}, {NULL, 0}}},
+    /* 4 */
+    {STD_HEADER "[a]\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 5 */
+    {STD_HEADER "[a]\nDelFiles=a.DelFiles\n"
+                "[a.nDelFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 6 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles\nDelFiles=a.DelFiles\n"
+                "[a.CopyFiles]\ntest,,,\n[a.DelFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 7 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles\n[b]\nDelFiles=b.DelFiles\n"
+                "[a.CopyFiles]\ntest,,,\n[b.DelFiles]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n",
+     {{"a", TRUE, 0}, {"b", TRUE, 0}}, "c:\00", sizeof("c:\00"), {{"c:", 4096}, {NULL, 0}}},
+    /* 7 */
+    {STD_HEADER "[a]\nCopyFiles=\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 8 */
+    {STD_HEADER "[a]\nCopyFiles=something\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "", sizeof(""), {{NULL, 0}, {NULL, 0}}},
+    /* 9 */
+    {STD_HEADER "[a]\nCopyFiles=a.CopyFiles,b.CopyFiles\n[a.CopyFiles]\ntest,,,\n[b.CopyFiles]\ntest,,,\n"
+                "[SourceDisksFiles]\ntest=1,,4096\n[DestinationDirs]\nb.CopyFiles=-1,F:\\test\r\n",
+     {{"a", TRUE, 0}, {NULL, TRUE, 0}}, "c:\00f:\00", sizeof("c:\00f:\00"), {{"c:", 4096}, {"f:", 4096}}},
+};
+
+static void test_SetupAddInstallSectionToDiskSpaceListA(void)
+{
+    char tmp[MAX_PATH];
+    char tmpfilename[MAX_PATH];
+    char buffer[MAX_PATH];
+    HDSKSPC diskspace;
+    LONGLONG space;
+    UINT err_line;
+    BOOL ret;
+    int i, j;
+    HINF inf;
+
+    if (!GetTempPathA(MAX_PATH, tmp))
+    {
+        win_skip("GetTempPath failed with error %ld\n", GetLastError());
+        return;
+    }
+
+    if (!GetTempFileNameA(tmp, "inftest", 0, tmpfilename))
+    {
+        win_skip("GetTempFileNameA failed with error %ld\n", GetLastError());
+        return;
+    }
+
+    inf = inf_open_file_content(tmpfilename, STD_HEADER "[a]\nCopyFiles=b\n[b]\ntest,,,\n[SourceDisksFiles]\ntest=1,,4096\r\n", &err_line);
+    ok(!!inf, "Failed to open inf file (%ld, line %u)\n", GetLastError(), err_line);
+
+    diskspace = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+    ok(diskspace != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+    ret = SetupAddInstallSectionToDiskSpaceListA(diskspace, NULL, NULL, "a", 0, 0);
+    ok(ret, "Expected SetupAddInstallSectionToDiskSpaceListA to succeed\n");
+
+    ret = SetupAddInstallSectionToDiskSpaceListA(NULL, inf, NULL, "a", 0, 0);
+    ok(!ret, "Expected SetupAddInstallSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "Expected ERROR_INVALID_HANDLE as error, got %lu\n",
+       GetLastError());
+
+    ret = SetupAddInstallSectionToDiskSpaceListA(diskspace, inf, NULL, NULL, 0, 0);
+    ok(!ret || broken(ret), "Expected SetupAddSectionToDiskSpaceListA to fail\n");
+    ok(GetLastError() == ERROR_INVALID_PARAMETER || broken(ret),
+       "Expected ERROR_INVALID_PARAMETER as error, got %lu\n", GetLastError());
+
+    ret = SetupAddInstallSectionToDiskSpaceListA(diskspace, inf, NULL, "", 0, 0);
+    ok(ret, "Expected SetupAddInstallSectionToDiskSpaceListA to succeed (%lu)\n", GetLastError());
+
+    ok(SetupDestroyDiskSpaceList(diskspace),
+       "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+    for (i = 0; i < sizeof(section_test_i) / sizeof(section_test_i[0]); i++)
+    {
+        err_line = 0;
+
+        inf = inf_open_file_content(tmpfilename, section_test_i[i].data, &err_line);
+        ok(!!inf, "test %u: Failed to open inf file (%lu, line %u)\n", i, GetLastError(), err_line);
+        if (!inf) continue;
+
+        diskspace = SetupCreateDiskSpaceListA(NULL, 0, SPDSL_IGNORE_DISK);
+        ok(diskspace != NULL,"Expected SetupCreateDiskSpaceListA to return a valid handle\n");
+
+        for (j = 0; j < 2; j++)
+        {
+            const struct section_i *section = &section_test_i[i].sections[j];
+            if (!section->name)
+                continue;
+
+            SetLastError(0xdeadbeef);
+            ret = SetupAddInstallSectionToDiskSpaceListA(diskspace, inf, NULL, section->name, 0, 0);
+            if (section->result)
+                ok(ret, "test %d: Expected adding section %d to succeed (%lu)\n", i, j, GetLastError());
+            else
+            {
+                ok(!ret, "test %d: Expected adding section %d to fail\n", i, j);
+                ok(GetLastError() == section->error_code, "test %d: Expected %lu as error, got %lu\n",
+                   i, section->error_code, GetLastError());
+            }
+        }
+
+        memset(buffer, 0x0, sizeof(buffer));
+        ret = SetupQueryDrivesInDiskSpaceListA(diskspace, buffer, sizeof(buffer), NULL);
+        ok(ret, "test %d: Expected SetupQueryDrivesInDiskSpaceListA to succeed (%lu)\n", i, GetLastError());
+        ok(!memcmp(section_test_i[i].devices, buffer, section_test_i[i].device_length),
+           "test %d: Device list (%s) does not match\n", i, buffer);
+
+        for (j = 0; j < 2; j++)
+        {
+            const struct device_usage *usage = &section_test_i[i].usage[j];
+            if (!usage->dev)
+                continue;
+
+            space = 0;
+            ret = SetupQuerySpaceRequiredOnDriveA(diskspace, usage->dev, &space, NULL, 0);
+            ok(ret, "test %d: Expected SetupQuerySpaceRequiredOnDriveA to succeed for device %s (%lu)\n",
+               i, usage->dev, GetLastError());
+            ok(space == usage->usage, "test %d: Expected size %lu for device %s, got %lu\n",
+               i, (DWORD)usage->usage, usage->dev, (DWORD)space);
+        }
+
+        ok(SetupDestroyDiskSpaceList(diskspace),
+           "Expected SetupDestroyDiskSpaceList to succeed\n");
+
+        SetupCloseInfFile(inf);
+    }
+
+    DeleteFileA(tmpfilename);
+}
+
 START_TEST(diskspace)
 {
     test_SetupCreateDiskSpaceListA();
@@ -468,4 +1112,8 @@ START_TEST(diskspace)
     test_SetupDuplicateDiskSpaceListW();
     test_SetupQuerySpaceRequiredOnDriveA();
     test_SetupQuerySpaceRequiredOnDriveW();
+    test_SetupAddToDiskSpaceListA();
+    test_SetupQueryDrivesInDiskSpaceListA();
+    test_SetupAddSectionToDiskSpaceListA();
+    test_SetupAddInstallSectionToDiskSpaceListA();
 }
diff --git a/dlls/setupapi/tests/query.c b/dlls/setupapi/tests/query.c
index f7aeba4..864c8d6 100644
--- a/dlls/setupapi/tests/query.c
+++ b/dlls/setupapi/tests/query.c
@@ -513,6 +513,72 @@ static void test_SetupGetTargetPath(void)
     DeleteFileA(inf_filename);
 }
 
+static void test_DriverStoreFindDriverPackageW(void)
+{
+    HMODULE library;
+    HRESULT result;
+    WCHAR buffer[500];
+    DWORD len;
+    HRESULT (WINAPI *pDriverStoreFindDriverPackageW)(const WCHAR*, void*, void*, DWORD, void*, WCHAR*, DWORD*);
+
+    library = LoadLibraryA("setupapi.dll");
+    ok(library != NULL, "Failed to load setupapi.dll\n");
+    if (!library) return;
+
+    pDriverStoreFindDriverPackageW = (void *)GetProcAddress(library, "DriverStoreFindDriverPackageW");
+    if (!pDriverStoreFindDriverPackageW)
+    {
+        win_skip("Can't find DriverStoreFindDriverPackageW\n");
+        return;
+    }
+
+    len = ARRAY_SIZE(buffer);
+
+    /* No invalid parameters, with flags */
+    result = pDriverStoreFindDriverPackageW(L"c:\\nonexistent.inf", 0, 0, 9, 0, buffer, &len);
+    todo_wine
+    ok(result == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Got %lx\n", result);
+
+    /* No invalid parameters, no flags */
+    result = pDriverStoreFindDriverPackageW(L"c:\\nonexistent.inf", 0, 0, 0, 0, buffer, &len);
+    if (sizeof(void *) == 4)
+        todo_wine
+        ok(result == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Got %lx\n", result);
+    else
+        todo_wine
+        ok(result == E_INVALIDARG, "Got %lx\n", result); /* Win64 needs flags 0x9, or it gives invalid parameter */
+
+    /* Invalid parameter tests */
+
+    result = pDriverStoreFindDriverPackageW(L"c:\\nonexistent.inf", 0, 0, 9, 0, 0, &len);
+    ok(result == E_INVALIDARG, "Got %lx\n", result);
+
+    result = pDriverStoreFindDriverPackageW(0, 0, 0, 9, 0, buffer, &len);
+    ok(result == E_INVALIDARG, "Got %lx\n", result);
+
+    result = pDriverStoreFindDriverPackageW(L"", 0, 0, 9, 0, buffer, &len);
+    todo_wine
+    ok(result == HRESULT_FROM_WIN32(ERROR_INVALID_NAME) /* win7 */ || result == E_INVALIDARG /* win10 */, "Got %lx\n", result);
+
+    result = pDriverStoreFindDriverPackageW(L"c:\\nonexistent.inf", 0, 0, 9, 0, buffer, 0);
+    ok(result == E_INVALIDARG, "Got %lx\n", result);
+
+    /* Tests with different length parameter */
+
+    len = 0;
+    result = pDriverStoreFindDriverPackageW(L"c:\\nonexistent.inf", 0, 0, 9, 0, buffer, &len);
+    ok(result == E_INVALIDARG, "Got %lx\n", result);
+
+    len = 259;
+    result = pDriverStoreFindDriverPackageW(L"c:\\nonexistent.inf", 0, 0, 9, 0, buffer, &len);
+    ok(result == E_INVALIDARG, "Got %lx\n", result);
+
+    len = 260;
+    result = pDriverStoreFindDriverPackageW(L"c:\\nonexistent.inf", 0, 0, 9, 0, buffer, &len);
+    todo_wine
+    ok(result == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND), "Got %lx\n", result);
+}
+
 START_TEST(query)
 {
     get_directories();
@@ -521,4 +587,5 @@ START_TEST(query)
     test_SetupGetSourceFileLocation();
     test_SetupGetSourceInfo();
     test_SetupGetTargetPath();
+    test_DriverStoreFindDriverPackageW();
 }
diff --git a/dlls/shdocvw/shdocvw_main.c b/dlls/shdocvw/shdocvw_main.c
index 6556223..194f0cd 100644
--- a/dlls/shdocvw/shdocvw_main.c
+++ b/dlls/shdocvw/shdocvw_main.c
@@ -344,8 +344,7 @@ DWORD WINAPI ParseURLFromOutsideSourceW(LPCWSTR url, LPWSTR out, LPDWORD plen, L
     HRESULT hr;
     DWORD needed;
     DWORD len;
-    DWORD res = 0;
-
+    DWORD res;
 
     TRACE("(%s, %p, %p, %p) len: %ld, unknown: 0x%lx\n", debugstr_w(url), out, plen, unknown,
             plen ? *plen : 0, unknown ? *unknown : 0);
@@ -371,10 +370,12 @@ DWORD WINAPI ParseURLFromOutsideSourceW(LPCWSTR url, LPWSTR out, LPDWORD plen, L
     needed = lstrlenW(buffer_out)+1;
     TRACE("got 0x%lx with %s (need %ld)\n", hr, debugstr_w(buffer_out), needed);
 
+    res = 0;
     if (*plen >= needed) {
         if (out != NULL) {
             lstrcpyW(out, buffer_out);
-            res++;
+            /* On success, 1 is returned for unicode version */
+            res = 1;
         }
         needed--;
     }
@@ -417,6 +418,7 @@ DWORD WINAPI ParseURLFromOutsideSourceA(LPCSTR url, LPSTR out, LPDWORD plen, LPD
     if (*plen >= needed) {
         if (out != NULL) {
             WideCharToMultiByte(CP_ACP, 0, buffer, -1, out, *plen, NULL, NULL);
+            /* On success, string size including terminating 0 is returned for ansi version */
             res = needed;
         }
         needed--;
diff --git a/dlls/shdocvw/tests/shdocvw.c b/dlls/shdocvw/tests/shdocvw.c
index fcfd4a6..24991ea 100644
--- a/dlls/shdocvw/tests/shdocvw.c
+++ b/dlls/shdocvw/tests/shdocvw.c
@@ -212,13 +212,13 @@ static void test_ParseURLFromOutsideSourceA(void)
         buffer[sizeof(buffer)-1] = '\0';
         len = sizeof(buffer);
         dummy = 0;
-        /* on success, len+1 is returned. No idea, if someone depend on this */
+        /* on success, string size including terminating 0 is returned for ansi version */
         res = pParseURLFromOutsideSourceA(ParseURL_table[i].url, buffer, &len, &dummy);
         /* len does not include the terminating 0, when buffer is large enough */
-        ok( res != 0 && len == ParseURL_table[i].len &&
+        ok( res == (ParseURL_table[i].len+1) && len == ParseURL_table[i].len &&
             !lstrcmpA(buffer, ParseURL_table[i].newurl),
-            "#%d: got %ld and %ld with '%s' (expected '!=0' and %ld with '%s')\n",
-            i, res, len, buffer, ParseURL_table[i].len, ParseURL_table[i].newurl);
+            "#%d: got %ld and %ld with '%s' (expected %ld and %ld with '%s')\n",
+            i, res, len, buffer, ParseURL_table[i].len+1, ParseURL_table[i].len, ParseURL_table[i].newurl);
 
 
         /* use the size test only for the first examples */
@@ -308,11 +308,12 @@ static void test_ParseURLFromOutsideSourceW(void)
     /* len is in characters */
     len = ARRAY_SIZE(bufferW);
     dummy = 0;
+    /* on success, 1 is returned for unicode version */
     res = pParseURLFromOutsideSourceW(urlW, bufferW, &len, &dummy);
     WideCharToMultiByte(CP_ACP, 0, bufferW, -1, bufferA, sizeof(bufferA), NULL, NULL);
-    ok( res != 0 && len == ParseURL_table[0].len &&
+    ok( res == 1 && len == ParseURL_table[0].len &&
         !lstrcmpA(bufferA, ParseURL_table[0].newurl),
-        "got %ld and %ld with '%s' (expected '!=0' and %ld with '%s')\n",
+        "got %ld and %ld with '%s' (expected 1 and %ld with '%s')\n",
         res, len, bufferA, ParseURL_table[0].len, ParseURL_table[0].newurl);
 
 
diff --git a/dlls/shell32/Makefile.in b/dlls/shell32/Makefile.in
index 743df59..8d4fa70 100644
--- a/dlls/shell32/Makefile.in
+++ b/dlls/shell32/Makefile.in
@@ -1,7 +1,7 @@
 EXTRADEFS = -D_SHELL32_
 MODULE    = shell32.dll
 IMPORTLIB = shell32
-IMPORTS   = uuid shlwapi user32 gdi32 advapi32
+IMPORTS   = uuid shlwapi user32 gdi32 advapi32 aclui
 DELAYIMPORTS = ole32 oleaut32 shdocvw version comctl32 comdlg32 gdiplus
 
 SOURCES = \
@@ -39,6 +39,8 @@ SOURCES = \
 	resources/folder.svg \
 	resources/folder_open.svg \
 	resources/help.svg \
+	resources/ietoolbar.svg \
+	resources/ietoolbar_small.svg \
 	resources/image.svg \
 	resources/internet.svg \
 	resources/log_off.svg \
@@ -75,6 +77,7 @@ SOURCES = \
 	shelldispatch.c \
 	shellitem.c \
 	shelllink.c \
+	shellnew.c \
 	shellole.c \
 	shellord.c \
 	shellpath.c \
diff --git a/dlls/shell32/brsfolder.c b/dlls/shell32/brsfolder.c
index 63f0a34..3e82584 100644
--- a/dlls/shell32/brsfolder.c
+++ b/dlls/shell32/brsfolder.c
@@ -648,7 +648,7 @@ static LRESULT BrsFolder_Treeview_Keydown(browse_info *info, LPNMTVKEYDOWN keydo
                 return 0;
 
             /* perform the item deletion - tree view gets updated over shell notification */
-            ISFHelper_DeleteItems(psfhlp, 1, &item_id);
+            ISFHelper_DeleteItems(psfhlp, 1, &item_id, TRUE);
             ISFHelper_Release(psfhlp);
         }
         break;
diff --git a/dlls/shell32/clipboard.c b/dlls/shell32/clipboard.c
index 487fd0d..68b6714 100644
--- a/dlls/shell32/clipboard.c
+++ b/dlls/shell32/clipboard.c
@@ -212,3 +212,41 @@ HGLOBAL RenderFILENAMEW (LPITEMIDLIST pidlRoot, LPITEMIDLIST * apidl, UINT cidl)
 
 	return hGlobal;
 }
+
+HGLOBAL RenderPREFERREDDROPEFFECT (DWORD value)
+{
+    DWORD *pEffect;
+    HGLOBAL hGlobal;
+
+    TRACE("(%ld)\n", value);
+
+    hGlobal = GlobalAlloc(GHND|GMEM_SHARE, sizeof(DWORD));
+    if(!hGlobal) return hGlobal;
+
+    pEffect = GlobalLock(hGlobal);
+    if (pEffect)
+    {
+        *pEffect = value;
+        GlobalUnlock(hGlobal);
+    }
+
+    return hGlobal;
+}
+
+HRESULT GetPREFERREDDROPEFFECT (STGMEDIUM *pmedium, DWORD *value)
+{
+    DWORD *pEffect;
+    BOOL result = E_OUTOFMEMORY;
+
+    TRACE("(%p, %p)\n", pmedium, value);
+
+    pEffect = GlobalLock(pmedium->hGlobal);
+    if (pEffect)
+    {
+        *value = *pEffect;
+        result = S_OK;
+        GlobalUnlock(pmedium->hGlobal);
+    }
+
+    return result;
+}
diff --git a/dlls/shell32/dataobject.c b/dlls/shell32/dataobject.c
index 96b9a0a..c0dce2b 100644
--- a/dlls/shell32/dataobject.c
+++ b/dlls/shell32/dataobject.c
@@ -193,7 +193,7 @@ LPENUMFORMATETC IEnumFORMATETC_Constructor(UINT cfmt, const FORMATETC afmt[])
 */
 
 /* number of supported formats */
-#define MAX_FORMATS 4
+#define MAX_FORMATS 5
 
 typedef struct
 {
@@ -205,12 +205,13 @@ typedef struct
 	LPITEMIDLIST	pidl;
 	LPITEMIDLIST *	apidl;
 	UINT		cidl;
+    DWORD       dropEffect;
 
 	FORMATETC	pFormatEtc[MAX_FORMATS];
 	UINT		cfShellIDList;
 	UINT		cfFileNameA;
 	UINT		cfFileNameW;
-
+	UINT        cfDropEffect;
 } IDataObjectImpl;
 
 static inline IDataObjectImpl *impl_from_IDataObject(IDataObject *iface)
@@ -310,6 +311,10 @@ static HRESULT WINAPI IDataObject_fnGetData(IDataObject *iface, LPFORMATETC pfor
 	  if (This->cidl < 1) return(E_UNEXPECTED);
 	  pmedium->hGlobal = RenderFILENAMEW(This->pidl, This->apidl, This->cidl);
 	}
+    else if (pformatetcIn->cfFormat == This->cfDropEffect)
+    {
+        pmedium->hGlobal = RenderPREFERREDDROPEFFECT(This->dropEffect);
+    }
 	else
 	{
 	  FIXME("-- expected clipformat not implemented\n");
@@ -364,7 +369,17 @@ static HRESULT WINAPI IDataObject_fnGetCanonicalFormatEtc(IDataObject *iface, LP
 static HRESULT WINAPI IDataObject_fnSetData(IDataObject *iface, LPFORMATETC pformatetc, STGMEDIUM *pmedium, BOOL fRelease)
 {
 	IDataObjectImpl *This = impl_from_IDataObject(iface);
-	FIXME("(%p)->()\n", This);
+
+    FIXME("(%p)->(%p, %p, %u): semi-stub\n", This, pformatetc, pmedium, fRelease);
+
+    if (pformatetc->cfFormat == This->cfDropEffect)
+    {
+        if (pmedium->tymed == TYMED_HGLOBAL)
+            return GetPREFERREDDROPEFFECT(pmedium, &This->dropEffect);
+        else
+            return DV_E_TYMED;
+    }
+
 	return E_NOTIMPL;
 }
 
@@ -437,14 +452,17 @@ IDataObject* IDataObject_Constructor(HWND hwndOwner,
         dto->pidl = ILClone(pMyPidl);
         dto->apidl = _ILCopyaPidl(apidl, cidl);
         dto->cidl = cidl;
+        dto->dropEffect = 0;
 
         dto->cfShellIDList = RegisterClipboardFormatW(CFSTR_SHELLIDLISTW);
         dto->cfFileNameA = RegisterClipboardFormatA(CFSTR_FILENAMEA);
         dto->cfFileNameW = RegisterClipboardFormatW(CFSTR_FILENAMEW);
+        dto->cfDropEffect = RegisterClipboardFormatW(CFSTR_PREFERREDDROPEFFECTW);
         InitFormatEtc(dto->pFormatEtc[0], dto->cfShellIDList, TYMED_HGLOBAL);
         InitFormatEtc(dto->pFormatEtc[1], CF_HDROP, TYMED_HGLOBAL);
         InitFormatEtc(dto->pFormatEtc[2], dto->cfFileNameA, TYMED_HGLOBAL);
         InitFormatEtc(dto->pFormatEtc[3], dto->cfFileNameW, TYMED_HGLOBAL);
+        InitFormatEtc(dto->pFormatEtc[4], dto->cfDropEffect, TYMED_HGLOBAL);
     }
 
     TRACE("(%p)->(apidl=%p cidl=%u)\n",dto, apidl, cidl);
diff --git a/dlls/shell32/iconcache.c b/dlls/shell32/iconcache.c
index c122c14..1f2590a 100644
--- a/dlls/shell32/iconcache.c
+++ b/dlls/shell32/iconcache.c
@@ -21,6 +21,7 @@
 #include <stdarg.h>
 #include <string.h>
 #include <sys/types.h>
+#include <math.h>
 
 #define COBJMACROS
 
@@ -333,17 +334,6 @@ static INT SIC_IconAppend (const WCHAR *sourcefile, INT src_index, HICON *hicons
     return ret;
 }
 
-static BOOL get_imagelist_icon_size(int list, SIZE *size)
-{
-    int cx, cy;
-    if (list < 0 || list >= ARRAY_SIZE(shell_imagelists)) return FALSE;
-
-    if (!ImageList_GetIconSize( shell_imagelists[list], &cx, &cy )) return FALSE;
-    size->cx = cx;
-    size->cy = cy;
-    return TRUE;
-}
-
 /****************************************************************************
  * SIC_LoadIcon				[internal]
  *
@@ -354,15 +344,67 @@ static INT SIC_LoadIcon (const WCHAR *sourcefile, INT index, DWORD flags)
 {
     HICON hicons[ARRAY_SIZE(shell_imagelists)] = { 0 };
     HICON hshortcuts[ARRAY_SIZE(hicons)] = { 0 };
+    SIZE size[ARRAY_SIZE(shell_imagelists)];
     unsigned int i;
-    SIZE size;
     INT ret = -1;
 
+    /* Keep track of the sizes in case any icon fails to get extracted */
+    for (i = 0; i < ARRAY_SIZE(hicons); i++)
+    {
+        ImageList_GetIconSize(shell_imagelists[i], &size[i].cx, &size[i].cy);
+        PrivateExtractIconsW(sourcefile, index, size[i].cx, size[i].cy, &hicons[i], 0, 1, 0);
+    }
+
+    /* Fill any icon handles that failed to get extracted, by resizing
+       another icon handle that succeeded and creating the icon from it.
+       Use a dumb O(n^2) algorithm since ARRAY_SIZE(hicons) is small */
     for (i = 0; i < ARRAY_SIZE(hicons); i++)
     {
-        if (!get_imagelist_icon_size( i, &size ) ||
-            !PrivateExtractIconsW( sourcefile, index, size.cx, size.cy, &hicons[i], 0, 1, 0 ))
-            WARN("Failed to load icon %d from %s.\n", index, debugstr_w(sourcefile));
+        unsigned int k, ix, iy;
+        BOOL failed = TRUE;
+        if (hicons[i]) continue;
+
+        for (k = 0; k < ARRAY_SIZE(hicons); k++)
+        {
+            if (hicons[k])
+            {
+                ix = iy = k;
+                failed = FALSE;
+                break;
+            }
+        }
+        if (failed) goto fail;
+
+        for (k++; k < ARRAY_SIZE(hicons); k++)
+        {
+            if (!hicons[k]) continue;
+
+            /* Find closest-sized icon, but favor larger icons to resize from */
+            if (size[k].cx >= size[i].cx)
+                ix = (size[ix].cx < size[i].cx || size[ix].cx > size[k].cx) ? k : ix;
+            else
+                ix = (size[ix].cx < size[i].cx && size[ix].cx < size[k].cx) ? k : ix;
+
+            if (size[k].cy >= size[i].cy)
+                iy = (size[iy].cy < size[i].cy || size[iy].cy > size[k].cy) ? k : iy;
+            else
+                iy = (size[iy].cy < size[i].cy && size[iy].cy < size[k].cy) ? k : iy;
+        }
+
+        /* Use the closest icon in aspect ratio if ix and iy differ */
+        if (ix != iy)
+        {
+            float i_ratio, ix_ratio, iy_ratio;
+            i_ratio  = (float)size[i].cx  / (float)size[i].cy;
+            ix_ratio = (float)size[ix].cx / (float)size[ix].cy;
+            iy_ratio = (float)size[iy].cx / (float)size[iy].cy;
+            if (fabsf(ix_ratio - i_ratio) > fabsf(iy_ratio - i_ratio))
+                ix = iy;
+        }
+
+        /* If this fails, we have to abort to prevent the image lists from
+           becoming out of sync and completely screwing the icons up */
+        hicons[i] = CopyImage(hicons[ix], IMAGE_ICON, size[i].cx, size[i].cy, 0);
         if (!hicons[i]) goto fail;
     }
 
@@ -976,6 +1018,119 @@ INT WINAPI SHGetIconOverlayIndexW(LPCWSTR pszIconPath, INT iIconIndex)
   return -1;
 }
 
+/****************************************************************************
+ * For SHGetStockIconInfo
+ */
+typedef struct {
+    SHSTOCKICONID id;
+    DWORD iconid;
+} SI_ENTRY;
+
+static const SI_ENTRY si_table[] =
+{
+    [0]   = { SIID_DOCNOASSOC, IDI_SHELL_FILE},
+    [1]   = { SIID_DOCASSOC, IDI_SHELL_DOCUMENT},
+    [2]   = { SIID_APPLICATION, IDI_SHELL_WINDOW},
+    [3]   = { SIID_FOLDER, IDI_SHELL_FOLDER},
+    [4]   = { SIID_FOLDEROPEN, IDI_SHELL_FOLDER_OPEN},
+    [5]   = { SIID_DRIVE525, 0},
+    [6]   = { SIID_DRIVE35, 0},
+    [7]   = { SIID_DRIVERREMOVE, 0},
+    [8]   = { SIID_DRIVERFIXED, IDI_SHELL_DRIVE},
+    [9]   = { SIID_DRIVERNET, IDI_SHELL_NETDRIVE},
+    [10]  = { SIID_DRIVERNETDISABLE, IDI_SHELL_NETDRIVE2},
+    [11]  = { SIID_DRIVERCD, IDI_SHELL_OPTICAL_DRIVE},
+    [12]  = { SIID_DRIVERRAM, IDI_SHELL_RAMDISK},
+    [13]  = { SIID_WORLD, 0},
+    /* Missing: 14 */
+    [15]  = { SIID_SERVER, 0},
+    [16]  = { SIID_PRINTER, IDI_SHELL_PRINT},
+    [17]  = { SIID_MYNETWORK, 0},
+    /* Missing: 18 - 21 */
+    [22]  = { SIID_FIND, 0},
+    [23]  = { SIID_HELP, IDI_SHELL_HELP},
+    /* Missing: 24 - 27 */
+    [28]  = {SIID_SHARE, 0},
+    [29]  = {SIID_LINK, 0},
+    [30]  = {SIID_SLOWFILE, 0},
+    [31]  = {SIID_RECYCLER, IDI_SHELL_TRASH_FOLDER},
+    [32]  = {SIID_RECYCLERFULL, IDI_SHELL_FULL_RECYCLE_BIN},
+    /* Missing: 33 - 39 */
+    [40]  = {SIID_MEDIACDAUDIO, 0},
+    /* Missing: 41 - 46 */
+    [47]  = {SIID_LOCK, IDI_SHELL_PASSWORDS},
+    /* Missing: 48 */
+    [49]  = {SIID_AUTOLIST, 0},
+    [50]  = {SIID_PRINTERNET, 0},
+    [51]  = {SIID_SERVERSHARE, 0},
+    [52]  = {SIID_PRINTERFAX, 0},
+    [53]  = {SIID_PRINTERFAXNET, 0},
+    [54]  = {SIID_PRINTERFILE, 0},
+    [55]  = {SIID_STACK, 0},
+    [56]  = {SIID_MEDIASVCD, 0},
+    [57]  = {SIID_STUFFEDFOLDER, 0},
+    [58]  = {SIID_DRIVEUNKNOWN, 0},
+    [59]  = {SIID_DRIVEDVD, 0},
+    [60]  = {SIID_MEDIADVD, 0},
+    [61]  = {SIID_MEDIADVDRAM, 0},
+    [62]  = {SIID_MEDIADVDRW, 0},
+    [63]  = {SIID_MEDIADVDR, 0},
+    [64]  = {SIID_MEDIADVDROM, 0},
+    [65]  = {SIID_MEDIACDAUDIOPLUS, 0},
+    [66]  = {SIID_MEDIACDRW, 0},
+    [67]  = {SIID_MEDIACDR, 0},
+    [68]  = {SIID_MEDIACDBURN, 0},
+    [69]  = {SIID_MEDIABLANKCD, 0},
+    [70]  = {SIID_MEDIACDROM, 0},
+    [71]  = {SIID_AUDIOFILES, IDI_SHELL_AUDIO_FILE},
+    [72]  = {SIID_IMAGEFILES, IDI_SHELL_IMAGE_FILE},
+    [73]  = {SIID_VIDEOFILES, IDI_SHELL_VIDEO_FILE},
+    [74]  = {SIID_MIXEDFILES, 0},
+    [75]  = {SIID_FOLDERBACK, 0},
+    [76]  = {SIID_FOLDERFRONT, 0},
+    [77]  = {SIID_SHIELD, 0},
+    [78]  = {SIID_WARNING, 0},
+    [79]  = {SIID_INFO, 0},
+    [80]  = {SIID_ERROR, 0},
+    [81]  = {SIID_KEY, 0},
+    [82]  = {SIID_SOFTWARE, 0},
+    [83]  = {SIID_RENAME, IDI_SHELL_RENAME},
+    [84]  = {SIID_DELETE, IDI_SHELL_CONFIRM_DELETE},
+    [85]  = {SIID_MEDIAAUDIODVD, 0},
+    [86]  = {SIID_MEDIAMOVIEDVD, 0},
+    [87]  = {SIID_MEDIAENHANCEDCD, 0},
+    [88]  = {SIID_MEDIAENHANCEDDVD, 0},
+    [89]  = {SIID_MEDIAHDDVD, 0},
+    [90]  = {SIID_MEDIABLUERAY, 0},
+    [91]  = {SIID_MEDIAVCD, 0},
+    [92]  = {SIID_MEDIADVDPLUSR, 0},
+    [93]  = {SIID_MEDIADVDPLUSRW, 0},
+    [94]  = {SIID_DESKTOPPC, IDI_SHELL_MY_COMPUTER},
+    [95]  = {SIID_MOBILEPC, 0},
+    [96]  = {SIID_USERS, IDI_SHELL_USERS},
+    [97]  = {SIID_MEDIASMARTMEDIA, 0},
+    [98]  = {SIID_MEDIACOMPACTFLASH, 0},
+    [99]  = {SIID_DEVICECELLPHONE, 0},
+    [100] = {SIID_DEVICECAMERA, 0},
+    [101] = {SIID_DEVICEVIDEOCAMERA, 0},
+    [102] = {SIID_DEVICEAUDIOPLAYER, 0},
+    [103] = {SIID_NETWORKCONNECT, 0},
+    [104] = {SIID_INTERNET, IDI_SHELL_WEB_BROWSER},
+    [105] = {SIID_ZIPFILE, 0},
+    [106] = {SIID_SETTINGS, IDI_SHELL_SETTINGS},
+    /* Missing: 107 - 131 */
+    [132] = {SIID_DRIVEHDDVD, 0},
+    [133] = {SIID_DRIVEBD, 0},
+    [134] = {SIID_MEDIAHDDVDROM, 0},
+    [135] = {SIID_MEDIAHDDVDR, 0},
+    [136] = {SIID_MEDIAHDDVDRAM, 0},
+    [137] = {SIID_MEDIABDROM, 0},
+    [138] = {SIID_MEDIABDR, 0},
+    [139] = {SIID_MEDIABDRE, 0},
+    [140] = {SIID_CLUSTEREDDRIVE, 0}
+    /* Missing: 141 - 180  and  SIID_MAX_ICONS = 181*/
+ };
+
 /****************************************************************************
  * SHGetStockIconInfo [SHELL32.@]
  *
@@ -993,23 +1148,52 @@ INT WINAPI SHGetIconOverlayIndexW(LPCWSTR pszIconPath, INT iIconIndex)
  */
 HRESULT WINAPI SHGetStockIconInfo(SHSTOCKICONID id, UINT flags, SHSTOCKICONINFO *sii)
 {
-    FIXME("(%d, 0x%x, %p) semi-stub\n", id, flags, sii);
+    HMODULE hmod;
+
+    TRACE("(%d, 0x%x, %p)\n", id, flags, sii);
+
     if ((id < 0) || (id >= SIID_MAX_ICONS) || !sii || (sii->cbSize != sizeof(SHSTOCKICONINFO))) {
         return E_INVALIDARG;
     }
 
     GetSystemDirectoryW(sii->szPath, MAX_PATH);
-
-    /* no icons defined: use default */
-    sii->iIcon = -IDI_SHELL_FILE;
     lstrcatW(sii->szPath, L"\\shell32.dll");
 
-    if (flags)
-        FIXME("flags 0x%x not implemented\n", flags);
-
     sii->hIcon = NULL;
     sii->iSysImageIndex = -1;
 
+    /* this is not how windows does it, on windows picked mostly from imageres.dll !*/
+    if (si_table[id].iconid)
+        sii->iIcon = sii->iSysImageIndex - si_table[id].id;
+    else
+    {
+        FIXME("Couldn`t find SIID %d, returning default values (IDI_SHELL_FILE)\n", id);
+        sii->iIcon = sii->iSysImageIndex - IDI_SHELL_FILE;
+    }
+
+    if (flags & SHGSI_ICON)
+    {
+        flags &= ~SHGSI_ICON;
+
+        hmod = GetModuleHandleW(L"shell32.dll");
+        if (hmod)
+        {
+            if (si_table[id].iconid)
+                sii->hIcon = LoadIconW(hmod, MAKEINTRESOURCEW(si_table[id].iconid));
+            else
+                sii->hIcon = LoadIconW(hmod, MAKEINTRESOURCEW(IDI_SHELL_FILE));
+        }
+
+        if (!sii->hIcon)
+        {
+            ERR("failed to get an icon handle\n");
+            return E_INVALIDARG;
+        }
+    }
+
+    if (flags)
+        FIXME("flags 0x%x not implemented\n", flags);
+
     TRACE("%3d: returning %s (%d)\n", id, debugstr_w(sii->szPath), sii->iIcon);
 
     return S_OK;
diff --git a/dlls/shell32/recyclebin.c b/dlls/shell32/recyclebin.c
index 91f1341..27a52ee 100644
--- a/dlls/shell32/recyclebin.c
+++ b/dlls/shell32/recyclebin.c
@@ -570,7 +570,7 @@ static void DoErase(RecycleBinMenu *This)
     ISFHelper *helper;
     IShellFolder2_QueryInterface(This->folder,&IID_ISFHelper,(void**)&helper);
     if(helper)
-        ISFHelper_DeleteItems(helper,This->cidl,(LPCITEMIDLIST*)This->apidl);
+        ISFHelper_DeleteItems(helper, This->cidl, (LPCITEMIDLIST *)This->apidl, TRUE);
 }
 
 static void DoRestore(RecycleBinMenu *This)
@@ -1194,10 +1194,10 @@ static HRESULT erase_items(HWND parent,const LPCITEMIDLIST * apidl, UINT cidl, B
 }
 
 static HRESULT WINAPI RecycleBin_DeleteItems(ISFHelper * iface, UINT cidl,
-                                             LPCITEMIDLIST * apidl)
+                                             LPCITEMIDLIST * apidl, BOOL confirm)
 {
     TRACE("(%p,%u,%p)\n",iface,cidl,apidl);
-    return erase_items(GetActiveWindow(),apidl,cidl,TRUE);
+    return erase_items(GetActiveWindow(), apidl, cidl, confirm);
 }
 
 static HRESULT WINAPI RecycleBin_CopyItems(ISFHelper * iface,
diff --git a/dlls/shell32/shell32.rc b/dlls/shell32/shell32.rc
index f899a27..4b247b1 100644
--- a/dlls/shell32/shell32.rc
+++ b/dlls/shell32/shell32.rc
@@ -99,6 +99,7 @@ BEGIN
 	  MENUITEM SEPARATOR
 	  MENUITEM "C&ut",		FCIDM_SHVIEW_CUT
 	  MENUITEM "&Copy",		FCIDM_SHVIEW_COPY
+	  MENUITEM "&Paste",		FCIDM_SHVIEW_INSERT
 	  MENUITEM SEPARATOR
 	  MENUITEM "Create &Link",	FCIDM_SHVIEW_CREATELINK
 	  MENUITEM "&Delete",		FCIDM_SHVIEW_DELETE
@@ -182,6 +183,13 @@ If the files in the destination folder have the same names as files in the\n\
 selected folder they will be replaced. Do you still want to move or copy\n\
 the folder?"
 
+        IDS_FILEOP_COPYING   "Copying"
+        IDS_FILEOP_MOVING    "Moving"
+        IDS_FILEOP_DELETING  "Deleting"
+        IDS_FILEOP_FROM_TO   "From %1 to %2"
+        IDS_FILEOP_FROM      "From %1"
+        IDS_FILEOP_PREFLIGHT "Preflight"
+
         /* message box strings */
         IDS_RESTART_TITLE       "Restart"
         IDS_RESTART_PROMPT      "Do you want to simulate a Windows reboot?"
@@ -195,6 +203,33 @@ the folder?"
         IDS_RUNDLG_BROWSE_FILTER_EXE "Executable files (*.exe)"
         IDS_RUNDLG_BROWSE_FILTER_ALL "All files (*.*)"
 
+        /* Security dialog - General */
+        IDS_SECURITY_ALL_ACCESS "Full Control"
+        IDS_SECURITY_MODIFY     "Modify"
+        IDS_SECURITY_READ_EXEC  "Read & Execute"
+        IDS_SECURITY_READ       "Read"
+        IDS_SECURITY_WRITE      "Write"
+        IDS_SECURITY_DIR_LIST   "List Folder Contents"
+
+        /* Security dialog - Advanced */
+        IDS_SECURITY_TRAVERSE      "Traverse Folder"
+        IDS_SECURITY_EXECUTE       "Execute File"
+        IDS_SECURITY_LIST_FOLDER   "List Folder"
+        IDS_SECURITY_READ_DATA     "Read Data"
+        IDS_SECURITY_READ_ATTR     "Read Attributes"
+        IDS_SECURITY_READ_EX_ATTR  "Read Extended Attributes"
+        IDS_SECURITY_CREATE_FILES  "Create Files"
+        IDS_SECURITY_WRITE_DATA    "Write Data"
+        IDS_SEUCRITY_CREATE_FOLDER "Create Folders"
+        IDS_SECURITY_APPEND_DATA   "Append Data"
+        IDS_SECURITY_WRITE_ATTR    "Write Attributes"
+        IDS_SECURITY_WRITE_EX_ATTR "Write Extended Attributes"
+        IDS_SECURITY_DELETE_CHILD  "Delete Subfolders and Files"
+        IDS_SECURITY_DELETE        "Delete"
+        IDS_SECURITY_READ_PERM     "Read Permissions"
+        IDS_SECURITY_CHANGE_PERM   "Change Permissions"
+        IDS_SECURITY_CHANGE_OWNER  "Take Ownership"
+
         /* shell folder path default values */
 	/* FIXME: Some will be unused until desktop.ini support is implemented */
 	IDS_PROGRAMS                "Programs"
@@ -1080,6 +1115,14 @@ IDB_TB_SMALL_LIGHT BITMAP resources/idb_tb_small.bmp
 /* @makedep: resources/idb_tb_small.bmp */
 IDB_TB_SMALL_DARK BITMAP resources/idb_tb_small.bmp
 
+/* @makedep: resources/ietoolbar.bmp */
+204 BITMAP resources/ietoolbar.bmp
+205 BITMAP resources/ietoolbar.bmp
+
+/* @makedep: resources/ietoolbar_small.bmp */
+206 BITMAP resources/ietoolbar_small.bmp
+207 BITMAP resources/ietoolbar_small.bmp
+
 /* @makedep: resources/searching.avi */
 IDR_AVI_SEARCHING AVI resources/searching.avi
 
diff --git a/dlls/shell32/shell32_classes.idl b/dlls/shell32/shell32_classes.idl
index dc65ed3..c5f4215 100644
--- a/dlls/shell32/shell32_classes.idl
+++ b/dlls/shell32/shell32_classes.idl
@@ -86,6 +86,11 @@ coclass KnownFolderManager { interface IKnownFolderManager; }
     uuid(4657278a-411b-11d2-839a-00c04fd918d0)
 ] coclass DragDropHelper { interface IDropTargetHelper; }
 
+[
+    threading(apartment),
+    uuid(d969a300-e7ff-11d0-a93b-00a0c90f2719)
+] coclass NewMenu { interface IShellExtInit; }
+
 [
     threading(apartment),
     uuid(00bb2763-6a77-11d0-a535-00c04fd7d062)
diff --git a/dlls/shell32/shell32_main.h b/dlls/shell32/shell32_main.h
index 3f94385..2b3bbd8 100644
--- a/dlls/shell32/shell32_main.h
+++ b/dlls/shell32/shell32_main.h
@@ -101,6 +101,7 @@ HRESULT WINAPI RecycleBin_Constructor(IUnknown * pUnkOuter, REFIID riif, LPVOID
 HRESULT WINAPI QueryAssociations_Constructor(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppOutput);
 HRESULT WINAPI ExplorerBrowser_Constructor(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv);
 HRESULT WINAPI KnownFolderManager_Constructor(IUnknown *pUnkOuter, REFIID riid, LPVOID *ppv);
+HRESULT WINAPI NewMenu_Constructor(IUnknown *outer, REFIID riid, LPVOID *ppv);
 HRESULT WINAPI IFileOperation_Constructor(IUnknown *outer, REFIID riid, void **out);
 HRESULT WINAPI ActiveDesktop_Constructor(IUnknown *outer, REFIID riid, void **out);
 
@@ -141,6 +142,8 @@ HGLOBAL RenderHDROP(LPITEMIDLIST pidlRoot, LPITEMIDLIST * apidl, UINT cidl);
 HGLOBAL RenderSHELLIDLIST (LPITEMIDLIST pidlRoot, LPITEMIDLIST * apidl, UINT cidl);
 HGLOBAL RenderFILENAMEA (LPITEMIDLIST pidlRoot, LPITEMIDLIST * apidl, UINT cidl);
 HGLOBAL RenderFILENAMEW (LPITEMIDLIST pidlRoot, LPITEMIDLIST * apidl, UINT cidl);
+HGLOBAL RenderPREFERREDDROPEFFECT (DWORD value);
+HRESULT GetPREFERREDDROPEFFECT (STGMEDIUM *pmedium, DWORD *value);
 
 /* Change Notification */
 void InitChangeNotifications(void);
diff --git a/dlls/shell32/shellfolder.h b/dlls/shell32/shellfolder.h
index 942e0e7..b8083a2 100644
--- a/dlls/shell32/shellfolder.h
+++ b/dlls/shell32/shellfolder.h
@@ -48,7 +48,7 @@ DECLARE_INTERFACE_(ISFHelper,IUnknown)
     /*** ISFHelper methods ***/
     STDMETHOD(GetUniqueName)(THIS_ LPWSTR  lpName, UINT  uLen) PURE;
     STDMETHOD(AddFolder)(THIS_ HWND  hwnd, LPCWSTR  lpName, LPITEMIDLIST * ppidlOut) PURE;
-    STDMETHOD(DeleteItems)(THIS_ UINT  cidl, LPCITEMIDLIST * apidl) PURE;
+    STDMETHOD(DeleteItems)(THIS_ UINT cidl, LPCITEMIDLIST *apidl, BOOL confirm) PURE;
     STDMETHOD(CopyItems)(THIS_ IShellFolder * pSFFrom, UINT  cidl, LPCITEMIDLIST * apidl) PURE;
 };
 #undef INTERFACE
@@ -61,7 +61,7 @@ DECLARE_INTERFACE_(ISFHelper,IUnknown)
 /*** ISFHelper methods ***/
 #define ISFHelper_GetUniqueName(p,a,b)          (p)->lpVtbl->GetUniqueName(p,a,b)
 #define ISFHelper_AddFolder(p,a,b,c)            (p)->lpVtbl->AddFolder(p,a,b,c)
-#define ISFHelper_DeleteItems(p,a,b)            (p)->lpVtbl->DeleteItems(p,a,b)
+#define ISFHelper_DeleteItems(p,a,b,c)          (p)->lpVtbl->DeleteItems(p,a,b,c)
 #define ISFHelper_CopyItems(p,a,b,c)            (p)->lpVtbl->CopyItems(p,a,b,c)
 #endif
 
diff --git a/dlls/shell32/shellole.c b/dlls/shell32/shellole.c
index 52123ac..256f6e4 100644
--- a/dlls/shell32/shellole.c
+++ b/dlls/shell32/shellole.c
@@ -70,6 +70,7 @@ static const struct {
 	{&CLSID_MyComputer,	ISF_MyComputer_Constructor},
 	{&CLSID_MyDocuments,    MyDocuments_Constructor},
 	{&CLSID_NetworkPlaces,  ISF_NetworkPlaces_Constructor},
+	{&CLSID_NewMenu,        NewMenu_Constructor},
 	{&CLSID_Printers,       Printers_Constructor},
 	{&CLSID_QueryAssociations, QueryAssociations_Constructor},
 	{&CLSID_RecycleBin,     RecycleBin_Constructor},
diff --git a/dlls/shell32/shfldr_fs.c b/dlls/shell32/shfldr_fs.c
index 54828f9..cb28f4d 100644
--- a/dlls/shell32/shfldr_fs.c
+++ b/dlls/shell32/shfldr_fs.c
@@ -1254,7 +1254,7 @@ static WCHAR *build_paths_list(LPCWSTR wszBasePath, int cidl, const LPCITEMIDLIS
  * deletes items in folder
  */
 static HRESULT WINAPI
-ISFHelper_fnDeleteItems (ISFHelper * iface, UINT cidl, LPCITEMIDLIST * apidl)
+ISFHelper_fnDeleteItems (ISFHelper *iface, UINT cidl, LPCITEMIDLIST *apidl, BOOL confirm)
 {
     IGenericSFImpl *This = impl_from_ISFHelper(iface);
     UINT i;
@@ -1279,6 +1279,7 @@ ISFHelper_fnDeleteItems (ISFHelper * iface, UINT cidl, LPCITEMIDLIST * apidl)
     op.wFunc = FO_DELETE;
     op.pFrom = wszPathsList;
     op.fFlags = FOF_ALLOWUNDO;
+    if (!confirm) op.fFlags |= FOF_NOCONFIRMATION;
     if (SHFileOperationW(&op))
     {
         WARN("SHFileOperation failed\n");
diff --git a/dlls/shell32/shlexec.c b/dlls/shell32/shlexec.c
index eb9ca4a..54ceb90 100644
--- a/dlls/shell32/shlexec.c
+++ b/dlls/shell32/shlexec.c
@@ -293,6 +293,21 @@ static HRESULT SHELL_GetPathFromIDListForExecuteW(LPCITEMIDLIST pidl, LPWSTR psz
     return hr;
 }
 
+static HANDLE get_admin_token(void)
+{
+    TOKEN_ELEVATION_TYPE type;
+    TOKEN_LINKED_TOKEN linked;
+    DWORD size;
+
+    if (!GetTokenInformation(GetCurrentThreadEffectiveToken(), TokenElevationType, &type, sizeof(type), &size)
+            || type == TokenElevationTypeFull)
+        return NULL;
+
+    if (!GetTokenInformation(GetCurrentThreadEffectiveToken(), TokenLinkedToken, &linked, sizeof(linked), &size))
+        return NULL;
+    return linked.LinkedToken;
+}
+
 /*************************************************************************
  *	SHELL_ExecuteW [Internal]
  *
@@ -306,6 +321,7 @@ static UINT_PTR SHELL_ExecuteW(const WCHAR *lpCmd, WCHAR *env, BOOL shWait,
     UINT gcdret = 0;
     WCHAR curdir[MAX_PATH];
     DWORD dwCreationFlags;
+    HANDLE token = NULL;
 
     TRACE("Execute %s from directory %s\n", debugstr_w(lpCmd), debugstr_w(psei->lpDirectory));
 
@@ -327,8 +343,12 @@ static UINT_PTR SHELL_ExecuteW(const WCHAR *lpCmd, WCHAR *env, BOOL shWait,
     dwCreationFlags = CREATE_UNICODE_ENVIRONMENT;
     if (!(psei->fMask & SEE_MASK_NO_CONSOLE))
         dwCreationFlags |= CREATE_NEW_CONSOLE;
-    if (CreateProcessW(NULL, (LPWSTR)lpCmd, NULL, NULL, FALSE, dwCreationFlags, env,
-                       NULL, &startup, &info))
+
+    if (psei->lpVerb && !wcsicmp(psei->lpVerb, L"runas"))
+        token = get_admin_token();
+
+    if (CreateProcessAsUserW(token, NULL, (LPWSTR)lpCmd, NULL, NULL, FALSE,
+            dwCreationFlags, env, NULL, &startup, &info))
     {
         /* Give 30 seconds to the app to come up, if desired. Probably only needed
            when starting app immediately before making a DDE connection. */
@@ -348,6 +368,8 @@ static UINT_PTR SHELL_ExecuteW(const WCHAR *lpCmd, WCHAR *env, BOOL shWait,
         retval = ERROR_BAD_FORMAT;
     }
 
+    CloseHandle(token);
+
     TRACE("returning %Iu\n", retval);
 
     psei_out->hInstApp = (HINSTANCE)retval;
@@ -442,7 +464,10 @@ static BOOL SHELL_TryAppPathW( LPCWSTR szName, LPWSTR lpResult, WCHAR **env)
 
     wcscat(buffer, szName);
     res = RegOpenKeyExW(HKEY_LOCAL_MACHINE, buffer, 0, KEY_READ, &hkApp);
-    if (res) goto end;
+    if (res)
+        res = RegOpenKeyExW(HKEY_LOCAL_MACHINE, lstrcatW(buffer, L".exe"), 0, KEY_READ, &hkApp);
+    if (res)
+        goto end;
 
     len = MAX_PATH*sizeof(WCHAR);
     res = RegQueryValueW(hkApp, NULL, lpResult, &len);
diff --git a/dlls/shell32/shlfileop.c b/dlls/shell32/shlfileop.c
index b4a9411..02bd8fe 100644
--- a/dlls/shell32/shlfileop.c
+++ b/dlls/shell32/shlfileop.c
@@ -55,24 +55,60 @@ WINE_DEFAULT_DEBUG_CHANNEL(shell);
 #define DE_SAMEFILE      0x71
 #define DE_DESTSAMETREE  0x7D
 
-static DWORD SHNotifyCreateDirectoryA(LPCSTR path, LPSECURITY_ATTRIBUTES sec);
-static DWORD SHNotifyCreateDirectoryW(LPCWSTR path, LPSECURITY_ATTRIBUTES sec);
-static DWORD SHNotifyRemoveDirectoryA(LPCSTR path);
-static DWORD SHNotifyRemoveDirectoryW(LPCWSTR path);
-static DWORD SHNotifyDeleteFileA(LPCSTR path);
-static DWORD SHNotifyDeleteFileW(LPCWSTR path);
-static DWORD SHNotifyMoveFileW(LPCWSTR src, LPCWSTR dest);
-static DWORD SHNotifyCopyFileW(LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists);
-static DWORD SHFindAttrW(LPCWSTR pName, BOOL fileOnly);
-
 typedef struct
 {
     SHFILEOPSTRUCTW *req;
     DWORD dwYesToAllMask;
     BOOL bManyItems;
     BOOL bCancelled;
+    IProgressDialog *progress;
+    ULARGE_INTEGER completedSize;
+    ULARGE_INTEGER totalSize;
+    WCHAR szBuilderString[64];
 } FILE_OPERATION;
 
+typedef struct
+{
+    DWORD attributes;
+    LPWSTR szDirectory;
+    LPWSTR szFilename;
+    LPWSTR szFullPath;
+    BOOL bFromWildcard;
+    BOOL bFromRelative;
+    BOOL bExists;
+} FILE_ENTRY;
+
+typedef struct
+{
+    FILE_ENTRY *feFiles;
+    DWORD num_alloc;
+    DWORD dwNumFiles;
+    BOOL bAnyFromWildcard;
+    BOOL bAnyDirectories;
+    BOOL bAnyDontExist;
+} FILE_LIST;
+
+#define ERROR_SHELL_INTERNAL_FILE_NOT_FOUND 1026
+
+static DWORD SHNotifyCreateDirectoryA(LPCSTR path, LPSECURITY_ATTRIBUTES sec);
+static DWORD SHNotifyCreateDirectoryW(LPCWSTR path, LPSECURITY_ATTRIBUTES sec);
+static DWORD SHNotifyRemoveDirectoryA(LPCSTR path);
+static DWORD SHNotifyRemoveDirectoryW(LPCWSTR path);
+static DWORD SHNotifyDeleteFileA(FILE_OPERATION *op, LPCSTR path);
+static DWORD SHNotifyDeleteFileW(FILE_OPERATION *op, LPCWSTR path);
+static DWORD SHNotifyMoveFileW(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dest);
+static DWORD SHNotifyCopyFileW(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists);
+static DWORD SHFindAttrW(LPCWSTR pName, BOOL fileOnly);
+
+static int copy_files(FILE_OPERATION *op, BOOL multidest, const FILE_LIST *flFrom, FILE_LIST *flTo);
+static int move_files(FILE_OPERATION *op, BOOL multidest, const FILE_LIST *flFrom, const FILE_LIST *flTo);
+
+static void progressbar_calc_totalsize(FILE_OPERATION *op, const FILE_LIST *from);
+static void progressbar_update_title(FILE_OPERATION *op);
+static void progressbar_update_files(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dst);
+static DWORD CALLBACK progressbar_copy_routine(LARGE_INTEGER total_size, LARGE_INTEGER total_transferred, LARGE_INTEGER stream_size,
+        LARGE_INTEGER stream_transferred, DWORD stream_number, DWORD reason, HANDLE src_file, HANDLE dst_file, LPVOID user);
+
 /* Confirm dialogs with an optional "Yes To All" as used in file operations confirmations
  */
 struct confirm_msg_info
@@ -200,108 +236,107 @@ static int SHELL_ConfirmMsgBox(HWND hWnd, LPWSTR lpszText, LPWSTR lpszCaption, H
 /* confirmation dialogs content */
 typedef struct
 {
-        HINSTANCE hIconInstance;
-        UINT icon_resource_id;
-	UINT caption_resource_id, text_resource_id;
+    HINSTANCE hIconInstance;
+    UINT icon_resource_id;
+    UINT caption_resource_id, text_resource_id;
 } SHELL_ConfirmIDstruc;
 
 static BOOL SHELL_ConfirmIDs(int nKindOfDialog, SHELL_ConfirmIDstruc *ids)
 {
-        ids->hIconInstance = shell32_hInstance;
-	switch (nKindOfDialog) {
-	  case ASK_DELETE_FILE:
-            ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
-	    ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
-	    ids->text_resource_id  = IDS_DELETEITEM_TEXT;
-	    return TRUE;
-	  case ASK_DELETE_FOLDER:
-            ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
-	    ids->caption_resource_id  = IDS_DELETEFOLDER_CAPTION;
-	    ids->text_resource_id  = IDS_DELETEITEM_TEXT;
-	    return TRUE;
-	  case ASK_DELETE_MULTIPLE_ITEM:
-            ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
-	    ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
-	    ids->text_resource_id  = IDS_DELETEMULTIPLE_TEXT;
-	    return TRUE;
-          case ASK_TRASH_FILE:
-            ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
-            ids->caption_resource_id = IDS_DELETEITEM_CAPTION;
-            ids->text_resource_id = IDS_TRASHITEM_TEXT;
-            return TRUE;
-          case ASK_TRASH_FOLDER:
-            ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
-            ids->caption_resource_id = IDS_DELETEFOLDER_CAPTION;
-            ids->text_resource_id = IDS_TRASHFOLDER_TEXT;
-            return TRUE;
-          case ASK_TRASH_MULTIPLE_ITEM:
-            ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
-            ids->caption_resource_id = IDS_DELETEITEM_CAPTION;
-            ids->text_resource_id = IDS_TRASHMULTIPLE_TEXT;
-            return TRUE;
-          case ASK_CANT_TRASH_ITEM:
-            ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
-            ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
-            ids->text_resource_id  = IDS_CANTTRASH_TEXT;
-            return TRUE;
-	  case ASK_DELETE_SELECTED:
-            ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
+    ids->hIconInstance = shell32_hInstance;
+    switch (nKindOfDialog) {
+        case ASK_DELETE_FILE:
+             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
             ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
-            ids->text_resource_id  = IDS_DELETESELECTED_TEXT;
+            ids->text_resource_id  = IDS_DELETEITEM_TEXT;
             return TRUE;
-	  case ASK_OVERWRITE_FILE:
-            ids->hIconInstance = NULL;
-            ids->icon_resource_id = IDI_WARNING;
-	    ids->caption_resource_id  = IDS_OVERWRITEFILE_CAPTION;
-	    ids->text_resource_id  = IDS_OVERWRITEFILE_TEXT;
+        case ASK_DELETE_FOLDER:
+             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
+            ids->caption_resource_id  = IDS_DELETEFOLDER_CAPTION;
+            ids->text_resource_id  = IDS_DELETEITEM_TEXT;
             return TRUE;
-	  case ASK_OVERWRITE_FOLDER:
-            ids->hIconInstance = NULL;
-            ids->icon_resource_id = IDI_WARNING;
-            ids->caption_resource_id  = IDS_OVERWRITEFILE_CAPTION;
-            ids->text_resource_id  = IDS_OVERWRITEFOLDER_TEXT;
+        case ASK_DELETE_MULTIPLE_ITEM:
+             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
+            ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
+            ids->text_resource_id  = IDS_DELETEMULTIPLE_TEXT;
             return TRUE;
-	  default:
-	    FIXME(" Unhandled nKindOfDialog %d stub\n", nKindOfDialog);
-	}
-	return FALSE;
+        case ASK_TRASH_FILE:
+             ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
+             ids->caption_resource_id = IDS_DELETEITEM_CAPTION;
+             ids->text_resource_id = IDS_TRASHITEM_TEXT;
+             return TRUE;
+        case ASK_TRASH_FOLDER:
+             ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
+             ids->caption_resource_id = IDS_DELETEFOLDER_CAPTION;
+             ids->text_resource_id = IDS_TRASHFOLDER_TEXT;
+             return TRUE;
+        case ASK_TRASH_MULTIPLE_ITEM:
+             ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
+             ids->caption_resource_id = IDS_DELETEITEM_CAPTION;
+             ids->text_resource_id = IDS_TRASHMULTIPLE_TEXT;
+             return TRUE;
+        case ASK_CANT_TRASH_ITEM:
+             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
+             ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
+             ids->text_resource_id  = IDS_CANTTRASH_TEXT;
+             return TRUE;
+        case ASK_DELETE_SELECTED:
+             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
+             ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
+             ids->text_resource_id  = IDS_DELETESELECTED_TEXT;
+             return TRUE;
+        case ASK_OVERWRITE_FILE:
+             ids->hIconInstance = NULL;
+             ids->icon_resource_id = IDI_WARNING;
+             ids->caption_resource_id  = IDS_OVERWRITEFILE_CAPTION;
+             ids->text_resource_id  = IDS_OVERWRITEFILE_TEXT;
+             return TRUE;
+        case ASK_OVERWRITE_FOLDER:
+             ids->hIconInstance = NULL;
+             ids->icon_resource_id = IDI_WARNING;
+             ids->caption_resource_id  = IDS_OVERWRITEFILE_CAPTION;
+             ids->text_resource_id  = IDS_OVERWRITEFOLDER_TEXT;
+             return TRUE;
+        default:
+            FIXME(" Unhandled nKindOfDialog %d stub\n", nKindOfDialog);
+   }
+   return FALSE;
 }
 
 static BOOL SHELL_ConfirmDialogW(HWND hWnd, int nKindOfDialog, LPCWSTR szDir, FILE_OPERATION *op)
 {
-	WCHAR szCaption[255], szText[255], szBuffer[MAX_PATH + 256];
-	SHELL_ConfirmIDstruc ids;
-	DWORD_PTR args[1];
-	HICON hIcon;
-	int ret;
-
-        assert(nKindOfDialog >= 0 && nKindOfDialog < 32);
-        if (op && (op->dwYesToAllMask & (1 << nKindOfDialog)))
-            return TRUE;
-
-        if (!SHELL_ConfirmIDs(nKindOfDialog, &ids)) return FALSE;
-
-        LoadStringW(shell32_hInstance, ids.caption_resource_id, szCaption, ARRAY_SIZE(szCaption));
-        LoadStringW(shell32_hInstance, ids.text_resource_id, szText, ARRAY_SIZE(szText));
-
-        args[0] = (DWORD_PTR)szDir;
-        FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-            szText, 0, 0, szBuffer, ARRAY_SIZE(szBuffer), (va_list*)args);
-
-        hIcon = LoadIconW(ids.hIconInstance, (LPWSTR)MAKEINTRESOURCE(ids.icon_resource_id));
+    WCHAR szCaption[255], szText[255], szBuffer[MAX_PATH + 256];
+    SHELL_ConfirmIDstruc ids;
+    DWORD_PTR args[1];
+    HICON hIcon;
+    int ret;
 
-        ret = SHELL_ConfirmMsgBox(hWnd, szBuffer, szCaption, hIcon, op && op->bManyItems);
-        if (op) {
-            if (ret == IDD_YESTOALL) {
-                op->dwYesToAllMask |= (1 << nKindOfDialog);
-                ret = IDYES;
-            }
-            if (ret == IDCANCEL)
-                op->bCancelled = TRUE;
-            if (ret != IDYES)
-                op->req->fAnyOperationsAborted = TRUE;
-        }
-        return ret == IDYES;
+    assert(nKindOfDialog >= 0 && nKindOfDialog < 32);
+    if (op && (op->dwYesToAllMask & (1 << nKindOfDialog)))
+        return TRUE;
+
+    if (!SHELL_ConfirmIDs(nKindOfDialog, &ids)) return FALSE;
+
+    LoadStringW(shell32_hInstance, ids.caption_resource_id, szCaption, ARRAY_SIZE(szCaption));
+    LoadStringW(shell32_hInstance, ids.text_resource_id, szText, ARRAY_SIZE(szText));
+
+    args[0] = (DWORD_PTR)szDir;
+    FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
+        szText, 0, 0, szBuffer, ARRAY_SIZE(szBuffer), (va_list*)args);
+    hIcon = LoadIconW(ids.hIconInstance, (LPWSTR)MAKEINTRESOURCE(ids.icon_resource_id));
+
+    ret = SHELL_ConfirmMsgBox(hWnd, szBuffer, szCaption, hIcon, op && op->bManyItems);
+    if (op) {
+        if (ret == IDD_YESTOALL) {
+            op->dwYesToAllMask |= (1 << nKindOfDialog);
+            ret = IDYES;
+         }
+        if (ret == IDCANCEL)
+            op->bCancelled = TRUE;
+        if (ret != IDYES)
+            op->req->fAnyOperationsAborted = TRUE;
+    }
+    return ret == IDYES;
 }
 
 BOOL SHELL_ConfirmYesNoW(HWND hWnd, int nKindOfDialog, LPCWSTR szDir)
@@ -311,18 +346,18 @@ BOOL SHELL_ConfirmYesNoW(HWND hWnd, int nKindOfDialog, LPCWSTR szDir)
 
 static DWORD SHELL32_AnsiToUnicodeBuf(LPCSTR aPath, LPWSTR *wPath, DWORD minChars)
 {
-	DWORD len = MultiByteToWideChar(CP_ACP, 0, aPath, -1, NULL, 0);
+    DWORD len = MultiByteToWideChar(CP_ACP, 0, aPath, -1, NULL, 0);
 
-	if (len < minChars)
-	  len = minChars;
+    if (len < minChars)
+      len = minChars;
 
-	*wPath = malloc(len * sizeof(WCHAR));
-	if (*wPath)
-	{
-	  MultiByteToWideChar(CP_ACP, 0, aPath, -1, *wPath, len);
-	  return NO_ERROR;
-	}
-	return E_OUTOFMEMORY;
+    *wPath = malloc(len * sizeof(WCHAR));
+    if (*wPath)
+    {
+        MultiByteToWideChar(CP_ACP, 0, aPath, -1, *wPath, len);
+        return NO_ERROR;
+    }
+    return E_OUTOFMEMORY;
 }
 
 HRESULT WINAPI SHIsFileAvailableOffline(LPCWSTR path, LPDWORD status)
@@ -337,7 +372,7 @@ HRESULT WINAPI SHIsFileAvailableOffline(LPCWSTR path, LPDWORD status)
  * Asks for confirmation when bShowUI is true and deletes the directory and
  * all its subdirectories and files if necessary.
  */
-static DWORD SHELL_DeleteDirectoryW(HWND hwnd, LPCWSTR pszDir, BOOL bShowUI)
+static DWORD SHELL_DeleteDirectoryW(FILE_OPERATION *op, LPCWSTR pszDir, BOOL bShowUI)
 {
     DWORD    ret = 0;
     HANDLE  hFind;
@@ -347,16 +382,25 @@ static DWORD SHELL_DeleteDirectoryW(HWND hwnd, LPCWSTR pszDir, BOOL bShowUI)
     PathCombineW(szTemp, pszDir, L"*");
     hFind = FindFirstFileW(szTemp, &wfd);
 
-    if (hFind != INVALID_HANDLE_VALUE) {
-        if (!bShowUI || SHELL_ConfirmDialogW(hwnd, ASK_DELETE_FOLDER, pszDir, NULL)) {
+    if (hFind != INVALID_HANDLE_VALUE)
+    {
+        if (!bShowUI || SHELL_ConfirmDialogW(op->req->hwnd, ASK_DELETE_FOLDER, pszDir, NULL))
+        {
             do {
                 if (IsDotDir(wfd.cFileName))
                     continue;
                 PathCombineW(szTemp, pszDir, wfd.cFileName);
                 if (FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes)
-                    ret = SHELL_DeleteDirectoryW(hwnd, szTemp, FALSE);
+                    ret = SHELL_DeleteDirectoryW(op, szTemp, FALSE);
                 else
-                    ret = SHNotifyDeleteFileW(szTemp);
+                    ret = SHNotifyDeleteFileW(op, szTemp);
+
+                /* Check if dialog was cancelled in the meantime */
+                if (op->progress != NULL)
+                    op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+                if (op->bCancelled)
+                    break;
+
             } while (!ret && FindNextFileW(hFind, &wfd));
         }
         FindClose(hFind);
@@ -365,8 +409,8 @@ static DWORD SHELL_DeleteDirectoryW(HWND hwnd, LPCWSTR pszDir, BOOL bShowUI)
         ret = SHNotifyRemoveDirectoryW(pszDir);
 
     return ret == ERROR_PATH_NOT_FOUND ?
-        0x7C: /* DE_INVALIDFILES (legacy Windows error) */
-        ret;
+                  0x7C: /* DE_INVALIDFILES (legacy Windows error) */
+                  ret;
 }
 
 /**************************************************************************
@@ -386,41 +430,41 @@ static DWORD SHELL_DeleteDirectoryW(HWND hwnd, LPCWSTR pszDir, BOOL bShowUI)
  */
 static DWORD SHNotifyCreateDirectoryA(LPCSTR path, LPSECURITY_ATTRIBUTES sec)
 {
-	LPWSTR wPath;
-	DWORD retCode;
+    LPWSTR wPath;
+    DWORD retCode;
 
-	TRACE("(%s, %p)\n", debugstr_a(path), sec);
+    TRACE("(%s, %p)\n", debugstr_a(path), sec);
 
-	retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
-	if (!retCode)
-	{
-	  retCode = SHNotifyCreateDirectoryW(wPath, sec);
-	  free(wPath);
-	}
-	return retCode;
+    retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
+    if (!retCode)
+    {
+        retCode = SHNotifyCreateDirectoryW(wPath, sec);
+        free(wPath);
+    }
+    return retCode;
 }
 
 /**********************************************************************/
 
 static DWORD SHNotifyCreateDirectoryW(LPCWSTR path, LPSECURITY_ATTRIBUTES sec)
 {
-	TRACE("(%s, %p)\n", debugstr_w(path), sec);
+    TRACE("(%s, %p)\n", debugstr_w(path), sec);
 
-	if (CreateDirectoryW(path, sec))
-	{
-	  SHChangeNotify(SHCNE_MKDIR, SHCNF_PATHW, path, NULL);
-	  return ERROR_SUCCESS;
-	}
-	return GetLastError();
+    if (CreateDirectoryW(path, sec))
+    {
+        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATHW, path, NULL);
+        return ERROR_SUCCESS;
+    }
+    return GetLastError();
 }
 
 /**********************************************************************/
 
 BOOL WINAPI Win32CreateDirectoryAW(LPCVOID path, LPSECURITY_ATTRIBUTES sec)
 {
-	if (SHELL_OsIsUnicode())
-	  return (SHNotifyCreateDirectoryW(path, sec) == ERROR_SUCCESS);
-	return (SHNotifyCreateDirectoryA(path, sec) == ERROR_SUCCESS);
+    if (SHELL_OsIsUnicode())
+        return (SHNotifyCreateDirectoryW(path, sec) == ERROR_SUCCESS);
+    return (SHNotifyCreateDirectoryA(path, sec) == ERROR_SUCCESS);
 }
 
 /************************************************************************
@@ -440,116 +484,125 @@ BOOL WINAPI Win32CreateDirectoryAW(LPCVOID path, LPSECURITY_ATTRIBUTES sec)
  */
 static DWORD SHNotifyRemoveDirectoryA(LPCSTR path)
 {
-	LPWSTR wPath;
-	DWORD retCode;
+    LPWSTR wPath;
+    DWORD retCode;
 
-	TRACE("(%s)\n", debugstr_a(path));
+    TRACE("(%s)\n", debugstr_a(path));
 
-	retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
-	if (!retCode)
-	{
-	  retCode = SHNotifyRemoveDirectoryW(wPath);
-	  free(wPath);
-	}
-	return retCode;
+    retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
+    if (!retCode)
+    {
+        retCode = SHNotifyRemoveDirectoryW(wPath);
+        free(wPath);
+    }
+    return retCode;
 }
 
 /***********************************************************************/
 
 static DWORD SHNotifyRemoveDirectoryW(LPCWSTR path)
 {
-	BOOL ret;
-	TRACE("(%s)\n", debugstr_w(path));
+    BOOL ret;
+    TRACE("(%s)\n", debugstr_w(path));
 
-	ret = RemoveDirectoryW(path);
-	if (!ret)
-	{
-	  /* Directory may be write protected */
-	  DWORD dwAttr = GetFileAttributesW(path);
-	  if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY))
-	    if (SetFileAttributesW(path, dwAttr & ~FILE_ATTRIBUTE_READONLY))
-	      ret = RemoveDirectoryW(path);
-	}
-	if (ret)
-	{
-	  SHChangeNotify(SHCNE_RMDIR, SHCNF_PATHW, path, NULL);
-	  return ERROR_SUCCESS;
-	}
-	return GetLastError();
+    ret = RemoveDirectoryW(path);
+    if (!ret)
+    {
+        /* Directory may be write protected */
+        DWORD dwAttr = GetFileAttributesW(path);
+        if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY))
+            if (SetFileAttributesW(path, dwAttr & ~FILE_ATTRIBUTE_READONLY))
+                ret = RemoveDirectoryW(path);
+    }
+    if (ret)
+    {
+        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATHW, path, NULL);
+        return ERROR_SUCCESS;
+    }
+    return GetLastError();
 }
 
 /***********************************************************************/
 
 BOOL WINAPI Win32RemoveDirectoryAW(LPCVOID path)
 {
-	if (SHELL_OsIsUnicode())
-	  return (SHNotifyRemoveDirectoryW(path) == ERROR_SUCCESS);
-	return (SHNotifyRemoveDirectoryA(path) == ERROR_SUCCESS);
+    if (SHELL_OsIsUnicode())
+        return (SHNotifyRemoveDirectoryW(path) == ERROR_SUCCESS);
+    return (SHNotifyRemoveDirectoryA(path) == ERROR_SUCCESS);
 }
 
-/************************************************************************
- * Win32DeleteFile           [SHELL32.164]
- *
- * Deletes a file. Also triggers a change notify if one exists.
- *
- * PARAMS
- *  path       [I]   path to file to delete
- *
- * RETURNS
- *  TRUE if successful, FALSE otherwise
- *
- * NOTES
- *  Verified on Win98 / IE 5 (SHELL32 4.72, March 1999 build) to be ANSI.
- *  This is Unicode on NT/2000
- */
-static DWORD SHNotifyDeleteFileA(LPCSTR path)
+/***********************************************************************/
+
+static DWORD SHNotifyDeleteFileA(FILE_OPERATION *op, LPCSTR path)
 {
-	LPWSTR wPath;
-	DWORD retCode;
+    LPWSTR wPath;
+    DWORD retCode;
 
-	TRACE("(%s)\n", debugstr_a(path));
+    TRACE("(%s)\n", debugstr_a(path));
 
-	retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
-	if (!retCode)
-	{
-	  retCode = SHNotifyDeleteFileW(wPath);
-	  free(wPath);
-	}
-	return retCode;
+    retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
+    if (!retCode)
+    {
+        retCode = SHNotifyDeleteFileW(op, wPath);
+        free(wPath);
+    }
+    return retCode;
 }
 
 /***********************************************************************/
 
-static DWORD SHNotifyDeleteFileW(LPCWSTR path)
+static DWORD SHNotifyDeleteFileW(FILE_OPERATION *op, LPCWSTR path)
 {
-	BOOL ret;
+    BOOL ret;
+    LARGE_INTEGER filesize;
+    filesize.QuadPart = 0;
 
-	TRACE("(%s)\n", debugstr_w(path));
+    TRACE("(%s)\n", debugstr_w(path));
 
-	ret = DeleteFileW(path);
-	if (!ret)
-	{
-	  /* File may be write protected or a system file */
-	  DWORD dwAttr = GetFileAttributesW(path);
-	  if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
-	    if (SetFileAttributesW(path, dwAttr & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
-	      ret = DeleteFileW(path);
-	}
-	if (ret)
-	{
-	  SHChangeNotify(SHCNE_DELETE, SHCNF_PATHW, path, NULL);
-	  return ERROR_SUCCESS;
-	}
-	return GetLastError();
+    /* Warning: can also be called with empty op */
+    if (op)
+    {
+        WIN32_FILE_ATTRIBUTE_DATA info;
+        progressbar_update_files(op, path, NULL);
+        if (GetFileAttributesExW(path, GetFileExInfoStandard, &info))
+        {
+            filesize.u.HighPart = info.nFileSizeHigh;
+            filesize.u.LowPart  = info.nFileSizeLow;
+        }
+    }
+
+    ret = DeleteFileW(path);
+    if (!ret)
+    {
+        /* File may be write protected or a system file */
+        DWORD dwAttr = GetFileAttributesW(path);
+        if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
+            if (SetFileAttributesW(path, dwAttr & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
+                ret = DeleteFileW(path);
+    }
+    if (ret)
+    {
+        if (op)
+        {
+            /* There is no progress while deleting a file,
+             * simply report full file size when we are done. */
+            progressbar_copy_routine(filesize, filesize, filesize, filesize, 0,
+                                     CALLBACK_STREAM_SWITCH, NULL, NULL, op);
+        }
+
+        SHChangeNotify(SHCNE_DELETE, SHCNF_PATHW, path, NULL);
+        return ERROR_SUCCESS;
+    }
+    return GetLastError();
 }
 
 /***********************************************************************/
 
 DWORD WINAPI Win32DeleteFileAW(LPCVOID path)
 {
-	if (SHELL_OsIsUnicode())
-	  return (SHNotifyDeleteFileW(path) == ERROR_SUCCESS);
-	return (SHNotifyDeleteFileA(path) == ERROR_SUCCESS);
+    if (SHELL_OsIsUnicode())
+        return (SHNotifyDeleteFileW(NULL, path) == ERROR_SUCCESS);
+    return (SHNotifyDeleteFileA(NULL, path) == ERROR_SUCCESS);
 }
 
 /************************************************************************
@@ -558,44 +611,48 @@ DWORD WINAPI Win32DeleteFileAW(LPCVOID path)
  * Moves a file. Also triggers a change notify if one exists.
  *
  * PARAMS
+ *  op         [I]   file operation context
  *  src        [I]   path to source file to move
  *  dest       [I]   path to target file to move to
  *
  * RETURNS
  *  ERROR_SUCCESS if successful
  */
-static DWORD SHNotifyMoveFileW(LPCWSTR src, LPCWSTR dest)
+static DWORD SHNotifyMoveFileW(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dest)
 {
-	BOOL ret;
+    BOOL ret;
 
-	TRACE("(%s %s)\n", debugstr_w(src), debugstr_w(dest));
+    TRACE("(%s %s)\n", debugstr_w(src), debugstr_w(dest));
 
-        ret = MoveFileExW(src, dest, MOVEFILE_REPLACE_EXISTING);
+    progressbar_update_files(op, src, dest);
 
-        /* MOVEFILE_REPLACE_EXISTING fails with dirs, so try MoveFile */
-        if (!ret)
-            ret = MoveFileW(src, dest);
+    ret = MoveFileWithProgressW(src, dest, progressbar_copy_routine,
+                                op, MOVEFILE_REPLACE_EXISTING);
 
-	if (!ret)
-	{
-	  DWORD dwAttr;
+    /* MOVEFILE_REPLACE_EXISTING fails with dirs, so try MoveFile */
+    if (!ret)
+        ret = MoveFileW(src, dest);
 
-	  dwAttr = SHFindAttrW(dest, FALSE);
-	  if (INVALID_FILE_ATTRIBUTES == dwAttr)
-	  {
-	    /* Source file may be write protected or a system file */
-	    dwAttr = GetFileAttributesW(src);
-	    if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
-	      if (SetFileAttributesW(src, dwAttr & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
-	        ret = MoveFileW(src, dest);
-	  }
-	}
-	if (ret)
-	{
-	  SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_PATHW, src, dest);
-	  return ERROR_SUCCESS;
-	}
-	return GetLastError();
+    if (!ret)
+    {
+        DWORD dwAttr;
+
+        dwAttr = SHFindAttrW(dest, FALSE);
+        if (INVALID_FILE_ATTRIBUTES == dwAttr)
+        {
+            /* Source file may be write protected or a system file */
+            dwAttr = GetFileAttributesW(src);
+            if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
+                if (SetFileAttributesW(src, dwAttr & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
+                    ret = MoveFileW(src, dest);
+        }
+    }
+    if (ret)
+    {
+        SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_PATHW, src, dest);
+        return ERROR_SUCCESS;
+    }
+    return GetLastError();
 }
 
 /************************************************************************
@@ -604,6 +661,7 @@ static DWORD SHNotifyMoveFileW(LPCWSTR src, LPCWSTR dest)
  * Copies a file. Also triggers a change notify if one exists.
  *
  * PARAMS
+ *  op            [I]   file operation context
  *  src           [I]   path to source file to move
  *  dest          [I]   path to target file to move to
  *  bFailIfExists [I]   if TRUE, the target file will not be overwritten if
@@ -612,26 +670,29 @@ static DWORD SHNotifyMoveFileW(LPCWSTR src, LPCWSTR dest)
  * RETURNS
  *  ERROR_SUCCESS if successful
  */
-static DWORD SHNotifyCopyFileW(LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists)
+static DWORD SHNotifyCopyFileW(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists)
 {
-	BOOL ret;
-	DWORD attribs;
+    BOOL ret;
+    DWORD attribs;
 
-	TRACE("(%s %s %s)\n", debugstr_w(src), debugstr_w(dest), bFailIfExists ? "failIfExists" : "");
+    TRACE("(%s %s %s)\n", debugstr_w(src), debugstr_w(dest), bFailIfExists ? "failIfExists" : "");
 
-        /* Destination file may already exist with read only attribute */
-        attribs = GetFileAttributesW(dest);
-        if (IsAttrib(attribs, FILE_ATTRIBUTE_READONLY))
-          SetFileAttributesW(dest, attribs & ~FILE_ATTRIBUTE_READONLY);
+    progressbar_update_files(op, src, dest);
 
-	ret = CopyFileW(src, dest, bFailIfExists);
-	if (ret)
-	{
-	  SHChangeNotify(SHCNE_CREATE, SHCNF_PATHW, dest, NULL);
-	  return ERROR_SUCCESS;
-	}
+    /* Destination file may already exist with read only attribute */
+    attribs = GetFileAttributesW(dest);
+    if (IsAttrib(attribs, FILE_ATTRIBUTE_READONLY))
+        SetFileAttributesW(dest, attribs & ~FILE_ATTRIBUTE_READONLY);
+
+    ret = CopyFileExW(src, dest, progressbar_copy_routine, op,
+                      &op->bCancelled, bFailIfExists);
+    if (ret)
+    {
+        SHChangeNotify(SHCNE_CREATE, SHCNF_PATHW, dest, NULL);
+        return ERROR_SUCCESS;
+    }
 
-	return GetLastError();
+    return GetLastError();
 }
 
 /*************************************************************************
@@ -661,9 +722,9 @@ static DWORD SHNotifyCopyFileW(LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists)
  */
 DWORD WINAPI SHCreateDirectory(HWND hWnd, LPCVOID path)
 {
-	if (SHELL_OsIsUnicode())
-	  return SHCreateDirectoryExW(hWnd, path, NULL);
-	return SHCreateDirectoryExA(hWnd, path, NULL);
+    if (SHELL_OsIsUnicode())
+        return SHCreateDirectoryExW(hWnd, path, NULL);
+    return SHCreateDirectoryExA(hWnd, path, NULL);
 }
 
 /*************************************************************************
@@ -700,18 +761,18 @@ DWORD WINAPI SHCreateDirectory(HWND hWnd, LPCVOID path)
  */
 int WINAPI SHCreateDirectoryExA(HWND hWnd, LPCSTR path, LPSECURITY_ATTRIBUTES sec)
 {
-	LPWSTR wPath;
-	DWORD retCode;
+    LPWSTR wPath;
+    DWORD retCode;
 
-	TRACE("(%s, %p)\n", debugstr_a(path), sec);
+    TRACE("(%s, %p)\n", debugstr_a(path), sec);
 
-	retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
-	if (!retCode)
-	{
-	  retCode = SHCreateDirectoryExW(hWnd, wPath, sec);
-	  free(wPath);
-	}
-	return retCode;
+    retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
+    if (!retCode)
+    {
+        retCode = SHCreateDirectoryExW(hWnd, wPath, sec);
+        free(wPath);
+    }
+    return retCode;
 }
 
 /*************************************************************************
@@ -785,25 +846,25 @@ int WINAPI SHCreateDirectoryExW(HWND hWnd, LPCWSTR path, LPSECURITY_ATTRIBUTES s
  */
 static DWORD SHFindAttrW(LPCWSTR pName, BOOL fileOnly)
 {
-	WIN32_FIND_DATAW wfd;
-	BOOL b_FileMask = fileOnly && (NULL != StrPBrkW(pName, L"*?"));
-	DWORD dwAttr = INVALID_FILE_ATTRIBUTES;
-	HANDLE hFind = FindFirstFileW(pName, &wfd);
+    WIN32_FIND_DATAW wfd;
+    BOOL b_FileMask = fileOnly && (NULL != StrPBrkW(pName, L"*?"));
+    DWORD dwAttr = INVALID_FILE_ATTRIBUTES;
+    HANDLE hFind = FindFirstFileW(pName, &wfd);
 
-	TRACE("%s %d\n", debugstr_w(pName), fileOnly);
-	if (INVALID_HANDLE_VALUE != hFind)
-	{
-	  do
-	  {
-	    if (b_FileMask && IsAttribDir(wfd.dwFileAttributes))
-	       continue;
-	    dwAttr = wfd.dwFileAttributes;
-	    break;
-	  }
-	  while (FindNextFileW(hFind, &wfd));
-	  FindClose(hFind);
-	}
-	return dwAttr;
+    TRACE("%s %d\n", debugstr_w(pName), fileOnly);
+    if (INVALID_HANDLE_VALUE != hFind)
+    {
+        do
+        {
+            if (b_FileMask && IsAttribDir(wfd.dwFileAttributes))
+                continue;
+            dwAttr = wfd.dwFileAttributes;
+            break;
+        }
+        while (FindNextFileW(hFind, &wfd));
+        FindClose(hFind);
+    }
+    return dwAttr;
 }
 
 /*************************************************************************
@@ -817,27 +878,27 @@ static DWORD SHFindAttrW(LPCWSTR pName, BOOL fileOnly)
  */
 static DWORD SHNameTranslate(LPWSTR* wString, LPCWSTR* pWToFrom, BOOL more)
 {
-	DWORD size = 0, aSize = 0;
-	LPCSTR aString = (LPCSTR)*pWToFrom;
+    DWORD size = 0, aSize = 0;
+    LPCSTR aString = (LPCSTR)*pWToFrom;
 
-	if (aString)
-	{
-	  do
-	  {
-	    size = lstrlenA(aString) + 1;
-	    aSize += size;
-	    aString += size;
-	  } while ((size != 1) && more);
-	  /* The two sizes might be different in the case of multibyte chars */
-	  size = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)*pWToFrom, aSize, *wString, 0);
-	  if (*wString) /* only in the second loop */
-	  {
-	    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)*pWToFrom, aSize, *wString, size);
-	    *pWToFrom = *wString;
-	    *wString += size;
-	  }
-	}
-	return size;
+    if (aString)
+    {
+        do
+        {
+            size = lstrlenA(aString) + 1;
+            aSize += size;
+            aString += size;
+        } while ((size != 1) && more);
+        /* The two sizes might be different in the case of multibyte chars */
+        size = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)*pWToFrom, aSize, *wString, 0);
+        if (*wString) /* only in the second loop */
+        {
+            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)*pWToFrom, aSize, *wString, size);
+            *pWToFrom = *wString;
+            *wString += size;
+        }
+    }
+    return size;
 }
 /*************************************************************************
  * SHFileOperationA          [SHELL32.@]
@@ -857,72 +918,47 @@ static DWORD SHNameTranslate(LPWSTR* wString, LPCWSTR* pWToFrom, BOOL more)
  */
 int WINAPI SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp)
 {
-	SHFILEOPSTRUCTW nFileOp = *((LPSHFILEOPSTRUCTW)lpFileOp);
-	int retCode = 0;
-	DWORD size;
-	LPWSTR ForFree = NULL, /* we change wString in SHNameTranslate and can't use it for freeing */
-	       wString = NULL; /* we change this in SHNameTranslate */
-
-	TRACE("\n");
-	if (FO_DELETE == (nFileOp.wFunc & FO_MASK))
-	  nFileOp.pTo = NULL; /* we need a NULL or a valid pointer for translation */
-	if (!(nFileOp.fFlags & FOF_SIMPLEPROGRESS))
-	  nFileOp.lpszProgressTitle = NULL; /* we need a NULL or a valid pointer for translation */
-	while (1) /* every loop calculate size, second translate also, if we have storage for this */
-	{
-	  size = SHNameTranslate(&wString, &nFileOp.lpszProgressTitle, FALSE); /* no loop */
-	  size += SHNameTranslate(&wString, &nFileOp.pFrom, TRUE); /* internal loop */
-	  size += SHNameTranslate(&wString, &nFileOp.pTo, TRUE); /* internal loop */
-
-	  if (ForFree)
-	  {
-	    retCode = SHFileOperationW(&nFileOp);
-	    /* Windows 95/98 returns S_OK for this case. */
-	    if (retCode == ERROR_ACCESS_DENIED && (GetVersion() & 0x80000000))
-	      retCode = S_OK;
+    SHFILEOPSTRUCTW nFileOp = *((LPSHFILEOPSTRUCTW)lpFileOp);
+    int retCode = 0;
+    DWORD size;
+    LPWSTR ForFree = NULL, /* we change wString in SHNameTranslate and can't use it for freeing */
+           wString = NULL; /* we change this in SHNameTranslate */
+
+    TRACE("\n");
+    if (FO_DELETE == (nFileOp.wFunc & FO_MASK))
+        nFileOp.pTo = NULL; /* we need a NULL or a valid pointer for translation */
+    if (!(nFileOp.fFlags & FOF_SIMPLEPROGRESS))
+        nFileOp.lpszProgressTitle = NULL; /* we need a NULL or a valid pointer for translation */
+    while (1) /* every loop calculate size, second translate also, if we have storage for this */
+    {
+        size = SHNameTranslate(&wString, &nFileOp.lpszProgressTitle, FALSE); /* no loop */
+        size += SHNameTranslate(&wString, &nFileOp.pFrom, TRUE); /* internal loop */
+        size += SHNameTranslate(&wString, &nFileOp.pTo, TRUE); /* internal loop */
 
-	    free(ForFree); /* we cannot use wString, it was changed */
-	    break;
-	  }
-	  else
-	  {
-	    wString = ForFree = malloc(size * sizeof(WCHAR));
-	    if (ForFree) continue;
-	    retCode = ERROR_OUTOFMEMORY;
-	    nFileOp.fAnyOperationsAborted = TRUE;
-	    return retCode;
-	  }
-	}
+        if (ForFree)
+        {
+            retCode = SHFileOperationW(&nFileOp);
+            /* Windows 95/98 returns S_OK for this case. */
+            if (retCode == ERROR_ACCESS_DENIED && (GetVersion() & 0x80000000))
+                retCode = S_OK;
+            free(ForFree); /* we cannot use wString, it was changed */
+            break;
+        }
+        else
+        {
+            wString = ForFree = malloc(size * sizeof(WCHAR));
+            if (ForFree) continue;
+            retCode = ERROR_OUTOFMEMORY;
+            nFileOp.fAnyOperationsAborted = TRUE;
+            return retCode;
+        }
+    }
 
-	lpFileOp->hNameMappings = nFileOp.hNameMappings;
-	lpFileOp->fAnyOperationsAborted = nFileOp.fAnyOperationsAborted;
-	return retCode;
+    lpFileOp->hNameMappings = nFileOp.hNameMappings;
+    lpFileOp->fAnyOperationsAborted = nFileOp.fAnyOperationsAborted;
+    return retCode;
 }
 
-#define ERROR_SHELL_INTERNAL_FILE_NOT_FOUND 1026
-
-typedef struct
-{
-    DWORD attributes;
-    LPWSTR szDirectory;
-    LPWSTR szFilename;
-    LPWSTR szFullPath;
-    BOOL bFromWildcard;
-    BOOL bFromRelative;
-    BOOL bExists;
-} FILE_ENTRY;
-
-typedef struct
-{
-    FILE_ENTRY *feFiles;
-    DWORD num_alloc;
-    DWORD dwNumFiles;
-    BOOL bAnyFromWildcard;
-    BOOL bAnyDirectories;
-    BOOL bAnyDontExist;
-} FILE_LIST;
-
-
 static inline void grow_list(FILE_LIST *list)
 {
     FILE_ENTRY *new = _recalloc(list->feFiles, list->num_alloc * 2, sizeof(*new));
@@ -1087,7 +1123,7 @@ static void destroy_file_list(FILE_LIST *flList)
 static void copy_dir_to_dir(FILE_OPERATION *op, const FILE_ENTRY *feFrom, LPCWSTR szDestPath)
 {
     WCHAR szFrom[MAX_PATH], szTo[MAX_PATH];
-    SHFILEOPSTRUCTW fileOp;
+    FILE_LIST flFromNew, flToNew;
 
     if (IsDotDir(feFrom->szFilename))
         return;
@@ -1113,17 +1149,16 @@ static void copy_dir_to_dir(FILE_OPERATION *op, const FILE_ENTRY *feFrom, LPCWST
     PathCombineW(szFrom, feFrom->szFullPath, L"*.*");
     szFrom[lstrlenW(szFrom) + 1] = '\0';
 
-    fileOp = *op->req;
-    fileOp.pFrom = szFrom;
-    fileOp.pTo = szTo;
-    fileOp.fFlags &= ~FOF_MULTIDESTFILES; /* we know we're copying to one dir */
+    ZeroMemory(&flFromNew, sizeof(FILE_LIST));
+    ZeroMemory(&flToNew, sizeof(FILE_LIST));
+    parse_file_list(&flFromNew, szFrom);
+    parse_file_list(&flToNew, szTo);
 
-    /* Don't ask the user about overwriting files when he accepted to overwrite the
-       folder. FIXME: this is not exactly what Windows does - e.g. there would be
-       an additional confirmation for a nested folder */
-    fileOp.fFlags |= FOF_NOCONFIRMATION;  
+    /* we know we're copying to one dir */
+    copy_files(op, FALSE, &flFromNew, &flToNew);
 
-    SHFileOperationW(&fileOp);
+    destroy_file_list(&flFromNew);
+    destroy_file_list(&flToNew);
 }
 
 static BOOL copy_file_to_file(FILE_OPERATION *op, const WCHAR *szFrom, const WCHAR *szTo)
@@ -1134,7 +1169,7 @@ static BOOL copy_file_to_file(FILE_OPERATION *op, const WCHAR *szFrom, const WCH
             return FALSE;
     }
 
-    return SHNotifyCopyFileW(szFrom, szTo, FALSE) == 0;
+    return SHNotifyCopyFileW(op, szFrom, szTo, FALSE) == 0;
 }
 
 /* copy a file or directory to another directory */
@@ -1174,7 +1209,7 @@ static void create_dest_dirs(LPCWSTR szDestDir)
 }
 
 /* the FO_COPY operation */
-static int copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *flTo)
+static int copy_files(FILE_OPERATION *op, BOOL multidest, const FILE_LIST *flFrom, FILE_LIST *flTo)
 {
     DWORD i;
     const FILE_ENTRY *entryToCopy;
@@ -1197,7 +1232,7 @@ static int copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *fl
         fileDest = &flTo->feFiles[0];
     }
 
-    if (op->req->fFlags & FOF_MULTIDESTFILES && flTo->dwNumFiles > 1)
+    if (multidest && flTo->dwNumFiles > 1)
     {
         if (flFrom->bAnyFromWildcard)
             return ERROR_CANCELLED;
@@ -1249,8 +1284,7 @@ static int copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *fl
     {
         entryToCopy = &flFrom->feFiles[i];
 
-        if ((op->req->fFlags & FOF_MULTIDESTFILES) &&
-            flTo->dwNumFiles > 1)
+        if (multidest && flTo->dwNumFiles > 1)
         {
             fileDest = &flTo->feFiles[i];
         }
@@ -1290,6 +1324,8 @@ static int copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *fl
         }
 
         /* Vista return code. XP would return e.g. ERROR_FILE_NOT_FOUND, ERROR_ALREADY_EXISTS */
+        if (op->progress != NULL)
+            op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
         if (op->bCancelled)
             return ERROR_CANCELLED;
     }
@@ -1321,7 +1357,7 @@ static BOOL confirm_delete_list(HWND hWnd, DWORD fFlags, BOOL fTrash, const FILE
 }
 
 /* the FO_DELETE operation */
-static int delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
+static int delete_files(FILE_OPERATION *op, const FILE_LIST *flFrom)
 {
     const FILE_ENTRY *fileEntry;
     DWORD i;
@@ -1332,12 +1368,12 @@ static int delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
         return ERROR_SUCCESS;
 
     /* Windows also checks only the first item */
-    bTrash = (lpFileOp->fFlags & FOF_ALLOWUNDO) && is_trash_available();
+    bTrash = (op->req->fFlags & FOF_ALLOWUNDO) && is_trash_available();
 
-    if (!(lpFileOp->fFlags & FOF_NOCONFIRMATION) || (!bTrash && lpFileOp->fFlags & FOF_WANTNUKEWARNING))
-        if (!confirm_delete_list(lpFileOp->hwnd, lpFileOp->fFlags, bTrash, flFrom))
+    if (!(op->req->fFlags & FOF_NOCONFIRMATION) || (!bTrash && op->req->fFlags & FOF_WANTNUKEWARNING))
+        if (!confirm_delete_list(op->req->hwnd, op->req->fFlags, bTrash, flFrom))
         {
-            lpFileOp->fAnyOperationsAborted = TRUE;
+            op->req->fAnyOperationsAborted = TRUE;
             return 0;
         }
 
@@ -1346,7 +1382,7 @@ static int delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
         fileEntry = &flFrom->feFiles[i];
 
         if (!IsAttribFile(fileEntry->attributes) &&
-            (lpFileOp->fFlags & FOF_FILESONLY && fileEntry->bFromWildcard))
+            (op->req->fFlags & FOF_FILESONLY && fileEntry->bFromWildcard))
             continue;
 
         if (bTrash)
@@ -1356,43 +1392,47 @@ static int delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
                 continue;
 
             /* Note: Windows silently deletes the file in such a situation, we show a dialog */
-            if (!(lpFileOp->fFlags & FOF_NOCONFIRMATION) || (lpFileOp->fFlags & FOF_WANTNUKEWARNING))
-                bDelete = SHELL_ConfirmDialogW(lpFileOp->hwnd, ASK_CANT_TRASH_ITEM, fileEntry->szFullPath, NULL);
+            if (!(op->req->fFlags & FOF_NOCONFIRMATION) || (op->req->fFlags & FOF_WANTNUKEWARNING))
+                bDelete = SHELL_ConfirmDialogW(op->req->hwnd, ASK_CANT_TRASH_ITEM, fileEntry->szFullPath, NULL);
             else
                 bDelete = TRUE;
 
             if (!bDelete)
             {
-                lpFileOp->fAnyOperationsAborted = TRUE;
+                op->req->fAnyOperationsAborted = TRUE;
                 break;
             }
         }
-        
+
         /* delete the file or directory */
         if (IsAttribFile(fileEntry->attributes))
-            ret = DeleteFileW(fileEntry->szFullPath) ?
-                    ERROR_SUCCESS : GetLastError();
+            ret = SHNotifyDeleteFileW(op, fileEntry->szFullPath);
         else
-            ret = SHELL_DeleteDirectoryW(lpFileOp->hwnd, fileEntry->szFullPath, FALSE);
+            ret = SHELL_DeleteDirectoryW(op, fileEntry->szFullPath, FALSE);
 
         if (ret)
             return ret;
+
+        if (op->progress != NULL)
+            op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+        if (op->bCancelled)
+            return ERROR_CANCELLED;
     }
 
     return ERROR_SUCCESS;
 }
 
 /* moves a file or directory to another directory */
-static void move_to_dir(LPSHFILEOPSTRUCTW lpFileOp, const FILE_ENTRY *feFrom, const FILE_ENTRY *feTo)
+static void move_to_dir(FILE_OPERATION *op, const FILE_ENTRY *feFrom, const FILE_ENTRY *feTo)
 {
     WCHAR szDestPath[MAX_PATH];
 
     PathCombineW(szDestPath, feTo->szFullPath, feFrom->szFilename);
-    SHNotifyMoveFileW(feFrom->szFullPath, szDestPath);
+    SHNotifyMoveFileW(op, feFrom->szFullPath, szDestPath);
 }
 
 /* the FO_MOVE operation */
-static int move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const FILE_LIST *flTo)
+static int move_files(FILE_OPERATION *op, BOOL multidest, const FILE_LIST *flFrom, const FILE_LIST *flTo)
 {
     DWORD i;
     INT mismatched = 0;
@@ -1405,23 +1445,25 @@ static int move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const
     if (!flTo->dwNumFiles)
         return ERROR_FILE_NOT_FOUND;
 
-    if (!(lpFileOp->fFlags & FOF_MULTIDESTFILES) &&
-        flTo->dwNumFiles > 1 && flFrom->dwNumFiles > 1)
+    if (!multidest && flTo->dwNumFiles > 1 && flFrom->dwNumFiles > 1)
     {
         return ERROR_CANCELLED;
     }
 
-    if (!(lpFileOp->fFlags & FOF_MULTIDESTFILES) &&
-        !flFrom->bAnyDirectories &&
+    if (!multidest && !flFrom->bAnyDirectories &&
         flFrom->dwNumFiles > flTo->dwNumFiles)
     {
         return ERROR_CANCELLED;
     }
 
     if (!PathFileExistsW(flTo->feFiles[0].szDirectory))
-        return ERROR_CANCELLED;
+    {
+        int ret = SHCreateDirectoryExW(NULL, flTo->feFiles[0].szDirectory, NULL);
+        if (ret)
+            return ret;
+    }
 
-    if (lpFileOp->fFlags & FOF_MULTIDESTFILES)
+    if (multidest)
         mismatched = flFrom->dwNumFiles - flTo->dwNumFiles;
 
     fileDest = &flTo->feFiles[0];
@@ -1432,7 +1474,7 @@ static int move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const
         if (!PathFileExistsW(fileDest->szDirectory))
             return ERROR_CANCELLED;
 
-        if (lpFileOp->fFlags & FOF_MULTIDESTFILES)
+        if (multidest)
         {
             if (i >= flTo->dwNumFiles)
                 break;
@@ -1446,9 +1488,14 @@ static int move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const
         }
 
         if (fileDest->bExists && IsAttribDir(fileDest->attributes))
-            move_to_dir(lpFileOp, entryToMove, fileDest);
+            move_to_dir(op, entryToMove, fileDest);
         else
-            SHNotifyMoveFileW(entryToMove->szFullPath, fileDest->szFullPath);
+            SHNotifyMoveFileW(op, entryToMove->szFullPath, fileDest->szFullPath);
+
+        if (op->progress != NULL)
+            op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+        if (op->bCancelled)
+            return ERROR_CANCELLED;
     }
 
     if (mismatched > 0)
@@ -1463,7 +1510,7 @@ static int move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const
 }
 
 /* the FO_RENAME files */
-static int rename_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const FILE_LIST *flTo)
+static int rename_files(FILE_OPERATION *op, const FILE_LIST *flFrom, const FILE_LIST *flTo)
 {
     const FILE_ENTRY *feFrom;
     const FILE_ENTRY *feTo;
@@ -1485,15 +1532,15 @@ static int rename_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, con
     if (feTo->bExists)
         return ERROR_ALREADY_EXISTS;
 
-    return SHNotifyMoveFileW(feFrom->szFullPath, feTo->szFullPath);
+    return SHNotifyMoveFileW(op, feFrom->szFullPath, feTo->szFullPath);
 }
 
 /* alert the user if an unsupported flag is used */
 static void check_flags(FILEOP_FLAGS fFlags)
 {
     WORD wUnsupportedFlags = FOF_NO_CONNECTED_ELEMENTS |
-        FOF_NOCOPYSECURITYATTRIBS | FOF_NORECURSEREPARSE |
-        FOF_RENAMEONCOLLISION | FOF_WANTMAPPINGHANDLE;
+                             FOF_NOCOPYSECURITYATTRIBS | FOF_NORECURSEREPARSE |
+                             FOF_RENAMEONCOLLISION | FOF_WANTMAPPINGHANDLE;
 
     if (fFlags & wUnsupportedFlags)
         FIXME("Unsupported flags: %04x\n", fFlags);
@@ -1508,6 +1555,7 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
 {
     FILE_OPERATION op;
     FILE_LIST flFrom, flTo;
+    HRESULT co_ret = E_FAIL;
     int ret = 0;
 
     if (!lpFileOp)
@@ -1526,28 +1574,56 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
 
     ZeroMemory(&op, sizeof(op));
     op.req = lpFileOp;
+    op.totalSize.QuadPart = 0;
+    op.completedSize.QuadPart = 0;
     op.bManyItems = (flFrom.dwNumFiles > 1);
     lpFileOp->fAnyOperationsAborted = FALSE;
 
+    if (lpFileOp->wFunc != FO_RENAME && !(lpFileOp->fFlags & FOF_SILENT))
+    {
+        co_ret = CoInitialize(NULL);
+        ret = CoCreateInstance(&CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER,
+                               &IID_IProgressDialog, (void**)&op.progress);
+        if (SUCCEEDED(ret))
+        {
+            IProgressDialog_StartProgressDialog(op.progress, op.req->hwnd, NULL,
+                                                PROGDLG_NORMAL | PROGDLG_AUTOTIME, NULL);
+
+            progressbar_update_title(&op);
+            progressbar_calc_totalsize(&op, &flFrom);
+        }
+        else
+        {
+            FIXME("Failed to create progress dialog\n");
+            op.progress = NULL;
+        }
+    }
+
     switch (lpFileOp->wFunc)
     {
         case FO_COPY:
-            ret = copy_files(&op, &flFrom, &flTo);
+            ret = copy_files(&op, op.req->fFlags & FOF_MULTIDESTFILES, &flFrom, &flTo);
             break;
         case FO_DELETE:
-            ret = delete_files(lpFileOp, &flFrom);
+            ret = delete_files(&op, &flFrom);
             break;
         case FO_MOVE:
-            ret = move_files(lpFileOp, &flFrom, &flTo);
+            ret = move_files(&op, op.req->fFlags & FOF_MULTIDESTFILES, &flFrom, &flTo);
             break;
         case FO_RENAME:
-            ret = rename_files(lpFileOp, &flFrom, &flTo);
+            ret = rename_files(&op, &flFrom, &flTo);
             break;
         default:
             ret = ERROR_INVALID_PARAMETER;
             break;
     }
 
+    if (op.progress)
+    {
+        IProgressDialog_StopProgressDialog(op.progress);
+        IProgressDialog_Release(op.progress);
+    }
+
     destroy_file_list(&flFrom);
 
     if (lpFileOp->wFunc != FO_DELETE)
@@ -1556,6 +1632,9 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
     if (ret == ERROR_CANCELLED)
         lpFileOp->fAnyOperationsAborted = TRUE;
 
+    if (SUCCEEDED(co_ret))
+        CoUninitialize();
+
     SetLastError(ERROR_SUCCESS);
     return ret;
 }
@@ -1576,19 +1655,19 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
  */
 void WINAPI SHFreeNameMappings(HANDLE hNameMapping)
 {
-	if (hNameMapping)
-	{
-	  int i = SHDSA_GetItemCount((HDSA)hNameMapping) - 1;
+    if (hNameMapping)
+    {
+        int i = SHDSA_GetItemCount((HDSA)hNameMapping) - 1;
 
-	  for (; i>= 0; i--)
-	  {
+        for (; i>= 0; i--)
+        {
             LPSHNAMEMAPPINGW lp = DSA_GetItemPtr(hNameMapping, i);
 
-	    SHFree(lp->pszOldPath);
-	    SHFree(lp->pszNewPath);
-	  }
-          DSA_Destroy(hNameMapping);
-	}
+            SHFree(lp->pszOldPath);
+            SHFree(lp->pszNewPath);
+        }
+        DSA_Destroy(hNameMapping);
+    }
 }
 
 /*************************************************************************
@@ -1694,14 +1773,14 @@ DWORD WINAPI SheChangeDirW(LPWSTR path)
 }
 
 /*************************************************************************
- * IsNetDrive			[SHELL32.66]
+ * IsNetDrive                   [SHELL32.66]
  */
 int WINAPI IsNetDrive(int drive)
 {
-	char root[4];
-	strcpy(root, "A:\\");
-	root[0] += (char)drive;
-	return (GetDriveTypeA(root) == DRIVE_REMOTE);
+    char root[4];
+    strcpy(root, "A:\\");
+    root[0] += (char)drive;
+    return (GetDriveTypeA(root) == DRIVE_REMOTE);
 }
 
 
@@ -2044,3 +2123,189 @@ HRESULT WINAPI IFileOperation_Constructor(IUnknown *outer, REFIID riid, void **o
 
     return hr;
 }
+
+static BOOL progressbar_calc_size(FILE_OPERATION *op, LPWSTR buf, BOOL is_folder, DWORD *ticks)
+{
+    WIN32_FIND_DATAW wfd;
+    HANDLE find;
+    UINT i = wcslen(buf);
+    WCHAR *file = buf + i;
+    size_t size = MAX_PATH - i;
+
+    if (size < 3)
+        return FALSE;
+
+    if (is_folder)
+    {
+        *file++ = '\\';
+        size--;
+
+        file[0] = '*';
+        file[1] = 0;
+    }
+    else
+    {
+        file[0] = 0;
+    }
+
+    find = FindFirstFileW(buf, &wfd);
+    if (find == INVALID_HANDLE_VALUE)
+    {
+        WARN("FindFirstFileW %s failed\n", debugstr_w(buf));
+        return FALSE;
+    }
+
+    do
+    {
+        if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+        {
+            if (wfd.cFileName[0] == '.')
+            {
+                if (wfd.cFileName[1] == 0) continue;
+                if (wfd.cFileName[1] == '.' && wfd.cFileName[2] == 0) continue;
+            }
+
+            if (!lstrcpynW(file, wfd.cFileName, size)) continue;
+            progressbar_calc_size(op, buf, TRUE, ticks);
+        }
+        else
+        {
+            LARGE_INTEGER filesize;
+            filesize.u.LowPart  = wfd.nFileSizeLow;
+            filesize.u.HighPart = wfd.nFileSizeHigh;
+            op->totalSize.QuadPart += filesize.QuadPart;
+        }
+
+        if (GetTickCount() - *ticks > 500)
+        {
+            if (op->progress != NULL)
+                op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+            if (op->bCancelled)
+                break;
+            *ticks = GetTickCount();
+        }
+
+    }
+    while (FindNextFileW(find, &wfd));
+
+    FindClose(find);
+    return TRUE;
+}
+
+static void progressbar_calc_totalsize(FILE_OPERATION *op, const FILE_LIST *from)
+{
+    WCHAR filename[MAX_PATH];
+    DWORD ticks = GetTickCount();
+    UINT i;
+
+    op->totalSize.QuadPart = 0;
+
+    for (i = 0; i < from->dwNumFiles && !op->bCancelled; i++)
+    {
+        if (!lstrcpynW(filename, from->feFiles[i].szFullPath, sizeof(filename)/sizeof(filename[0])))
+            continue;
+        progressbar_calc_size(op, filename, IsAttribDir(from->feFiles[i].attributes), &ticks);
+    }
+}
+
+static void progressbar_update_title(FILE_OPERATION *op)
+{
+    WCHAR buf[64];
+    UINT title_id, builder_id, animation_id;
+
+    if (op->progress == NULL)
+        return;
+
+    switch (op->req->wFunc)
+    {
+        case FO_COPY:
+            title_id      = IDS_FILEOP_COPYING;
+            builder_id    = IDS_FILEOP_FROM_TO;
+            animation_id  = IDR_AVI_FILECOPY;
+            break;
+
+        case FO_DELETE:
+            title_id      = IDS_FILEOP_DELETING;
+            builder_id    = IDS_FILEOP_FROM;
+            animation_id  = IDR_AVI_FILEDELETE;
+            break;
+
+        case FO_MOVE:
+            title_id      = IDS_FILEOP_MOVING;
+            builder_id    = IDS_FILEOP_FROM_TO;
+            animation_id  = IDR_AVI_FILEMOVE;
+            break;
+
+        default:
+            return;
+    }
+
+    LoadStringW(shell32_hInstance, title_id, buf, sizeof(buf)/sizeof(WCHAR));
+    IProgressDialog_SetTitle(op->progress, buf);
+
+    LoadStringW(shell32_hInstance, builder_id,  op->szBuilderString,
+                sizeof(op->szBuilderString)/sizeof(WCHAR));
+
+    LoadStringW(shell32_hInstance, IDS_FILEOP_PREFLIGHT, buf, sizeof(buf)/sizeof(WCHAR));
+    IProgressDialog_SetLine(op->progress, 1, buf, FALSE, NULL);
+
+    IProgressDialog_SetAnimation(op->progress, shell32_hInstance, animation_id);
+}
+
+static void progressbar_update_files(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dst)
+{
+    LPWSTR src_file, dst_file;
+    WCHAR src_dir[64], dst_dir[64], final[260];
+    DWORD_PTR args[2] = {0, 0};
+
+    if (!op->progress || !src || (op->req->wFunc == FO_MOVE && !dst))
+        return;
+
+    if (op->req->wFunc != FO_COPY &&
+        op->req->wFunc != FO_MOVE &&
+        op->req->wFunc != FO_DELETE)
+    {
+        return;
+    }
+
+    src_file = PathFindFileNameW(src);
+    lstrcpynW(src_dir, src, min(sizeof(src_dir) / sizeof(WCHAR) - 1, src_file - src));
+    args[0] = (DWORD_PTR)&src_dir;
+
+    if (op->req->wFunc == FO_MOVE ||
+        op->req->wFunc == FO_COPY)
+    {
+        if (PathIsDirectoryW(dst))
+            args[1] = (DWORD_PTR)&dst;
+        else
+        {
+            dst_file = PathFindFileNameW(dst);
+            lstrcpynW(dst_dir, dst, min(sizeof(dst_dir) / sizeof(WCHAR) - 1, dst_file - dst));
+            args[1] = (DWORD_PTR)&dst_dir;
+        }
+    }
+
+    FormatMessageW(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, op->szBuilderString,
+                   0, 0, final, sizeof(final)/sizeof(final[0]), (va_list *)&args);
+
+    IProgressDialog_SetLine(op->progress, 1, src_file, FALSE, NULL);
+    IProgressDialog_SetLine(op->progress, 2, final, FALSE, NULL);
+}
+
+static DWORD CALLBACK progressbar_copy_routine(LARGE_INTEGER total_size, LARGE_INTEGER total_transferred, LARGE_INTEGER stream_size,
+        LARGE_INTEGER stream_transferred, DWORD stream_number, DWORD reason, HANDLE src_file, HANDLE dst_file, LPVOID user)
+{
+    FILE_OPERATION *op = (FILE_OPERATION *)user;
+
+    if (!op->progress)
+        return PROGRESS_CONTINUE;
+
+    if (reason == CALLBACK_STREAM_SWITCH)
+        op->completedSize.QuadPart += total_size.QuadPart;
+
+    IProgressDialog_SetProgress64(op->progress, op->completedSize.QuadPart - total_size.QuadPart +
+                                  total_transferred.QuadPart, op->totalSize.QuadPart);
+
+    op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+    return op->bCancelled ? PROGRESS_CANCEL : PROGRESS_CONTINUE;
+}
diff --git a/dlls/shell32/shlfolder.c b/dlls/shell32/shlfolder.c
index 1ff45e7..eddaa2c 100644
--- a/dlls/shell32/shlfolder.c
+++ b/dlls/shell32/shlfolder.c
@@ -439,7 +439,23 @@ HRESULT SHELL32_GetItemAttributes (IShellFolder2 *psf, LPCITEMIDLIST pidl, LPDWO
                           SFGAO_CANRENAME | SFGAO_CANLINK | SFGAO_CANMOVE | SFGAO_CANCOPY;
 
 	if (file_attr & FILE_ATTRIBUTE_DIRECTORY)
-	    *pdwAttributes |=  (SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE);
+        {
+            IEnumIDList *enum_list;
+            IShellFolder *child;
+
+            *pdwAttributes |= (SFGAO_FOLDER | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE);
+
+            if (SUCCEEDED(IShellFolder2_BindToObject(psf, pidl, NULL, &IID_IShellFolder, (void **)&child)))
+            {
+                if (IShellFolder_EnumObjects(child, NULL, SHCONTF_FOLDERS|SHCONTF_INCLUDEHIDDEN, &enum_list) == S_OK)
+                {
+                    if (IEnumIDList_Skip(enum_list, 1) != S_OK)
+                        *pdwAttributes &= ~SFGAO_HASSUBFOLDER;
+                    IEnumIDList_Release(enum_list);
+                }
+                IShellFolder_Release(child);
+            }
+        }
 	else
         {
 	    *pdwAttributes &= ~(SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE);
diff --git a/dlls/shell32/shlview.c b/dlls/shell32/shlview.c
index bb11193..3217c99 100644
--- a/dlls/shell32/shlview.c
+++ b/dlls/shell32/shlview.c
@@ -1599,7 +1599,7 @@ static LRESULT ShellView_OnNotify(IShellViewImpl * This, UINT CtlID, LPNMHDR lpn
 		  }
 
 		  /* perform the item deletion */
-		  ISFHelper_DeleteItems(psfhlp, i, (LPCITEMIDLIST*)pItems);
+		  ISFHelper_DeleteItems(psfhlp, i, (LPCITEMIDLIST *)pItems, TRUE);
 		  ISFHelper_Release(psfhlp);
 
 		  /* free pidl array memory */
diff --git a/dlls/shell32/shlview_cmenu.c b/dlls/shell32/shlview_cmenu.c
index 181ff36..42af292 100644
--- a/dlls/shell32/shlview_cmenu.c
+++ b/dlls/shell32/shlview_cmenu.c
@@ -36,13 +36,132 @@
 
 #include "shresdef.h"
 #include "shlwapi.h"
+#include "aclui.h"
+#include "aclapi.h"
 
 #include "wine/debug.h"
 
+/* Small hack: We need to remove DECLSPEC_HIDDEN from the aclui export. */
+const GUID IID_ISecurityInformation = {0x965fc360, 0x16ff, 0x11d0, {0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23}};
+
 WINE_DEFAULT_DEBUG_CHANNEL(shell);
 
 #define FCIDM_BASE 0x7000
 
+/* According to https://blogs.msdn.microsoft.com/oldnewthing/20070726-00/?p=25833 */
+static const SI_ACCESS access_rights_files[] =
+{
+    /* General access rights */
+    {
+        &GUID_NULL,
+        FILE_ALL_ACCESS, MAKEINTRESOURCEW(IDS_SECURITY_ALL_ACCESS),
+        SI_ACCESS_GENERAL
+    },
+    {
+        &GUID_NULL,
+        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE | DELETE,
+        MAKEINTRESOURCEW(IDS_SECURITY_MODIFY),
+        SI_ACCESS_GENERAL
+    },
+    {
+        &GUID_NULL,
+        FILE_GENERIC_READ | FILE_GENERIC_EXECUTE,
+        MAKEINTRESOURCEW(IDS_SECURITY_READ_EXEC),
+        SI_ACCESS_GENERAL
+    },
+    {
+        &GUID_NULL,
+        FILE_GENERIC_READ,
+        MAKEINTRESOURCEW(IDS_SECURITY_READ),
+        SI_ACCESS_GENERAL
+    },
+    {
+        &GUID_NULL,
+        FILE_GENERIC_WRITE & ~READ_CONTROL,
+        MAKEINTRESOURCEW(IDS_SECURITY_WRITE),
+        SI_ACCESS_GENERAL
+    },
+
+    /* Advanced permissions */
+    { &GUID_NULL, FILE_ALL_ACCESS,       MAKEINTRESOURCEW(IDS_SECURITY_ALL_ACCESS),    SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_EXECUTE,          MAKEINTRESOURCEW(IDS_SECURITY_EXECUTE),       SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_READ_DATA,        MAKEINTRESOURCEW(IDS_SECURITY_READ_DATA),     SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_READ_ATTRIBUTES,  MAKEINTRESOURCEW(IDS_SECURITY_READ_ATTR),     SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_READ_EA,          MAKEINTRESOURCEW(IDS_SECURITY_READ_EX_ATTR),  SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_WRITE_DATA,       MAKEINTRESOURCEW(IDS_SECURITY_WRITE_DATA),    SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_APPEND_DATA,      MAKEINTRESOURCEW(IDS_SECURITY_APPEND_DATA),   SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_WRITE_ATTRIBUTES, MAKEINTRESOURCEW(IDS_SECURITY_WRITE_ATTR),    SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_WRITE_EA,         MAKEINTRESOURCEW(IDS_SECURITY_WRITE_EX_ATTR), SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, DELETE,                MAKEINTRESOURCEW(IDS_SECURITY_DELETE),        SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, READ_CONTROL,          MAKEINTRESOURCEW(IDS_SECURITY_READ_PERM),     SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, WRITE_DAC,             MAKEINTRESOURCEW(IDS_SECURITY_CHANGE_PERM),   SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, WRITE_OWNER,           MAKEINTRESOURCEW(IDS_SECURITY_CHANGE_OWNER),  SI_ACCESS_SPECIFIC },
+};
+
+static const SI_ACCESS access_rights_directories[] =
+{
+    /* General access rights */
+    {
+        &GUID_NULL,
+        FILE_ALL_ACCESS,
+        MAKEINTRESOURCEW(IDS_SECURITY_ALL_ACCESS),
+        SI_ACCESS_GENERAL
+    },
+    {
+        &GUID_NULL,
+        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE | DELETE,
+        MAKEINTRESOURCEW(IDS_SECURITY_MODIFY),
+        SI_ACCESS_GENERAL
+    },
+    {
+        &GUID_NULL,
+        FILE_GENERIC_READ | FILE_GENERIC_EXECUTE,
+        MAKEINTRESOURCEW(IDS_SECURITY_DIR_LIST),
+        SI_ACCESS_GENERAL
+    },
+    {
+        &GUID_NULL,
+        FILE_GENERIC_READ,
+        MAKEINTRESOURCEW(IDS_SECURITY_READ),
+        SI_ACCESS_GENERAL
+    },
+    {
+        &GUID_NULL,
+        FILE_GENERIC_WRITE & ~READ_CONTROL,
+        MAKEINTRESOURCEW(IDS_SECURITY_WRITE),
+        SI_ACCESS_GENERAL
+    },
+
+    /* Advanced permissions */
+    { &GUID_NULL, FILE_ALL_ACCESS,       MAKEINTRESOURCEW(IDS_SECURITY_ALL_ACCESS),    SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_TRAVERSE,         MAKEINTRESOURCEW(IDS_SECURITY_TRAVERSE),      SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_LIST_DIRECTORY,   MAKEINTRESOURCEW(IDS_SECURITY_LIST_FOLDER),   SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_READ_ATTRIBUTES,  MAKEINTRESOURCEW(IDS_SECURITY_READ_ATTR),     SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_READ_EA,          MAKEINTRESOURCEW(IDS_SECURITY_READ_EX_ATTR),  SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_ADD_FILE,         MAKEINTRESOURCEW(IDS_SECURITY_CREATE_FILES),  SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_ADD_SUBDIRECTORY, MAKEINTRESOURCEW(IDS_SEUCRITY_CREATE_FOLDER), SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_WRITE_ATTRIBUTES, MAKEINTRESOURCEW(IDS_SECURITY_WRITE_ATTR),    SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_WRITE_EA,         MAKEINTRESOURCEW(IDS_SECURITY_WRITE_EX_ATTR), SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, FILE_DELETE_CHILD,     MAKEINTRESOURCEW(IDS_SECURITY_DELETE_CHILD),  SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, DELETE,                MAKEINTRESOURCEW(IDS_SECURITY_DELETE),        SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, READ_CONTROL,          MAKEINTRESOURCEW(IDS_SECURITY_READ_PERM),     SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, WRITE_DAC,             MAKEINTRESOURCEW(IDS_SECURITY_CHANGE_PERM),   SI_ACCESS_SPECIFIC },
+    { &GUID_NULL, WRITE_OWNER,           MAKEINTRESOURCEW(IDS_SECURITY_CHANGE_OWNER),  SI_ACCESS_SPECIFIC },
+};
+
+struct FileSecurity
+{
+    ISecurityInformation ISecurityInformation_iface;
+    LONG ref;
+    WCHAR *path;
+    BOOL directory;
+};
+
+static inline struct FileSecurity *impl_from_ISecurityInformation(ISecurityInformation *iface)
+{
+    return CONTAINING_RECORD(iface, struct FileSecurity, ISecurityInformation_iface);
+}
+
 typedef struct
 {
     IContextMenu3 IContextMenu3_iface;
@@ -62,6 +181,8 @@ typedef struct
     BOOL desktop;
 } ContextMenu;
 
+static HRESULT DoPaste(ContextMenu *This);
+
 static inline ContextMenu *impl_from_IContextMenu3(IContextMenu3 *iface)
 {
     return CONTAINING_RECORD(iface, ContextMenu, IContextMenu3_iface);
@@ -171,6 +292,30 @@ static UINT max_menu_id(HMENU hmenu, UINT offset, UINT last)
     return max_id;
 }
 
+static BOOL CheckClipboard(void)
+{
+    IDataObject *pda;
+    BOOL ret = FALSE;
+
+    if (SUCCEEDED(OleGetClipboard(&pda)))
+    {
+        STGMEDIUM medium;
+        FORMATETC formatetc;
+
+        /* Set the FORMATETC structure*/
+        InitFormatEtc(formatetc, RegisterClipboardFormatW(CFSTR_SHELLIDLISTW), TYMED_HGLOBAL);
+
+        /* Get the pidls from IDataObject */
+        if (SUCCEEDED(IDataObject_GetData(pda, &formatetc, &medium)))
+        {
+            ReleaseStgMedium(&medium);
+            ret = TRUE;
+        }
+        IDataObject_Release(pda);
+    }
+    return ret;
+}
+
 static HRESULT WINAPI ItemMenu_QueryContextMenu(
 	IContextMenu3 *iface,
 	HMENU hmenu,
@@ -181,6 +326,7 @@ static HRESULT WINAPI ItemMenu_QueryContextMenu(
 {
     ContextMenu *This = impl_from_IContextMenu3(iface);
     INT uIDMax;
+    DWORD attr = SFGAO_CANRENAME;
 
     TRACE("(%p)->(%p %d 0x%x 0x%x 0x%x )\n", This, hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
 
@@ -218,6 +364,9 @@ static HRESULT WINAPI ItemMenu_QueryContextMenu(
 
         SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);
 
+        if (This->apidl && This->cidl == 1)
+            IShellFolder_GetAttributesOf(This->parent, 1, (LPCITEMIDLIST*)This->apidl, &attr);
+
         if(uFlags & ~CMF_CANRENAME)
             RemoveMenu(hmenu, FCIDM_SHVIEW_RENAME - FCIDM_BASE + idCmdFirst, MF_BYCOMMAND);
         else
@@ -228,16 +377,14 @@ static HRESULT WINAPI ItemMenu_QueryContextMenu(
             if (!This->apidl || This->cidl > 1)
                 enable |= MFS_DISABLED;
             else
-            {
-                DWORD attr = SFGAO_CANRENAME;
-
-                IShellFolder_GetAttributesOf(This->parent, 1, (LPCITEMIDLIST*)This->apidl, &attr);
                 enable |= (attr & SFGAO_CANRENAME) ? MFS_ENABLED : MFS_DISABLED;
-            }
 
             EnableMenuItem(hmenu, FCIDM_SHVIEW_RENAME - FCIDM_BASE + idCmdFirst, enable);
         }
 
+        if ((attr & (SFGAO_FILESYSTEM|SFGAO_FOLDER)) != (SFGAO_FILESYSTEM|SFGAO_FOLDER) || !CheckClipboard())
+            RemoveMenu(hmenu, FCIDM_SHVIEW_INSERT - FCIDM_BASE + idCmdFirst, MF_BYCOMMAND);
+
         return MAKE_HRESULT(SEVERITY_SUCCESS, 0, uIDMax-idCmdFirst);
     }
     return MAKE_HRESULT(SEVERITY_SUCCESS, 0, 0);
@@ -296,11 +443,69 @@ static void DoDelete(ContextMenu *This)
     IShellFolder_QueryInterface(This->parent, &IID_ISFHelper, (void**)&helper);
     if (helper)
     {
-        ISFHelper_DeleteItems(helper, This->cidl, (LPCITEMIDLIST*)This->apidl);
+        ISFHelper_DeleteItems(helper, This->cidl, (LPCITEMIDLIST *)This->apidl, TRUE);
         ISFHelper_Release(helper);
     }
 }
 
+/**************************************************************************
+ * SetDropEffect
+ *
+ * Set the drop effect in a IDataObject object
+ */
+static void SetDropEffect(IDataObject *dataobject, DWORD value)
+{
+    FORMATETC formatetc;
+    STGMEDIUM medium;
+    DWORD *effect;
+
+    InitFormatEtc(formatetc, RegisterClipboardFormatW(CFSTR_PREFERREDDROPEFFECTW), TYMED_HGLOBAL);
+
+    medium.tymed = TYMED_HGLOBAL;
+    medium.pUnkForRelease = NULL;
+    medium.hGlobal = GlobalAlloc(GHND|GMEM_SHARE, sizeof(DWORD));
+    if (!medium.hGlobal) return;
+
+    effect = GlobalLock(medium.hGlobal);
+    if (!effect)
+    {
+        ReleaseStgMedium(&medium);
+        return;
+    }
+    *effect = value;
+    GlobalUnlock(effect);
+
+    IDataObject_SetData(dataobject, &formatetc, &medium, FALSE);
+    ReleaseStgMedium(&medium);
+}
+
+/**************************************************************************
+ * GetDropEffect
+ *
+ * Get the drop effect from a IDataObject object
+ */
+static void GetDropEffect(IDataObject *dataobject, DWORD *value)
+{
+    FORMATETC formatetc;
+    STGMEDIUM medium;
+    DWORD *effect;
+
+    *value = DROPEFFECT_NONE;
+
+    InitFormatEtc(formatetc, RegisterClipboardFormatW(CFSTR_PREFERREDDROPEFFECTW), TYMED_HGLOBAL);
+
+    if (SUCCEEDED(IDataObject_GetData(dataobject, &formatetc, &medium)))
+    {
+        effect = GlobalLock(medium.hGlobal);
+        if (effect)
+        {
+            *value = *effect;
+            GlobalUnlock(effect);
+        }
+        ReleaseStgMedium(&medium);
+    }
+}
+
 /**************************************************************************
  * DoCopyOrCut
  *
@@ -314,6 +519,7 @@ static void DoCopyOrCut(ContextMenu *This, HWND hwnd, BOOL cut)
 
     if (SUCCEEDED(IShellFolder_GetUIObjectOf(This->parent, hwnd, This->cidl, (LPCITEMIDLIST*)This->apidl, &IID_IDataObject, 0, (void**)&dataobject)))
     {
+        SetDropEffect(dataobject, cut ? DROPEFFECT_MOVE : DROPEFFECT_COPY);
         OleSetClipboard(dataobject);
         IDataObject_Release(dataobject);
     }
@@ -634,6 +840,269 @@ error:
     free(props);
 }
 
+static HRESULT WINAPI filesecurity_QueryInterface(ISecurityInformation *iface, REFIID riid, void **ppv)
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+
+    if (IsEqualGUID(&IID_IUnknown, riid))
+    {
+        TRACE("(%p)->(IID_IUnknown %p)\n", This, ppv);
+        *ppv = &This->ISecurityInformation_iface;
+    }
+    else if (IsEqualGUID(&IID_ISecurityInformation, riid))
+    {
+        TRACE("(%p)->(IID_ISecurityInformation %p)\n", This, ppv);
+        *ppv = &This->ISecurityInformation_iface;
+    }
+    else
+    {
+        *ppv = NULL;
+        WARN("Unsupported interface %s\n", debugstr_guid(riid));
+        return E_NOINTERFACE;
+    }
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+    return S_OK;
+}
+
+static ULONG WINAPI filesecurity_AddRef(ISecurityInformation *iface)
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+
+    TRACE("(%p)\n", This);
+
+    return InterlockedIncrement(&This->ref);
+}
+
+static ULONG WINAPI filesecurity_Release(ISecurityInformation *iface)
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+    ULONG ref;
+
+    TRACE("(%p)\n", This);
+
+    ref = InterlockedDecrement(&This->ref);
+    if (!ref)
+    {
+        HeapFree(GetProcessHeap(), 0, This->path);
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+
+    return ref;
+}
+
+static HRESULT WINAPI filesecurity_GetObjectInformation(ISecurityInformation *iface, SI_OBJECT_INFO *info)
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+
+    TRACE("(%p, %p)\n", This, info);
+
+    info->dwFlags = SI_ADVANCED;
+    info->hInstance = shell32_hInstance;
+    info->pszServerName = NULL;
+    info->pszObjectName = This->path;
+    info->pszPageTitle = NULL;
+    memcpy(&info->guidObjectType, &GUID_NULL, sizeof(GUID));
+
+    return S_OK;
+}
+
+static HRESULT WINAPI filesecurity_GetSecurity(ISecurityInformation *iface, SECURITY_INFORMATION info, PSECURITY_DESCRIPTOR *sd, BOOL default_sd)
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+
+    TRACE("(%p, %lu, %p, %u)\n", This, info, sd, default_sd);
+
+    if (default_sd)
+        FIXME("Returning a default sd is not implemented\n");
+
+    if (GetNamedSecurityInfoW(This->path, SE_FILE_OBJECT, info, NULL, NULL, NULL, NULL, sd) != ERROR_SUCCESS)
+        return E_FAIL;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI filesecurity_SetSecurity(ISecurityInformation *iface, SECURITY_INFORMATION info, PSECURITY_DESCRIPTOR sd)
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+    BOOL present, defaulted;
+    PSID owner, group;
+    ACL *dacl, *sacl;
+
+    TRACE("(%p, %lu, %p)\n", This, info, sd);
+
+    if (!GetSecurityDescriptorOwner(sd, &owner, &defaulted))
+        return E_FAIL;
+
+    if (!GetSecurityDescriptorGroup(sd, &group, &defaulted))
+        return E_FAIL;
+
+    if (!GetSecurityDescriptorDacl(sd, &present, &dacl, &defaulted))
+        return E_FAIL;
+    if (!present) dacl = NULL;
+
+    if (!GetSecurityDescriptorSacl(sd, &present, &sacl, &defaulted))
+        return E_FAIL;
+    if (!present) sacl = NULL;
+
+    if (SetNamedSecurityInfoW(This->path, SE_FILE_OBJECT, info, owner, group, dacl, sacl) != ERROR_SUCCESS)
+        return E_FAIL;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI filesecurity_GetAccessRights(ISecurityInformation *iface, const GUID* type, DWORD flags, SI_ACCESS **access,
+                                                   ULONG *count, ULONG *default_access )
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+
+    TRACE("(%p, %s, %lx, %p, %p, %p)\n", This, debugstr_guid(type), flags, access, count, default_access);
+
+    if (This->directory)
+    {
+        *access = (SI_ACCESS *)access_rights_directories;
+        *count = sizeof(access_rights_directories) / sizeof(access_rights_directories[0]);
+    }
+    else
+    {
+        *access = (SI_ACCESS *)access_rights_files;
+        *count = sizeof(access_rights_files) / sizeof(access_rights_files[0]);
+    }
+
+    *default_access = 0;
+    return S_OK;
+}
+
+static HRESULT WINAPI filesecurity_MapGeneric(ISecurityInformation *iface, const GUID *type, UCHAR *ace_flags, ACCESS_MASK *mask)
+{
+    static GENERIC_MAPPING file_access_map =
+    {
+        FILE_GENERIC_READ,
+        FILE_GENERIC_WRITE,
+        FILE_GENERIC_EXECUTE,
+        FILE_ALL_ACCESS
+    };
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+
+    FIXME("(%p, %s, %p, %p): semi-stub!\n", This, debugstr_guid(type), ace_flags, mask);
+
+    MapGenericMask((DWORD*)mask, &file_access_map);
+    return S_OK;
+}
+
+static HRESULT WINAPI filesecurity_GetInheritTypes(ISecurityInformation *iface, PSI_INHERIT_TYPE *types, ULONG *count)
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+
+    FIXME("(%p, %p, %p): stub!\n", This, types, count);
+
+    *types = NULL;
+    *count = 0;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI filesecurity_PropertySheetPageCallback(ISecurityInformation *iface, HWND hwnd, UINT msg, SI_PAGE_TYPE page)
+{
+    struct FileSecurity *This = impl_from_ISecurityInformation(iface);
+
+    TRACE("(%p, %p, %u, %u)\n", This, hwnd, msg, page);
+    return S_OK;
+}
+
+static const struct ISecurityInformationVtbl filesecurity_vtbl =
+{
+    /* IUnknown */
+    filesecurity_QueryInterface,
+    filesecurity_AddRef,
+    filesecurity_Release,
+    /* ISecurityInformation */
+    filesecurity_GetObjectInformation,
+    filesecurity_GetSecurity,
+    filesecurity_SetSecurity,
+    filesecurity_GetAccessRights,
+    filesecurity_MapGeneric,
+    filesecurity_GetInheritTypes,
+    filesecurity_PropertySheetPageCallback,
+};
+
+static ISecurityInformation *create_filesecurity_information(WCHAR *path, BOOL directory)
+{
+    struct FileSecurity *security;
+    DWORD len;
+
+    security = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*security));
+    if (!security) return NULL;
+
+    security->ISecurityInformation_iface.lpVtbl = &filesecurity_vtbl;
+    security->ref = 1;
+    security->directory = directory;
+
+    len = (wcslen(path) + 1) * sizeof(WCHAR);
+    security->path = HeapAlloc(GetProcessHeap(), 0, len);
+    if (!security->path) goto error;
+
+    memcpy(security->path, path, len);
+    return &security->ISecurityInformation_iface;
+
+error:
+    HeapFree(GetProcessHeap(), 0, security);
+    return NULL;
+}
+
+static void init_security_properties_pages(IDataObject *pDo, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
+{
+    ISecurityInformation *security;
+    HPROPSHEETPAGE security_page;
+    FORMATETC format;
+    STGMEDIUM stgm;
+    DWORD attrib;
+    WCHAR *path;
+    UINT len;
+
+    format.cfFormat = CF_HDROP;
+    format.ptd      = NULL;
+    format.dwAspect = DVASPECT_CONTENT;
+    format.lindex   = -1;
+    format.tymed    = TYMED_HGLOBAL;
+
+    if (FAILED(IDataObject_GetData(pDo, &format, &stgm)))
+        return;
+
+    if (!(len = DragQueryFileW((HDROP)stgm.hGlobal, 0, NULL, 0)))
+    {
+        ReleaseStgMedium(&stgm);
+        return;
+    }
+
+    if (!(path = HeapAlloc(GetProcessHeap(), 0, (len + 1) * sizeof(WCHAR))))
+    {
+        ReleaseStgMedium(&stgm);
+        return;
+    }
+
+    len = DragQueryFileW((HDROP)stgm.hGlobal, 0, path, len + 1);
+    ReleaseStgMedium(&stgm);
+    if (!len) goto done;
+
+    attrib = GetFileAttributesW(path);
+    if (attrib == INVALID_FILE_ATTRIBUTES)
+        goto done;
+
+    if (!(security = create_filesecurity_information(path, attrib & FILE_ATTRIBUTE_DIRECTORY)))
+        goto done;
+
+    security_page = CreateSecurityPage(security);
+    IUnknown_Release((IUnknown *)security);
+    if (!security_page) goto done;
+
+    lpfnAddPage(security_page, lParam);
+
+done:
+    HeapFree(GetProcessHeap(), 0, path);
+}
+
+
 #define MAX_PROP_PAGES 99
 
 static void DoOpenProperties(ContextMenu *This, HWND hwnd)
@@ -713,6 +1182,7 @@ static void DoOpenProperties(ContextMenu *This, HWND hwnd)
 	if (SUCCEEDED(ret))
 	{
             init_file_properties_pages(lpDo, Properties_AddPropSheetCallback, (LPARAM)&psh);
+            init_security_properties_pages(lpDo, Properties_AddPropSheetCallback, (LPARAM)&psh);
 
 	    hpsxa = SHCreatePropSheetExtArrayEx(HKEY_CLASSES_ROOT, wszFiletype, MAX_PROP_PAGES - psh.nPages, lpDo);
 	    if (hpsxa != NULL)
@@ -796,6 +1266,10 @@ static HRESULT WINAPI ItemMenu_InvokeCommand(
             TRACE("Verb FCIDM_SHVIEW_CUT\n");
             DoCopyOrCut(This, lpcmi->hwnd, TRUE);
             break;
+        case FCIDM_SHVIEW_INSERT:
+            TRACE("Verb FCIDM_SHVIEW_INSERT\n");
+            DoPaste(This);
+            break;
         case FCIDM_SHVIEW_PROPERTIES:
             TRACE("Verb FCIDM_SHVIEW_PROPERTIES\n");
             DoOpenProperties(This, lpcmi->hwnd);
@@ -816,6 +1290,12 @@ static HRESULT WINAPI ItemMenu_InvokeCommand(
             DoCopyOrCut(This, lpcmi->hwnd, TRUE);
         else if (strcmp(lpcmi->lpVerb,"properties")==0)
             DoOpenProperties(This, lpcmi->hwnd);
+        else if (strcmp(lpcmi->lpVerb,"cut")==0)
+            DoCopyOrCut(This, lpcmi->hwnd, TRUE);
+        else if (strcmp(lpcmi->lpVerb,"copy")==0)
+            DoCopyOrCut(This, lpcmi->hwnd, FALSE);
+        else if (strcmp(lpcmi->lpVerb,"paste")==0)
+            DoPaste(This);
         else {
             FIXME("Unhandled string verb %s\n",debugstr_a(lpcmi->lpVerb));
             return E_FAIL;
@@ -856,6 +1336,9 @@ static HRESULT WINAPI ItemMenu_GetCommandString(IContextMenu3 *iface, UINT_PTR c
         case FCIDM_SHVIEW_COPY:
             cmdW = L"copy";
             break;
+        case FCIDM_SHVIEW_INSERT:
+            cmdW = L"paste";
+            break;
         case FCIDM_SHVIEW_CREATELINK:
             cmdW = L"link";
             break;
@@ -1108,7 +1591,7 @@ static void DoNewFolder(ContextMenu *This, IShellView *view)
     }
 }
 
-static HRESULT paste_pidls(ContextMenu *This, ITEMIDLIST **pidls, UINT count)
+static HRESULT paste_pidls(ContextMenu *This, IDataObject *pda, ITEMIDLIST **pidls, UINT count)
 {
     IShellFolder *psfDesktop;
     UINT i;
@@ -1140,10 +1623,12 @@ static HRESULT paste_pidls(ContextMenu *This, ITEMIDLIST **pidls, UINT count)
             /* do the copy/move */
             if (psfhlpdst && psfhlpsrc)
             {
+                DWORD dropEffect;
+                GetDropEffect(pda, &dropEffect);
+
                 hr = ISFHelper_CopyItems(psfhlpdst, psfFrom, 1, (LPCITEMIDLIST*)&pidl_item);
-                /* FIXME handle move
-                ISFHelper_DeleteItems(psfhlpsrc, 1, &pidl_item);
-                */
+                if (SUCCEEDED(hr) && dropEffect == DROPEFFECT_MOVE)
+                    hr = ISFHelper_DeleteItems(psfhlpsrc, 1, (LPCITEMIDLIST*)&pidl_item, FALSE);
             }
             if(psfhlpdst) ISFHelper_Release(psfhlpdst);
             if(psfhlpsrc) ISFHelper_Release(psfhlpsrc);
@@ -1189,7 +1674,7 @@ static HRESULT DoPaste(ContextMenu *This)
 	      apidl = _ILCopyCidaToaPidl(&pidl, lpcida);
 	      if (apidl)
 	      {
-	        hr = paste_pidls(This, apidl, lpcida->cidl);
+                hr = paste_pidls(This, pda, apidl, lpcida->cidl);
 	        _ILFreeaPidl(apidl, lpcida->cidl);
 	        SHFree(pidl);
 	      }
@@ -1227,7 +1712,7 @@ static HRESULT DoPaste(ContextMenu *This)
 	          }
 	        }
 	        if (SUCCEEDED(hr))
-	          hr = paste_pidls(This, pidls, count);
+                  hr = paste_pidls(This, pda, pidls, count);
 	        _ILFreeaPidl(pidls, count);
 	      }
 	      else
diff --git a/dlls/shell32/shresdef.h b/dlls/shell32/shresdef.h
index af8eb46..0f3a64f 100644
--- a/dlls/shell32/shresdef.h
+++ b/dlls/shell32/shresdef.h
@@ -147,6 +147,41 @@
 #define IDM_RECYCLEBIN_RESTORE      301
 #define IDM_RECYCLEBIN_ERASE        302
 
+/* Strings for file operations */
+#define IDS_FILEOP_COPYING          333
+#define IDS_FILEOP_MOVING           334
+#define IDS_FILEOP_DELETING         335
+#define IDS_FILEOP_FROM_TO          336
+#define IDS_FILEOP_FROM             337
+#define IDS_FILEOP_PREFLIGHT        338
+
+/* Strings for security dialog - General */
+#define IDS_SECURITY_ALL_ACCESS     340
+#define IDS_SECURITY_MODIFY         341
+#define IDS_SECURITY_READ_EXEC      342
+#define IDS_SECURITY_READ           343
+#define IDS_SECURITY_WRITE          344
+#define IDS_SECURITY_DIR_LIST       345
+
+/* Strings for security dialog - Advanced */
+#define IDS_SECURITY_TRAVERSE       346
+#define IDS_SECURITY_EXECUTE        347
+#define IDS_SECURITY_LIST_FOLDER    348
+#define IDS_SECURITY_READ_DATA      349
+#define IDS_SECURITY_READ_ATTR      350
+#define IDS_SECURITY_READ_EX_ATTR   351
+#define IDS_SECURITY_CREATE_FILES   352
+#define IDS_SECURITY_WRITE_DATA     353
+#define IDS_SEUCRITY_CREATE_FOLDER  354
+#define IDS_SECURITY_APPEND_DATA    355
+#define IDS_SECURITY_WRITE_ATTR     356
+#define IDS_SECURITY_WRITE_EX_ATTR  357
+#define IDS_SECURITY_DELETE_CHILD   358
+#define IDS_SECURITY_DELETE         359
+#define IDS_SECURITY_READ_PERM      360
+#define IDS_SECURITY_CHANGE_PERM    361
+#define IDS_SECURITY_CHANGE_OWNER   362
+
 /* Note: this string is referenced from the registry*/
 #define IDS_RECYCLEBIN_FOLDER_NAME   8964
 
diff --git a/dlls/shell32/tests/shelllink.c b/dlls/shell32/tests/shelllink.c
index f13155a..c70bc9d 100644
--- a/dlls/shell32/tests/shelllink.c
+++ b/dlls/shell32/tests/shelllink.c
@@ -1119,6 +1119,21 @@ static void test_SHGetStockIconInfo(void)
     /* there is a NULL check for the struct  */
     hr = pSHGetStockIconInfo(SIID_FOLDER, SHGSI_ICONLOCATION, NULL);
     ok(hr == E_INVALIDARG, "NULL: got 0x%lx\n", hr);
+
+    for(i = 0; i < 140; i++)  /* highest on wvista, i > 140 gives E_INVALIDARG, win7 can go higher */
+    {
+        memset(buffer, 0, sizeof(buffer));
+        sii->cbSize = sizeof(SHSTOCKICONINFO);
+        hr = pSHGetStockIconInfo(i, SHGSI_ICON | SHGSI_SMALLICON, sii);
+        ok(hr == S_OK, "got 0x%lx (expected S_OK)\n", hr);
+        ok(sii->hIcon != NULL, "got NULL, expected an icon handle\n");
+        ok(sii->iIcon != 0, "got unexpected 0 for SIID %d\n", i); /* howto find out exact sii->iIcon value??? */
+        ok(sii->iSysImageIndex == -1, "got %d (expected -1)\n", sii->iSysImageIndex);
+        ok(DestroyIcon(sii->hIcon), "DestroyIcon failed\n");
+        if (winetest_debug > 1)
+            trace("%3d: got iSysImageIndex %3d, iIcon %3d and %s\n", i, sii->iSysImageIndex,
+            sii->iIcon, wine_dbgstr_w(sii->szPath));
+    }
 }
 
 static void test_SHExtractIcons(void)
diff --git a/dlls/shell32/tests/shlfileop.c b/dlls/shell32/tests/shlfileop.c
index 273b09d..ed1c25a 100644
--- a/dlls/shell32/tests/shlfileop.c
+++ b/dlls/shell32/tests/shlfileop.c
@@ -2306,13 +2306,13 @@ static void test_move(void)
         ok(!DeleteFileA("d.txt"), "Expected d.txt to not exist\n");
     }
 
-    /* FO_MOVE does not create dest directories */
+    /* FO_MOVE should create dest directories */
     shfo.pFrom = "test2.txt\0";
     shfo.pTo = "dir1\\dir2\\test2.txt\0";
     retval = SHFileOperationA(&shfo);
     if (dir_exists("dir1"))
     {
-        /* Vista and W2K8 (broken or new behavior ?) */
+        /* New behavior on Vista or later */
         ok(retval == ERROR_SUCCESS, "Expected ERROR_SUCCESS, got %ld\n", retval);
         ok(DeleteFileA("dir1\\dir2\\test2.txt"), "Expected dir1\\dir2\\test2.txt to exist\n");
         RemoveDirectoryA("dir1\\dir2");
diff --git a/dlls/shell32/tests/shlview.c b/dlls/shell32/tests/shlview.c
index 89ff2e7..2bfe543 100644
--- a/dlls/shell32/tests/shlview.c
+++ b/dlls/shell32/tests/shlview.c
@@ -1482,7 +1482,6 @@ static void test_newmenu(void)
     HRESULT hr;
 
     hr = CoCreateInstance(&CLSID_NewMenu, NULL, CLSCTX_INPROC_SERVER, &IID_IUnknown, (void **)&unk);
-    todo_wine
     ok(hr == S_OK, "Failed to create NewMenu object, hr %#lx.\n", hr);
     if (hr != S_OK)
     {
@@ -1494,6 +1493,14 @@ static void test_newmenu(void)
     ok(hr == S_OK, "Failed to get IShellExtInit, hr %#lx.\n", hr);
     IUnknown_Release(unk2);
 
+    hr = IUnknown_QueryInterface(unk, &IID_IContextMenu, (void **)&unk2);
+    ok(hr == S_OK, "Failed to get IContextMenu, hr %#lx.\n", hr);
+    IUnknown_Release(unk2);
+
+    hr = IUnknown_QueryInterface(unk, &IID_IContextMenu2, (void **)&unk2);
+    ok(hr == S_OK, "Failed to get IContextMenu2, hr %#lx.\n", hr);
+    IUnknown_Release(unk2);
+
     hr = IUnknown_QueryInterface(unk, &IID_IContextMenu3, (void **)&unk2);
     ok(hr == S_OK, "Failed to get IContextMenu3, hr %#lx.\n", hr);
     IUnknown_Release(unk2);
diff --git a/dlls/shlwapi/assoc.c b/dlls/shlwapi/assoc.c
index b2afe52..06221b6 100644
--- a/dlls/shlwapi/assoc.c
+++ b/dlls/shlwapi/assoc.c
@@ -100,6 +100,174 @@ HRESULT WINAPI AssocCreate(CLSID clsid, REFIID refiid, void **lpInterface)
   return SHCoCreateInstance( NULL, &clsid, NULL, refiid, lpInterface );
 }
 
+
+struct AssocPerceivedInfo
+{
+    PCWSTR Type;
+    PERCEIVED Perceived;
+    INT FlagHardcoded;
+    INT FlagSoftcoded;
+    PCWSTR Extensions;
+};
+
+static const WCHAR unspecified_exts[] = {
+    '.','l','n','k',0,
+    '.','s','e','a','r','c','h','-','m','s',0,
+    0
+};
+
+static const WCHAR image_exts[] = {
+    '.','b','m','p',0,
+    '.','d','i','b',0,
+    '.','e','m','f',0,
+    '.','g','i','f',0,
+    '.','i','c','o',0,
+    '.','j','f','i','f',0,
+    '.','j','p','e',0,
+    '.','j','p','e','g',0,
+    '.','j','p','g',0,
+    '.','p','n','g',0,
+    '.','r','l','e',0,
+    '.','t','i','f',0,
+    '.','t','i','f','f',0,
+    '.','w','m','f',0,
+    0
+};
+
+static const WCHAR audio_exts[] = {
+    '.','a','i','f',0,
+    '.','a','i','f','c',0,
+    '.','a','i','f','f',0,
+    '.','a','u',0,
+    '.','m','3','u',0,
+    '.','m','i','d',0,
+    '.','m','i','d','i',0,
+#if _WIN32_WINNT > 0x602
+    '.','m','p','2',0,
+#endif
+    '.','m','p','3',0,
+    '.','r','m','i',0,
+    '.','s','n','d',0,
+    '.','w','a','v',0,
+    '.','w','a','x',0,
+    '.','w','m','a',0,
+    0
+};
+
+static const WCHAR video_exts[] = {
+    '.','a','s','f',0,
+    '.','a','s','x',0,
+    '.','a','v','i',0,
+    '.','d','v','r','-','m','s',0,
+    '.','I','V','F',0,
+    '.','m','1','v',0,
+#if _WIN32_WINNT <= 0x602
+    '.','m','p','2',0,
+#endif
+    '.','m','p','2','v',0,
+    '.','m','p','a',0,
+    '.','m','p','e',0,
+    '.','m','p','e','g',0,
+    '.','m','p','g',0,
+    '.','m','p','v','2',0,
+    '.','w','m',0,
+    '.','w','m','v',0,
+    '.','w','m','x',0,
+    '.','w','v','x',0,
+    0
+};
+
+static const WCHAR compressed_exts[] = {
+    '.','z','i','p',0,
+    0
+};
+
+static const WCHAR document_exts[] = {
+#if _WIN32_WINNT >= 0x600
+    '.','h','t','m',0,
+    '.','h','t','m','l',0,
+#endif
+    '.','m','h','t',0,
+    0
+};
+
+static const WCHAR system_exts[] = {
+    '.','c','p','l',0,
+    0
+};
+
+static const WCHAR application_exts[] = {
+    '.','b','a','s',0,
+    '.','b','a','t',0,
+    '.','c','m','d',0,
+    '.','c','o','m',0,
+    '.','e','x','e',0,
+    '.','h','t','a',0,
+    '.','m','s','i',0,
+    '.','p','i','f',0,
+    '.','r','e','g',0,
+    '.','s','c','r',0,
+    '.','v','b',0,
+    0
+};
+
+const WCHAR type_text[] = {'t','e','x','t',0};
+const WCHAR type_image[] = {'i','m','a','g','e',0};
+const WCHAR type_audio[] = {'a','u','d','i','o',0};
+const WCHAR type_video[] = {'v','i','d','e','o',0};
+const WCHAR type_compressed[] = {'c','o','m','p','r','e','s','s','e','d',0};
+const WCHAR type_document[] = {'d','o','c','u','m','e','n','t',0};
+const WCHAR type_system[] = {'s','y','s','t','e','m',0};
+const WCHAR type_application[] = {'a','p','p','l','i','c','a','t','i','o','n',0};
+
+#define HARDCODED_NATIVE_WMSDK      (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_WMSDK)
+#define HARDCODED_NATIVE_GDIPLUS    (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_GDIPLUS)
+#define HARDCODED_NATIVE_ZIPFLDR    (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_ZIPFOLDER)
+#define SOFTCODED_NATIVESUPPORT     (PERCEIVEDFLAG_SOFTCODED | PERCEIVEDFLAG_NATIVESUPPORT)
+
+static const struct AssocPerceivedInfo known_types[] = {
+    { NULL,             PERCEIVED_TYPE_UNSPECIFIED, PERCEIVEDFLAG_HARDCODED,  PERCEIVEDFLAG_SOFTCODED, unspecified_exts },
+    { type_text,        PERCEIVED_TYPE_TEXT,        PERCEIVEDFLAG_HARDCODED,  SOFTCODED_NATIVESUPPORT, NULL },
+    { type_image,       PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS, PERCEIVEDFLAG_SOFTCODED, image_exts },
+    { type_audio,       PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,   PERCEIVEDFLAG_SOFTCODED, audio_exts },
+    { type_video,       PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,   PERCEIVEDFLAG_SOFTCODED, video_exts },
+    { type_compressed,  PERCEIVED_TYPE_COMPRESSED,  HARDCODED_NATIVE_ZIPFLDR, PERCEIVEDFLAG_SOFTCODED, compressed_exts },
+    { type_document,    PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_HARDCODED,  PERCEIVEDFLAG_SOFTCODED, document_exts },
+    { type_system,      PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_HARDCODED,  PERCEIVEDFLAG_SOFTCODED, system_exts },
+    { type_application, PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,  PERCEIVEDFLAG_SOFTCODED, application_exts },
+};
+
+static const struct AssocPerceivedInfo* AssocFindByBuiltinExtension(LPCWSTR pszExt)
+{
+    UINT n;
+    for (n = 0; n < sizeof(known_types) / sizeof(known_types[0]); ++n)
+    {
+        PCWSTR Ext = known_types[n].Extensions;
+        while (Ext && *Ext)
+        {
+            if (!StrCmpIW(Ext, pszExt))
+                return &known_types[n];
+            Ext += (lstrlenW(Ext) + 1);
+        }
+    }
+    return NULL;
+}
+
+static const struct AssocPerceivedInfo* AssocFindByType(LPCWSTR pszType)
+{
+    UINT n;
+    for (n = 0; n < sizeof(known_types) / sizeof(known_types[0]); ++n)
+    {
+        if (known_types[n].Type)
+        {
+            if (!StrCmpIW(known_types[n].Type, pszType))
+                return &known_types[n];
+        }
+    }
+    return NULL;
+}
+
+
 /*************************************************************************
  * AssocGetPerceivedType  [SHLWAPI.@]
  *
@@ -121,19 +289,64 @@ HRESULT WINAPI AssocCreate(CLSID clsid, REFIID refiid, void **lpInterface)
  *  lppszType is optional and it can be NULL.
  *  if lpType or lpFlag are NULL, the function will crash.
  *  if lpszExt is NULL, an error is returned.
- *
- * BUGS
- *   Unimplemented.
  */
 HRESULT WINAPI AssocGetPerceivedType(LPCWSTR lpszExt, PERCEIVED *lpType,
                                      INT *lpFlag, LPWSTR *lppszType)
 {
-  FIXME("(%s, %p, %p, %p) not supported\n", debugstr_w(lpszExt), lpType, lpFlag, lppszType);
+    static const WCHAR PerceivedTypeKey[] = {'P','e','r','c','e','i','v','e','d','T','y','p','e',0};
+    static const WCHAR SystemFileAssociationsKey[] = {'S','y','s','t','e','m','F','i','l','e',
+        'A','s','s','o','c','i','a','t','i','o','n','s','\\','%','s',0};
+    const struct AssocPerceivedInfo *Info;
 
-  if (lpszExt == NULL)
-    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
+    TRACE("(%s,%p,%p,%p)\n", debugstr_w(lpszExt), lpType, lpFlag, lppszType);
+
+    Info = AssocFindByBuiltinExtension(lpszExt);
+    if (Info)
+    {
+        *lpType = Info->Perceived;
+        *lpFlag = Info->FlagHardcoded;
+    }
+    else
+    {
+        WCHAR Buffer[100] = { 0 };
+        DWORD Size = sizeof(Buffer);
+        if (RegGetValueW(HKEY_CLASSES_ROOT, lpszExt, PerceivedTypeKey,
+                         RRF_RT_REG_SZ, NULL, Buffer, &Size) == ERROR_SUCCESS)
+        {
+            Info = AssocFindByType(Buffer);
+        }
+        if (!Info)
+        {
+            WCHAR KeyName[MAX_PATH] = { 0 };
+            swprintf(KeyName, MAX_PATH, SystemFileAssociationsKey, lpszExt);
+            Size = sizeof(Buffer);
+            if (RegGetValueW(HKEY_CLASSES_ROOT, KeyName, PerceivedTypeKey,
+                             RRF_RT_REG_SZ, NULL, Buffer, &Size) == ERROR_SUCCESS)
+            {
+                Info = AssocFindByType(Buffer);
+            }
+        }
+        if (Info)
+        {
+            *lpType = Info->Perceived;
+            *lpFlag = Info->FlagSoftcoded;
+        }
+    }
 
-  return E_NOTIMPL;
+    if (Info)
+    {
+        if (lppszType && Info->Type)
+        {
+            return SHStrDupW(Info->Type, lppszType);
+        }
+        return Info->Type ? S_OK : E_FAIL;
+    }
+    else
+    {
+        *lpType = PERCEIVED_TYPE_UNSPECIFIED;
+        *lpFlag = 0;
+    }
+    return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
 }
 
 /*************************************************************************
diff --git a/dlls/shlwapi/tests/assoc.c b/dlls/shlwapi/tests/assoc.c
index 93e0d14..6c92e07 100644
--- a/dlls/shlwapi/tests/assoc.c
+++ b/dlls/shlwapi/tests/assoc.c
@@ -23,12 +23,13 @@
 #include "shlwapi.h"
 #include "shlguid.h"
 
-#define expect(expected, got) ok ( expected == got, "Expected %ld, got %ld\n", expected, got)
-#define expect_hr(expected, got) ok ( expected == got, "Expected %08lx, got %08lx\n", expected, got)
+#define expect(expected, got) ok( (expected) == (got), "Expected %ld, got %ld\n", (expected), (got))
+#define expect_hr(expected, got) ok( (expected) == (got), "Expected %08lx, got %08lx\n", (expected), (got))
 
 static HRESULT (WINAPI *pAssocQueryStringA)(ASSOCF,ASSOCSTR,LPCSTR,LPCSTR,LPSTR,LPDWORD) = NULL;
 static HRESULT (WINAPI *pAssocQueryStringW)(ASSOCF,ASSOCSTR,LPCWSTR,LPCWSTR,LPWSTR,LPDWORD) = NULL;
 static HRESULT (WINAPI *pAssocCreate)(CLSID, REFIID, void **) = NULL;
+static HRESULT (WINAPI *pAssocGetPerceivedType)(LPCWSTR, PERCEIVED *, INT *, LPWSTR *) = NULL;
 
 /* Should every version of Windows with IE have .html association? */
 
@@ -301,6 +302,283 @@ static void test_assoc_create(void)
     }
 }
 
+/* Based on http://www.geoffchappell.com/studies/windows/shell/shlwapi/api/assocapi/getperceivedtype.htm */
+struct assoc_test_struct
+{
+    PCSTR     extension;
+    PERCEIVED perceived;
+    INT       flags;
+    PCSTR     type;
+    DWORD     minversion;
+    HRESULT   hr;
+};
+
+#define HARDCODED_NATIVE_WMSDK      (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_WMSDK)
+#define HARDCODED_NATIVE_GDIPLUS    (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_GDIPLUS)
+#define HARDCODED_NATIVE_ZIPFLDR    (PERCEIVEDFLAG_HARDCODED | PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_ZIPFOLDER)
+#define SOFTCODED_NATIVESUPPORT     (PERCEIVEDFLAG_SOFTCODED | PERCEIVEDFLAG_NATIVESUPPORT)
+
+static const struct assoc_test_struct assoc_perceived_types[] =
+{
+    /* builtins */
+    { ".aif",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".aifc",          PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".aiff",          PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".asf",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".asx",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".au",            PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".avi",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".bas",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".bat",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".bmp",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".cmd",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".com",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".cpl",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_HARDCODED,    "system",       0x600 },
+    { ".dib",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".dvr-ms",        PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".emf",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".exe",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".gif",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".hta",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    /* htm & html are PERCEIVED_TYPE_TEXT, PERCEIVEDFLAG_NATIVESUPPORT | PERCEIVEDFLAG_SOFTCODED in w2k3 */
+    { ".htm",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_HARDCODED,    "document",     0x600 },
+    { ".html",          PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_HARDCODED,    "document",     0x600 },
+    { ".ico",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".IVF",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".jfif",          PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".jpe",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".jpeg",          PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".jpg",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".lnk",           PERCEIVED_TYPE_UNSPECIFIED, PERCEIVEDFLAG_HARDCODED,    NULL,           0x600, E_FAIL },
+    { ".m1v",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".m3u",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".mht",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_HARDCODED,    "document",     0x600 },
+    { ".mid",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".midi",          PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".msi",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    /* below win8 this is defined to be video */
+    { ".mp2",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio",        0x602 },
+    { ".mp2v",          PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mp3",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".mpa",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mpe",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mpeg",          PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mpg",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".mpv2",          PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".pif",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".png",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".reg",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".rle",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".rmi",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".scr",           PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".search-ms",     PERCEIVED_TYPE_UNSPECIFIED, PERCEIVEDFLAG_HARDCODED,    NULL,           0x600, E_FAIL },
+    { ".snd",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".tif",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".tiff",          PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".vb",            PERCEIVED_TYPE_APPLICATION, PERCEIVEDFLAG_HARDCODED,    "application" },
+    { ".wav",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".wax",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".wm",            PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".wma",           PERCEIVED_TYPE_AUDIO,       HARDCODED_NATIVE_WMSDK,     "audio" },
+    { ".wmf",           PERCEIVED_TYPE_IMAGE,       HARDCODED_NATIVE_GDIPLUS,   "image" },
+    { ".wmv",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".wmx",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".wvx",           PERCEIVED_TYPE_VIDEO,       HARDCODED_NATIVE_WMSDK,     "video" },
+    { ".zip",           PERCEIVED_TYPE_COMPRESSED,  HARDCODED_NATIVE_ZIPFLDR,   "compressed" },
+    /* found in the registry under HKEY_CLASSES_ROOT on a new Win7 VM */
+    { ".386",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".3g2",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".3gp",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".3gp2",          PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".3gpp",          PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".AAC",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".ADT",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".ADTS",          PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".asm",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".asmx",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".aspx",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".c",             PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".cab",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed",   0x600 },
+    { ".chk",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".cpp",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".css",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".cxx",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".def",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".diz",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".docx",          PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x601 },
+    { ".drv",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system",       0x600 },
+    { ".gz",            PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".h",             PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".hpp",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".hxx",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".inc",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".ini",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text",         0x600 },
+    { ".java",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".local",         PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".M2T",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".M2TS",          PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".M2V",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".m4a",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".m4b",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".m4p",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".m4v",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".manifest",      PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".MOD",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".mov",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".mp4",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".mp4v",          PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".MTS",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".nvr",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".ocx",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".odt",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x601 },
+    { ".php3",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".pl",            PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".plg",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".ps1xml",        PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "Text" },
+    { ".rtf",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".sed",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".shtml",         PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".sql",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".sys",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system",       0x600 },
+    { ".tar",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".text",          PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".tgz",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".TS",            PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".tsv",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".TTS",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".txt",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".vob",           PERCEIVED_TYPE_VIDEO,       PERCEIVEDFLAG_SOFTCODED,    "video",        0x601 },
+    { ".vxd",           PERCEIVED_TYPE_SYSTEM,      PERCEIVEDFLAG_SOFTCODED,    "system" },
+    { ".wdp",           PERCEIVED_TYPE_IMAGE,       PERCEIVEDFLAG_SOFTCODED,    "image" },
+    { ".wmz",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".wpl",           PERCEIVED_TYPE_AUDIO,       PERCEIVEDFLAG_SOFTCODED,    "audio",        0x601 },
+    { ".wsz",           PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    { ".x",             PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text" },
+    { ".xml",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text",         0x601 },
+    { ".xsl",           PERCEIVED_TYPE_TEXT,        SOFTCODED_NATIVESUPPORT,    "text",         0x601 },
+    { ".z",             PERCEIVED_TYPE_COMPRESSED,  PERCEIVEDFLAG_SOFTCODED,    "compressed" },
+    /* found in the registry under HKEY_CLASSES_ROOT\PerceivedType */
+    { ".doc",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".dot",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".mhtml",         PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".pot",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".ppt",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".rtf",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".wri",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".xls",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+    { ".xlt",           PERCEIVED_TYPE_DOCUMENT,    PERCEIVEDFLAG_SOFTCODED,    "document",     0x600 },
+
+};
+
+static void test_assoc_one(const struct assoc_test_struct* test)
+{
+    LPWSTR extension, type_expected, type_returned;
+    PERCEIVED perceived;
+    HRESULT hr;
+    INT flags;
+
+    /* if SHStrDupA receives a nullptr as input, it will null the output */
+    SHStrDupA(test->extension, &extension);
+    SHStrDupA(test->type, &type_expected);
+
+    perceived = 0xdeadbeef;
+    flags = 0xdeadbeef;
+
+    hr = pAssocGetPerceivedType(extension, &perceived, &flags, NULL);
+    expect_hr(type_expected ? S_OK : test->hr, hr);
+    ok(perceived == test->perceived, "%s: got perceived 0x%x, expected 0x%x\n",
+       test->extension, perceived, test->perceived);
+    ok(flags == test->flags, "%s: got flags 0x%x, expected 0x%x\n",
+       test->extension, flags, test->flags);
+
+    type_returned = (void *)0xdeadbeef;
+    perceived = 0xdeadbeef;
+    flags = 0xdeadbeef;
+
+    hr = pAssocGetPerceivedType(extension, &perceived, &flags, &type_returned);
+    expect_hr(type_expected ? S_OK : test->hr, hr);
+    ok(perceived == test->perceived, "%s: got perceived 0x%x, expected 0x%x\n",
+       test->extension, perceived, test->perceived);
+    ok(flags == test->flags, "%s: got flags 0x%x, expected 0x%x\n",
+       test->extension, flags, test->flags);
+
+    if (!type_expected)
+    {
+        ok(type_returned == (void *)0xdeadbeef || broken(type_returned == NULL) /* Win 8 */,
+           "%s: got type %p, expected 0xdeadbeef\n", test->extension, type_returned);
+    }
+    else if (type_returned == (void *)0xdeadbeef)
+    {
+        ok(type_returned != (void *)0xdeadbeef, "%s: got type %p, expected '%s'\n",
+           test->extension, type_returned, test->type);
+    }
+    else
+    {
+        ok(StrCmpIW(type_expected, type_returned) == 0, "%s: got type %s, expected '%s'\n",
+           test->extension, wine_dbgstr_w(type_returned), test->type);
+    }
+
+    CoTaskMemFree(type_returned);
+    CoTaskMemFree(extension);
+    CoTaskMemFree(type_expected);
+}
+
+static void test_assoc_perceived(void)
+{
+    static const struct assoc_test_struct should_not_exist =
+        { ".should_not_exist", PERCEIVED_TYPE_UNSPECIFIED, PERCEIVEDFLAG_UNDEFINED, NULL, 0, 0x80070002 };
+    static const struct assoc_test_struct htm[] =
+    {
+        { ".htm",  PERCEIVED_TYPE_TEXT, SOFTCODED_NATIVESUPPORT, "text", 0x600 },
+        { ".html", PERCEIVED_TYPE_TEXT, SOFTCODED_NATIVESUPPORT, "text", 0x600 },
+    };
+    static const struct assoc_test_struct mp2 =
+        { ".mp2", PERCEIVED_TYPE_VIDEO, HARDCODED_NATIVE_WMSDK, "video" };
+
+    OSVERSIONINFOEXW osvi;
+    DWORD version;
+    size_t i;
+
+    if (!pAssocGetPerceivedType)
+    {
+        win_skip("AssocGetPerceivedType() is missing\n");
+        return;
+    }
+
+    memset(&osvi, 0, sizeof(osvi));
+    osvi.dwOSVersionInfoSize = sizeof(osvi);
+    GetVersionExW((LPOSVERSIONINFOW)&osvi);
+    version = (osvi.dwMajorVersion << 8) | osvi.dwMinorVersion;
+
+    /* invalid entry results in HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) */
+    test_assoc_one(&should_not_exist);
+
+    for (i = 0; i < sizeof(assoc_perceived_types) / sizeof(assoc_perceived_types[0]); ++i)
+    {
+        if (assoc_perceived_types[i].minversion && assoc_perceived_types[i].minversion > version)
+            continue;
+        if (!(assoc_perceived_types[i].flags & PERCEIVEDFLAG_HARDCODED))
+            todo_wine test_assoc_one(&assoc_perceived_types[i]);
+        else
+            test_assoc_one(&assoc_perceived_types[i]);
+    }
+
+    /* below Vista */
+    if (version < 0x600)
+    {
+        todo_wine
+        test_assoc_one(&htm[0]);
+        todo_wine
+        test_assoc_one(&htm[1]);
+    }
+
+    /* below Win8 */
+    if (version < 0x602)
+    {
+        test_assoc_one(&mp2);
+    }
+}
+
 START_TEST(assoc)
 {
     HMODULE hshlwapi;
@@ -308,9 +586,11 @@ START_TEST(assoc)
     pAssocQueryStringA = (void*)GetProcAddress(hshlwapi, "AssocQueryStringA");
     pAssocQueryStringW = (void*)GetProcAddress(hshlwapi, "AssocQueryStringW");
     pAssocCreate       = (void*)GetProcAddress(hshlwapi, "AssocCreate");
+    pAssocGetPerceivedType = (void*)GetProcAddress(hshlwapi, "AssocGetPerceivedType");
 
     test_getstring_bad();
     test_getstring_basic();
     test_getstring_no_extra();
     test_assoc_create();
+    test_assoc_perceived();
 }
diff --git a/dlls/shlwapi/tests/url.c b/dlls/shlwapi/tests/url.c
index 160f769..d8b063b 100644
--- a/dlls/shlwapi/tests/url.c
+++ b/dlls/shlwapi/tests/url.c
@@ -179,7 +179,19 @@ static const TEST_URL_CANONICALIZE TEST_CANONICALIZE[] = {
     {"///A/../B", URL_WININET_COMPATIBILITY, "///B", FALSE},
     {"A", 0, "A", FALSE},
     {"../A", 0, "../A", FALSE},
+    {"./A", 0, "A", FALSE},
+    {"./A/./B", 0, "A/B", FALSE},
+    {"./A", URL_DONT_SIMPLIFY, "./A", FALSE},
+    {"A/./B", 0, "A/B", TRUE},
     {"A/../B", 0, "B", TRUE},
+    {"A/../B/./../C", 0, "C", TRUE},
+    {"A/../B/./../C", URL_DONT_SIMPLIFY, "A/../B/./../C", FALSE},
+    {".\\A", 0, ".\\A", FALSE},
+    {"A\\.\\B", 0, "A\\.\\B", FALSE},
+    {".", 0, "/", TRUE},
+    {"./A", 0, "A", TRUE},
+    {"A/./B", 0, "A/B", TRUE},
+    {"/:test\\", 0, "/:test\\", TRUE},
     {"/uri-res/N2R?urn:sha1:B3K", URL_DONT_ESCAPE_EXTRA_INFO | URL_WININET_COMPATIBILITY /*0x82000000*/, "/uri-res/N2R?urn:sha1:B3K", FALSE} /*LimeWire online installer calls this*/,
     {"http:www.winehq.org/dir/../index.html", 0, "http:www.winehq.org/index.html"},
     {"http://localhost/test.html", URL_FILE_USE_PATHURL, "http://localhost/test.html"},
@@ -315,6 +327,7 @@ typedef struct _TEST_URL_COMBINE {
     const char *url2;
     DWORD flags;
     const char *expecturl;
+    BOOL todo;
 } TEST_URL_COMBINE;
 
 static const TEST_URL_COMBINE TEST_COMBINE[] = {
@@ -336,6 +349,8 @@ static const TEST_URL_COMBINE TEST_COMBINE[] = {
     {"http://www.winehq.org/test14#aaa/bbb#ccc", "#", 0, "http://www.winehq.org/test14#"},
     {"http://www.winehq.org/tests/?query=x/y/z", "tests15", 0, "http://www.winehq.org/tests/tests15"},
     {"http://www.winehq.org/tests/?query=x/y/z#example", "tests16", 0, "http://www.winehq.org/tests/tests16"},
+    {"http://www.winehq.org/tests17", ".", 0, "http://www.winehq.org/"},
+    {"http://www.winehq.org/tests18/test", ".", 0, "http://www.winehq.org/tests18/"},
     {"file:///C:\\dir\\file.txt", "test.txt", 0, "file:///C:/dir/test.txt"},
     {"file:///C:\\dir\\file.txt#hash\\hash", "test.txt", 0, "file:///C:/dir/file.txt#hash/test.txt"},
     {"file:///C:\\dir\\file.html#hash\\hash", "test.html", 0, "file:///C:/dir/test.html"},
@@ -1255,7 +1270,7 @@ static void test_UrlCanonicalizeW(void)
 
 /* ########################### */
 
-static void check_url_combine(const char *szUrl1, const char *szUrl2, DWORD dwFlags, const char *szExpectUrl)
+static void check_url_combine(const char *szUrl1, const char *szUrl2, DWORD dwFlags, const char *szExpectUrl, BOOL todo)
 {
     HRESULT hr;
     CHAR szReturnUrl[INTERNET_MAX_URL_LENGTH];
@@ -1275,17 +1290,28 @@ static void check_url_combine(const char *szUrl1, const char *szUrl2, DWORD dwFl
     dwSize = 0;
     hr = UrlCombineA(szUrl1, szUrl2, NULL, &dwSize, dwFlags);
     ok(hr == E_POINTER, "Checking length of string, return was 0x%08lx, expected 0x%08lx\n", hr, E_POINTER);
-    ok(dwSize == dwExpectLen+1, "Got length %ld, expected %ld\n", dwSize, dwExpectLen+1);
+    ok(todo || dwSize == dwExpectLen+1, "Got length %ld, expected %ld\n", dwSize, dwExpectLen+1);
 
     dwSize--;
     hr = UrlCombineA(szUrl1, szUrl2, szReturnUrl, &dwSize, dwFlags);
     ok(hr == E_POINTER, "UrlCombineA returned 0x%08lx, expected 0x%08lx\n", hr, E_POINTER);
-    ok(dwSize == dwExpectLen+1, "Got length %ld, expected %ld\n", dwSize, dwExpectLen+1);
+    ok(todo || dwSize == dwExpectLen+1, "Got length %ld, expected %ld\n", dwSize, dwExpectLen+1);
 
     hr = UrlCombineA(szUrl1, szUrl2, szReturnUrl, &dwSize, dwFlags);
     ok(hr == S_OK, "Got unexpected hr %#lx.\n", hr);
     ok(dwSize == dwExpectLen, "Got length %ld, expected %ld\n", dwSize, dwExpectLen);
-    ok(!strcmp(szReturnUrl, szExpectUrl), "Expected %s, got %s.\n", szExpectUrl, szReturnUrl);
+
+    if (todo)
+    {
+        todo_wine ok(dwSize == dwExpectLen && (FAILED(hr) || strcmp(szReturnUrl, szExpectUrl)==0),
+                "Expected %s (len=%ld), but got %s (len=%ld)\n", szExpectUrl, dwExpectLen, SUCCEEDED(hr) ? szReturnUrl : "(null)", dwSize);
+    }
+    else
+    {
+        ok(dwSize == dwExpectLen, "Got length %ld, expected %ld\n", dwSize, dwExpectLen);
+        if (SUCCEEDED(hr))
+            ok(strcmp(szReturnUrl, szExpectUrl)==0, "Expected %s, but got %s\n", szExpectUrl, szReturnUrl);
+     }
 
     dwSize = 0;
     hr = UrlCombineW(wszUrl1, wszUrl2, NULL, &dwSize, dwFlags);
@@ -1316,7 +1342,7 @@ static void test_UrlCombine(void)
 {
     unsigned int i;
     for (i = 0; i < ARRAY_SIZE(TEST_COMBINE); i++) {
-        check_url_combine(TEST_COMBINE[i].url1, TEST_COMBINE[i].url2, TEST_COMBINE[i].flags, TEST_COMBINE[i].expecturl);
+        check_url_combine(TEST_COMBINE[i].url1, TEST_COMBINE[i].url2, TEST_COMBINE[i].flags, TEST_COMBINE[i].expecturl, TEST_COMBINE[i].todo);
     }
 }
 
diff --git a/dlls/stdole32.tlb/Makefile.in b/dlls/stdole32.tlb/Makefile.in
index 8ae404a..f83892d 100644
--- a/dlls/stdole32.tlb/Makefile.in
+++ b/dlls/stdole32.tlb/Makefile.in
@@ -1,4 +1,5 @@
 MODULE    = stdole32.tlb
+EXTRAIDLFLAGS = --oldtlb
 
 EXTRADLLFLAGS = -Wb,--data-only
 
diff --git a/dlls/stdole32.tlb/std_ole_v1.idl b/dlls/stdole32.tlb/std_ole_v1.idl
index 359a810..de053e9 100644
--- a/dlls/stdole32.tlb/std_ole_v1.idl
+++ b/dlls/stdole32.tlb/std_ole_v1.idl
@@ -20,121 +20,4 @@
 
 #pragma makedep regtypelib
 
-[
-  uuid(00020430-0000-0000-C000-000000000046),
-  restricted,
-  version(1.0),
-  helpstring("OLE Automation")
-]
-library stdole
-{
-	/* typedefs aren't stored in the type library.
-           These type names are known by the type compiler so it
-           doesn't really matter what we define them as. */
-
-    typedef void *VARIANT;
-    typedef wchar_t *BSTR;
-    typedef unsigned long SCODE;
-    typedef unsigned long HRESULT;
-    
-    typedef struct GUID {
-        unsigned long  Data1;
-        unsigned short Data2;
-        unsigned short Data3;
-        unsigned char  Data4[ 8 ];
-    } GUID;
-
-    typedef struct DISPPARAMS {
-        VARIANT *rgvarg;
-        long *rgdispidNamedArgs;
-        unsigned int cArgs;
-        unsigned int cNamedArgs;
-    } DISPPARAMS;
-
-    typedef struct EXCEPINFO {
-        unsigned short wCode;
-        unsigned short wReserved;
-        BSTR  bstrSource;
-        BSTR  bstrDescription;
-        BSTR  bstrHelpFile;
-        unsigned long dwHelpContext;
-        void *pvReserved;
-        void *pfnDeferredFillIn;
-        SCODE scode;
-    } EXCEPINFO;
-
-    [
-        odl,
-        uuid(00000000-0000-0000-C000-000000000046)
-    ]
-    interface IUnknown
-    {
-        [restricted]
-        HRESULT QueryInterface(
-                               [in] GUID *riid,
-                               [out] void **ppvObj);
-
-        [restricted]
-        unsigned long AddRef();
-
-        [restricted]
-        unsigned long Release();
-    }
-
-    [
-        odl,
-        uuid(00020400-0000-0000-C000-000000000046)
-    ]
-    interface IDispatch : IUnknown
-    {
-        [restricted]
-        HRESULT GetTypeInfoCount(
-                                 [out] unsigned int *pctinfo);
-
-        [restricted]
-        HRESULT GetTypeInfo(
-                            [in] unsigned int itinfo,
-                            [in] unsigned long lcid,
-                            [out] void **pptinfo);
-
-        [restricted]
-        HRESULT GetIDsOfNames(
-                              [in] GUID *riid,
-                              [in] char **rgszNames,
-                              [in] unsigned int cNames,
-                              [in] unsigned long lcid,
-                              [out] long *rgdispid);
-
-        [restricted]
-        HRESULT Invoke(
-                       [in] long dispidMember,
-                       [in] GUID *riid,
-                       [in] unsigned long lcid,
-                       [in] unsigned short wFlags,
-                       [in] DISPPARAMS *pdispparams,
-                       [out] VARIANT *pvarResult,
-                       [out] EXCEPINFO *pexcepinfo,
-                       [out] unsigned int *puArgErr);
-
-    }
-
-    [
-        odl,
-        uuid(00020404-0000-0000-C000-000000000046)
-    ]
-    interface IEnumVARIANT : IUnknown
-    {
-        HRESULT Next(
-                     [in] unsigned long celt,
-                     [in] VARIANT *rgvar,
-                     [out] unsigned long *pceltFetched);
-
-        HRESULT Skip(
-                     [in] unsigned long celt);
-
-        HRESULT Reset();
-
-        HRESULT Clone(
-                      [out] IEnumVARIANT **ppenum);
-    }
-};
+#include "stdole32.idl"
diff --git a/dlls/user32/cursoricon.c b/dlls/user32/cursoricon.c
index 0bfaca1..59642fa 100644
--- a/dlls/user32/cursoricon.c
+++ b/dlls/user32/cursoricon.c
@@ -1376,7 +1376,12 @@ static HICON CURSORICON_Load(HINSTANCE hInstance, LPCWSTR name,
           hInstance, debugstr_w(name), width, height, depth, fCursor, loadflags);
 
     if ( loadflags & LR_LOADFROMFILE )    /* Load from file */
-        return CURSORICON_LoadFromFile( name, width, height, depth, fCursor, loadflags );
+    {
+        if (IS_INTRESOURCE(name) && GetProcessVersion(0) < 0x40000)
+            WARN("Windows 3.1 app set LR_LOADFROMFILE without a name, fallback to loading from resource\n");
+        else
+            return CURSORICON_LoadFromFile( name, width, height, depth, fCursor, loadflags );
+    }
 
     if (!hInstance) hInstance = user32_module;  /* Load OEM cursor/icon */
 
diff --git a/dlls/user32/defdlg.c b/dlls/user32/defdlg.c
index 88b64ee..eab6bc9 100644
--- a/dlls/user32/defdlg.c
+++ b/dlls/user32/defdlg.c
@@ -180,6 +180,25 @@ static BOOL DEFDLG_SetDefButton( HWND hwndDlg, DIALOGINFO *dlgInfo, HWND hwndNew
 }
 
 
+static HWND root_dialog(HWND hwnd)
+{
+    while ((GetWindowLongA(hwnd, GWL_EXSTYLE) & WS_EX_CONTROLPARENT) &&
+           (GetWindowLongA(hwnd, GWL_STYLE) & (WS_CHILD|WS_POPUP)) == WS_CHILD)
+    {
+        HWND parent = GetParent(hwnd);
+
+        if (!DIALOG_get_info(parent, FALSE))
+            break;
+
+        hwnd = parent;
+
+        if (!(GetWindowLongA(hwnd, GWL_STYLE) & DS_CONTROL))
+            break;
+    }
+
+    return hwnd;
+}
+
 /***********************************************************************
  *           DEFDLG_Proc
  *
@@ -231,11 +250,17 @@ static LRESULT DEFDLG_Proc( HWND hwnd, UINT msg, WPARAM wParam,
             return 0;
 
         case DM_SETDEFID:
+            hwnd = root_dialog( hwnd );
+            dlgInfo = DIALOG_get_info( hwnd, FALSE );
+
             if (dlgInfo && !(dlgInfo->flags & DF_END))
                 DEFDLG_SetDefId( hwnd, dlgInfo, wParam );
             return 1;
 
         case DM_GETDEFID:
+            hwnd = root_dialog( hwnd );
+            dlgInfo = DIALOG_get_info( hwnd, FALSE );
+
             if (dlgInfo && !(dlgInfo->flags & DF_END))
             {
                 HWND hwndDefId;
@@ -317,7 +342,7 @@ static LRESULT USER_DefDlgProcA( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPar
     LRESULT result;
 
     /* Perform DIALOGINFO initialization if not done */
-    if(!(dlgInfo = DIALOG_get_info( hwnd, TRUE ))) return 0;
+    if (!(dlgInfo = DIALOG_get_info( hwnd, msg == WM_NCCREATE ))) return 0;
 
     SetWindowLongPtrW( hwnd, DWLP_MSGRESULT, 0 );
 
@@ -369,7 +394,7 @@ static LRESULT USER_DefDlgProcW( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lPar
     LRESULT result;
 
     /* Perform DIALOGINFO initialization if not done */
-    if(!(dlgInfo = DIALOG_get_info( hwnd, TRUE ))) return 0;
+    if (!(dlgInfo = DIALOG_get_info( hwnd, msg == WM_NCCREATE ))) return 0;
 
     SetWindowLongPtrW( hwnd, DWLP_MSGRESULT, 0 );
     result = WINPROC_CallDlgProcW( hwnd, msg, wParam, lParam );
diff --git a/dlls/user32/dialog.c b/dlls/user32/dialog.c
index d135943..053eddf 100644
--- a/dlls/user32/dialog.c
+++ b/dlls/user32/dialog.c
@@ -189,7 +189,7 @@ static const WORD *DIALOG_GetControl32( const WORD *p, DLG_CONTROL_INFO *info,
 static BOOL DIALOG_CreateControls32( HWND hwnd, LPCSTR template, const DLG_TEMPLATE *dlgTemplate,
                                      HINSTANCE hInst, BOOL unicode )
 {
-    DIALOGINFO *dlgInfo = DIALOG_get_info( hwnd, TRUE );
+    DIALOGINFO *dlgInfo = DIALOG_get_info( hwnd, FALSE );
     DLG_CONTROL_INFO info;
     HWND hwndCtrl, hwndDefButton = 0;
     INT items = dlgTemplate->nbItems;
@@ -701,6 +701,7 @@ static HWND DIALOG_CreateIndirect( HINSTANCE hInst, LPCVOID dlgTemplate,
         if (template.style & WS_VISIBLE && !(GetWindowLongW( hwnd, GWL_STYLE ) & WS_VISIBLE))
         {
            NtUserShowWindow( hwnd, SW_SHOWNORMAL );   /* SW_SHOW doesn't always work */
+            UpdateWindow( hwnd );
         }
         return hwnd;
     }
diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 1fff29c..2909858 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -475,6 +475,15 @@ HKL WINAPI LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     return ret;
 }
 
+/***********************************************************************
+ *              LoadKeyboardLayoutEx (USER32.@)
+ */
+HKL WINAPI LoadKeyboardLayoutEx(DWORD unknown, const WCHAR *locale, UINT flags)
+{
+    FIXME("(%ld, %s, %x) semi-stub!\n", unknown, debugstr_w(locale), flags);
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return LoadKeyboardLayoutW(locale, flags);
+}
 
 /***********************************************************************
  *		UnloadKeyboardLayout (USER32.@)
@@ -486,7 +495,6 @@ BOOL WINAPI UnloadKeyboardLayout( HKL layout )
     return FALSE;
 }
 
-
 static DWORD CALLBACK devnotify_window_callbackW(HANDLE handle, DWORD flags, DEV_BROADCAST_HDR *header)
 {
     SendMessageTimeoutW(handle, WM_DEVICECHANGE, flags, (LPARAM)header, SMTO_ABORTIFHUNG, 2000, NULL);
diff --git a/dlls/user32/listbox.c b/dlls/user32/listbox.c
index d3ca2cc..73fcfde 100644
--- a/dlls/user32/listbox.c
+++ b/dlls/user32/listbox.c
@@ -452,8 +452,11 @@ static void LISTBOX_UpdatePage( LB_DESCR *descr )
 static void LISTBOX_UpdateSize( LB_DESCR *descr )
 {
     RECT rect;
+    LONG style = GetWindowLongW( descr->self, GWL_STYLE );
 
     GetClientRect( descr->self, &rect );
+    if (style & WS_HSCROLL)
+        rect.bottom += GetSystemMetrics(SM_CYHSCROLL);
     descr->width  = rect.right - rect.left;
     descr->height = rect.bottom - rect.top;
     if (!(descr->style & LBS_NOINTEGRALHEIGHT) && !(descr->style & LBS_OWNERDRAWVARIABLE))
diff --git a/dlls/user32/mdi.c b/dlls/user32/mdi.c
index f579298..01cb09f 100644
--- a/dlls/user32/mdi.c
+++ b/dlls/user32/mdi.c
@@ -2,6 +2,7 @@
  *
  * Copyright 1994, Bob Amstadt
  *           1995,1996 Alex Korobka
+ * Copyright 2018 Katayama Hirofumi MZ
  *
  * This file contains routines to support MDI (Multiple Document
  * Interface) features .
@@ -131,6 +132,10 @@ typedef struct
 
 static HBITMAP hBmpClose   = 0;
 
+static WCHAR shelltray[] = {'S','h','e','l','l','_','T','r','a','y','W','n','d',0};
+static WCHAR progman[] = {'P','r','o','g','m','a','n',0};
+
+
 /* ----------------- declarations ----------------- */
 static void MDI_UpdateFrameText( HWND, HWND, BOOL, LPCWSTR);
 static BOOL MDI_AugmentFrameMenu( HWND, HWND );
@@ -1357,6 +1362,7 @@ LRESULT WINAPI DefMDIChildProcA( HWND hwnd, UINT message,
 	DefWindowProcA(hwnd, message, wParam, lParam);
 	if( ci->hwndChildMaximized == hwnd )
 	    MDI_UpdateFrameText( GetParent(client), client, TRUE, NULL );
+        MDI_RefreshMenu( ci );
         return 1; /* success. FIXME: check text length */
 
     case WM_GETMINMAXINFO:
@@ -1397,6 +1403,7 @@ LRESULT WINAPI DefMDIChildProcW( HWND hwnd, UINT message,
         DefWindowProcW(hwnd, message, wParam, lParam);
         if( ci->hwndChildMaximized == hwnd )
             MDI_UpdateFrameText( GetParent(client), client, TRUE, NULL );
+        MDI_RefreshMenu( ci );
         return 1; /* success. FIXME: check text length */
 
     case WM_GETMINMAXINFO:
@@ -1795,12 +1802,221 @@ done:
  *    Success: Number of cascaded windows.
  *    Failure: 0
  */
+
+typedef struct CASCADE_INFO
+{
+    HWND top;
+    UINT flags;
+    HWND parent;
+    HWND desktop;
+    HWND tray_wnd;
+    HWND progman;
+    HWND *wnd_array;
+    DWORD wnd_count;
+} CASCADE_INFO;
+
+static BOOL CALLBACK GetCascadeChildProc(HWND hwnd, LPARAM lParam)
+{
+    DWORD count, size;
+    HWND *wnd_array;
+    CASCADE_INFO *info = (CASCADE_INFO *)lParam;
+
+    if (hwnd == info->desktop || hwnd == info->tray_wnd ||
+        hwnd == info->progman || hwnd == info->top)
+    {
+        return TRUE;
+    }
+
+    if (info->parent && GetParent(hwnd) != info->parent)
+        return TRUE;
+
+    if ((info->flags & MDITILE_SKIPDISABLED) && !IsWindowEnabled(hwnd))
+        return TRUE;
+
+    if (!IsWindowVisible(hwnd) || IsIconic(hwnd))
+        return TRUE;
+
+    count = info->wnd_count;
+    size = (count + 1) * sizeof(HWND);
+
+    if (count == 0 || !info->wnd_array)
+    {
+        count = 0;
+        info->wnd_array = (HWND *)heap_alloc(size);
+    }
+    else
+    {
+        wnd_array = (HWND *)heap_realloc(info->wnd_array, size);
+        if (!wnd_array)
+        {
+            heap_free(info->wnd_array);
+        }
+        info->wnd_array = wnd_array;
+    }
+
+    if (!info->wnd_array)
+    {
+        info->wnd_count = 0;
+        return FALSE;
+    }
+
+    info->wnd_array[count] = hwnd;
+    info->wnd_count = count + 1;
+    return TRUE;
+}
+
+static BOOL
+QuerySizeFix(HWND hwnd, INT *pcx, INT *pcy)
+{
+    MINMAXINFO mmi;
+    DWORD_PTR result;
+
+    mmi.ptMinTrackSize.x = mmi.ptMinTrackSize.y = 0;
+    mmi.ptMaxTrackSize.x = mmi.ptMaxTrackSize.y = MAXLONG;
+    if (SendMessageTimeoutW(hwnd, WM_GETMINMAXINFO, 0, (LPARAM)&mmi,
+                            SMTO_ABORTIFHUNG | SMTO_NORMAL, 120, &result))
+    {
+        *pcx = min(max(*pcx, mmi.ptMinTrackSize.x), mmi.ptMaxTrackSize.x);
+        *pcy = min(max(*pcy, mmi.ptMinTrackSize.y), mmi.ptMaxTrackSize.y);
+        return TRUE;
+    }
+    return FALSE;
+}
+
 WORD WINAPI
 CascadeWindows (HWND hwndParent, UINT wFlags, const RECT *lpRect,
 		UINT cKids, const HWND *lpKids)
 {
-    FIXME("(%p,0x%08x,...,%u,...): stub\n", hwndParent, wFlags, cKids);
-    return 0;
+    CASCADE_INFO info;
+    HWND hwnd, top, prev;
+    HMONITOR monitor;
+    MONITORINFO mi;
+    RECT work_rect, wnd_rect;
+    DWORD i, ret = 0;
+    INT x, y, width, height, new_width, new_height, work_width, work_height, dx, dy;
+    HDWP hDWP;
+    POINT pt;
+
+    TRACE("(%p,0x%08x,%p,%u,%p)\n", hwndParent, wFlags, lpRect, cKids, lpKids);
+
+    top = GetTopWindow(hwndParent);
+
+    ZeroMemory(&info, sizeof(info));
+    info.desktop = GetDesktopWindow();
+    info.tray_wnd = FindWindowW(shelltray, NULL);
+    info.progman = FindWindowW(progman, NULL);
+    info.parent = hwndParent;
+    info.flags = wFlags;
+
+    if (cKids == 0 || lpKids == NULL)
+    {
+        info.top = top;
+        EnumChildWindows(hwndParent, GetCascadeChildProc, (LPARAM)&info);
+
+        info.top = NULL;
+        GetCascadeChildProc(top, (LPARAM)&info);
+    }
+    else
+    {
+        info.wnd_count = cKids;
+        info.wnd_array = (HWND *)lpKids;
+    }
+
+    if (info.wnd_count == 0 || info.wnd_array == NULL)
+        return ret;
+
+    if (lpRect)
+    {
+        work_rect = *lpRect;
+    }
+    else if (hwndParent)
+    {
+        GetClientRect(hwndParent, &work_rect);
+    }
+    else
+    {
+        pt.x = pt.y = 0;
+        monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY);
+        mi.cbSize = sizeof(mi);
+        GetMonitorInfoW(monitor, &mi);
+        work_rect = mi.rcWork;
+    }
+
+    hDWP = BeginDeferWindowPos(info.wnd_count);
+    if (hDWP == NULL)
+        goto cleanup;
+
+    x = work_rect.left;
+    y = work_rect.top;
+    dx = GetSystemMetrics(SM_CXSIZEFRAME) + GetSystemMetrics(SM_CXSIZE);
+    dy = GetSystemMetrics(SM_CYSIZEFRAME) + GetSystemMetrics(SM_CYSIZE);
+    work_width = work_rect.right - work_rect.left;
+    work_height = work_rect.bottom - work_rect.top;
+    prev = NULL;
+    for (i = info.wnd_count; i > 0;)    /* in reverse order */
+    {
+        --i;
+        hwnd = info.wnd_array[i];
+
+        if (!IsWindowVisible(hwnd) || IsIconic(hwnd))
+            continue;
+
+        if ((info.flags & MDITILE_SKIPDISABLED) && !IsWindowEnabled(hwnd))
+            continue;
+
+        if (IsZoomed(hwnd))
+            NtUserShowWindow(hwnd, SW_RESTORE | SW_SHOWNA);
+
+        GetWindowRect(hwnd, &wnd_rect);
+        new_width = width = wnd_rect.right - wnd_rect.left;
+        new_height = height = wnd_rect.bottom - wnd_rect.top;
+
+        /* if we can change the window size and it is not only one */
+        if (info.wnd_count != 1 && (GetWindowLongPtrW(hwnd, GWL_STYLE) & WS_THICKFRAME))
+        {
+            /* check the size */
+#define THRESHOLD(xy) (((xy) * 5) / 7)      /* in the rate 5/7 */
+            new_width = min(new_width, THRESHOLD(work_width));
+            new_height = min(new_height, THRESHOLD(work_height));
+#undef THRESHOLD
+            if (width != new_width || height != new_height)
+            {
+                /* too large. shrink if we can */
+                if (QuerySizeFix(hwnd, &new_width, &new_height))
+                {
+                    width = new_width;
+                    height = new_height;
+                }
+            }
+        }
+
+        if (x + width > work_rect.right)
+            x = work_rect.left;
+        if (y + height > work_rect.bottom)
+            y = work_rect.top;
+
+        hDWP = DeferWindowPos(hDWP, hwnd, HWND_TOP, x, y, width, height, SWP_NOACTIVATE);
+        if (hDWP == NULL)
+        {
+            ret = 0;
+            goto cleanup;
+        }
+
+        x += dx;
+        y += dy;
+        prev = hwnd;
+        ++ret;
+    }
+
+    EndDeferWindowPos(hDWP);
+
+    if (prev)
+        SetForegroundWindow(prev);
+
+cleanup:
+    heap_free(info.wnd_array);
+
+    return (WORD)ret;
 }
 
 
@@ -1824,8 +2040,177 @@ WORD WINAPI
 TileWindows (HWND hwndParent, UINT wFlags, const RECT *lpRect,
 	     UINT cKids, const HWND *lpKids)
 {
-    FIXME("(%p,0x%08x,...,%u,...): stub\n", hwndParent, wFlags, cKids);
-    return 0;
+    HWND hwnd, hwndTop, hwndPrev;
+    CASCADE_INFO info;
+    RECT rcWork, rcWnd;
+    DWORD i, iRow, iColumn, cRows, cColumns, ret = 0;
+    INT x, y, cx, cy, cxNew, cyNew, cxWork, cyWork, cxCell, cyCell, cxMin2, cyMin3;
+    HDWP hDWP;
+    MONITORINFO mi;
+    HMONITOR hMon;
+    POINT pt;
+
+    TRACE("(%p,0x%08x,...,%u,...)\n", hwndParent, wFlags, cKids);
+
+    hwndTop = GetTopWindow(hwndParent);
+
+    ZeroMemory(&info, sizeof(info));
+    info.desktop = GetDesktopWindow();
+    info.tray_wnd = FindWindowW(shelltray, NULL);
+    info.progman = FindWindowW(progman, NULL);
+    info.parent = hwndParent;
+    info.flags = wFlags;
+
+    if (cKids == 0 || lpKids == NULL)
+    {
+        info.top = hwndTop;
+        EnumChildWindows(hwndParent, GetCascadeChildProc, (LPARAM)&info);
+
+        info.top = NULL;
+        GetCascadeChildProc(hwndTop, (LPARAM)&info);
+    }
+    else
+    {
+        info.wnd_count = cKids;
+        info.wnd_array = (HWND *)lpKids;
+    }
+
+    if (info.wnd_count == 0 || info.wnd_array == NULL)
+        return ret;
+
+    if (lpRect)
+    {
+        rcWork = *lpRect;
+    }
+    else if (hwndParent)
+    {
+        GetClientRect(hwndParent, &rcWork);
+    }
+    else
+    {
+        pt.x = pt.y = 0;
+        hMon = MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY);
+        mi.cbSize = sizeof(mi);
+        GetMonitorInfoW(hMon, &mi);
+        rcWork = mi.rcWork;
+    }
+
+    cxWork = rcWork.right - rcWork.left;
+    cyWork = rcWork.bottom - rcWork.top;
+
+    cxMin2 = GetSystemMetrics(SM_CXMIN) * 2;
+    cyMin3 = GetSystemMetrics(SM_CYMIN) * 3;
+
+    /* calculate the numbers and widths of columns and rows */
+    if (info.flags & MDITILE_HORIZONTAL)
+    {
+        cColumns = info.wnd_count;
+        cRows = 1;
+        for (;;)
+        {
+            cxCell = cxWork / cColumns;
+            cyCell = cyWork / cRows;
+            if (cyCell <= cyMin3 || cxCell >= cxMin2)
+                break;
+
+            ++cRows;
+            cColumns = (info.wnd_count + cRows - 1) / cRows;
+        }
+    }
+    else
+    {
+        cRows = info.wnd_count;
+        cColumns = 1;
+        for (;;)
+        {
+            cxCell = cxWork / cColumns;
+            cyCell = cyWork / cRows;
+            if (cxCell <= cxMin2 || cyCell >= cyMin3)
+                break;
+
+            ++cColumns;
+            cRows = (info.wnd_count + cColumns - 1) / cColumns;
+        }
+    }
+
+    hDWP = BeginDeferWindowPos(info.wnd_count);
+    if (hDWP == NULL)
+        goto cleanup;
+
+    x = rcWork.left;
+    y = rcWork.top;
+    hwndPrev = NULL;
+    iRow = iColumn = 0;
+    for (i = info.wnd_count; i > 0;)    /* in reverse order */
+    {
+        --i;
+        hwnd = info.wnd_array[i];
+
+        if (IsZoomed(hwnd))
+            NtUserShowWindow(hwnd, SW_RESTORE | SW_SHOWNA);
+
+        GetWindowRect(hwnd, &rcWnd);
+        cx = rcWnd.right - rcWnd.left;
+        cy = rcWnd.bottom - rcWnd.top;
+
+        /* if we can change the window size */
+        if (GetWindowLongPtrW(hwnd, GWL_STYLE) & WS_THICKFRAME)
+        {
+            cxNew = cxCell;
+            cyNew = cyCell;
+            /* shrink if we can */
+            if (QuerySizeFix(hwnd, &cxNew, &cyNew))
+            {
+                cx = cxNew;
+                cy = cyNew;
+            }
+        }
+
+        hDWP = DeferWindowPos(hDWP, hwnd, HWND_TOP, x, y, cx, cy, SWP_NOACTIVATE);
+        if (hDWP == NULL)
+        {
+            ret = 0;
+            goto cleanup;
+        }
+
+        if (info.flags & MDITILE_HORIZONTAL)
+        {
+            x += cxCell;
+            ++iColumn;
+            if (iColumn >= cColumns)
+            {
+                iColumn = 0;
+                ++iRow;
+                x = rcWork.left;
+                y += cyCell;
+            }
+        }
+        else
+        {
+            y += cyCell;
+            ++iRow;
+            if (iRow >= cRows)
+            {
+                iRow = 0;
+                ++iColumn;
+                x += cxCell;
+                y = rcWork.top;
+            }
+        }
+        hwndPrev = hwnd;
+        ++ret;
+    }
+
+    EndDeferWindowPos(hDWP);
+
+    if (hwndPrev)
+        SetForegroundWindow(hwndPrev);
+
+cleanup:
+    if (cKids == 0 || lpKids == NULL)
+        HeapFree(GetProcessHeap(), 0, info.wnd_array);
+
+    return (WORD)ret;
 }
 
 
diff --git a/dlls/user32/msgbox.c b/dlls/user32/msgbox.c
index 4d34577..de02079 100644
--- a/dlls/user32/msgbox.c
+++ b/dlls/user32/msgbox.c
@@ -41,6 +41,11 @@ struct ThreadWindows
     HWND *handles;
 };
 
+/* Index the order the buttons need to appear to an ID* constant */
+static const int buttonOrder[10] = { IDYES, IDNO, IDOK, IDABORT, IDRETRY,
+                                 IDCANCEL, IDIGNORE, IDTRYAGAIN,
+                                 IDCONTINUE, IDHELP };
+
 static BOOL CALLBACK MSGBOX_EnumProc(HWND hwnd, LPARAM lParam)
 {
     struct ThreadWindows *threadWindows = (struct ThreadWindows *)lParam;
@@ -74,11 +79,6 @@ static void MSGBOX_OnInit(HWND hwnd, LPMSGBOXPARAMSW lpmb)
     WCHAR *buffer = NULL;
     const WCHAR *ptr;
 
-    /* Index the order the buttons need to appear to an ID* constant */
-    static const int buttonOrder[10] = { IDYES, IDNO, IDOK, IDABORT, IDRETRY,
-                                         IDCANCEL, IDIGNORE, IDTRYAGAIN,
-                                         IDCONTINUE, IDHELP };
-
     nclm.cbSize = sizeof(nclm);
     SystemParametersInfoW (SPI_GETNONCLIENTMETRICS, 0, &nclm, 0);
 
@@ -320,6 +320,93 @@ static void MSGBOX_OnInit(HWND hwnd, LPMSGBOXPARAMSW lpmb)
     HeapFree( GetProcessHeap(), 0, buffer );
 }
 
+static void MSGBOX_CopyToClipbaord( HWND hwnd )
+{
+    int i;
+    static const WCHAR line[] = {'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-',
+                           '-','-','-','-','-','-','-','-','\r','\n', 0};
+    static const WCHAR carriage[] = {'\r','\n', 0};
+    static const WCHAR spaces[] = {' ',' ',' ', 0};
+    int lenTitle = GetWindowTextLengthW(hwnd) + 1;
+    int lenMsg = GetWindowTextLengthW(GetDlgItem(hwnd, MSGBOX_IDTEXT)) + 1;
+
+    /*
+    ---------------------------
+    Dialog Title
+    ---------------------------
+    Dialog Message
+    ---------------------------
+    Button(s) Text. OK
+    ---------------------------
+    */
+    int len = ((sizeof(carriage) * 3) + (sizeof(line) * 4) + lenTitle + lenMsg) * sizeof(WCHAR);
+    WCHAR *text = heap_alloc(len);
+    if(text)
+    {
+        lstrcpyW(text, line);
+        if (GetWindowTextW(hwnd, text + lstrlenW(text), lenTitle))
+        {
+            HGLOBAL hMem;
+            WCHAR *data;
+
+            lstrcatW(text, carriage);
+            lstrcatW(text, line);
+            GetWindowTextW(GetDlgItem(hwnd, MSGBOX_IDTEXT), text + lstrlenW(text), lenMsg);
+            lstrcatW(text, carriage);
+            lstrcatW(text, line);
+
+            for (i = 0; i < ARRAY_SIZE(buttonOrder); i++)
+            {
+                HWND hItem = GetDlgItem(hwnd, buttonOrder[i]);
+                if (GetWindowLongW(hItem, GWL_STYLE) & WS_VISIBLE)
+                {
+                    WCHAR buffer[1024] = {0};
+                    int j = 0, k = lstrlenW(text);
+                    GetWindowTextW(hItem, buffer, 1024);
+                    while(buffer[j] != 0)
+                    {
+                        if(buffer[j] != '&')
+                            text[k++] = buffer[j];
+                        j++;
+                    }
+                    text[k] = 0;
+                    lstrcatW(text, spaces);
+                }
+            }
+
+            lstrcatW(text, carriage);
+            lstrcatW(text, line);
+
+            hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE|GMEM_ZEROINIT, (len + 1) * sizeof(WCHAR));
+            data = GlobalLock(hMem);
+            lstrcpyW(data, text);
+            GlobalUnlock(hMem);
+
+            OpenClipboard(hwnd);
+            NtUserEmptyClipboard();
+            SetClipboardData(CF_UNICODETEXT, hMem);
+            NtUserCloseClipboard();
+        }
+
+        heap_free(text);
+    }
+}
+
+HHOOK msghook_handle;
+
+LRESULT CALLBACK msg_hook_proc(int nCode, WPARAM wParam, LPARAM lParam)
+{
+    MSG *msg = (MSG *)lParam;
+    if (nCode == MSGF_DIALOGBOX && msg->message == WM_KEYUP)
+    {
+        if ( (msg->wParam == 'C' || msg->wParam == 'c') && (NtUserGetKeyState(VK_CONTROL) & 0x8000))
+        {
+            MSGBOX_CopyToClipbaord(GetParent(msg->hwnd));
+        }
+    }
+
+    return NtUserCallNextHookEx(msghook_handle, nCode, wParam, lParam);
+}
 
 /**************************************************************************
  *           MSGBOX_DlgProc
@@ -336,8 +423,17 @@ static INT_PTR CALLBACK MSGBOX_DlgProc( HWND hwnd, UINT message,
        SetWindowContextHelpId(hwnd, mbp->dwContextHelpId);
        MSGBOX_OnInit(hwnd, mbp);
        SetPropA(hwnd, "WINE_MSGBOX_HELPCALLBACK", mbp->lpfnMsgBoxCallback);
+       msghook_handle = SetWindowsHookExA(WH_MSGFILTER, msg_hook_proc, NULL, GetCurrentThreadId());
        break;
    }
+   case WM_COPY:
+   {
+        MSGBOX_CopyToClipbaord(hwnd);
+        break;
+   }
+   case WM_DESTROY:
+       NtUserUnhookWindowsHookEx(msghook_handle);
+       break;
 
    case WM_COMMAND:
     switch (LOWORD(wParam))
diff --git a/dlls/user32/tests/dialog.c b/dlls/user32/tests/dialog.c
index 7ea0d13..448b69c 100644
--- a/dlls/user32/tests/dialog.c
+++ b/dlls/user32/tests/dialog.c
@@ -2068,6 +2068,187 @@ static void test_MessageBoxFontTest(void)
     DestroyWindow(hDlg);
 }
 
+static const char msgbox_title[] = "%5!z9ZXw*ia;57n/FGl.bCH,Su\"mfKN;foCqAU\'j6AmoJgAc_D:Z0A\'E6PF_O/w";
+static WCHAR expectedOK[] =
+{
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'%','5','!','z','9','Z','X','w','*','i','a',';','5','7','n','/','F','G','l','.','b','C','H',',','S','u','"','m','f',
+'K','N',';','f','o','C','q','A','U','\'','j','6','A','m','o','J','g','A','c','_','D',':','Z','0','A','\'','E','6','P',
+'F','_','O','/','w','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'M','e','s','s','a','g','e','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'O','K',' ',' ',' ','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n', 0
+};
+static WCHAR expectedOkCancel[] =
+{
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'%','5','!','z','9','Z','X','w','*','i','a',';','5','7','n','/','F','G','l','.','b','C','H',',','S','u','"','m','f',
+'K','N',';','f','o','C','q','A','U','\'','j','6','A','m','o','J','g','A','c','_','D',':','Z','0','A','\'','E','6','P',
+'F','_','O','/','w','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'M','e','s','s','a','g','e','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'O','K',' ',' ',' ','C','a','n','c','e','l',' ',' ',' ','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n', 0
+};
+static WCHAR expectedAbortRetryIgnore[] =
+{
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'%','5','!','z','9','Z','X','w','*','i','a',';','5','7','n','/','F','G','l','.','b','C','H',',','S','u','"','m','f',
+'K','N',';','f','o','C','q','A','U','\'','j','6','A','m','o','J','g','A','c','_','D',':','Z','0','A','\'','E','6','P',
+'F','_','O','/','w','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'M','e','s','s','a','g','e','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'A','b','o','r','t',' ',' ',' ','R','e','t','r','y',' ',' ',' ','I','g','n','o','r','e',' ',' ',' ','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n', 0
+};
+
+static WCHAR expectedYesNo[] =
+{
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'%','5','!','z','9','Z','X','w','*','i','a',';','5','7','n','/','F','G','l','.','b','C','H',',','S','u','"','m','f',
+'K','N',';','f','o','C','q','A','U','\'','j','6','A','m','o','J','g','A','c','_','D',':','Z','0','A','\'','E','6','P',
+'F','_','O','/','w','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'M','e','s','s','a','g','e','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'Y','e','s',' ',' ',' ','N','o',' ',' ',' ','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n', 0
+};
+static WCHAR expectedYesNoCancel[] =
+{
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'%','5','!','z','9','Z','X','w','*','i','a',';','5','7','n','/','F','G','l','.','b','C','H',',','S','u','"','m','f',
+'K','N',';','f','o','C','q','A','U','\'','j','6','A','m','o','J','g','A','c','_','D',':','Z','0','A','\'','E','6','P',
+'F','_','O','/','w','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'M','e','s','s','a','g','e','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'Y','e','s',' ',' ',' ','N','o',' ',' ',' ','C','a','n','c','e','l',' ',' ',' ','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n', 0
+};
+static WCHAR expectedRetryCancel[] =
+{
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'%','5','!','z','9','Z','X','w','*','i','a',';','5','7','n','/','F','G','l','.','b','C','H',',','S','u','"','m','f',
+'K','N',';','f','o','C','q','A','U','\'','j','6','A','m','o','J','g','A','c','_','D',':','Z','0','A','\'','E','6','P',
+'F','_','O','/','w','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'M','e','s','s','a','g','e','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'R','e','t','r','y',' ',' ',' ','C','a','n','c','e','l',' ',' ',' ','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n', 0
+};
+static WCHAR expectedCancelTryContinue[] =
+{
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'%','5','!','z','9','Z','X','w','*','i','a',';','5','7','n','/','F','G','l','.','b','C','H',',','S','u','"','m','f',
+'K','N',';','f','o','C','q','A','U','\'','j','6','A','m','o','J','g','A','c','_','D',':','Z','0','A','\'','E','6','P',
+'F','_','O','/','w','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'M','e','s','s','a','g','e','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n',
+'C','a','n','c','e','l',' ',' ',' ','T','r','y',' ','A','g','a','i','n',' ',' ',' ','C','o','n','t','i','n','u','e',' ',' ',' ','\r','\n',
+'-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','-','\r','\n', 0
+};
+
+BOOL non_english = FALSE;
+
+DWORD WINAPI WorkerThread(void *param)
+{
+    WCHAR *expected = param;
+    char windowTitle[sizeof(msgbox_title)];
+    HWND hwndMbox;
+    BOOL succeeded = FALSE;
+
+    Sleep(200);
+
+    hwndMbox = GetForegroundWindow();
+
+    /* Find the Window, if it doesn't have focus */
+    if (!(IsWindow(hwndMbox) &&
+        GetWindowTextA(hwndMbox, windowTitle, sizeof(msgbox_title)) &&
+        lstrcmpA(msgbox_title, windowTitle) == 0))
+    {
+        hwndMbox = FindWindowA(NULL, msgbox_title);
+
+        if (!IsWindow(hwndMbox))
+            goto cleanup;
+    }
+
+    SendMessageA(hwndMbox, WM_COPY, 0, 0);
+
+    if (IsClipboardFormatAvailable(CF_UNICODETEXT) && OpenClipboard(NULL))
+    {
+        HANDLE textHandle = GetClipboardData(CF_UNICODETEXT);
+        WCHAR *text = GlobalLock(textHandle);
+
+        if (text != NULL)
+        {
+            if(non_english)
+                ok(lstrlenW(text) > 0, "Empty string on clipboard\n");
+            else
+            {
+                succeeded = lstrcmpW(expected, text) == 0;
+                if(!succeeded)
+                {
+                    ok(0, "%s\n", wine_dbgstr_w(text));
+                    ok(0, "%s\n", wine_dbgstr_w(expected));
+                }
+            }
+
+            GlobalUnlock(textHandle);
+        }
+        else
+            ok(0, "No text on clipboard.\n");
+
+        CloseClipboard();
+
+    }
+    else
+        trace("Clipboard error\n");
+
+    PostMessageA(hwndMbox, WM_COMMAND, IDIGNORE, 0); /* For MB_ABORTRETRYIGNORE dialog. */
+    PostMessageA(hwndMbox, WM_CLOSE, 0, 0);
+
+cleanup:
+    ok(succeeded || non_english, "Failed to get string.\n");
+
+    return 0;
+}
+
+static void test_MessageBox_WM_COPY_Test(void)
+{
+    DWORD tid = 0;
+
+    non_english = (PRIMARYLANGID(GetUserDefaultLangID()) != LANG_ENGLISH);
+    trace("non_english %d\n", non_english);
+
+    CreateThread(NULL, 0, WorkerThread, &expectedOK, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_OK);
+
+    CreateThread(NULL, 0, WorkerThread, &expectedOkCancel, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_OKCANCEL);
+
+    CreateThread(NULL, 0, WorkerThread, &expectedAbortRetryIgnore, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_ABORTRETRYIGNORE);
+
+    CreateThread(NULL, 0, WorkerThread, &expectedYesNo, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_YESNO);
+
+    CreateThread(NULL, 0, WorkerThread, &expectedYesNoCancel, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_YESNOCANCEL);
+
+    CreateThread(NULL, 0, WorkerThread, &expectedRetryCancel, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_RETRYCANCEL);
+
+    CreateThread(NULL, 0, WorkerThread, &expectedCancelTryContinue, 0, &tid);
+    MessageBoxA(NULL, "Message", msgbox_title, MB_CANCELTRYCONTINUE);
+}
+
 static void test_SaveRestoreFocus(void)
 {
     HWND hDlg;
@@ -2455,4 +2636,5 @@ START_TEST(dialog)
     test_timer_message();
     test_MessageBox();
     test_capture_release();
+    test_MessageBox_WM_COPY_Test();
 }
diff --git a/dlls/user32/tests/input.c b/dlls/user32/tests/input.c
index 02200fb..9f7f9e7 100644
--- a/dlls/user32/tests/input.c
+++ b/dlls/user32/tests/input.c
@@ -5508,6 +5508,40 @@ static void test_keyboard_ll_hook_blocking(void)
     ok_ret( 1, DestroyWindow( hwnd ) );
 }
 
+static void test_GetKeyboardLayoutList(void)
+{
+    int cnt, cnt2;
+    HKL *layouts;
+    ULONG_PTR baselayout;
+    LANGID langid;
+
+    baselayout = GetUserDefaultLCID();
+    langid = PRIMARYLANGID(LANGIDFROMLCID(baselayout));
+    if (langid == LANG_CHINESE || langid == LANG_JAPANESE || langid == LANG_KOREAN)
+        baselayout = MAKELONG( baselayout, 0xe001 ); /* IME */
+    else
+        baselayout |= baselayout << 16;
+
+    cnt = GetKeyboardLayoutList(0, NULL);
+    /* Most users will not have more than a few keyboard layouts installed at a time. */
+    ok(cnt > 0 && cnt < 10, "Layout count %d\n", cnt);
+    if (cnt > 0)
+    {
+        layouts = HeapAlloc(GetProcessHeap(), 0, sizeof(*layouts) * cnt );
+
+        cnt2 = GetKeyboardLayoutList(cnt, layouts);
+        ok(cnt == cnt2, "wrong value %d!=%d\n", cnt, cnt2);
+        for(cnt = 0; cnt < cnt2; cnt++)
+        {
+            if(layouts[cnt] == (HKL)baselayout)
+                break;
+        }
+        ok(cnt < cnt2, "Didnt find current keyboard\n");
+
+        HeapFree(GetProcessHeap(), 0, layouts);
+    }
+}
+
 /* run the tests in a separate desktop to avoid interaction with other
  * tests, current desktop state, or user actions. */
 static void test_input_desktop( char **argv )
@@ -5598,6 +5632,7 @@ START_TEST(input)
     test_GetRawInputBuffer();
     test_RegisterRawInputDevices();
     test_rawinput(argv[0]);
+    test_GetKeyboardLayoutList();
     test_DefRawInputProc();
 
     if(pGetMouseMovePointsEx)
diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 2dba792..97fe17e 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -5205,6 +5205,39 @@ static void test_showwindow(void)
     flush_sequence();
 }
 
+static void test_recursive_activation(void)
+{
+    static const struct message seq[] =
+    {
+        { HCBT_ACTIVATE, hook },
+        { WM_NCACTIVATE, sent|wparam, TRUE },
+        { WM_ACTIVATE, sent|wparam, WA_ACTIVE },
+        { HCBT_ACTIVATE, hook },
+        { WM_NCACTIVATE, sent|wparam, FALSE },
+        { WM_ACTIVATE, sent|wparam, WA_INACTIVE },
+        { WM_SETFOCUS, sent|optional },
+        { 0 }
+    };
+    HWND hwnd, recursive;
+
+    hwnd = CreateWindowExA(0, "SimpleWindowClass", NULL, WS_OVERLAPPED|WS_VISIBLE,
+                              100, 100, 200, 200, 0, 0, 0, NULL);
+    ok(hwnd != 0, "Failed to create simple window\n");
+
+    recursive = CreateWindowExA(0, "RecursiveActivationClass", NULL, WS_OVERLAPPED|WS_VISIBLE,
+                                10, 10, 50, 50, hwnd, 0, 0, NULL);
+    ok(recursive != 0, "Failed to create recursive activation window\n");
+    SetActiveWindow(hwnd);
+
+    flush_sequence();
+    SetActiveWindow(recursive);
+    ok_sequence(seq, "Recursive Activation", FALSE);
+
+    DestroyWindow(recursive);
+    DestroyWindow(hwnd);
+    flush_sequence();
+}
+
 static void test_sys_menu(void)
 {
     HWND hwnd;
@@ -11080,6 +11113,48 @@ static LRESULT WINAPI ShowWindowProcA(HWND hwnd, UINT message, WPARAM wParam, LP
     return ret;
 }
 
+static LRESULT WINAPI recursive_activation_wndprocA(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
+{
+    static LONG defwndproc_counter = 0;
+    struct recvd_message msg;
+    LRESULT ret;
+
+    switch (message)
+    {
+    /* log only specific messages we are interested in */
+    case WM_NCACTIVATE:
+    case WM_ACTIVATE:
+    case WM_SETFOCUS:
+    case WM_KILLFOCUS:
+        break;
+    default:
+        return DefWindowProcA(hwnd, message, wParam, lParam);
+    }
+
+    msg.hwnd = hwnd;
+    msg.message = message;
+    msg.flags = sent|wparam|lparam;
+    if (defwndproc_counter) msg.flags |= defwinproc;
+    msg.wParam = wParam;
+    msg.lParam = lParam;
+    msg.descr = "recursive_activation";
+    add_message(&msg);
+
+    /* recursively activate ourselves by first losing activation and changing it back */
+    if (message == WM_ACTIVATE && LOWORD(wParam) != WA_INACTIVE)
+    {
+        SetActiveWindow((HWND)lParam);
+        SetActiveWindow(hwnd);
+        return 0;
+    }
+
+    defwndproc_counter++;
+    ret = DefWindowProcA(hwnd, message, wParam, lParam);
+    defwndproc_counter--;
+
+    return ret;
+}
+
 static LRESULT WINAPI PaintLoopProcA(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 {
     switch (msg)
@@ -11177,6 +11252,10 @@ static void register_classes(void)
     cls.lpszClassName = "ShowWindowClass";
     register_class(&cls);
 
+    cls.lpfnWndProc = recursive_activation_wndprocA;
+    cls.lpszClassName = "RecursiveActivationClass";
+    register_class(&cls);
+
     cls.lpfnWndProc = PopupMsgCheckProcA;
     cls.lpszClassName = "TestPopupClass";
     register_class(&cls);
@@ -11235,6 +11314,7 @@ static BOOL is_our_logged_class(HWND hwnd)
     {
 	if (!lstrcmpiA(buf, "TestWindowClass") ||
 	    !lstrcmpiA(buf, "ShowWindowClass") ||
+	    !lstrcmpiA(buf, "RecursiveActivationClass") ||
 	    !lstrcmpiA(buf, "TestParentClass") ||
 	    !lstrcmpiA(buf, "TestPopupClass") ||
 	    !lstrcmpiA(buf, "SimpleWindowClass") ||
@@ -14321,13 +14401,10 @@ static void test_PeekMessage3(void)
     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     PostMessageA(hwnd, WM_USER, 0, 0);
     ret = PeekMessageA(&msg, hwnd, 0, 0, PM_NOREMOVE);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = GetMessageA(&msg, hwnd, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = GetMessageA(&msg, hwnd, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
     ret = PeekMessageA(&msg, hwnd, 0, 0, 0);
     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
@@ -14337,10 +14414,8 @@ static void test_PeekMessage3(void)
     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     PostMessageA(hwnd, WM_USER, 0, 0);
     ret = PeekMessageA(&msg, hwnd, 0, 0, PM_REMOVE);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = PeekMessageA(&msg, hwnd, 0, 0, PM_REMOVE);
-    todo_wine
     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
     ret = PeekMessageA(&msg, hwnd, 0, 0, 0);
     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
@@ -14352,10 +14427,11 @@ static void test_PeekMessage3(void)
     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     PostMessageA(hwnd, WM_USER, 0, 0);
     ret = GetMessageA(&msg, hwnd, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = GetMessageA(&msg, hwnd, 0, 0);
-    todo_wine
+    ret = GetMessageA(&msg, NULL, 0, 0);
+    ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+    ret = GetMessageA(&msg, NULL, 0, 0);
     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
     ret = PeekMessageA(&msg, hwnd, 0, 0, 0);
     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
@@ -14383,14 +14459,32 @@ static void test_PeekMessage3(void)
     ret = GetMessageA(&msg, hwnd, 0, 0);
     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
     ret = GetMessageA(&msg, hwnd, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = GetMessageA(&msg, hwnd, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_USER + 1, "msg.message = %u instead of WM_USER + 1\n", msg.message);
     ret = PeekMessageA(&msg, hwnd, 0, 0, 0);
     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
 
+    /* Newer messages are still returned when specifying a message range. */
+
+    SetTimer(hwnd, 1, 0, NULL);
+    while (!PeekMessageA(&msg, NULL, WM_TIMER, WM_TIMER, PM_NOREMOVE));
+    ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+    PostMessageA(hwnd, WM_USER + 1, 0, 0);
+    PostMessageA(hwnd, WM_USER, 0, 0);
+    ret = PeekMessageA(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);
+    ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
+    ret = PeekMessageA(&msg, NULL, WM_USER, WM_USER + 1, PM_NOREMOVE);
+    ok(ret && msg.message == WM_USER + 1, "msg.message = %u instead of WM_USER + 1\n", msg.message);
+    ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
+    ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+    ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
+    ok(ret && msg.message == WM_USER + 1, "msg.message = %u instead of WM_USER + 1\n", msg.message);
+    ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
+    ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
+    ret = PeekMessageA(&msg, NULL, 0, 0, 0);
+    ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
+
     /* Also works for posted messages, but the situation is a bit different,
      * because both messages are in the same queue. */
 
@@ -18678,6 +18772,7 @@ static const struct message WmSetParentSeq_2[] = {
     { HCBT_ACTIVATE, hook|optional },
     { EVENT_SYSTEM_FOREGROUND, winevent_hook|wparam|lparam|optional, 0, 0 },
     { WM_WINDOWPOSCHANGING, sent|wparam|optional, SWP_NOSIZE|SWP_NOMOVE },
+    { WM_QUERYNEWPALETTE, sent|optional },
     { WM_NCACTIVATE, sent|wparam|optional, 1 },
     { WM_ACTIVATE, sent|wparam|optional, 1 },
     { HCBT_SETFOCUS, hook|optional },
@@ -18748,7 +18843,7 @@ static void test_SetParent(void)
 
     SetParent(popup, child);
     flush_events();
-    ok_sequence(WmSetParentSeq_2, "SetParent() visible WS_POPUP", TRUE);
+    ok_sequence(WmSetParentSeq_2, "SetParent() visible WS_POPUP", FALSE);
 
     ok(GetWindowLongA(popup, GWL_STYLE) & WS_VISIBLE, "WS_VISIBLE should be set\n");
     ok(!IsWindowVisible(popup), "IsWindowVisible() should return FALSE\n");
@@ -20483,6 +20578,7 @@ START_TEST(msg)
     test_messages();
     test_setwindowpos();
     test_showwindow();
+    test_recursive_activation();
     invisible_parent_tests();
     test_mdi_messages();
     test_button_messages();
diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index 8dad718..3b4442d 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -5159,15 +5159,65 @@ static void test_window_styles(void)
     }
 }
 
+static HWND root_dialog(HWND hwnd)
+{
+    while ((GetWindowLongA(hwnd, GWL_EXSTYLE) & WS_EX_CONTROLPARENT) &&
+           (GetWindowLongA(hwnd, GWL_STYLE) & (WS_CHILD|WS_POPUP)) == WS_CHILD)
+    {
+        HWND parent = GetParent(hwnd);
+
+        /* simple detector for a window being a dialog */
+        if (!DefDlgProcA(parent, DM_GETDEFID, 0, 0))
+            break;
+
+        hwnd = parent;
+
+        if (!(GetWindowLongA(hwnd, GWL_STYLE) & DS_CONTROL))
+            break;
+    }
+
+    return hwnd;
+}
+
 static INT_PTR WINAPI empty_dlg_proc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     return 0;
 }
 
+static LRESULT expected_id;
+
 static INT_PTR WINAPI empty_dlg_proc3(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
 {
     if (msg == WM_INITDIALOG)
+    {
+        HWND parent = GetParent(hwnd);
+        LRESULT id, ret;
+
+        id = DefDlgProcA(parent, DM_GETDEFID, 0, 0);
+        if (!id || root_dialog(hwnd) == hwnd)
+            parent = 0;
+
+        id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+        if (!parent)
+            ok(id == MAKELONG(IDOK,DC_HASDEFID), "expected (IDOK,DC_HASDEFID), got %08lx\n", id);
+        else
+            ok(id == expected_id, "expected %08lx, got %08lx\n", expected_id, id);
+
+        ret = DefDlgProcA(hwnd, DM_SETDEFID, 0x3333, 0);
+        ok(ret, "DefDlgProc(DM_SETDEFID) failed\n");
+        id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+        ok(id == MAKELONG(0x3333,DC_HASDEFID), "expected (0x3333,DC_HASDEFID), got %08lx\n", id);
+
+        if (parent)
+        {
+            id = DefDlgProcA(parent, DM_GETDEFID, 0, 0);
+            ok(id == MAKELONG(0x3333,DC_HASDEFID), "expected (0x3333,DC_HASDEFID), got %08lx\n", id);
+
+            expected_id = MAKELONG(0x3333,DC_HASDEFID);
+        }
+
         EndDialog(hwnd, 0);
+    }
 
     return 0;
 }
@@ -5186,6 +5236,16 @@ static INT_PTR WINAPI empty_dlg_proc2(HWND hwnd, UINT msg, WPARAM wparam, LPARAM
         struct dialog_param *param = (struct dialog_param *)lparam;
         BOOL parent_is_child;
         HWND disabled_hwnd;
+        LRESULT id, ret;
+
+        id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+        ok(id == MAKELONG(IDOK,DC_HASDEFID), "expected (IDOK,DC_HASDEFID), got %08lx\n", id);
+        ret = DefDlgProcA(hwnd, DM_SETDEFID, 0x2222, 0);
+        ok(ret, "DefDlgProc(DM_SETDEFID) failed\n");
+        id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+        ok(id == MAKELONG(0x2222,DC_HASDEFID), "expected (0x2222,DC_HASDEFID), got %08lx\n", id);
+
+        expected_id = MAKELONG(0x2222,DC_HASDEFID);
 
         parent_is_child = (GetWindowLongA(param->parent, GWL_STYLE) & (WS_POPUP | WS_CHILD)) == WS_CHILD;
 
@@ -5227,6 +5287,25 @@ static INT_PTR WINAPI empty_dlg_proc2(HWND hwnd, UINT msg, WPARAM wparam, LPARAM
         DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
         ok(IsWindowEnabled(hwnd), "wrong state for %p (%08lx)\n", hwnd, style);
 
+        param->dlg_data->style |= DS_CONTROL;
+        DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
+        ok(IsWindowEnabled(hwnd), "wrong state for %p (%08x)\n", hwnd, style);
+
+        param->dlg_data->dwExtendedStyle |= WS_EX_CONTROLPARENT;
+        SetWindowLongA(hwnd, GWL_EXSTYLE, GetWindowLongA(hwnd, GWL_EXSTYLE) | WS_EX_CONTROLPARENT);
+        SetWindowLongA(hwnd, GWL_STYLE, style & ~DS_CONTROL);
+        param->dlg_data->style &= ~DS_CONTROL;
+        DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
+        ok(IsWindowEnabled(hwnd), "wrong state for %p (%08x)\n", hwnd, style);
+
+        SetWindowLongA(hwnd, GWL_STYLE, style | DS_CONTROL);
+        DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
+        ok(IsWindowEnabled(hwnd), "wrong state for %p (%08x)\n", hwnd, style);
+
+        param->dlg_data->style |= DS_CONTROL;
+        DialogBoxIndirectParamA(GetModuleHandleA(NULL), param->dlg_data, hwnd, empty_dlg_proc3, 0);
+        ok(IsWindowEnabled(hwnd), "wrong state for %p (%08x)\n", hwnd, style);
+
         EndDialog(hwnd, 0);
     }
     return 0;
@@ -5245,6 +5324,7 @@ static void check_dialog_style(DWORD style_in, DWORD ex_style_in, DWORD style_ou
     DWORD style, ex_style;
     HWND hwnd, grand_parent = 0, parent = 0;
     struct dialog_param param;
+    LRESULT id, ret;
 
     if (style_in & WS_CHILD)
     {
@@ -5272,6 +5352,13 @@ static void check_dialog_style(DWORD style_in, DWORD ex_style_in, DWORD style_ou
     hwnd = CreateDialogIndirectParamA(GetModuleHandleA(NULL), &dlg_data.dt, parent, empty_dlg_proc, 0);
     ok(hwnd != 0, "dialog creation failed, style %#lx, exstyle %#lx\n", style_in, ex_style_in);
 
+    id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+    ok(id == MAKELONG(IDOK,DC_HASDEFID), "expected (IDOK,DC_HASDEFID), got %08lx\n", id);
+    ret = DefDlgProcA(hwnd, DM_SETDEFID, 0x1111, 0);
+    ok(ret, "DefDlgProc(DM_SETDEFID) failed\n");
+    id = DefDlgProcA(hwnd, DM_GETDEFID, 0, 0);
+    ok(id == MAKELONG(0x1111,DC_HASDEFID), "expected (0x1111,DC_HASDEFID), got %08lx\n", id);
+
     flush_events( TRUE );
 
     style = GetWindowLongA(hwnd, GWL_STYLE);
@@ -9761,7 +9848,7 @@ static void test_FlashWindowEx(void)
 
     SetLastError(0xdeadbeef);
     ret = pFlashWindowEx(&finfo);
-    todo_wine ok(!ret, "previous window state should not be active\n");
+    ok(!ret, "previous window state should not be active\n");
 
     finfo.cbSize = sizeof(FLASHWINFO) - 1;
     SetLastError(0xdeadbeef);
@@ -9812,7 +9899,7 @@ static void test_FlashWindowEx(void)
     finfo.dwFlags = FLASHW_STOP;
     SetLastError(0xdeadbeef);
     ret = pFlashWindowEx(&finfo);
-    ok(prev != ret, "previous window state should be different\n");
+    todo_wine ok(prev != ret, "previous window state should be different\n");
 
     DestroyWindow( hwnd );
 }
diff --git a/dlls/user32/text.c b/dlls/user32/text.c
index 1896627..1c95e8b 100644
--- a/dlls/user32/text.c
+++ b/dlls/user32/text.c
@@ -914,6 +914,15 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
     if (dtp && dtp->cbSize != sizeof(DRAWTEXTPARAMS))
         return 0;
 
+    if (GetGraphicsMode(hdc) == GM_COMPATIBLE)
+    {
+        SIZE window_ext, viewport_ext;
+        GetWindowExtEx(hdc, &window_ext);
+        GetViewportExtEx(hdc, &viewport_ext);
+        if ((window_ext.cy > 0) != (viewport_ext.cy > 0))
+            invert_y = TRUE;
+    }
+
     if (count == -1)
     {
         count = lstrlenW(str);
@@ -923,7 +932,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
             {
                 rect->right = rect->left;
                 if( flags & DT_SINGLELINE)
-                    rect->bottom = rect->top + lh;
+                    rect->bottom = rect->top + (invert_y ? -lh : lh);
                 else
                     rect->bottom = rect->top;
             }
@@ -931,15 +940,6 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
         }
     }
 
-    if (GetGraphicsMode(hdc) == GM_COMPATIBLE)
-    {
-        SIZE window_ext, viewport_ext;
-        GetWindowExtEx(hdc, &window_ext);
-        GetViewportExtEx(hdc, &viewport_ext);
-        if ((window_ext.cy > 0) != (viewport_ext.cy > 0))
-            invert_y = TRUE;
-    }
-
     if (dtp)
     {
         lmargin = dtp->iLeftMargin;
@@ -987,9 +987,10 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
 
 	if (flags & DT_SINGLELINE)
 	{
-	    if (flags & DT_VCENTER) y = rect->top +
-	    	(rect->bottom - rect->top) / 2 - size.cy / 2;
-	    else if (flags & DT_BOTTOM) y = rect->bottom - size.cy;
+            if (flags & DT_VCENTER)
+                y = rect->top + (rect->bottom - rect->top) / 2 + (invert_y ? (size.cy / 2) : (-size.cy / 2));
+            else if (flags & DT_BOTTOM)
+                y = rect->bottom + (invert_y ? 0 : -size.cy);
         }
 
 	if (!(flags & DT_CALCRECT))
@@ -1047,10 +1048,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
 	else if (size.cx > max_width)
 	    max_width = size.cx;
 
-        if (invert_y)
-	    y -= lh;
-        else
-	    y += lh;
+        y += invert_y ? -lh : lh;
         if (dtp)
             dtp->uiLengthDrawn += len;
     }
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index 0427308..5466c0c 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -507,7 +507,7 @@
 @ stdcall LoadImageA(long str long long long long)
 @ stdcall LoadImageW(long wstr long long long long)
 @ stdcall LoadKeyboardLayoutA(str long)
-# @ stub LoadKeyboardLayoutEx
+@ stdcall LoadKeyboardLayoutEx(long wstr long)
 @ stdcall LoadKeyboardLayoutW(wstr long)
 @ stdcall LoadLocalFonts()
 @ stdcall LoadMenuA(long str)
diff --git a/dlls/vbscript/interp.c b/dlls/vbscript/interp.c
index 937cdaf..1d760ea 100644
--- a/dlls/vbscript/interp.c
+++ b/dlls/vbscript/interp.c
@@ -1501,6 +1501,7 @@ static HRESULT interp_newenum(exec_ctx_t *ctx)
         V_UNKNOWN(r) = (IUnknown*)iter;
         break;
     }
+    case VT_BSTR|VT_ARRAY:
     case VT_VARIANT|VT_ARRAY:
     case VT_VARIANT|VT_ARRAY|VT_BYREF: {
         IEnumVARIANT *iter;
diff --git a/dlls/vbscript/tests/lang.vbs b/dlls/vbscript/tests/lang.vbs
index 3c6ce65..e329226 100644
--- a/dlls/vbscript/tests/lang.vbs
+++ b/dlls/vbscript/tests/lang.vbs
@@ -2239,4 +2239,22 @@ f1 not 1 = 0
 
 arr (0) = 2 xor -2
 
+function wmi_array_bstr()
+const HKEY_LOCAL_MACHINE = &H80000002
+Dim oReg
+
+Set oReg = GetObject("winmgmts:{impersonationLevel=impersonate}!\\.\root\default:StdRegProv")
+
+Dim strKeyPath, strSubkey, arrSubKeys
+strKeyPath = "Software\Microsoft\NET Framework Setup\NDP"
+oReg.EnumKey HKEY_LOCAL_MACHINE, strKeyPath, arrSubKeys
+
+Call ok(getVT(arrSubKeys) = "VT_ARRAY|VT_VARIANT*", "getVT(arrSubKeys) = " & getVT(arrSubKeys))
+For Each strSubkey In arrSubKeys
+Next
+end function
+
+Call wmi_array_bstr()
+
+
 reportSuccess()
diff --git a/dlls/vbscript/tests/run.c b/dlls/vbscript/tests/run.c
index 8aaafbe..e7ef7f6 100644
--- a/dlls/vbscript/tests/run.c
+++ b/dlls/vbscript/tests/run.c
@@ -187,6 +187,11 @@ static const char *vt2a(VARIANT *v)
         sprintf(buf, "%s*", vt2a(V_BYREF(v)));
         return buf;
     }
+    else if(V_VT(v) == (VT_BYREF|VT_VARIANT|VT_ARRAY)) {
+        static char buf[64];
+        sprintf(buf, "%s*", vt2a(V_BYREF(v)));
+        return buf;
+    }
 
     switch(V_VT(v)) {
     case VT_EMPTY:
diff --git a/dlls/vbscript/utils.c b/dlls/vbscript/utils.c
index 4bfc2c6..9ad4f2a 100644
--- a/dlls/vbscript/utils.c
+++ b/dlls/vbscript/utils.c
@@ -110,11 +110,20 @@ static HRESULT WINAPI safearray_iter_IEnumVARIANT_Next(IEnumVARIANT *iface,
     if(!This->sa->cLocks)
         ERR("SAFEARRAY not locked\n");
 
-    v = (VARIANT*)(((BYTE*)This->sa->pvData) + This->i * This->sa->cbElements);
-    V_VT(rgVar) = VT_EMPTY;
-    hres = VariantCopy(rgVar, v);
-    if(FAILED(hres))
-        return hres;
+    if (This->sa->fFeatures & FADF_VARIANT)
+    {
+        v = (VARIANT*)(((BYTE*)This->sa->pvData) + This->i * This->sa->cbElements);
+        V_VT(rgVar) = VT_EMPTY;
+        hres = VariantCopy(rgVar, v);
+        if(FAILED(hres))
+            return hres;
+    }
+    else if (This->sa->fFeatures & FADF_BSTR)
+    {
+        BSTR bstr  = *(BSTR*)(((BYTE*)This->sa->pvData) + This->i * This->sa->cbElements);
+        V_VT(rgVar) = VT_BSTR;
+        V_BSTR(rgVar) = SysAllocString(bstr);
+    }
 
     This->i++;
     if(pCeltFetched)
@@ -169,11 +178,6 @@ HRESULT create_safearray_iter(SAFEARRAY *sa, BOOL owned, IEnumVARIANT **ev)
     safearray_iter *iter;
     HRESULT hres;
 
-    if(sa && !(sa->fFeatures & FADF_VARIANT)) {
-        FIXME("enumeration not supported: %x\n", sa->fFeatures);
-        return E_NOTIMPL;
-    }
-
     iter = malloc(sizeof(*iter));
     if(!iter)
         return E_OUTOFMEMORY;
diff --git a/dlls/vbscript/vbdisp.c b/dlls/vbscript/vbdisp.c
index 0ede0cf..eb0da45 100644
--- a/dlls/vbscript/vbdisp.c
+++ b/dlls/vbscript/vbdisp.c
@@ -500,7 +500,7 @@ static IDispatchExVtbl DispatchExVtbl = {
 static inline vbdisp_t *unsafe_impl_from_IDispatch(IDispatch *iface)
 {
     return iface->lpVtbl == (IDispatchVtbl*)&DispatchExVtbl
-        ? CONTAINING_RECORD(iface, vbdisp_t, IDispatchEx_iface)
+        ? CONTAINING_RECORD((IDispatchEx *)iface, vbdisp_t, IDispatchEx_iface)
         : NULL;
 }
 
diff --git a/dlls/vcomp/main.c b/dlls/vcomp/main.c
index 63ec050..4cde038 100644
--- a/dlls/vcomp/main.c
+++ b/dlls/vcomp/main.c
@@ -1034,6 +1034,26 @@ double CDECL omp_get_wtime(void)
     return GetTickCount() / 1000.0;
 }
 
+/*****************************************************
+*      omp_get_wtick - Taken from:
+*      https://gist.github.com/Randl/45bcca59720f661fa033a67d5f44bff0
+*/
+double CDECL omp_get_wtick (void)
+{
+     /*return GetTickCount();*/
+    FILETIME createTime;
+    FILETIME exitTime;
+    FILETIME kernelTime;
+    FILETIME userTime;
+    ULARGE_INTEGER li;
+
+    GetProcessTimes(GetCurrentProcess(), &createTime, &exitTime, &kernelTime, &userTime);
+    li.LowPart = userTime.dwLowDateTime;
+    li.HighPart = userTime.dwHighDateTime;
+
+    return (double)li.QuadPart / 10000000.0;
+}
+
 void CDECL omp_set_dynamic(int val)
 {
     TRACE("(%d): stub\n", val);
@@ -1486,6 +1506,77 @@ void CDECL _vcomp_for_dynamic_init(unsigned int flags, unsigned int first, unsig
     }
 }
 
+void CDECL _vcomp_for_dynamic_init_i8(ULONG64 flags, ULONG64 first, ULONG64 last,
+                                   ULONG64 step, ULONG64 chunksize)
+{
+    ULONG64 iterations, per_thread, remaining;
+    struct vcomp_thread_data *thread_data = vcomp_init_thread_data();
+    struct vcomp_team_data *team_data = thread_data->team;
+    struct vcomp_task_data *task_data = thread_data->task;
+    LONG64 num_threads = team_data ? team_data->num_threads : 1;
+    LONG64 thread_num = thread_data->thread_num;
+    unsigned int type = flags & ~VCOMP_DYNAMIC_FLAGS_INCREMENT;
+
+    TRACE("(%llu, %llu, %llu, %lld, %llu)\n", flags, first, last, step, chunksize);
+
+    if (step <= 0)
+    {
+        thread_data->dynamic_type = 0;
+        return;
+    }
+
+    if (flags & VCOMP_DYNAMIC_FLAGS_INCREMENT)
+        iterations = 1 + (last - first) / step;
+    else
+    {
+        iterations = 1 + (first - last) / step;
+        step *= -1;
+    }
+
+    if (type == VCOMP_DYNAMIC_FLAGS_STATIC)
+    {
+        per_thread = iterations / num_threads;
+        remaining  = iterations - per_thread * num_threads;
+
+        if (thread_num < remaining)
+            per_thread++;
+        else if (per_thread)
+            first += remaining * step;
+        else
+        {
+            thread_data->dynamic_type = 0;
+            return;
+        }
+
+        thread_data->dynamic_type   = VCOMP_DYNAMIC_FLAGS_STATIC;
+        thread_data->dynamic_begin  = first + per_thread * thread_num * step;
+        thread_data->dynamic_end    = thread_data->dynamic_begin + (per_thread - 1) * step;
+    }
+    else
+    {
+        if (type != VCOMP_DYNAMIC_FLAGS_CHUNKED &&
+            type != VCOMP_DYNAMIC_FLAGS_GUIDED)
+        {
+            FIXME("unsupported flags %llu\n", flags);
+            type = VCOMP_DYNAMIC_FLAGS_GUIDED;
+        }
+
+        EnterCriticalSection(&vcomp_section);
+        thread_data->dynamic++;
+        thread_data->dynamic_type = type;
+        if ((LONG64)(thread_data->dynamic - task_data->dynamic) > 0)
+        {
+            task_data->dynamic              = thread_data->dynamic;
+            task_data->dynamic_first        = first;
+            task_data->dynamic_last         = last;
+            task_data->dynamic_iterations   = iterations;
+            task_data->dynamic_step         = step;
+            task_data->dynamic_chunksize    = chunksize;
+        }
+        LeaveCriticalSection(&vcomp_section);
+    }
+}
+
 int CDECL _vcomp_for_dynamic_next(unsigned int *begin, unsigned int *end)
 {
     struct vcomp_thread_data *thread_data = vcomp_init_thread_data();
@@ -1530,6 +1621,50 @@ int CDECL _vcomp_for_dynamic_next(unsigned int *begin, unsigned int *end)
     return 0;
 }
 
+LONG64 CDECL _vcomp_for_dynamic_next_i8(LONG64 *begin, LONG64 *end)
+{
+    struct vcomp_thread_data *thread_data = vcomp_init_thread_data();
+    struct vcomp_task_data *task_data = thread_data->task;
+    struct vcomp_team_data *team_data = thread_data->team;
+    LONG64 num_threads = team_data ? team_data->num_threads : 1;
+
+    TRACE("(%p, %p)\n", begin, end);
+
+    if (thread_data->dynamic_type == VCOMP_DYNAMIC_FLAGS_STATIC)
+    {
+        *begin = thread_data->dynamic_begin;
+        *end   = thread_data->dynamic_end;
+        thread_data->dynamic_type = 0;
+        return 1;
+    }
+    else if (thread_data->dynamic_type == VCOMP_DYNAMIC_FLAGS_CHUNKED ||
+             thread_data->dynamic_type == VCOMP_DYNAMIC_FLAGS_GUIDED)
+    {
+        unsigned int iterations = 0;
+        EnterCriticalSection(&vcomp_section);
+        if (thread_data->dynamic == task_data->dynamic &&
+            task_data->dynamic_iterations != 0)
+        {
+            iterations = min(task_data->dynamic_iterations, task_data->dynamic_chunksize);
+            if (thread_data->dynamic_type == VCOMP_DYNAMIC_FLAGS_GUIDED &&
+                task_data->dynamic_iterations > num_threads * task_data->dynamic_chunksize)
+            {
+                iterations = (task_data->dynamic_iterations + num_threads - 1) / num_threads;
+            }
+            *begin = task_data->dynamic_first;
+            *end   = task_data->dynamic_first + (iterations - 1) * task_data->dynamic_step;
+            task_data->dynamic_iterations -= iterations;
+            task_data->dynamic_first      += iterations * task_data->dynamic_step;
+            if (!task_data->dynamic_iterations)
+                *end = task_data->dynamic_last;
+        }
+        LeaveCriticalSection(&vcomp_section);
+        return iterations != 0;
+    }
+
+    return 0;
+}
+
 int CDECL omp_in_parallel(void)
 {
     TRACE("()\n");
diff --git a/dlls/vcomp/vcomp.spec b/dlls/vcomp/vcomp.spec
index fb67146..09bf455 100644
--- a/dlls/vcomp/vcomp.spec
+++ b/dlls/vcomp/vcomp.spec
@@ -56,9 +56,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64)
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr)
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -96,7 +96,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick()
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp100/vcomp100.spec b/dlls/vcomp100/vcomp100.spec
index fb67146..9aa43e3 100644
--- a/dlls/vcomp100/vcomp100.spec
+++ b/dlls/vcomp100/vcomp100.spec
@@ -56,9 +56,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -96,7 +96,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp110/vcomp110.spec b/dlls/vcomp110/vcomp110.spec
index e1cb8ab..d8b4d3e 100644
--- a/dlls/vcomp110/vcomp110.spec
+++ b/dlls/vcomp110/vcomp110.spec
@@ -57,9 +57,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -97,7 +97,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp120/vcomp120.spec b/dlls/vcomp120/vcomp120.spec
index e1cb8ab..d8b4d3e 100644
--- a/dlls/vcomp120/vcomp120.spec
+++ b/dlls/vcomp120/vcomp120.spec
@@ -57,9 +57,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -97,7 +97,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp140/vcomp140.spec b/dlls/vcomp140/vcomp140.spec
index e1cb8ab..d8b4d3e 100644
--- a/dlls/vcomp140/vcomp140.spec
+++ b/dlls/vcomp140/vcomp140.spec
@@ -57,9 +57,9 @@
 @ cdecl _vcomp_enter_critsect(ptr)
 @ cdecl _vcomp_flush()
 @ cdecl _vcomp_for_dynamic_init(long long long long long)
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr)
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end()
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr)
@@ -97,7 +97,7 @@
 @ cdecl omp_get_num_procs()
 @ cdecl omp_get_num_threads()
 @ cdecl omp_get_thread_num()
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime()
 @ cdecl omp_in_parallel()
 @ cdecl omp_init_lock(ptr)
diff --git a/dlls/vcomp90/vcomp90.spec b/dlls/vcomp90/vcomp90.spec
index 9fac400..563f539 100644
--- a/dlls/vcomp90/vcomp90.spec
+++ b/dlls/vcomp90/vcomp90.spec
@@ -56,9 +56,9 @@
 @ cdecl _vcomp_enter_critsect(ptr) vcomp._vcomp_enter_critsect
 @ cdecl _vcomp_flush() vcomp._vcomp_flush
 @ cdecl _vcomp_for_dynamic_init(long long long long long) vcomp._vcomp_for_dynamic_init
-@ stub _vcomp_for_dynamic_init_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_init_i8(int64 int64 int64 int64 int64) vcomp._vcomp_for_dynamic_init_i8
 @ cdecl _vcomp_for_dynamic_next(ptr ptr) vcomp._vcomp_for_dynamic_next
-@ stub _vcomp_for_dynamic_next_i8
+@ cdecl -arch=win64 _vcomp_for_dynamic_next_i8(ptr ptr) vcomp._vcomp_for_dynamic_next_i8
 @ cdecl _vcomp_for_static_end() vcomp._vcomp_for_static_end
 @ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr) vcomp._vcomp_for_static_init
 @ cdecl _vcomp_for_static_init_i8(int64 int64 int64 int64 ptr ptr ptr ptr ptr) vcomp._vcomp_for_static_init_i8
@@ -96,7 +96,7 @@
 @ cdecl omp_get_num_procs() vcomp.omp_get_num_procs
 @ cdecl omp_get_num_threads() vcomp.omp_get_num_threads
 @ cdecl omp_get_thread_num() vcomp.omp_get_thread_num
-@ stub omp_get_wtick
+@ cdecl omp_get_wtick() vcomp.omp_get_wtick
 @ cdecl omp_get_wtime() vcomp.omp_get_wtime
 @ cdecl omp_in_parallel() vcomp.omp_in_parallel
 @ cdecl omp_init_lock(ptr) vcomp.omp_init_lock
diff --git a/dlls/version/tests/info.c b/dlls/version/tests/info.c
index 61ff05b..30bf088 100644
--- a/dlls/version/tests/info.c
+++ b/dlls/version/tests/info.c
@@ -572,6 +572,129 @@ static void test_VerQueryValueA(void)
     HeapFree(GetProcessHeap(), 0, ver);
 }
 
+static void test_VerQueryValue_InvalidLength(void)
+{
+    /* this buffer is created with the reactos resource compiler from this resource:
+#include "winver.h"
+
+VS_VERSION_INFO VERSIONINFO
+FILEVERSION    1,0,0,0
+PRODUCTVERSION 1,0,0,0
+FILEFLAGSMASK  63
+FILEFLAGS      0
+FILEOS         VOS_UNKNOWN
+FILETYPE       VFT_APP
+FILESUBTYPE    VFT2_UNKNOWN
+{
+    BLOCK "StringFileInfo"
+    {
+    }
+}
+*/
+    char preparedbuffer[] = {
+        /* VS_VERSION_INFO_STRUCT32 */
+        0x80, 0x00,     /* wLength */
+        0x34, 0x00,     /* wValueLength */
+        0x00, 0x00,     /* wType */
+        /* L"VS_VERSION_INFO" + DWORD alignment */
+        0x56, 0x00, 0x53, 0x00, 0x5f, 0x00, 0x56, 0x00, 0x45, 0x00, 0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4f,
+        0x00, 0x4e, 0x00, 0x5f, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x46, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+        /* VS_FIXEDFILEINFO */
+        0xbd, 0x04, 0xef, 0xfe,     /* dwSignature */
+        0x00, 0x00, 0x01, 0x00,     /* dwStrucVersion */
+        0x00, 0x00, 0x01, 0x00,     /* dwFileVersionMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileVersionLS */
+        0x00, 0x00, 0x01, 0x00,     /* dwProductVersionMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwProductVersionLS */
+        0x3f, 0x00, 0x00, 0x00,     /* dwFileFlagsMask */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileFlags */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileOS */
+        0x01, 0x00, 0x00, 0x00,     /* dwFileType */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileSubtype */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileDateMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileDateLS */
+
+        /* first child: */
+            0x24, 0x00,     /* wLength */
+            0x00, 0x00,     /* wValueLength */
+            0x01, 0x00,     /* wType */
+            /* L"StringFileInfo" + DWORD alignment */
+            0x53, 0x00, 0x74, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x46, 0x00, 0x69, 0x00,
+            0x6c, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x00, 0x00,
+            /* "FE2X" */
+            0x46, 0x45, 0x32, 0x58,
+
+            /* Extra bytes allocated for W->A conversions. */
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+    };
+    char *p;
+    UINT len, ret;
+    WCHAR FileDescriptionW[] = { '\\', '\\', 'S', 't', 'r', 'i', 'n', 'g', 'F', 'i', 'l', 'e', 'I', 'n', 'f', 'o', 0 };
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "\\StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "\\\\StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    /* also test the W versions. */
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW + 2, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW + 1, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %lu\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+}
+
 static void test_extra_block(void)
 {
     WORD extra_block[] = {
@@ -731,6 +854,7 @@ START_TEST(info)
     test_info();
     test_32bit_win();
     test_VerQueryValueA();
+    test_VerQueryValue_InvalidLength();
     test_extra_block();
     test_GetFileVersionInfoEx();
 }
diff --git a/dlls/wbemdisp/locator.c b/dlls/wbemdisp/locator.c
index c3e0c86..dbdf4f2 100644
--- a/dlls/wbemdisp/locator.c
+++ b/dlls/wbemdisp/locator.c
@@ -1292,6 +1292,90 @@ static HRESULT WINAPI object_Invoke(
         memset( params, 0, sizeof(*params) );
         return IWbemClassObject_Get( object->object, name, 0, result, NULL, NULL );
     }
+    else if (flags == DISPATCH_METHOD)
+    {
+        IWbemClassObject *sig_in, *in, *out = NULL;
+        VARIANT path;
+        int i;
+        BSTR param;
+
+        if (!params->cArgs || !params->rgvarg)
+        {
+            WARN( "Missing property value\n" );
+            return E_INVALIDARG;
+        }
+
+        hr = IWbemClassObject_GetMethod( object->object, name, 0, &sig_in, NULL );
+        if (FAILED(hr))
+            return hr;
+
+        hr = IWbemClassObject_SpawnInstance( sig_in, 0, &in );
+        IWbemClassObject_Release( sig_in );
+        if (FAILED(hr))
+            return hr;
+
+        IWbemClassObject_BeginEnumeration( in, 0 );
+        i = params->cArgs - 1;
+        while (IWbemClassObject_Next( in, 0, &param, NULL, NULL, NULL ) == S_OK)
+        {
+            TRACE("Param %s = %s\n", debugstr_w(param), debugstr_variant(&params->rgvarg[i]));
+            hr = IWbemClassObject_Put( in, param, 0, &params->rgvarg[i], 0 );
+            SysFreeString( param );
+            if (FAILED(hr))
+            {
+                WARN("Failed to set paramter\n");
+                break;
+            }
+            i--;
+        }
+        IWbemClassObject_EndEnumeration( in );
+
+        V_VT( &path ) = VT_EMPTY;
+        hr = IWbemClassObject_Get( object->object, L"__PATH", 0, &path, NULL, NULL );
+        if (FAILED(hr))
+        {
+            IWbemClassObject_Release( in );
+            return hr;
+        }
+
+        hr = IWbemServices_ExecMethod( object->services->services, V_BSTR(&path), name, 0, NULL, in, &out, NULL );
+        IWbemClassObject_Release( in );
+        VariantClear(&path);
+        if (FAILED(hr))
+            return hr;
+
+        IWbemClassObject_BeginEnumeration( out, 0 );
+        while (IWbemClassObject_Next( out, 0, &param, NULL, NULL, NULL ) == S_OK)
+        {
+            TRACE("Output parameter %s\n", debugstr_w(param));
+
+            if (i < 0)
+            {
+                ERR("Unexpected output parameter\n");
+                hr = E_FAIL;
+                break;
+            }
+            if (!lstrcmpiW(param, L"ReturnValue"))
+            {
+                SysFreeString( param );
+                continue;
+            }
+            hr = IWbemClassObject_Get( out, param, 0, V_VARIANTREF(&params->rgvarg[i]), NULL, NULL );
+            if (FAILED(hr))
+            {
+                ERR("Failed to get output paramter\n");
+                break;
+            }
+
+            SysFreeString( param );
+            i--;
+        }
+        IWbemClassObject_EndEnumeration( out );
+
+        IWbemClassObject_Release( out );
+
+        return hr;
+    }
     else if (flags == DISPATCH_PROPERTYPUT)
     {
         if (!params->cArgs || !params->rgvarg)
@@ -1657,7 +1741,7 @@ static struct object *unsafe_object_impl_from_IDispatch(IDispatch *iface)
         FIXME( "External implementations are not supported.\n" );
         return NULL;
     }
-    return CONTAINING_RECORD(iface, struct object, ISWbemObject_iface);
+    return CONTAINING_RECORD((ISWbemObject *)iface, struct object, ISWbemObject_iface);
 }
 
 static HRESULT SWbemObject_create( struct services *services, IWbemClassObject *wbem_object,
@@ -3492,7 +3576,7 @@ static struct namedvalueset *unsafe_valueset_impl_from_IDispatch(IDispatch *ifac
         FIXME( "External implementations are not supported.\n" );
         return NULL;
     }
-    return CONTAINING_RECORD(iface, struct namedvalueset, ISWbemNamedValueSet_iface);
+    return CONTAINING_RECORD((ISWbemNamedValueSet*)iface, struct namedvalueset, ISWbemNamedValueSet_iface);
 }
 
 HRESULT SWbemNamedValueSet_create( void **obj )
diff --git a/dlls/wbemprox/query.c b/dlls/wbemprox/query.c
index 1087e27..666a963 100644
--- a/dlls/wbemprox/query.c
+++ b/dlls/wbemprox/query.c
@@ -1327,6 +1327,9 @@ HRESULT to_longlong( VARIANT *var, LONGLONG *val, CIMTYPE *type )
         *val = 0;
         return S_OK;
     }
+    if (V_VT( var ) & VT_BYREF)
+        var = V_VARIANTREF( var );
+
     if (V_VT( var ) & VT_ARRAY)
     {
         *val = (INT_PTR)to_array( var, type );
diff --git a/dlls/win32u/dce.c b/dlls/win32u/dce.c
index 5df3055..138678b 100644
--- a/dlls/win32u/dce.c
+++ b/dlls/win32u/dce.c
@@ -1734,10 +1734,13 @@ INT WINAPI NtUserScrollWindowEx( HWND hwnd, INT dx, INT dy, const RECT *rect,
     rdw_flags = (flags & SW_ERASE) && (flags & SW_INVALIDATE) ?
         RDW_INVALIDATE | RDW_ERASE  : RDW_INVALIDATE;
 
-    if (!is_window_drawable( hwnd, TRUE )) return ERROR;
     hwnd = get_full_window_handle( hwnd );
 
-    get_client_rect( hwnd, &rc );
+    if (!is_window_drawable( hwnd, TRUE ))
+        SetRectEmpty( &rc );
+    else
+        get_client_rect( hwnd, &rc );
+
     if (clip_rect) intersect_rect( &cliprc, &rc, clip_rect );
     else cliprc = rc;
 
diff --git a/dlls/win32u/dibdrv/graphics.c b/dlls/win32u/dibdrv/graphics.c
index 009143b..efae778 100644
--- a/dlls/win32u/dibdrv/graphics.c
+++ b/dlls/win32u/dibdrv/graphics.c
@@ -310,6 +310,60 @@ static int get_arc_points( int arc_dir, const RECT *rect, POINT start, POINT end
     return pos - count;
 }
 
+/*
+ Check if matrix has uniform scale and shear and contains a rotation.
+*/
+static BOOL xform_has_rotate_and_uniform_scale_and_shear( const XFORM *xform )
+{
+    return xform->eM21 != 0 && xform->eM11 == xform->eM22 && -xform->eM21 == xform->eM12;
+}
+
+/*
+ Decompose rotation and translation from matrix xform.
+
+ If parameter rotation_and_translation is != NULL, save rotation and translation into it.
+
+ Note: The current implementation only works on matrixes with uniform scale and shear,
+       which has to be checked by a call to xform_has_rotate_and_uniform_scale_and_shear().
+       Hints how to get unique values for non-uniform matrixes are welcome.
+*/
+static BOOL xform_decompose_rotation_and_translation( XFORM *xform, XFORM *rotation_and_translation )
+{
+    XFORM inverse_matrix_scale;
+    XFORM origin_matrix = *xform;
+    double determinant = 0;
+
+    /* xform = xfrom-transposed * xform */
+    xform->eM11 = sqrt( xform->eM11 * xform->eM11 + xform->eM21 * xform->eM21 );
+    xform->eM22 = sqrt( xform->eM12 * xform->eM12 + xform->eM22 * xform->eM22 );
+    xform->eM12 = 0;
+    xform->eM21 = 0;
+    xform->eDx = 0;
+    xform->eDy = 0;
+
+    if ( rotation_and_translation == NULL )
+        return TRUE;
+
+    if ( xform->eM11 == 0 || xform->eM22 == 0 )
+        return FALSE;
+
+    determinant = xform->eM11 * xform->eM22;
+
+    inverse_matrix_scale.eM11 = xform->eM22 / determinant;
+    inverse_matrix_scale.eM12 = 0;
+    inverse_matrix_scale.eM21 = 0;
+    inverse_matrix_scale.eM22 = xform->eM11 / determinant;
+
+    /* calculate the rotation matrix */
+    rotation_and_translation->eM11 = inverse_matrix_scale.eM11 * origin_matrix.eM11;
+    rotation_and_translation->eM12 = inverse_matrix_scale.eM11 * origin_matrix.eM12;
+    rotation_and_translation->eM21 = inverse_matrix_scale.eM22 * origin_matrix.eM12 * -1;
+    rotation_and_translation->eM22 = inverse_matrix_scale.eM22 * origin_matrix.eM22;
+    rotation_and_translation->eDx = origin_matrix.eDx;
+    rotation_and_translation->eDy = origin_matrix.eDy;
+    return TRUE;
+}
+
 /* backend for arc functions; extra_lines is -1 for ArcTo, 0 for Arc, 1 for Chord, 2 for Pie */
 static BOOL draw_arc( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
                       INT start_x, INT start_y, INT end_x, INT end_y, INT extra_lines )
@@ -322,6 +376,22 @@ static BOOL draw_arc( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
     BOOL ret = TRUE;
     HRGN outline = 0, interior = 0;
 
+    BOOL exclude_rotation = FALSE;
+    XFORM old;
+    XFORM rotation_and_translation;
+    if (dc->attr->graphics_mode == GM_ADVANCED)
+    {
+        XFORM xf;
+        NtGdiGetTransform( pdev->dev.hdc, 0x203, &old );
+        xf = old;
+        if (xform_has_rotate_and_uniform_scale_and_shear( &xf ) &&
+            xform_decompose_rotation_and_translation( &xf, &rotation_and_translation ))
+        {
+            NtGdiModifyWorldTransform( pdev->dev.hdc, &xf, MWT_SET );
+            exclude_rotation = TRUE;
+        }
+    }
+
     if (!get_pen_device_rect( dc, pdev, &rect, left, top, right, bottom )) return TRUE;
 
     width = rect.right - rect.left;
@@ -355,6 +425,16 @@ static BOOL draw_arc( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
         points[count].y = rect.top + height / 2;
         count++;
     }
+
+    if (exclude_rotation == TRUE)
+    {
+        NtGdiModifyWorldTransform( pdev->dev.hdc, &rotation_and_translation, MWT_SET );
+        /* apply rotation and translation to calculated points */
+        NtGdiTransformPoints( dev->hdc, points, points, count, NtGdiLPtoDP );
+        /* restore origin matrix */
+        NtGdiModifyWorldTransform( pdev->dev.hdc, &old, MWT_SET );
+    }
+
     if (count < 2)
     {
         free( points );
@@ -1455,6 +1535,23 @@ BOOL dibdrv_RoundRect( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
     BOOL ret = TRUE;
     HRGN outline = 0, interior = 0;
 
+    BOOL exclude_rotation_translation = FALSE;
+    XFORM old;
+    XFORM rotation_and_translation;
+
+    if (dc->attr->graphics_mode == GM_ADVANCED)
+    {
+        XFORM xf;
+        NtGdiGetTransform( pdev->dev.hdc, 0x203, &old );
+        xf = old;
+        if (xform_has_rotate_and_uniform_scale_and_shear( &xf ) &&
+            xform_decompose_rotation_and_translation( &xf, &rotation_and_translation ))
+        {
+            NtGdiModifyWorldTransform( pdev->dev.hdc, &xf, MWT_SET );
+            exclude_rotation_translation = TRUE;
+        }
+    }
+
     if (!get_pen_device_rect( dc, pdev, &rect, left, top, right, bottom )) return TRUE;
 
     pt[0].x = pt[0].y = 0;
@@ -1475,23 +1572,6 @@ BOOL dibdrv_RoundRect( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
         return FALSE;
     }
 
-    if (pdev->brush.style != BS_NULL &&
-        !(interior = NtGdiCreateRoundRectRgn( rect.left, rect.top, rect.right + 1, rect.bottom + 1,
-                                              ellipse_width, ellipse_height )))
-    {
-        free( points );
-        if (outline) NtGdiDeleteObjectApp( outline );
-        return FALSE;
-    }
-
-    /* if not using a region, paint the interior first so the outline can overlap it */
-    if (interior && !outline)
-    {
-        ret = brush_region( pdev, interior );
-        NtGdiDeleteObjectApp( interior );
-        interior = 0;
-    }
-
     count = ellipse_first_quadrant( ellipse_width, ellipse_height, points );
 
     if (dc->attr->arc_direction == AD_CLOCKWISE)
@@ -1535,13 +1615,37 @@ BOOL dibdrv_RoundRect( PHYSDEV dev, INT left, INT top, INT right, INT bottom,
     }
     count = end + 1;
 
+    if (exclude_rotation_translation == TRUE)
+    {
+        NtGdiModifyWorldTransform( pdev->dev.hdc, &rotation_and_translation, MWT_SET );
+        /* apply rotation and translation to calculated points */
+        NtGdiTransformPoints( dev->hdc, points, points, count, NtGdiLPtoDP );
+        /* restore origin matrix */
+        NtGdiModifyWorldTransform( pdev->dev.hdc, &old, MWT_SET );
+    }
+
+    if (pdev->brush.style != BS_NULL &&
+        !(interior = ULongToHandle(NtGdiPolyPolyDraw( ULongToHandle(ALTERNATE), points, (const UINT *)&count, 1, NtGdiPolyPolygonRgn ))))
+    {
+        free( points );
+        if (outline) NtGdiDeleteObjectApp( outline );
+            return FALSE;
+    }
+
+    /* if not using a region, paint the interior first so the outline can overlap it */
+    if (interior && !outline)
+    {
+        ret = brush_region( pdev, interior );
+        NtGdiDeleteObjectApp( interior );
+        interior = 0;
+    }
+
     reset_dash_origin( pdev );
     pdev->pen_lines( pdev, count, points, TRUE, outline );
     add_pen_lines_bounds( pdev, count, points, outline );
 
     if (interior)
     {
-        NtGdiCombineRgn( interior, interior, outline, RGN_DIFF );
         ret = brush_region( pdev, interior );
         NtGdiDeleteObjectApp( interior );
     }
diff --git a/dlls/win32u/driver.c b/dlls/win32u/driver.c
index 7fcdbc4..17460a0 100644
--- a/dlls/win32u/driver.c
+++ b/dlls/win32u/driver.c
@@ -868,6 +868,10 @@ static BOOL nulldrv_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
                         hdc, rect.left - dx, rect.top - dy, SRCCOPY, 0, 0 );
 }
 
+static void nulldrv_SetActiveWindow( HWND hwnd )
+{
+}
+
 static void nulldrv_SetCapture( HWND hwnd, UINT flags )
 {
 }
@@ -954,6 +958,11 @@ static struct opengl_funcs *nulldrv_wine_get_wgl_driver( UINT version )
     return (void *)-1;
 }
 
+static void nulldrv_UpdateCandidatePos( HWND hwnd, const RECT *caret_rect )
+{
+
+}
+
 static void nulldrv_ThreadDetach( void )
 {
 }
@@ -1313,6 +1322,7 @@ static const struct user_driver_funcs lazy_load_driver =
     nulldrv_ProcessEvents,
     nulldrv_ReleaseDC,
     nulldrv_ScrollDC,
+    nulldrv_SetActiveWindow,
     nulldrv_SetCapture,
     loaderdrv_SetDesktopWindow,
     nulldrv_SetFocus,
@@ -1334,6 +1344,7 @@ static const struct user_driver_funcs lazy_load_driver =
     loaderdrv_wine_get_vulkan_driver,
     /* opengl support */
     nulldrv_wine_get_wgl_driver,
+    nulldrv_UpdateCandidatePos,
     /* thread management */
     nulldrv_ThreadDetach,
 };
@@ -1399,6 +1410,7 @@ void __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT version
     SET_USER_FUNC(ProcessEvents);
     SET_USER_FUNC(ReleaseDC);
     SET_USER_FUNC(ScrollDC);
+    SET_USER_FUNC(SetActiveWindow);
     SET_USER_FUNC(SetCapture);
     SET_USER_FUNC(SetDesktopWindow);
     SET_USER_FUNC(SetFocus);
@@ -1417,6 +1429,7 @@ void __wine_set_user_driver( const struct user_driver_funcs *funcs, UINT version
     SET_USER_FUNC(SystemParametersInfo);
     SET_USER_FUNC(wine_get_vulkan_driver);
     SET_USER_FUNC(wine_get_wgl_driver);
+    SET_USER_FUNC(UpdateCandidatePos);
     SET_USER_FUNC(ThreadDetach);
 #undef SET_USER_FUNC
 
diff --git a/dlls/win32u/input.c b/dlls/win32u/input.c
index ef8d564..bd1739f 100644
--- a/dlls/win32u/input.c
+++ b/dlls/win32u/input.c
@@ -664,6 +664,7 @@ UINT WINAPI NtUserSendInput( UINT count, INPUT *inputs, int size )
 {
     UINT i;
     NTSTATUS status = STATUS_SUCCESS;
+    RAWINPUT rawinput;
 
     if (size != sizeof(INPUT))
     {
@@ -693,7 +694,7 @@ UINT WINAPI NtUserSendInput( UINT count, INPUT *inputs, int size )
             update_mouse_coords( &input );
             /* fallthrough */
         case INPUT_KEYBOARD:
-            status = send_hardware_message( 0, &input, NULL, SEND_HWMSG_INJECTED );
+            status = send_hardware_message( 0, &input, &rawinput, SEND_HWMSG_INJECTED );
             break;
         case INPUT_HARDWARE:
             RtlSetLastWin32Error( ERROR_CALL_NOT_IMPLEMENTED );
@@ -1267,11 +1268,7 @@ HKL WINAPI NtUserActivateKeyboardLayout( HKL layout, UINT flags )
  */
 UINT WINAPI NtUserGetKeyboardLayoutList( INT size, HKL *layouts )
 {
-    char buffer[4096];
-    KEY_NODE_INFORMATION *key_info = (KEY_NODE_INFORMATION *)buffer;
-    KEY_VALUE_PARTIAL_INFORMATION *value_info = (KEY_VALUE_PARTIAL_INFORMATION *)buffer;
-    DWORD count, tmp, i = 0;
-    HKEY hkey, subkey;
+    DWORD count;
     HKL layout;
 
     TRACE_(keyboard)( "size %d, layouts %p.\n", size, layouts );
@@ -1285,33 +1282,6 @@ UINT WINAPI NtUserGetKeyboardLayoutList( INT size, HKL *layouts )
     if (size && layouts)
     {
         layouts[count - 1] = layout;
-        if (count == size) return count;
-    }
-
-    if ((hkey = reg_open_key( NULL, keyboard_layouts_keyW, sizeof(keyboard_layouts_keyW) )))
-    {
-        while (!NtEnumerateKey( hkey, i++, KeyNodeInformation, key_info,
-                                sizeof(buffer) - sizeof(WCHAR), &tmp ))
-        {
-            if (!(subkey = reg_open_key( hkey, key_info->Name, key_info->NameLength ))) continue;
-            key_info->Name[key_info->NameLength / sizeof(WCHAR)] = 0;
-            tmp = wcstoul( key_info->Name, NULL, 16 );
-            if (query_reg_ascii_value( subkey, "Layout Id", value_info, sizeof(buffer) ) &&
-                value_info->Type == REG_SZ)
-                tmp = 0xf000 | (wcstoul( (const WCHAR *)value_info->Data, NULL, 16 ) & 0xfff);
-            NtClose( subkey );
-
-            tmp = MAKELONG( LOWORD( layout ), LOWORD( tmp ) );
-            if (layout == UlongToHandle( tmp )) continue;
-
-            count++;
-            if (size && layouts)
-            {
-                layouts[count - 1] = UlongToHandle( tmp );
-                if (count == size) break;
-            }
-        }
-        NtClose( hkey );
     }
 
     return count;
@@ -1848,7 +1818,7 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
 {
     HWND previous = get_active_window();
     BOOL ret;
-    DWORD old_thread, new_thread;
+    DWORD winflags, old_thread, new_thread;
     CBTACTIVATESTRUCT cbt;
 
     if (previous == hwnd)
@@ -1857,16 +1827,24 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
         goto done;
     }
 
-    /* call CBT hook chain */
-    cbt.fMouse     = mouse;
-    cbt.hWndActive = previous;
-    if (call_hooks( WH_CBT, HCBT_ACTIVATE, (WPARAM)hwnd, (LPARAM)&cbt, sizeof(cbt) )) return FALSE;
-
-    if (is_window( previous ))
+    /* Prevent a recursive activation loop with the activation messages */
+    winflags = win_set_flags(hwnd, WIN_IS_IN_ACTIVATION, 0);
+    if (!(winflags & WIN_IS_IN_ACTIVATION))
     {
-        send_message( previous, WM_NCACTIVATE, FALSE, (LPARAM)hwnd );
-        send_message( previous, WM_ACTIVATE,
-                      MAKEWPARAM( WA_INACTIVE, is_iconic(previous) ), (LPARAM)hwnd );
+        ret = FALSE;
+
+        /* call CBT hook chain */
+        cbt.fMouse     = mouse;
+        cbt.hWndActive = previous;
+        if (call_hooks( WH_CBT, HCBT_ACTIVATE, (WPARAM)hwnd, (LPARAM)&cbt, sizeof(cbt) ))
+            goto clear_flags;
+
+        if (is_window(previous))
+        {
+            send_message( previous, WM_NCACTIVATE, FALSE, (LPARAM)hwnd );
+            send_message( previous, WM_ACTIVATE,
+                          MAKEWPARAM( WA_INACTIVE, is_iconic(previous) ), (LPARAM)hwnd );
+        }
     }
 
     SERVER_START_REQ( set_active_window )
@@ -1886,7 +1864,11 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
         if (send_message( hwnd, WM_QUERYNEWPALETTE, 0, 0 ))
             send_message_timeout( HWND_BROADCAST, WM_PALETTEISCHANGING, (WPARAM)hwnd, 0,
                                   SMTO_ABORTIFHUNG, 2000, FALSE );
-        if (!is_window(hwnd)) return FALSE;
+        if (!is_window(hwnd))
+        {
+            ret = FALSE;
+            goto clear_flags;
+        }
     }
 
     old_thread = previous ? get_window_thread( previous, NULL ) : 0;
@@ -1918,16 +1900,25 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
         }
     }
 
-    if (is_window(hwnd))
+    if (!(winflags & WIN_IS_IN_ACTIVATION) && is_window(hwnd))
     {
         send_message( hwnd, WM_NCACTIVATE, hwnd == NtUserGetForegroundWindow(), (LPARAM)previous );
         send_message( hwnd, WM_ACTIVATE,
                       MAKEWPARAM( mouse ? WA_CLICKACTIVE : WA_ACTIVE, is_iconic(hwnd) ),
                       (LPARAM)previous );
+
+        send_message( hwnd, WM_NCPOINTERUP, 0, 0);
+
         if (NtUserGetAncestor( hwnd, GA_PARENT ) == get_desktop_window())
             NtUserPostMessage( get_desktop_window(), WM_PARENTNOTIFY, WM_NCACTIVATE, (LPARAM)hwnd );
+
+        if (hwnd == NtUserGetForegroundWindow() && !is_iconic( hwnd ))
+            NtUserSetActiveWindow( hwnd );
+
     }
 
+    user_driver->pSetActiveWindow( hwnd );
+
     /* now change focus if necessary */
     if (focus)
     {
@@ -1943,9 +1934,13 @@ static BOOL set_active_window( HWND hwnd, HWND *prev, BOOL mouse, BOOL focus )
         }
     }
 
+clear_flags:
+    win_set_flags(hwnd, 0, WIN_IS_IN_ACTIVATION);
+
 done:
     if (hwnd) clip_fullscreen_window( hwnd, FALSE );
-    return TRUE;
+
+    return ret;
 }
 
 /**********************************************************************
@@ -2338,6 +2333,8 @@ BOOL set_caret_pos( int x, int y )
         r.left = x;
         r.top = y;
         display_caret( hwnd, &r );
+        if (user_driver->pUpdateCandidatePos)
+            user_driver->pUpdateCandidatePos( hwnd, &r );
         NtUserSetSystemTimer( hwnd, SYSTEM_TIMER_CARET, caret.timeout );
     }
     return ret;
@@ -2375,6 +2372,8 @@ BOOL WINAPI NtUserShowCaret( HWND hwnd )
     if (ret && hidden == 1)  /* hidden was 1 so it's now 0 */
     {
         display_caret( hwnd, &r );
+        if (user_driver->pUpdateCandidatePos)
+            user_driver->pUpdateCandidatePos( hwnd, &r );
         NtUserSetSystemTimer( hwnd, SYSTEM_TIMER_CARET, caret.timeout );
     }
     return ret;
diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 0cd2068..e787ef2 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -2463,7 +2463,7 @@ static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, H
     {
         HWND orig = msg->hwnd;
 
-        msg->hwnd = window_from_point( msg->hwnd, msg->pt, &hittest );
+        msg->hwnd = window_from_point( 0, msg->pt, &hittest );
         if (!msg->hwnd) /* As a heuristic, try the next window if it's the owner of orig */
         {
             HWND next = get_window_relative( orig, GW_HWNDNEXT );
@@ -3529,6 +3529,7 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *r
             req->input.mouse.flags = input->mi.dwFlags;
             req->input.mouse.time  = input->mi.time;
             req->input.mouse.info  = input->mi.dwExtraInfo;
+            if (rawinput) req->flags |= SEND_HWMSG_RAWINPUT;
             affects_key_state = !!(input->mi.dwFlags & (MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP |
                                                         MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_RIGHTUP |
                                                         MOUSEEVENTF_MIDDLEDOWN | MOUSEEVENTF_MIDDLEUP |
@@ -3540,6 +3541,7 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *r
             req->input.kbd.flags = input->ki.dwFlags;
             req->input.kbd.time  = input->ki.time;
             req->input.kbd.info  = input->ki.dwExtraInfo;
+            if (rawinput) req->flags |= SEND_HWMSG_RAWINPUT;
             affects_key_state = TRUE;
             break;
         case INPUT_HARDWARE:
@@ -3552,6 +3554,12 @@ NTSTATUS send_hardware_message( HWND hwnd, const INPUT *input, const RAWINPUT *r
                 req->input.hw.rawinput.type = rawinput->header.dwType;
                 switch (rawinput->header.dwType)
                 {
+                case RIM_TYPEMOUSE:
+                    req->input.hw.rawinput.mouse.x = rawinput->data.mouse.lLastX;
+                    req->input.hw.rawinput.mouse.y = rawinput->data.mouse.lLastY;
+                    req->input.hw.rawinput.mouse.data = rawinput->data.mouse.ulRawButtons;
+                    req->input.hw.lparam = rawinput->data.mouse.usFlags;
+                    break;
                 case RIM_TYPEHID:
                     req->input.hw.rawinput.hid.device = HandleToUlong( rawinput->header.hDevice );
                     req->input.hw.rawinput.hid.param = rawinput->header.wParam;
@@ -4045,7 +4053,7 @@ UINT_PTR WINAPI NtUserSetTimer( HWND hwnd, UINT_PTR id, UINT timeout, TIMERPROC
 
     if (proc) winproc = alloc_winproc( (WNDPROC)proc, TRUE );
 
-    timeout = min( max( USER_TIMER_MINIMUM, timeout ), USER_TIMER_MAXIMUM );
+    timeout = min( max( 5, timeout ), USER_TIMER_MAXIMUM );
 
     SERVER_START_REQ( set_win_timer )
     {
diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 11bb7f4..f9ea3b6 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -104,6 +104,7 @@ typedef struct tagWND
 #define WIN_NEEDS_SHOW_OWNEDPOPUP 0x0020 /* WM_SHOWWINDOW:SC_SHOW must be sent in the next ShowOwnedPopup call */
 #define WIN_CHILDREN_MOVED        0x0040 /* children may have moved, ignore stored positions */
 #define WIN_HAS_IME_WIN           0x0080 /* the window has been registered with imm32 */
+#define WIN_IS_IN_ACTIVATION      0x0100 /* the window is in an activation process */
 
 #define WND_OTHER_PROCESS ((WND *)1)  /* returned by get_win_ptr on unknown window handles */
 #define WND_DESKTOP       ((WND *)2)  /* returned by get_win_ptr on the desktop window */
diff --git a/dlls/win32u/rawinput.c b/dlls/win32u/rawinput.c
index e6c442c..46c131e 100644
--- a/dlls/win32u/rawinput.c
+++ b/dlls/win32u/rawinput.c
@@ -96,7 +96,8 @@ static bool rawinput_from_hardware_message( RAWINPUT *rawinput, const struct har
         rawinput->header.hDevice = WINE_MOUSE_HANDLE;
         rawinput->header.wParam  = 0;
 
-        rawinput->data.mouse.usFlags           = MOUSE_MOVE_RELATIVE;
+        rawinput->data.mouse.usFlags = msg_data->flags & MOUSEEVENTF_ABSOLUTE ? MOUSE_MOVE_ABSOLUTE : MOUSE_MOVE_RELATIVE;
+        if (msg_data->flags & MOUSEEVENTF_VIRTUALDESK) rawinput->data.mouse.usFlags |= MOUSE_VIRTUAL_DESKTOP;
         rawinput->data.mouse.usButtonFlags = 0;
         rawinput->data.mouse.usButtonData  = 0;
         for (i = 1; i < ARRAY_SIZE(button_flags); ++i)
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index 69dd8ca..74d1af5 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -3232,8 +3232,11 @@ static BOOL fixup_swp_flags( WINDOWPOS *winpos, const RECT *old_window_rect, int
     if (winpos->cy < 0) winpos->cy = 0;
     else if (winpos->cy > 32767) winpos->cy = 32767;
 
-    parent = NtUserGetAncestor( winpos->hwnd, GA_PARENT );
-    if (!is_window_visible( parent )) winpos->flags |= SWP_NOREDRAW;
+    if (win->dwStyle & WS_CHILD)
+    {
+        parent = NtUserGetAncestor( winpos->hwnd, GA_PARENT );
+        if (!is_window_visible( parent )) winpos->flags |= SWP_NOREDRAW;
+    }
 
     if (win->dwStyle & WS_VISIBLE) winpos->flags &= ~SWP_SHOWWINDOW;
     else
@@ -4338,8 +4341,8 @@ static BOOL show_window( HWND hwnd, INT cmd )
     }
     swp = new_swp;
 
-    parent = NtUserGetAncestor( hwnd, GA_PARENT );
-    if (parent && !is_window_visible( parent ) && !(swp & SWP_STATECHANGED))
+        if ((style & WS_CHILD) && (parent = NtUserGetAncestor( hwnd, GA_PARENT )) &&
+        !is_window_visible( parent ) && !(swp & SWP_STATECHANGED))
     {
         /* if parent is not visible simply toggle WS_VISIBLE and return */
         if (show_flag) set_window_style( hwnd, WS_VISIBLE, 0 );
@@ -4542,8 +4545,7 @@ BOOL WINAPI NtUserFlashWindowEx( FLASHWINFO *info )
         if (!win || win == WND_OTHER_PROCESS || win == WND_DESKTOP) return FALSE;
         hwnd = win->obj.handle;  /* make it a full handle */
 
-        if (info->dwFlags) wparam = !(win->flags & WIN_NCACTIVATED);
-        else wparam = (hwnd == NtUserGetForegroundWindow());
+        wparam = (win->flags & WIN_NCACTIVATED) != 0;
 
         release_win_ptr( win );
 
@@ -4551,7 +4553,7 @@ BOOL WINAPI NtUserFlashWindowEx( FLASHWINFO *info )
             send_message( hwnd, WM_NCACTIVATE, wparam, 0 );
 
         user_driver->pFlashWindowEx( info );
-        return wparam;
+        return (info->dwFlags & FLASHW_CAPTION) ? TRUE : wparam;
     }
 }
 
diff --git a/dlls/windowscodecs/info.c b/dlls/windowscodecs/info.c
index 689d2e2..dd88a1f 100644
--- a/dlls/windowscodecs/info.c
+++ b/dlls/windowscodecs/info.c
@@ -198,7 +198,7 @@ typedef struct {
 
 static inline BitmapDecoderInfo *impl_from_IWICBitmapDecoderInfo(IWICBitmapDecoderInfo *iface)
 {
-    return CONTAINING_RECORD(iface, BitmapDecoderInfo, base.IWICComponentInfo_iface);
+    return CONTAINING_RECORD((IWICComponentInfo*)iface, BitmapDecoderInfo, base.IWICComponentInfo_iface);
 }
 
 static HRESULT WINAPI BitmapDecoderInfo_QueryInterface(IWICBitmapDecoderInfo *iface, REFIID iid,
@@ -682,7 +682,7 @@ typedef struct {
 
 static inline BitmapEncoderInfo *impl_from_IWICBitmapEncoderInfo(IWICBitmapEncoderInfo *iface)
 {
-    return CONTAINING_RECORD(iface, BitmapEncoderInfo, base.IWICComponentInfo_iface);
+    return CONTAINING_RECORD((IWICComponentInfo*)iface, BitmapEncoderInfo, base.IWICComponentInfo_iface);
 }
 
 static HRESULT WINAPI BitmapEncoderInfo_QueryInterface(IWICBitmapEncoderInfo *iface, REFIID iid,
@@ -973,7 +973,7 @@ typedef struct {
 
 static inline FormatConverterInfo *impl_from_IWICFormatConverterInfo(IWICFormatConverterInfo *iface)
 {
-    return CONTAINING_RECORD(iface, FormatConverterInfo, base.IWICComponentInfo_iface);
+    return CONTAINING_RECORD((IWICComponentInfo*)iface, FormatConverterInfo, base.IWICComponentInfo_iface);
 }
 
 static HRESULT WINAPI FormatConverterInfo_QueryInterface(IWICFormatConverterInfo *iface, REFIID iid,
@@ -1186,7 +1186,7 @@ typedef struct {
 
 static inline PixelFormatInfo *impl_from_IWICPixelFormatInfo2(IWICPixelFormatInfo2 *iface)
 {
-    return CONTAINING_RECORD(iface, PixelFormatInfo, base.IWICComponentInfo_iface);
+    return CONTAINING_RECORD((IWICComponentInfo*)iface, PixelFormatInfo, base.IWICComponentInfo_iface);
 }
 
 static HRESULT WINAPI PixelFormatInfo_QueryInterface(IWICPixelFormatInfo2 *iface, REFIID iid,
@@ -1496,7 +1496,7 @@ static struct metadata_container *get_metadata_container(MetadataReaderInfo *inf
 
 static inline MetadataReaderInfo *impl_from_IWICMetadataReaderInfo(IWICMetadataReaderInfo *iface)
 {
-    return CONTAINING_RECORD(iface, MetadataReaderInfo, base.IWICComponentInfo_iface);
+    return CONTAINING_RECORD((IWICComponentInfo*)iface, MetadataReaderInfo, base.IWICComponentInfo_iface);
 }
 
 static HRESULT WINAPI MetadataReaderInfo_QueryInterface(IWICMetadataReaderInfo *iface,
diff --git a/dlls/windowscodecs/metadatahandler.c b/dlls/windowscodecs/metadatahandler.c
index 09ded6d..d3ed0ad 100644
--- a/dlls/windowscodecs/metadatahandler.c
+++ b/dlls/windowscodecs/metadatahandler.c
@@ -718,7 +718,7 @@ static int tag_to_vt(SHORT tag)
 static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
                               MetadataItem *item, BOOL native_byte_order)
 {
-    ULONG count, value, i, bytesread;
+    ULONG count, value, i;
     SHORT type;
     LARGE_INTEGER pos;
     HRESULT hr;
@@ -770,9 +770,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.caub.pElems);
             return hr;
         }
-        hr = IStream_Read(input, item->value.caub.pElems, count, &bytesread);
-        if (bytesread != count) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.caub.pElems, count, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.caub.pElems);
             return hr;
@@ -805,7 +804,7 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
 
         item->value.vt |= VT_VECTOR;
         item->value.caui.cElems = count;
-        item->value.caui.pElems = CoTaskMemAlloc(count * 2);
+        item->value.caui.pElems = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, count * 2);
         if (!item->value.caui.pElems) return E_OUTOFMEMORY;
 
         pos.QuadPart = value;
@@ -815,9 +814,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.caui.pElems);
             return hr;
         }
-        hr = IStream_Read(input, item->value.caui.pElems, count * 2, &bytesread);
-        if (bytesread != count * 2) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.caui.pElems, count * 2, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.caui.pElems);
             return hr;
@@ -848,9 +846,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.caul.pElems);
             return hr;
         }
-        hr = IStream_Read(input, item->value.caul.pElems, count * 4, &bytesread);
-        if (bytesread != count * 4) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.caul.pElems, count * 4, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.caul.pElems);
             return hr;
@@ -876,8 +873,7 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             hr = IStream_Seek(input, pos, SEEK_SET, NULL);
             if (FAILED(hr)) return hr;
 
-            hr = IStream_Read(input, &ull, sizeof(ull), &bytesread);
-            if (bytesread != sizeof(ull)) hr = E_FAIL;
+            hr = IStream_Read(input, &ull, sizeof(ull), NULL);
             if (hr != S_OK) return hr;
 
             item->value.uhVal.QuadPart = ull;
@@ -905,9 +901,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
                 CoTaskMemFree(item->value.cauh.pElems);
                 return hr;
             }
-            hr = IStream_Read(input, item->value.cauh.pElems, count * 8, &bytesread);
-            if (bytesread != count * 8) hr = E_FAIL;
-            if (hr != S_OK)
+            hr = IStream_Read(input, item->value.cauh.pElems, count * 8, NULL);
+            if (FAILED(hr))
             {
                 CoTaskMemFree(item->value.cauh.pElems);
                 return hr;
@@ -943,9 +938,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.pszVal);
             return hr;
         }
-        hr = IStream_Read(input, item->value.pszVal, count, &bytesread);
-        if (bytesread != count) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.pszVal, count, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.pszVal);
             return hr;
@@ -979,9 +973,8 @@ static HRESULT load_IFD_entry(IStream *input, const struct IFD_entry *entry,
             CoTaskMemFree(item->value.blob.pBlobData);
             return hr;
         }
-        hr = IStream_Read(input, item->value.blob.pBlobData, count, &bytesread);
-        if (bytesread != count) hr = E_FAIL;
-        if (hr != S_OK)
+        hr = IStream_Read(input, item->value.blob.pBlobData, count, NULL);
+        if (FAILED(hr))
         {
             CoTaskMemFree(item->value.blob.pBlobData);
             return hr;
diff --git a/dlls/windowscodecs/tests/converter.c b/dlls/windowscodecs/tests/converter.c
index d13ee89..5074f6f 100644
--- a/dlls/windowscodecs/tests/converter.c
+++ b/dlls/windowscodecs/tests/converter.c
@@ -1418,6 +1418,8 @@ static void test_multi_encoder_impl(const struct bitmap_data **srcs, const CLSID
 
         if (hglobal && SUCCEEDED(hr))
         {
+            IWICBitmapEncoderInfo *info = NULL;
+
             if (palette)
             {
                 hr = IWICBitmapEncoder_SetPalette(encoder, palette);
@@ -1437,6 +1439,20 @@ static void test_multi_encoder_impl(const struct bitmap_data **srcs, const CLSID
                 hr = S_OK;
             }
 
+            hr = IWICBitmapEncoder_GetEncoderInfo(encoder, &info);
+            ok(hr == S_OK || hr == WINCODEC_ERR_COMPONENTNOTFOUND, "wrong error %#lx\n", hr);
+            if (SUCCEEDED(hr))
+            {
+                CLSID clsid;
+
+                hr = IWICBitmapEncoderInfo_GetCLSID(info, &clsid);
+                ok(hr == S_OK, "wrong error %#lx\n", hr);
+                ok(!IsEqualGUID(clsid_encoder, &clsid), "wrong CLSID %s (%s)\n",
+                       wine_dbgstr_guid(clsid_encoder), wine_dbgstr_guid(&clsid));
+
+                IWICBitmapEncoderInfo_Release(info);
+            }
+
             i=0;
             while (SUCCEEDED(hr) && srcs[i])
             {
diff --git a/dlls/wineandroid.drv/keyboard.c b/dlls/wineandroid.drv/keyboard.c
index 9f36909..1606afb 100644
--- a/dlls/wineandroid.drv/keyboard.c
+++ b/dlls/wineandroid.drv/keyboard.c
@@ -671,6 +671,7 @@ static BOOL get_async_key_state( BYTE state[256] )
 
 static void send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, DWORD flags )
 {
+    RAWINPUT rawinput;
     INPUT input;
 
     input.type           = INPUT_KEYBOARD;
@@ -680,7 +681,7 @@ static void send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, DWORD flags )
     input.ki.time        = 0;
     input.ki.dwExtraInfo = 0;
 
-    __wine_send_input( hwnd, &input, NULL );
+    __wine_send_input( hwnd, &input, &rawinput );
 }
 
 /***********************************************************************
diff --git a/dlls/wineandroid.drv/window.c b/dlls/wineandroid.drv/window.c
index d62a2c5..47a424b 100644
--- a/dlls/wineandroid.drv/window.c
+++ b/dlls/wineandroid.drv/window.c
@@ -421,6 +421,7 @@ static int process_events( DWORD mask )
     DPI_AWARENESS_CONTEXT context;
     struct java_event *event, *next, *previous;
     unsigned int count = 0;
+    RAWINPUT rawinput;
 
     assert( GetCurrentThreadId() == desktop_tid );
 
@@ -514,7 +515,7 @@ static int process_events( DWORD mask )
                     }
                     SERVER_END_REQ;
                 }
-                __wine_send_input( capture ? capture : event->data.motion.hwnd, &event->data.motion.input, NULL );
+                __wine_send_input( capture ? capture : event->data.motion.hwnd, &event->data.motion.input, &rawinput );
             }
             break;
 
@@ -528,7 +529,7 @@ static int process_events( DWORD mask )
                       event->data.kbd.input.ki.wVk, event->data.kbd.input.ki.wVk,
                       event->data.kbd.input.ki.wScan );
             update_keyboard_lock_state( event->data.kbd.input.ki.wVk, event->data.kbd.lock_state );
-            __wine_send_input( 0, &event->data.kbd.input, NULL );
+            __wine_send_input( 0, &event->data.kbd.input, &rawinput );
             break;
 
         default:
diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index 7ae3143..b03b64f 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -57,6 +57,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
 
     /* ARB */
     {"GL_ARB_base_instance",                ARB_BASE_INSTANCE             },
+    {"GL_ARB_bindless_texture",             ARB_BINDLESS_TEXTURE          },
     {"GL_ARB_blend_func_extended",          ARB_BLEND_FUNC_EXTENDED       },
     {"GL_ARB_buffer_storage",               ARB_BUFFER_STORAGE            },
     {"GL_ARB_clear_buffer_object",          ARB_CLEAR_BUFFER_OBJECT       },
@@ -237,6 +238,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_NV_vertex_program2_option",        NV_VERTEX_PROGRAM2_OPTION     },
     {"GL_NV_vertex_program3",               NV_VERTEX_PROGRAM3            },
     {"GL_NV_texture_barrier",               NV_TEXTURE_BARRIER            },
+    {"GL_NVX_gpu_memory_info",              NVX_GPU_MEMORY_INFO           },
 };
 
 static const struct wined3d_extension_map wgl_extension_map[] =
@@ -1028,6 +1030,17 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
 
         gpu_description = wined3d_get_gpu_description(vendor, device);
     }
+    else if (gl_info->supported[NVX_GPU_MEMORY_INFO])
+    {
+        GLint vram_kb;
+        gl_info->gl_ops.gl.p_glGetIntegerv(GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX, &vram_kb);
+
+        *vram_bytes = (UINT64)vram_kb * 1024;
+        TRACE("Got 0x%s as video memory from NVX_GPU_MEMORY_INFO extension.\n",
+                wine_dbgstr_longlong(*vram_bytes));
+
+        gpu_description = wined3d_get_gpu_description(vendor, device);
+    }
 
     if ((gpu_description_override = wined3d_get_user_override_gpu_description(vendor, device)))
         gpu_description = gpu_description_override;
@@ -1191,6 +1204,7 @@ static enum wined3d_gl_vendor wined3d_guess_gl_vendor(const struct wined3d_gl_in
         return GL_VENDOR_FGLRX;
 
     if (strstr(gl_vendor_string, "Mesa")
+            || strstr(gl_vendor_string, "Brian Paul")
             || strstr(gl_vendor_string, "X.Org")
             || strstr(gl_vendor_string, "Advanced Micro Devices, Inc.")
             || strstr(gl_vendor_string, "DRI R300 Project")
@@ -2114,6 +2128,11 @@ static void load_gl_funcs(struct wined3d_gl_info *gl_info)
     /* GL_ARB_base_instance */
     USE_GL_FUNC(glDrawArraysInstancedBaseInstance)
     USE_GL_FUNC(glDrawElementsInstancedBaseVertexBaseInstance)
+    /* GL_ARB_bindless_texture */
+    USE_GL_FUNC(glGetTextureSamplerHandleARB)
+    USE_GL_FUNC(glMakeTextureHandleNonResidentARB)
+    USE_GL_FUNC(glMakeTextureHandleResidentARB)
+    USE_GL_FUNC(glUniformHandleui64ARB)
     /* GL_ARB_blend_func_extended */
     USE_GL_FUNC(glBindFragDataLocationIndexed)
     USE_GL_FUNC(glGetFragDataIndex)
@@ -4312,6 +4331,7 @@ static void adapter_gl_get_wined3d_caps(const struct wined3d_adapter *adapter, s
     const struct wined3d_d3d_info *d3d_info = &adapter->d3d_info;
 
     caps->ddraw_caps.dds_caps |= WINEDDSCAPS_BACKBUFFER
+            | WINEDDSCAPS_FLIP
             | WINEDDSCAPS_COMPLEX
             | WINEDDSCAPS_FRONTBUFFER
             | WINEDDSCAPS_3DDEVICE
diff --git a/dlls/wined3d/adapter_vk.c b/dlls/wined3d/adapter_vk.c
index 1216a84..73d17e3 100644
--- a/dlls/wined3d/adapter_vk.c
+++ b/dlls/wined3d/adapter_vk.c
@@ -513,6 +513,7 @@ static void adapter_vk_get_wined3d_caps(const struct wined3d_adapter *adapter, s
     const struct wined3d_vk_info *vk_info = &adapter_vk->vk_info;
 
     caps->ddraw_caps.dds_caps |= WINEDDSCAPS_BACKBUFFER
+            | WINEDDSCAPS_FLIP
             | WINEDDSCAPS_COMPLEX
             | WINEDDSCAPS_FRONTBUFFER
             | WINEDDSCAPS_3DDEVICE
diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
index ee69392..46fb221 100644
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -5691,6 +5691,12 @@ static void shader_arb_handle_instruction(const struct wined3d_shader_instructio
     shader_arb_add_instruction_modifiers(ins);
 }
 
+void shader_arb_resource_view_handle(void *shader_priv, struct wined3d_context *context,
+            const struct wined3d_state *state, const struct wined3d_shader *shader)
+{
+    ERR("Not implemented.\n");
+}
+
 static void shader_arb_precompile(void *shader_priv, struct wined3d_shader *shader) {}
 
 static uint64_t shader_arb_shader_compile(struct wined3d_context *context, const struct wined3d_shader_desc *shader_desc,
@@ -5718,6 +5724,7 @@ const struct wined3d_shader_backend_ops arb_program_shader_backend =
     shader_arb_init_context_state,
     shader_arb_get_caps,
     shader_arb_color_fixup_supported,
+    shader_arb_resource_view_handle,
     shader_arb_shader_compile,
 };
 
diff --git a/dlls/wined3d/context_gl.c b/dlls/wined3d/context_gl.c
index 2c31913..dd58ba1 100644
--- a/dlls/wined3d/context_gl.c
+++ b/dlls/wined3d/context_gl.c
@@ -4027,6 +4027,12 @@ static void wined3d_context_gl_bind_shader_resources(struct wined3d_context_gl *
         return;
     }
 
+    if (device->shader_backend->shader_load_sampler_handles)
+    {
+        device->shader_backend->shader_load_sampler_handles(device->shader_priv, &context_gl->c, state, shader);
+        return;
+    }
+
     tex_unit_map = wined3d_context_gl_get_tex_unit_mapping(context_gl,
             &shader->reg_maps.shader_version, &base, &count);
 
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index aad112d..612d9f6 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -580,6 +580,59 @@ void wined3d_device_destroy_default_samplers(struct wined3d_device *device)
     device->null_sampler = NULL;
 }
 
+static GLuint64 create_dummy_sampler_handle(struct wined3d_device *device, struct wined3d_context_gl *context_gl,
+        GLuint texture)
+{
+    const struct wined3d_gl_info *gl_info = context_gl->gl_info;
+    GLuint64 handle;
+
+    handle = GL_EXTCALL(glGetTextureSamplerHandleARB(texture, wined3d_sampler_gl(device->default_sampler)->name));
+    GL_EXTCALL(glMakeTextureHandleResidentARB(handle));
+    checkGLcall("glMakeTextureHandleResidentARB");
+    return handle;
+}
+
+/* Context activation is done by the caller. */
+static void create_dummy_sampler_handles(struct wined3d_device *device, struct wined3d_context_gl *context_gl)
+{
+    const struct wined3d_gl_info *gl_info = context_gl->gl_info;
+    const struct wined3d_dummy_textures *textures = &wined3d_device_gl(device)->dummy_textures;
+    struct wined3d_dummy_sampler_handles *handles = &wined3d_device_gl(device)->dummy_sampler_handles;
+
+    if (!gl_info->supported[ARB_BINDLESS_TEXTURE])
+        return;
+
+    if (gl_info->supported[ARB_TEXTURE_MULTISAMPLE])
+    {
+        handles->tex_2d_ms = create_dummy_sampler_handle(device, context_gl, textures->tex_2d_ms);
+        handles->tex_2d_ms_array = create_dummy_sampler_handle(device, context_gl, textures->tex_2d_ms_array);
+    }
+
+    if (gl_info->supported[ARB_TEXTURE_BUFFER_OBJECT])
+        handles->tex_buffer = create_dummy_sampler_handle(device, context_gl, textures->tex_buffer);
+
+    if (gl_info->supported[EXT_TEXTURE_ARRAY])
+    {
+        handles->tex_2d_array = create_dummy_sampler_handle(device, context_gl, textures->tex_2d_array);
+        handles->tex_1d_array = create_dummy_sampler_handle(device, context_gl, textures->tex_1d_array);
+    }
+
+    if (gl_info->supported[ARB_TEXTURE_CUBE_MAP_ARRAY])
+        handles->tex_cube_array = create_dummy_sampler_handle(device, context_gl, textures->tex_cube_array);
+
+    if (gl_info->supported[ARB_TEXTURE_CUBE_MAP])
+        handles->tex_cube = create_dummy_sampler_handle(device, context_gl, textures->tex_cube);
+
+    if (gl_info->supported[EXT_TEXTURE3D])
+        handles->tex_3d = create_dummy_sampler_handle(device, context_gl, textures->tex_3d);
+
+    if (gl_info->supported[ARB_TEXTURE_RECTANGLE])
+        handles->tex_rect = create_dummy_sampler_handle(device, context_gl, textures->tex_rect);
+
+    handles->tex_2d = create_dummy_sampler_handle(device, context_gl, textures->tex_2d);
+    handles->tex_1d = create_dummy_sampler_handle(device, context_gl, textures->tex_1d);
+}
+
 static bool wined3d_null_image_vk_init(struct wined3d_image_vk *image, struct wined3d_context_vk *context_vk,
         VkCommandBuffer vk_command_buffer, VkImageType type, unsigned int layer_count, unsigned int sample_count)
 {
@@ -1323,6 +1376,7 @@ void wined3d_device_gl_create_primary_opengl_context_cs(void *object)
 
     wined3d_device_gl_create_dummy_textures(device_gl, context_gl);
     wined3d_device_create_default_samplers(device, context);
+    create_dummy_sampler_handles(device, context_gl);
     context_release(context);
 }
 
@@ -1533,6 +1587,29 @@ UINT CDECL wined3d_device_get_available_texture_mem(const struct wined3d_device
 
     driver_info = &device->adapter->driver_info;
 
+    /* We can not acquire the context unless there is a swapchain. */
+    /*
+    if (device->swapchains && gl_info->supported[NVX_GPU_MEMORY_INFO] &&
+            !wined3d_settings.emulated_textureram)
+    {
+        GLint vram_free_kb;
+        UINT64 vram_free;
+
+        struct wined3d_context *context = context_acquire(device, NULL, 0);
+        gl_info->gl_ops.gl.p_glGetIntegerv(GL_GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX, &vram_free_kb);
+        vram_free = (UINT64)vram_free_kb * 1024;
+        context_release(context);
+
+        TRACE("Total 0x%s bytes. emulation 0x%s left, driver 0x%s left.\n",
+                wine_dbgstr_longlong(device->adapter->vram_bytes),
+                wine_dbgstr_longlong(device->adapter->vram_bytes - device->adapter->vram_bytes_used),
+                wine_dbgstr_longlong(vram_free));
+
+        vram_free = min(vram_free, device->adapter->vram_bytes - device->adapter->vram_bytes_used);
+        return min(UINT_MAX, vram_free);
+    }
+    */
+
     TRACE("Emulating 0x%s bytes. 0x%s used, returning 0x%s left.\n",
             wine_dbgstr_longlong(driver_info->vram_bytes),
             wine_dbgstr_longlong(device->adapter->vram_bytes_used),
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index 50990e4..5bd6d36 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -2699,8 +2699,7 @@ HRESULT CDECL wined3d_get_device_caps(const struct wined3d_adapter *adapter,
     caps->ddraw_caps.ssb_color_key_caps = ckey_caps;
     caps->ddraw_caps.ssb_fx_caps = fx_caps;
 
-    caps->ddraw_caps.dds_caps = WINEDDSCAPS_FLIP
-            | WINEDDSCAPS_OFFSCREENPLAIN
+    caps->ddraw_caps.dds_caps = WINEDDSCAPS_OFFSCREENPLAIN
             | WINEDDSCAPS_PALETTE
             | WINEDDSCAPS_PRIMARYSURFACE
             | WINEDDSCAPS_TEXTURE
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 4141a39..ed575d4 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -730,6 +730,113 @@ static void shader_glsl_append_sampler_binding_qualifier(struct wined3d_string_b
         ERR("Unmapped sampler %u.\n", sampler_idx);
 }
 
+static BOOL shader_glsl_use_bindless_texture(const struct wined3d_gl_info *gl_info,
+        unsigned int sampler_idx, const struct wined3d_shader_resource_info *resource_info)
+{
+    return gl_info->supported[ARB_BINDLESS_TEXTURE]
+            && shader_glsl_use_layout_binding_qualifier(gl_info)
+            && sampler_idx >= 16
+            && resource_info->type != WINED3D_SHADER_RESOURCE_BUFFER;
+}
+
+static GLuint64 shader_glsl_dummy_sampler_handle(const struct wined3d_context *context,
+        enum wined3d_shader_resource_type type)
+{
+    const struct wined3d_device_gl *device = wined3d_device_gl(context->device);
+
+    switch (type)
+    {
+    case WINED3D_SHADER_RESOURCE_BUFFER:
+        return device->dummy_sampler_handles.tex_buffer;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_1D:
+        return device->dummy_sampler_handles.tex_1d;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_2D:
+        return device->dummy_sampler_handles.tex_2d;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_3D:
+        return device->dummy_sampler_handles.tex_3d;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_CUBE:
+        return device->dummy_sampler_handles.tex_cube;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_1DARRAY:
+        return device->dummy_sampler_handles.tex_1d_array;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_2DARRAY:
+        return device->dummy_sampler_handles.tex_2d_array;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_CUBEARRAY:
+        return device->dummy_sampler_handles.tex_cube_array;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_2DMS:
+        return device->dummy_sampler_handles.tex_2d_ms;
+    case WINED3D_SHADER_RESOURCE_TEXTURE_2DMSARRAY:
+        return device->dummy_sampler_handles.tex_2d_array;
+    default:
+        FIXME("Unhandled resource type %#x.\n", type);
+        return 0;
+    }
+}
+
+static void shader_glsl_load_sampler_handles(void *shader_priv, struct wined3d_context *context,
+        const struct wined3d_state *state, const struct wined3d_shader *shader)
+{
+    struct wined3d_context_gl *context_gl = wined3d_context_gl(context);
+    const struct glsl_context_data *ctx_data = context->shader_backend_data;
+    const struct wined3d_device *device = context->device;
+    const struct wined3d_gl_info *gl_info = context_gl->gl_info;
+    struct shader_glsl_priv *priv = shader_priv;
+    struct wined3d_string_buffer *sampler_name = string_buffer_get(&priv->string_buffers);
+    enum wined3d_shader_type shader_type = shader->reg_maps.shader_version.type;
+    const char *prefix = shader_glsl_get_prefix(shader_type);
+
+    struct wined3d_shader_sampler_map_entry *entry;
+    struct wined3d_shader_resource_view *view;
+    struct wined3d_sampler *sampler;
+    unsigned int bind_idx, i;
+    GLint name_loc;
+
+    for (i = 0; i < shader->reg_maps.sampler_map.count; ++i)
+    {
+        entry = &shader->reg_maps.sampler_map.entries[i];
+        bind_idx = shader_glsl_map_tex_unit(context, &shader->reg_maps.shader_version, entry->bind_idx);
+        if (entry->sampler_idx == WINED3D_SAMPLER_DEFAULT)
+            sampler = device->default_sampler;
+        else if (!(sampler = state->sampler[shader_type][entry->sampler_idx]))
+            sampler = device->null_sampler;
+
+        string_buffer_sprintf(sampler_name, "%s_sampler%u", prefix, entry->bind_idx);
+        name_loc = GL_EXTCALL(glGetUniformLocation(ctx_data->glsl_program->id, sampler_name->buffer));
+        if (name_loc == -1)
+        {
+            ERR("No uniform location at %u, %s\n", i, sampler_name->buffer);
+            continue;
+        }
+
+        if (!(view = state->shader_resource_view[shader_type][entry->resource_idx]))
+            WARN("No resource view bound at index %u, %u.\n", shader_type, entry->resource_idx);
+
+        if (shader_glsl_use_bindless_texture(gl_info, i, &shader->reg_maps.resource_info[entry->resource_idx]))
+        {
+            GLuint64 handle;
+            if (view)
+            {
+                handle = wined3d_shader_resource_view_gl_handle(wined3d_shader_resource_view_gl(view), sampler, context_gl);
+            }
+            else
+            {
+                handle = shader_glsl_dummy_sampler_handle(context,
+                        shader->reg_maps.resource_info[entry->resource_idx].type);
+            }
+            GL_EXTCALL(glUniformHandleui64ARB(name_loc, handle));
+            checkGLcall("glUniformHandleui64ARB");
+        }
+        else if (bind_idx == WINED3D_UNMAPPED_STAGE || bind_idx >= gl_info->limits.combined_samplers)
+        {
+            ERR("Trying to load sampler %s on unsupported unit %u.\n", sampler_name->buffer, bind_idx);
+        }
+        else if (view)
+        {
+            wined3d_shader_resource_view_gl_bind(wined3d_shader_resource_view_gl(view), bind_idx, wined3d_sampler_gl(sampler), context_gl);
+        }
+    }
+    string_buffer_release(&priv->string_buffers, sampler_name);
+}
+
 /* Context activation is done by the caller. */
 static void shader_glsl_load_samplers(const struct wined3d_context *context,
         struct shader_glsl_priv *priv, GLuint program_id, const struct wined3d_shader_reg_maps *reg_maps)
@@ -2170,6 +2277,19 @@ static void shader_generate_glsl_declarations(const struct wined3d_context_gl *c
     if (wined3d_settings.strict_shader_math)
         shader_addline(buffer, "#pragma optionNV(fastmath off)\n");
 
+    if (wined3d_settings.multiply_special == 2 && version->major < 4)
+    {
+        shader_addline(buffer, "float dot1(float v1, float v2) {return abs(v1) == 0.0 || abs(v2) == 0.0 ? 0.0 : v1 * v2;}\n");
+        shader_addline(buffer, "float dot2(vec2 v1, vec2 v2) {return dot1(v1.x, v2.x) + dot1(v1.y, v2.y);}\n");
+        shader_addline(buffer, "float dot3(vec3 v1, vec3 v2) {return dot2(v1.xy, v2.xy) + dot1(v1.z, v2.z);}\n");
+        shader_addline(buffer, "float dot4(vec4 v1, vec4 v2) {return dot2(v1.xy, v2.xy) + dot2(v1.zw, v2.zw);}\n");
+
+        shader_addline(buffer, "float mul1(float v1, float v2) {return abs(v1) == 0.0 || abs(v2) == 0.0 ? 0.0 : v1 * v2;}\n");
+        shader_addline(buffer, "vec2 mul2(vec2 v1, vec2 v2) {return vec2(mul1(v1.x, v2.x), mul1(v1.y, v2.y));}\n");
+        shader_addline(buffer, "vec3 mul3(vec3 v1, vec3 v2) {return vec3(mul2(v1.xy, v2.xy), mul1(v1.z, v2.z));}\n");
+        shader_addline(buffer, "vec4 mul4(vec4 v1, vec4 v2) {return vec4(mul2(v1.xy, v2.xy), mul2(v1.zw, v2.zw));}\n");
+    }
+
     prefix = shader_glsl_get_prefix(version->type);
 
     /* Prototype the subroutines */
@@ -2412,7 +2532,9 @@ static void shader_generate_glsl_declarations(const struct wined3d_context_gl *c
                 break;
         }
 
-        if (shader_glsl_use_layout_binding_qualifier(gl_info))
+        if (shader_glsl_use_bindless_texture(gl_info, i, &reg_maps->resource_info[entry->resource_idx]))
+            shader_addline(buffer, "layout(bindless_sampler)\n");
+        else if (shader_glsl_use_layout_binding_qualifier(gl_info))
             shader_glsl_append_sampler_binding_qualifier(buffer, &context_gl->c, version, entry->bind_idx);
         shader_addline(buffer, "uniform %s%s %s_sampler%u;\n",
                 sampler_type_prefix, sampler_type, prefix, entry->bind_idx);
@@ -3753,7 +3875,12 @@ static void shader_glsl_binop(const struct wined3d_shader_instruction *ins)
     write_mask = shader_glsl_append_dst(buffer, ins);
     shader_glsl_add_src_param(ins, &ins->src[0], write_mask, &src0_param);
     shader_glsl_add_src_param(ins, &ins->src[1], write_mask, &src1_param);
-    shader_addline(buffer, "%s %s %s);\n", src0_param.param_str, op, src1_param.param_str);
+    if (wined3d_settings.multiply_special == 2 && ins->ctx->reg_maps->shader_version.major < 4
+            && ins->handler_idx == WINED3DSIH_MUL)
+        shader_addline(buffer, "mul%d(%s, %s));\n", shader_glsl_get_write_mask_size(write_mask),
+                src0_param.param_str, src1_param.param_str);
+    else
+        shader_addline(buffer, "%s %s %s);\n", src0_param.param_str, op, src1_param.param_str);
 }
 
 static void shader_glsl_relop(const struct wined3d_shader_instruction *ins)
@@ -3966,26 +4093,45 @@ static void shader_glsl_dot(const struct wined3d_shader_instruction *ins)
     struct glsl_src_param src0_param;
     struct glsl_src_param src1_param;
     DWORD dst_write_mask, src_write_mask;
-    unsigned int dst_size;
+    unsigned int dst_size, src_size;
 
     dst_write_mask = shader_glsl_append_dst(buffer, ins);
     dst_size = shader_glsl_get_write_mask_size(dst_write_mask);
 
     /* dp4 works on vec4, dp3 on vec3, etc. */
     if (ins->handler_idx == WINED3DSIH_DP4)
+    {
         src_write_mask = WINED3DSP_WRITEMASK_ALL;
+        src_size = 4;
+    }
     else if (ins->handler_idx == WINED3DSIH_DP3)
+    {
         src_write_mask = WINED3DSP_WRITEMASK_0 | WINED3DSP_WRITEMASK_1 | WINED3DSP_WRITEMASK_2;
+        src_size = 3;
+    }
     else
+    {
         src_write_mask = WINED3DSP_WRITEMASK_0 | WINED3DSP_WRITEMASK_1;
-
+        src_size = 2;
+    }
     shader_glsl_add_src_param(ins, &ins->src[0], src_write_mask, &src0_param);
     shader_glsl_add_src_param(ins, &ins->src[1], src_write_mask, &src1_param);
 
-    if (dst_size > 1) {
-        shader_addline(buffer, "vec%d(dot(%s, %s)));\n", dst_size, src0_param.param_str, src1_param.param_str);
-    } else {
-        shader_addline(buffer, "dot(%s, %s));\n", src0_param.param_str, src1_param.param_str);
+    if (dst_size > 1)
+    {
+        if (wined3d_settings.multiply_special == 2 && ins->ctx->reg_maps->shader_version.major < 4)
+            shader_addline(buffer, "vec%d(dot%d(%s, %s)));\n", dst_size, src_size,
+                    src0_param.param_str, src1_param.param_str);
+        else
+            shader_addline(buffer, "vec%d(dot(%s, %s)));\n", dst_size,
+                    src0_param.param_str, src1_param.param_str);
+    }
+    else
+    {
+        if (wined3d_settings.multiply_special == 2 && ins->ctx->reg_maps->shader_version.major < 4)
+            shader_addline(buffer, "dot%d(%s, %s));\n", src_size, src0_param.param_str, src1_param.param_str);
+        else
+            shader_addline(buffer, "dot(%s, %s));\n", src0_param.param_str, src1_param.param_str);
     }
 }
 
@@ -4021,10 +4167,15 @@ static void shader_glsl_cut(const struct wined3d_shader_instruction *ins)
 static void shader_glsl_pow(const struct wined3d_shader_instruction *ins)
 {
     struct wined3d_string_buffer *buffer = ins->ctx->buffer;
+    const struct shader_glsl_ctx_priv *priv = ins->ctx->backend_data;
+    static const float max_float = FLT_MAX;
     struct glsl_src_param src0_param;
     struct glsl_src_param src1_param;
     DWORD dst_write_mask;
     unsigned int dst_size;
+    BOOL guard_inf;
+
+    guard_inf = wined3d_settings.multiply_special == 1 && ins->ctx->reg_maps->shader_version.major < 4;
 
     dst_write_mask = shader_glsl_append_dst(buffer, ins);
     dst_size = shader_glsl_get_write_mask_size(dst_write_mask);
@@ -4034,13 +4185,33 @@ static void shader_glsl_pow(const struct wined3d_shader_instruction *ins)
 
     if (dst_size > 1)
     {
-        shader_addline(buffer, "vec%u(%s == 0.0 ? 1.0 : pow(abs(%s), %s)));\n",
-                dst_size, src1_param.param_str, src0_param.param_str, src1_param.param_str);
+        if (guard_inf)
+        {
+            shader_addline(buffer, "vec%u(%s == 0.0 ? 1.0 : min(pow(abs(%s), %s), ",
+                    dst_size, src1_param.param_str, src0_param.param_str, src1_param.param_str);
+            shader_glsl_append_imm_vec(buffer, &max_float, 1, priv->gl_info);
+            shader_addline(buffer, ")));\n");
+        }
+        else
+        {
+            shader_addline(buffer, "vec%u(%s == 0.0 ? 1.0 : pow(abs(%s), %s)));\n",
+                    dst_size, src1_param.param_str, src0_param.param_str, src1_param.param_str);
+        }
     }
     else
     {
-        shader_addline(buffer, "%s == 0.0 ? 1.0 : pow(abs(%s), %s));\n",
-                src1_param.param_str, src0_param.param_str, src1_param.param_str);
+        if (guard_inf)
+        {
+            shader_addline(buffer, "%s == 0.0 ? 1.0 : min(pow(abs(%s), %s), ",
+                    src1_param.param_str, src0_param.param_str, src1_param.param_str);
+            shader_glsl_append_imm_vec(buffer, &max_float, 1, priv->gl_info);
+            shader_addline(buffer, "));\n");
+        }
+        else
+        {
+            shader_addline(buffer, "%s == 0.0 ? 1.0 : pow(abs(%s), %s));\n",
+                    src1_param.param_str, src0_param.param_str, src1_param.param_str);
+        }
     }
 }
 
@@ -4218,11 +4389,15 @@ static void shader_glsl_scalar_op(const struct wined3d_shader_instruction *ins)
 {
     DWORD shader_version = WINED3D_SHADER_VERSION(ins->ctx->reg_maps->shader_version.major,
             ins->ctx->reg_maps->shader_version.minor);
+    static const float max_float = FLT_MAX, min_float = -FLT_MAX;
+    struct shader_glsl_ctx_priv *priv = ins->ctx->backend_data;
     struct wined3d_string_buffer *buffer = ins->ctx->buffer;
+    struct wined3d_string_buffer *suffix;
     struct glsl_src_param src0_param;
-    const char *prefix, *suffix;
     unsigned int dst_size;
     DWORD dst_write_mask;
+    const char *prefix;
+    BOOL guard_inf;
 
     dst_write_mask = shader_glsl_append_dst(buffer, ins);
     dst_size = shader_glsl_get_write_mask_size(dst_write_mask);
@@ -4232,41 +4407,78 @@ static void shader_glsl_scalar_op(const struct wined3d_shader_instruction *ins)
 
     shader_glsl_add_src_param(ins, &ins->src[0], dst_write_mask, &src0_param);
 
+    guard_inf = wined3d_settings.multiply_special == 1 && shader_version < WINED3D_SHADER_VERSION(4, 0);
+    suffix = string_buffer_get(priv->string_buffers);
+
     switch (ins->handler_idx)
     {
         case WINED3DSIH_EXP:
         case WINED3DSIH_EXPP:
             prefix = "exp2(";
-            suffix = ")";
+            string_buffer_sprintf(suffix, ")");
             break;
 
         case WINED3DSIH_LOG:
         case WINED3DSIH_LOGP:
-            prefix = "log2(abs(";
-            suffix = "))";
+            if (guard_inf)
+            {
+                prefix = "max(log2(abs(";
+                string_buffer_sprintf(suffix, ")), ");
+                shader_glsl_append_imm_vec(suffix, &min_float, 1, priv->gl_info);
+                shader_addline(suffix, ")");
+            }
+            else
+            {
+                prefix = "log2(abs(";
+                string_buffer_sprintf(suffix, "))");
+            }
             break;
 
         case WINED3DSIH_RCP:
-            prefix = "1.0 / ";
-            suffix = "";
+            if (guard_inf)
+            {
+                prefix = "clamp(1.0 / ";
+                string_buffer_sprintf(suffix, ", ");
+                shader_glsl_append_imm_vec(suffix, &min_float, 1, priv->gl_info);
+                shader_addline(suffix, ", ");
+                shader_glsl_append_imm_vec(suffix, &max_float, 1, priv->gl_info);
+                shader_addline(suffix, ")");
+            }
+            else
+            {
+                prefix = "1.0 / ";
+                string_buffer_clear(suffix);
+            }
             break;
 
         case WINED3DSIH_RSQ:
-            prefix = "inversesqrt(abs(";
-            suffix = "))";
+            if (guard_inf)
+            {
+                prefix = "min(inversesqrt(abs(";
+                string_buffer_sprintf(suffix, ")), ");
+                shader_glsl_append_imm_vec(suffix, &max_float, 1, priv->gl_info);
+                shader_addline(suffix, ")");
+            }
+            else
+            {
+                prefix = "inversesqrt(abs(";
+                string_buffer_sprintf(suffix, "))");
+            }
             break;
 
         default:
             prefix = "";
-            suffix = "";
+            string_buffer_clear(suffix);
             FIXME("Unhandled instruction %#x.\n", ins->handler_idx);
             break;
     }
 
     if (dst_size > 1 && shader_version < WINED3D_SHADER_VERSION(4, 0))
-        shader_addline(buffer, "vec%u(%s%s%s));\n", dst_size, prefix, src0_param.param_str, suffix);
+        shader_addline(buffer, "vec%u(%s%s%s));\n", dst_size, prefix, src0_param.param_str, suffix->buffer);
     else
-        shader_addline(buffer, "%s%s%s);\n", prefix, src0_param.param_str, suffix);
+        shader_addline(buffer, "%s%s%s);\n", prefix, src0_param.param_str, suffix->buffer);
+
+    string_buffer_release(priv->string_buffers, suffix);
 }
 
 /** Process the WINED3DSIO_EXPP instruction in GLSL:
@@ -4611,8 +4823,13 @@ static void shader_glsl_mad(const struct wined3d_shader_instruction *ins)
     shader_glsl_add_src_param(ins, &ins->src[0], write_mask, &src0_param);
     shader_glsl_add_src_param(ins, &ins->src[1], write_mask, &src1_param);
     shader_glsl_add_src_param(ins, &ins->src[2], write_mask, &src2_param);
-    shader_addline(ins->ctx->buffer, "(%s * %s) + %s);\n",
-            src0_param.param_str, src1_param.param_str, src2_param.param_str);
+    if (wined3d_settings.multiply_special == 2 && ins->ctx->reg_maps->shader_version.major < 4)
+        shader_addline(ins->ctx->buffer, "mul%d(%s, %s) + %s);\n",
+                shader_glsl_get_write_mask_size(write_mask), src0_param.param_str,
+                src1_param.param_str, src2_param.param_str);
+    else
+        shader_addline(ins->ctx->buffer, "(%s * %s) + %s);\n",
+                src0_param.param_str, src1_param.param_str, src2_param.param_str);
 }
 
 /* Handles transforming all WINED3DSIO_M?x? opcodes for
@@ -5421,26 +5638,30 @@ static void shader_glsl_atomic(const struct wined3d_shader_instruction *ins)
                 op = "imageAtomicAdd";
             break;
         case WINED3DSIH_ATOMIC_IMAX:
+        case WINED3DSIH_ATOMIC_UMAX:
         case WINED3DSIH_IMM_ATOMIC_IMAX:
+        case WINED3DSIH_IMM_ATOMIC_UMAX:
             if (is_tgsm)
                 op = "atomicMax";
             else
                 op = "imageAtomicMax";
-            if (data_type != WINED3D_DATA_INT)
+            if (data_type != WINED3D_DATA_INT && data_type != WINED3D_DATA_UINT)
             {
-                FIXME("Unhandled opcode %#x for unsigned integers.\n", ins->handler_idx);
+                FIXME("Unhandled opcode %#x for integers.\n", ins->handler_idx);
                 return;
             }
             break;
         case WINED3DSIH_ATOMIC_IMIN:
+        case WINED3DSIH_ATOMIC_UMIN:
         case WINED3DSIH_IMM_ATOMIC_IMIN:
+        case WINED3DSIH_IMM_ATOMIC_UMIN:
             if (is_tgsm)
                 op = "atomicMin";
             else
                 op = "imageAtomicMin";
-            if (data_type != WINED3D_DATA_INT)
+            if (data_type != WINED3D_DATA_INT && data_type != WINED3D_DATA_UINT)
             {
-                FIXME("Unhandled opcode %#x for unsigned integers.\n", ins->handler_idx);
+                FIXME("Unhandled opcode %#x for integers.\n", ins->handler_idx);
                 return;
             }
             break;
@@ -5451,30 +5672,6 @@ static void shader_glsl_atomic(const struct wined3d_shader_instruction *ins)
             else
                 op = "imageAtomicOr";
             break;
-        case WINED3DSIH_ATOMIC_UMAX:
-        case WINED3DSIH_IMM_ATOMIC_UMAX:
-            if (is_tgsm)
-                op = "atomicMax";
-            else
-                op = "imageAtomicMax";
-            if (data_type != WINED3D_DATA_UINT)
-            {
-                FIXME("Unhandled opcode %#x for signed integers.\n", ins->handler_idx);
-                return;
-            }
-            break;
-        case WINED3DSIH_ATOMIC_UMIN:
-        case WINED3DSIH_IMM_ATOMIC_UMIN:
-            if (is_tgsm)
-                op = "atomicMin";
-            else
-                op = "imageAtomicMin";
-            if (data_type != WINED3D_DATA_UINT)
-            {
-                FIXME("Unhandled opcode %#x for signed integers.\n", ins->handler_idx);
-                return;
-            }
-            break;
         case WINED3DSIH_ATOMIC_XOR:
         case WINED3DSIH_IMM_ATOMIC_XOR:
             if (is_tgsm)
@@ -7546,6 +7743,8 @@ static void shader_glsl_generate_colour_key_test(struct wined3d_string_buffer *b
 static void shader_glsl_enable_extensions(struct wined3d_string_buffer *buffer,
         const struct wined3d_gl_info *gl_info)
 {
+    if (gl_info->supported[ARB_BINDLESS_TEXTURE])
+        shader_addline(buffer, "#extension GL_ARB_bindless_texture : enable\n");
     if (gl_info->supported[ARB_CULL_DISTANCE])
         shader_addline(buffer, "#extension GL_ARB_cull_distance : enable\n");
     if (gl_info->supported[ARB_GPU_SHADER5])
@@ -11557,6 +11756,7 @@ const struct wined3d_shader_backend_ops glsl_shader_backend =
     shader_glsl_init_context_state,
     shader_glsl_get_caps,
     shader_glsl_color_fixup_supported,
+    shader_glsl_load_sampler_handles,
     shader_glsl_shader_compile,
 };
 
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
index 91105a4..6b97353 100644
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -2026,6 +2026,12 @@ static BOOL shader_none_color_fixup_supported(struct color_fixup_desc fixup)
     return TRUE;
 }
 
+void shader_none_resource_view_handle(void *shader_priv, struct wined3d_context *context,
+            const struct wined3d_state *state, const struct wined3d_shader *shader)
+{
+    ERR("Not implemented.\n");
+}
+
 static uint64_t shader_none_shader_compile(struct wined3d_context *context, const struct wined3d_shader_desc *shader_desc,
         enum wined3d_shader_type shader_type)
 {
@@ -2050,6 +2056,7 @@ const struct wined3d_shader_backend_ops none_shader_backend =
     shader_none_init_context_state,
     shader_none_get_caps,
     shader_none_color_fixup_supported,
+    shader_none_resource_view_handle,
     shader_none_shader_compile,
 };
 
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index 87b3d3c..302ca8d 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -209,6 +209,25 @@ static void convert_yuy2_r5g6b5(const BYTE *src, BYTE *dst,
     }
 }
 
+static void convert_x8r8g8b8_l8(const BYTE *src, BYTE *dst,
+        unsigned int pitch_in, unsigned int pitch_out, unsigned int w, unsigned int h)
+{
+    unsigned int x, y;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u.\n", w, h, pitch_in, pitch_out);
+
+    for (y = 0; y < h; ++y)
+    {
+        const DWORD *src_line = (const DWORD *)(src + y * pitch_in);
+        BYTE *dst_line = (BYTE *)(dst + y * pitch_out);
+
+        for (x = 0; x < w; ++x)
+        {
+            dst_line[x] = src_line[x] & 0x000000ff;
+        }
+    }
+}
+
 struct d3dfmt_converter_desc
 {
     enum wined3d_format_id from, to;
@@ -225,6 +244,7 @@ static const struct d3dfmt_converter_desc converters[] =
     {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_B8G8R8A8_UNORM,  convert_a8r8g8b8_x8r8g8b8},
     {WINED3DFMT_YUY2,           WINED3DFMT_B8G8R8X8_UNORM,  convert_yuy2_x8r8g8b8},
     {WINED3DFMT_YUY2,           WINED3DFMT_B5G6R5_UNORM,    convert_yuy2_r5g6b5},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_L8_UNORM,        convert_x8r8g8b8_l8},
 };
 
 static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_format_id from,
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
index 8a02847..476f6d1 100644
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -523,8 +523,9 @@ static void wined3d_swapchain_gl_rotate(struct wined3d_swapchain *swapchain, str
     unsigned int i;
     static const DWORD supported_locations = WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_RB_MULTISAMPLE;
 
-    if (swapchain->state.desc.backbuffer_count < 2 || wined3d_settings.offscreen_rendering_mode != ORM_FBO)
-        return;
+    if (swapchain->state.desc.swap_effect == WINED3D_SWAP_EFFECT_DISCARD
+            || swapchain->state.desc.backbuffer_count < 2 || wined3d_settings.offscreen_rendering_mode != ORM_FBO)
+         return;
 
     texture_prev = wined3d_texture_gl(swapchain->back_buffers[0]);
 
@@ -1178,7 +1179,8 @@ static void wined3d_swapchain_vk_rotate(struct wined3d_swapchain *swapchain, str
 
     static const DWORD supported_locations = WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_RB_MULTISAMPLE;
 
-    if (swapchain->state.desc.backbuffer_count < 2)
+    if (swapchain->state.desc.swap_effect == WINED3D_SWAP_EFFECT_DISCARD
+            || swapchain->state.desc.backbuffer_count < 2)
         return;
 
     texture_prev = wined3d_texture_vk(swapchain->back_buffers[0]);
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 8a7f945..b272769 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -1296,7 +1296,7 @@ void wined3d_gl_texture_swizzle_from_color_fixup(GLint swizzle[4], struct color_
 }
 
 /* Context activation is done by the caller. */
-void wined3d_texture_gl_bind(struct wined3d_texture_gl *texture_gl,
+GLuint wined3d_texture_gl_get_bindless_name(struct wined3d_texture_gl *texture_gl,
         struct wined3d_context_gl *context_gl, BOOL srgb)
 {
     const struct wined3d_format *format = texture_gl->t.resource.format;
@@ -1320,10 +1320,7 @@ void wined3d_texture_gl_bind(struct wined3d_texture_gl *texture_gl,
     target = texture_gl->target;
 
     if (gl_tex->name)
-    {
-        wined3d_context_gl_bind_texture(context_gl, target, gl_tex->name);
-        return;
-    }
+        return gl_tex->name;
 
     gl_info->gl_ops.gl.p_glGenTextures(1, &gl_tex->name);
     checkGLcall("glGenTextures");
@@ -1332,7 +1329,7 @@ void wined3d_texture_gl_bind(struct wined3d_texture_gl *texture_gl,
     if (!gl_tex->name)
     {
         ERR("Failed to generate a texture name.\n");
-        return;
+        return 0;
     }
 
     /* Initialise the state of the texture object to the OpenGL defaults, not
@@ -1416,6 +1413,15 @@ void wined3d_texture_gl_bind(struct wined3d_texture_gl *texture_gl,
         gl_info->gl_ops.gl.p_glTexParameteriv(target, GL_TEXTURE_SWIZZLE_RGBA, swizzle);
         checkGLcall("set format swizzle");
     }
+
+    return gl_tex->name;
+}
+
+/* Context activation is done by the caller. */
+void wined3d_texture_gl_bind(struct wined3d_texture_gl *texture_gl,
+        struct wined3d_context_gl *context_gl, BOOL srgb)
+{
+    wined3d_context_gl_bind_texture(context_gl, texture_gl->target, wined3d_texture_gl_get_bindless_name(texture_gl, context_gl, srgb));
 }
 
 /* Context activation is done by the caller. */
@@ -2829,6 +2835,7 @@ static void wined3d_texture_gl_download_data(struct wined3d_context *context,
     struct wined3d_bo *dst_bo;
     BOOL srgb = FALSE;
     GLenum target;
+    struct wined3d_texture_sub_resource *sub_resource;
 
     TRACE("context %p, src_texture %p, src_sub_resource_idx %u, src_location %s, src_box %s, dst_bo_addr %s, "
             "dst_format %s, dst_x %u, dst_y %u, dst_z %u, dst_row_pitch %u, dst_slice_pitch %u.\n",
@@ -2883,6 +2890,7 @@ static void wined3d_texture_gl_download_data(struct wined3d_context *context,
 
     format_gl = wined3d_format_gl(src_texture->resource.format);
     target = wined3d_texture_gl_get_sub_resource_target(src_texture_gl, src_sub_resource_idx);
+    sub_resource = &src_texture->sub_resources[src_sub_resource_idx];
 
     if ((src_texture->resource.type == WINED3D_RTYPE_TEXTURE_2D
             && (target == GL_TEXTURE_2D_ARRAY || format_gl->f.conv_byte_count
@@ -2921,6 +2929,23 @@ static void wined3d_texture_gl_download_data(struct wined3d_context *context,
         GL_EXTCALL(glGetCompressedTexImage(target, src_level, offset));
         checkGLcall("glGetCompressedTexImage");
     }
+    else if (dst_bo_addr->buffer_object && src_texture->resource.bind_flags & WINED3D_BIND_RENDER_TARGET)
+    {
+        /* PBO texture download is not accelerated on Mesa. Use glReadPixels if possible. */
+        TRACE("Downloading (glReadPixels) texture %p, %u, level %u, format %#x, type %#x, data %p.\n",
+                src_texture, src_sub_resource_idx, src_level, format_gl->format, format_gl->type, dst_bo_addr->addr);
+
+        wined3d_context_gl_apply_fbo_state_explicit(context_gl, GL_READ_FRAMEBUFFER, &src_texture->resource, src_sub_resource_idx, NULL,
+                0, sub_resource->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB));
+        wined3d_context_gl_check_fbo_status(context_gl, GL_READ_FRAMEBUFFER);
+        context_invalidate_state(context, STATE_FRAMEBUFFER);
+        gl_info->gl_ops.gl.p_glReadBuffer(GL_COLOR_ATTACHMENT0);
+        checkGLcall("glReadBuffer()");
+
+        gl_info->gl_ops.gl.p_glReadPixels(0, 0, wined3d_texture_get_level_width(src_texture, src_level),
+                wined3d_texture_get_level_height(src_texture, src_level), format_gl->format, format_gl->type, dst_bo_addr->addr);
+        checkGLcall("glReadPixels");
+    }
     else
     {
         TRACE("Downloading texture %p, %u, level %u, format %#x, type %#x, data %p.\n",
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
index c86501c..4a46654 100644
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -1311,6 +1311,35 @@ void wined3d_shader_resource_view_gl_bind(struct wined3d_shader_resource_view_gl
         context_gl->c.constant_update_mask |= WINED3D_SHADER_CONST_PS_NP2_FIXUP;
 }
 
+GLuint64 wined3d_shader_resource_view_gl_handle(struct wined3d_shader_resource_view_gl *view_gl,
+        struct wined3d_sampler *sampler, struct wined3d_context_gl *context_gl)
+{
+    const struct wined3d_gl_info *gl_info = context_gl->gl_info;
+    GLuint name;
+    GLuint64 handle;
+
+    if (view_gl->gl_view.name)
+    {
+        name = view_gl->gl_view.name;
+    }
+    else if (view_gl->v.resource->type == WINED3D_RTYPE_BUFFER)
+    {
+        FIXME("Buffer shader resources not supported.\n");
+        return 0;
+    }
+    else
+    {
+        struct wined3d_texture_gl *texture_gl = wined3d_texture_gl(wined3d_texture_from_resource(view_gl->v.resource));
+        name = wined3d_texture_gl_get_bindless_name(texture_gl, context_gl, FALSE);
+    }
+
+    handle = GL_EXTCALL(glGetTextureSamplerHandleARB(name, wined3d_sampler_gl(sampler)->name));
+    checkGLcall("glGetTextureSamplerHandleARB");
+    GL_EXTCALL(glMakeTextureHandleResidentARB(handle));
+    checkGLcall("glMakeTextureHandleResidentARB");
+    return handle;
+}
+
 /* Context activation is done by the caller. */
 static void shader_resource_view_gl_bind_and_dirtify(struct wined3d_shader_resource_view_gl *view_gl,
         struct wined3d_context_gl *context_gl)
diff --git a/dlls/wined3d/wined3d_gl.h b/dlls/wined3d/wined3d_gl.h
index dc6901b..11e28eb 100644
--- a/dlls/wined3d/wined3d_gl.h
+++ b/dlls/wined3d/wined3d_gl.h
@@ -51,6 +51,7 @@ enum wined3d_gl_extension
     APPLE_YCBCR_422,
     /* ARB */
     ARB_BASE_INSTANCE,
+    ARB_BINDLESS_TEXTURE,
     ARB_BLEND_FUNC_EXTENDED,
     ARB_BUFFER_STORAGE,
     ARB_CLEAR_BUFFER_OBJECT,
@@ -223,6 +224,7 @@ enum wined3d_gl_extension
     NV_VERTEX_PROGRAM2_OPTION,
     NV_VERTEX_PROGRAM3,
     NV_TEXTURE_BARRIER,
+    NVX_GPU_MEMORY_INFO,
     /* WGL extensions */
     WGL_ARB_PIXEL_FORMAT,
     WGL_EXT_SWAP_CONTROL,
@@ -861,6 +863,21 @@ struct wined3d_dummy_textures
     GLuint tex_2d_ms_array;
 };
 
+struct wined3d_dummy_sampler_handles
+{
+    GLuint64 tex_1d;
+    GLuint64 tex_2d;
+    GLuint64 tex_rect;
+    GLuint64 tex_3d;
+    GLuint64 tex_cube;
+    GLuint64 tex_cube_array;
+    GLuint64 tex_1d_array;
+    GLuint64 tex_2d_array;
+    GLuint64 tex_buffer;
+    GLuint64 tex_2d_ms;
+    GLuint64 tex_2d_ms_array;
+};
+
 struct wined3d_device_gl
 {
     struct wined3d_device d;
@@ -868,6 +885,9 @@ struct wined3d_device_gl
     /* Textures for when no other textures are bound. */
     struct wined3d_dummy_textures dummy_textures;
 
+    /* Texture sampler handles for when no texture is mapped */
+    struct wined3d_dummy_sampler_handles dummy_sampler_handles;
+
     CRITICAL_SECTION allocator_cs;
     struct wined3d_allocator allocator;
     uint64_t completed_fence_id;
@@ -1037,6 +1057,8 @@ void wined3d_texture_gl_apply_sampler_desc(struct wined3d_texture_gl *texture_gl
 void wined3d_texture_gl_bind(struct wined3d_texture_gl *texture_gl, struct wined3d_context_gl *context_gl, BOOL srgb);
 void wined3d_texture_gl_bind_and_dirtify(struct wined3d_texture_gl *texture_gl,
         struct wined3d_context_gl *context_gl, BOOL srgb);
+GLuint wined3d_texture_gl_get_bindless_name(struct wined3d_texture_gl *texture_gl,
+        struct wined3d_context_gl *context_gl, BOOL srgb);
 HRESULT wined3d_texture_gl_init(struct wined3d_texture_gl *texture_gl, struct wined3d_device *device,
         const struct wined3d_resource_desc *desc, unsigned int layer_count, unsigned int level_count,
         uint32_t flags, void *parent, const struct wined3d_parent_ops *parent_ops);
@@ -1114,6 +1136,8 @@ void wined3d_shader_resource_view_gl_bind(struct wined3d_shader_resource_view_gl
         struct wined3d_sampler_gl *sampler_gl, struct wined3d_context_gl *context_gl);
 void wined3d_shader_resource_view_gl_generate_mipmap(struct wined3d_shader_resource_view_gl *srv_gl,
         struct wined3d_context_gl *context_gl);
+GLuint64 wined3d_shader_resource_view_gl_handle(struct wined3d_shader_resource_view_gl *view_gl,
+        struct wined3d_sampler *sampler, struct wined3d_context_gl *context_gl);
 HRESULT wined3d_shader_resource_view_gl_init(struct wined3d_shader_resource_view_gl *view_gl,
         const struct wined3d_view_desc *desc, struct wined3d_resource *resource,
         void *parent, const struct wined3d_parent_ops *parent_ops);
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
index 1368b4f..159096f 100644
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -445,6 +445,8 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             ERR_(winediag)("Setting strict shader math to %#x.\n", wined3d_settings.strict_shader_math);
         if (!get_config_key_dword(hkey, appkey, env, "MaxShaderModelVS", &wined3d_settings.max_sm_vs))
             TRACE("Limiting VS shader model to %u.\n", wined3d_settings.max_sm_vs);
+        if (!get_config_key_dword(hkey, appkey, env, "multiply_special", &wined3d_settings.multiply_special))
+            ERR_(winediag)("Setting multiply special to %#x.\n", wined3d_settings.multiply_special);
         if (!get_config_key_dword(hkey, appkey, env, "MaxShaderModelHS", &wined3d_settings.max_sm_hs))
             TRACE("Limiting HS shader model to %u.\n", wined3d_settings.max_sm_hs);
         if (!get_config_key_dword(hkey, appkey, env, "MaxShaderModelDS", &wined3d_settings.max_sm_ds))
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 549a2aa..7b23c9e 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -478,6 +478,7 @@ struct wined3d_settings
     unsigned int sample_count;
     BOOL check_float_constants;
     unsigned int strict_shader_math;
+    unsigned int multiply_special;
     unsigned int max_sm_vs;
     unsigned int max_sm_hs;
     unsigned int max_sm_ds;
@@ -1560,6 +1561,8 @@ struct wined3d_shader_backend_ops
     void (*shader_init_context_state)(struct wined3d_context *context);
     void (*shader_get_caps)(const struct wined3d_adapter *adapter, struct shader_caps *caps);
     BOOL (*shader_color_fixup_supported)(struct color_fixup_desc fixup);
+    void (*shader_load_sampler_handles)(void *shader_priv, struct wined3d_context *context,
+            const struct wined3d_state *state, const struct wined3d_shader *shader);
     uint64_t (*shader_compile)(struct wined3d_context *context, const struct wined3d_shader_desc *shader_desc,
         enum wined3d_shader_type shader_type);
 };
diff --git a/dlls/winemac.drv/keyboard.c b/dlls/winemac.drv/keyboard.c
index bf1daa7..b378bb0 100644
--- a/dlls/winemac.drv/keyboard.c
+++ b/dlls/winemac.drv/keyboard.c
@@ -990,6 +990,7 @@ void macdrv_compute_keyboard_layout(struct macdrv_thread_data *thread_data)
  */
 static void macdrv_send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, unsigned int flags, unsigned int time)
 {
+    RAWINPUT rawinput;
     INPUT input;
 
     TRACE_(key)("hwnd %p vkey=%04x scan=%04x flags=%04x\n", hwnd, vkey, scan, flags);
@@ -1001,7 +1002,7 @@ static void macdrv_send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, unsigned
     input.ki.time           = time;
     input.ki.dwExtraInfo    = 0;
 
-    __wine_send_input(hwnd, &input, NULL);
+    __wine_send_input(hwnd, &input, &rawinput);
 }
 
 
diff --git a/dlls/winemac.drv/macdrv.h b/dlls/winemac.drv/macdrv.h
index 7e43314..8d00a22 100644
--- a/dlls/winemac.drv/macdrv.h
+++ b/dlls/winemac.drv/macdrv.h
@@ -44,6 +44,7 @@
 extern BOOL allow_set_gamma;
 extern BOOL allow_software_rendering;
 extern BOOL disable_window_decorations;
+extern BOOL force_backing_store;
 
 extern const char* debugstr_cf(CFTypeRef t);
 
diff --git a/dlls/winemac.drv/macdrv_main.c b/dlls/winemac.drv/macdrv_main.c
index 21b148f..3034fe2 100644
--- a/dlls/winemac.drv/macdrv_main.c
+++ b/dlls/winemac.drv/macdrv_main.c
@@ -60,6 +60,7 @@ int use_precise_scrolling = TRUE;
 int gl_surface_mode = GL_SURFACE_IN_FRONT_OPAQUE;
 int retina_enabled = FALSE;
 int enable_app_nap = FALSE;
+BOOL force_backing_store = FALSE;
 
 CFDictionaryRef localized_strings;
 
@@ -378,6 +379,9 @@ static void setup_options(void)
     if (!get_config_key(hkey, appkey, "EnableAppNap", buffer, sizeof(buffer)))
         enable_app_nap = IS_OPTION_TRUE(buffer[0]);
 
+    if (!get_config_key(hkey, appkey, "ForceOpenGLBackingStore", buffer, sizeof(buffer)))
+        force_backing_store = IS_OPTION_TRUE(buffer[0]);
+
     /* Don't use appkey.  The DPI and monitor sizes should be consistent for all
        processes in the prefix. */
     if (!get_config_key(hkey, NULL, "RetinaMode", buffer, sizeof(buffer)))
diff --git a/dlls/winemac.drv/mouse.c b/dlls/winemac.drv/mouse.c
index 2f05a33..5799cb0 100644
--- a/dlls/winemac.drv/mouse.c
+++ b/dlls/winemac.drv/mouse.c
@@ -129,6 +129,7 @@ static const CFStringRef cocoa_cursor_names[] =
 static void send_mouse_input(HWND hwnd, macdrv_window cocoa_window, UINT flags, int x, int y,
                              DWORD mouse_data, BOOL drag, unsigned long time)
 {
+    RAWINPUT rawinput;
     INPUT input;
     HWND top_level_hwnd;
 
@@ -158,7 +159,7 @@ static void send_mouse_input(HWND hwnd, macdrv_window cocoa_window, UINT flags,
     input.mi.time           = time;
     input.mi.dwExtraInfo    = 0;
 
-    __wine_send_input(top_level_hwnd, &input, NULL);
+    __wine_send_input(top_level_hwnd, &input, &rawinput);
 }
 
 
diff --git a/dlls/winemac.drv/opengl.c b/dlls/winemac.drv/opengl.c
index f78454e..205c081 100644
--- a/dlls/winemac.drv/opengl.c
+++ b/dlls/winemac.drv/opengl.c
@@ -1451,7 +1451,7 @@ static BOOL create_context(struct wgl_context *context, CGLContextObj share, uns
         attribs[n++] = pf->samples;
     }
 
-    if (pf->backing_store)
+    if (force_backing_store || pf->backing_store)
         attribs[n++] = kCGLPFABackingStore;
 
     if (core)
diff --git a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
index 22d4715..53e34a0 100644
--- a/dlls/winemac.drv/vulkan.c
+++ b/dlls/winemac.drv/vulkan.c
@@ -591,6 +591,8 @@ static VkSurfaceKHR macdrv_wine_get_host_surface(VkSurfaceKHR surface)
 
 static const struct vulkan_funcs vulkan_funcs =
 {
+    NULL,
+    NULL,
     macdrv_vkCreateInstance,
     macdrv_vkCreateSwapchainKHR,
     macdrv_vkCreateWin32SurfaceKHR,
diff --git a/dlls/winemapi/Makefile.in b/dlls/winemapi/Makefile.in
index c9c5a51..99aea12 100644
--- a/dlls/winemapi/Makefile.in
+++ b/dlls/winemapi/Makefile.in
@@ -3,4 +3,5 @@ IMPORTS   = shlwapi shell32 mapi32
 
 SOURCES = \
 	main.c \
-	sendmail.c
+	sendmail.c \
+	xdg-email.c
diff --git a/dlls/winemapi/sendmail.c b/dlls/winemapi/sendmail.c
index 1bd3908..35c85f7 100644
--- a/dlls/winemapi/sendmail.c
+++ b/dlls/winemapi/sendmail.c
@@ -34,6 +34,8 @@
 #include "winternl.h"
 #include "wine/debug.h"
 
+#include "winemapi_private.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(winemapi);
 
 /* Escapes a string for use in mailto: URL */
@@ -68,23 +70,12 @@ static char *escape_string(char *in, char *empty_string)
 }
 
 /**************************************************************************
- *  MAPISendMail
- *
- * Send a message using a native mail client.
- *
- * PARAMS
- *  session  [I] Handle to a MAPI session.
- *  uiparam  [I] Parent window handle.
- *  message  [I] Pointer to a MAPIMessage structure.
- *  flags    [I] Flags.
- *  reserved [I] Reserved, pass 0.
+ *  BrowserSendMail
  *
- * RETURNS
- *  Success: SUCCESS_SUCCESS
- *  Failure: MAPI_E_FAILURE
+ * Send an email by forming a mailto uri and invoking a browser.
  *
  */
-ULONG WINAPI MAPISendMail(LHANDLE session, ULONG_PTR uiparam,
+static ULONG BrowserSendMail(LHANDLE session, ULONG_PTR uiparam,
     lpMapiMessage message, FLAGS flags, ULONG reserved)
 {
     ULONG ret = MAPI_E_FAILURE;
@@ -289,6 +280,35 @@ exit:
     return ret;
 }
 
+/**************************************************************************
+ *  MAPISendMail
+ *
+ * Send a message using a native mail client.
+ *
+ * PARAMS
+ *  session  [I] Handle to a MAPI session.
+ *  uiparam  [I] Parent window handle.
+ *  message  [I] Pointer to a MAPIMessage structure.
+ *  flags    [I] Flags.
+ *  reserved [I] Reserved, pass 0.
+ *
+ * RETURNS
+ *  Success: SUCCESS_SUCCESS
+ *  Failure: MAPI_E_FAILURE
+ *
+ */
+ULONG WINAPI MAPISendMail(LHANDLE session, ULONG_PTR uiparam,
+    lpMapiMessage message, FLAGS flags, ULONG reserved)
+{
+    TRACE("(0x%I64xx 0x%I64xx %p 0x%08lx 0x%08lx)\n", session, uiparam,
+           message, flags, reserved);
+
+    if (XDGMailAvailable())
+        return XDGSendMail(session, uiparam, message, flags, reserved);
+
+    return BrowserSendMail(session, uiparam, message, flags, reserved);
+}
+
 ULONG WINAPI MAPISendDocuments(ULONG_PTR uiparam, LPSTR delim, LPSTR paths,
     LPSTR filenames, ULONG reserved)
 {
diff --git a/dlls/winepulse.drv/pulse.c b/dlls/winepulse.drv/pulse.c
index 62658fc..d9289d6 100644
--- a/dlls/winepulse.drv/pulse.c
+++ b/dlls/winepulse.drv/pulse.c
@@ -433,9 +433,11 @@ static UINT pulse_channel_map_to_channel_mask(const pa_channel_map *map)
     for (i = 0; i < map->channels; ++i) {
         switch (map->map[i]) {
             default: FIXME("Unhandled channel %s\n", pa_channel_position_to_string(map->map[i])); break;
+            case PA_CHANNEL_POSITION_AUX0:
             case PA_CHANNEL_POSITION_FRONT_LEFT: mask |= SPEAKER_FRONT_LEFT; break;
             case PA_CHANNEL_POSITION_MONO:
             case PA_CHANNEL_POSITION_FRONT_CENTER: mask |= SPEAKER_FRONT_CENTER; break;
+            case PA_CHANNEL_POSITION_AUX1:
             case PA_CHANNEL_POSITION_FRONT_RIGHT: mask |= SPEAKER_FRONT_RIGHT; break;
             case PA_CHANNEL_POSITION_REAR_LEFT: mask |= SPEAKER_BACK_LEFT; break;
             case PA_CHANNEL_POSITION_REAR_CENTER: mask |= SPEAKER_BACK_CENTER; break;
@@ -693,7 +695,8 @@ static void convert_channel_map(const pa_channel_map *pa_map, WAVEFORMATEXTENSIB
     fmt->dwChannelMask = pa_mask;
 }
 
-static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATEXTENSIBLE *fmt, REFERENCE_TIME *def_period, REFERENCE_TIME *min_period)
+static void pulse_probe_settings(pa_mainloop *ml, pa_context *ctx, int render, const char *pulse_name,
+                                 WAVEFORMATEXTENSIBLE *fmt, REFERENCE_TIME *def_period, REFERENCE_TIME *min_period)
 {
     WAVEFORMATEX *wfx = &fmt->Format;
     pa_stream *stream;
@@ -716,7 +719,7 @@ static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATE
     attr.minreq = attr.fragsize = pa_frame_size(&ss);
     attr.prebuf = 0;
 
-    stream = pa_stream_new(pulse_ctx, "format test stream", &ss, &map);
+    stream = pa_stream_new(ctx, "format test stream", &ss, &map);
     if (stream)
         pa_stream_set_state_callback(stream, pulse_stream_state, NULL);
     if (!stream)
@@ -727,7 +730,7 @@ static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATE
     else
         ret = pa_stream_connect_record(stream, pulse_name, &attr, PA_STREAM_START_CORKED|PA_STREAM_FIX_RATE|PA_STREAM_FIX_CHANNELS|PA_STREAM_EARLY_REQUESTS);
     if (ret >= 0) {
-        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
                 pa_stream_get_state(stream) == PA_STREAM_CREATING)
         {}
         if (pa_stream_get_state(stream) == PA_STREAM_READY) {
@@ -738,7 +741,7 @@ static void pulse_probe_settings(int render, const char *pulse_name, WAVEFORMATE
             else
                 length = pa_stream_get_buffer_attr(stream)->fragsize;
             pa_stream_disconnect(stream);
-            while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+            while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
                     pa_stream_get_state(stream) == PA_STREAM_READY)
             {}
         }
@@ -786,34 +789,33 @@ static NTSTATUS pulse_test_connect(void *args)
     pa_operation *o;
     int ret;
     char *name = wstr_to_str(params->name);
+    pa_mainloop *ml;
+    pa_context *ctx;
 
     pulse_lock();
-    pulse_ml = pa_mainloop_new();
+    ml = pa_mainloop_new();
 
-    pa_mainloop_set_poll_func(pulse_ml, pulse_poll_func, NULL);
-
-    pulse_ctx = pa_context_new(pa_mainloop_get_api(pulse_ml), name);
+    pa_mainloop_set_poll_func(ml, pulse_poll_func, NULL);
 
+    ctx = pa_context_new(pa_mainloop_get_api(ml), name);
     free(name);
-
-    if (!pulse_ctx) {
+    if (!ctx) {
         ERR("Failed to create context\n");
-        pa_mainloop_free(pulse_ml);
-        pulse_ml = NULL;
+        pa_mainloop_free(ml);
         pulse_unlock();
         params->priority = Priority_Unavailable;
         return STATUS_SUCCESS;
     }
 
-    pa_context_set_state_callback(pulse_ctx, pulse_contextcallback, NULL);
+    pa_context_set_state_callback(ctx, pulse_contextcallback, NULL);
 
-    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(pulse_ctx), PA_API_VERSION);
-    if (pa_context_connect(pulse_ctx, NULL, 0, NULL) < 0)
+    TRACE("libpulse protocol version: %u. API Version %u\n", pa_context_get_protocol_version(ctx), PA_API_VERSION);
+    if (pa_context_connect(ctx, NULL, 0, NULL) < 0)
         goto fail;
 
     /* Wait for connection */
-    while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0) {
-        pa_context_state_t state = pa_context_get_state(pulse_ctx);
+    while (pa_mainloop_iterate(ml, 1, &ret) >= 0) {
+        pa_context_state_t state = pa_context_get_state(ctx);
 
         if (state == PA_CONTEXT_FAILED || state == PA_CONTEXT_TERMINATED)
             goto fail;
@@ -822,12 +824,12 @@ static NTSTATUS pulse_test_connect(void *args)
             break;
     }
 
-    if (pa_context_get_state(pulse_ctx) != PA_CONTEXT_READY)
+    if (pa_context_get_state(ctx) != PA_CONTEXT_READY)
         goto fail;
 
     TRACE("Test-connected to server %s with protocol version: %i.\n",
-        pa_context_get_server(pulse_ctx),
-        pa_context_get_server_protocol_version(pulse_ctx));
+        pa_context_get_server(ctx),
+        pa_context_get_server_protocol_version(ctx));
 
     free_phys_device_lists();
     list_init(&g_phys_speakers);
@@ -837,34 +839,32 @@ static NTSTATUS pulse_test_connect(void *args)
     pulse_add_device(&g_phys_speakers, NULL, 0, Speakers, 0, "", "PulseAudio Output");
     pulse_add_device(&g_phys_sources, NULL, 0, Microphone, 0, "", "PulseAudio Input");
 
-    o = pa_context_get_sink_info_list(pulse_ctx, &pulse_phys_speakers_cb, NULL);
+    o = pa_context_get_sink_info_list(ctx, &pulse_phys_speakers_cb, NULL);
     if (o) {
-        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
                 pa_operation_get_state(o) == PA_OPERATION_RUNNING)
         {}
         pa_operation_unref(o);
     }
 
-    o = pa_context_get_source_info_list(pulse_ctx, &pulse_phys_sources_cb, NULL);
+    o = pa_context_get_source_info_list(ctx, &pulse_phys_sources_cb, NULL);
     if (o) {
-        while (pa_mainloop_iterate(pulse_ml, 1, &ret) >= 0 &&
+        while (pa_mainloop_iterate(ml, 1, &ret) >= 0 &&
                 pa_operation_get_state(o) == PA_OPERATION_RUNNING)
         {}
         pa_operation_unref(o);
     }
 
     LIST_FOR_EACH_ENTRY(dev, &g_phys_speakers, PhysDevice, entry) {
-        pulse_probe_settings(1, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
+        pulse_probe_settings(ml, ctx, 1, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
     }
 
     LIST_FOR_EACH_ENTRY(dev, &g_phys_sources, PhysDevice, entry) {
-        pulse_probe_settings(0, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
+        pulse_probe_settings(ml, ctx, 0, dev->pulse_name, &dev->fmt, &dev->def_period, &dev->min_period);
     }
 
-    pa_context_unref(pulse_ctx);
-    pulse_ctx = NULL;
-    pa_mainloop_free(pulse_ml);
-    pulse_ml = NULL;
+    pa_context_unref(ctx);
+    pa_mainloop_free(ml);
 
     pulse_unlock();
 
@@ -872,10 +872,8 @@ static NTSTATUS pulse_test_connect(void *args)
     return STATUS_SUCCESS;
 
 fail:
-    pa_context_unref(pulse_ctx);
-    pulse_ctx = NULL;
-    pa_mainloop_free(pulse_ml);
-    pulse_ml = NULL;
+    pa_context_unref(ctx);
+    pa_mainloop_free(ml);
     pulse_unlock();
     params->priority = Priority_Unavailable;
     return STATUS_SUCCESS;
@@ -925,7 +923,9 @@ static const enum pa_channel_position pulse_pos_from_wfx[] = {
     PA_CHANNEL_POSITION_TOP_FRONT_RIGHT,
     PA_CHANNEL_POSITION_TOP_REAR_LEFT,
     PA_CHANNEL_POSITION_TOP_REAR_CENTER,
-    PA_CHANNEL_POSITION_TOP_REAR_RIGHT
+    PA_CHANNEL_POSITION_TOP_REAR_RIGHT,
+    PA_CHANNEL_POSITION_AUX0,
+    PA_CHANNEL_POSITION_AUX1
 };
 
 static HRESULT pulse_spec_from_waveformat(struct pulse_stream *stream, const WAVEFORMATEX *fmt)
diff --git a/dlls/winex11.drv/bitblt.c b/dlls/winex11.drv/bitblt.c
index 94aa067..feb1a0a 100644
--- a/dlls/winex11.drv/bitblt.c
+++ b/dlls/winex11.drv/bitblt.c
@@ -48,6 +48,7 @@
 
 #include "x11drv.h"
 #include "winternl.h"
+#include "wine/server.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(bitblt);
@@ -1627,6 +1628,48 @@ static inline void add_row( HRGN rgn, RGNDATA *data, int x, int y, int len )
 }
 #endif
 
+static void set_layer_region( struct x11drv_window_surface *surface, HRGN hrgn )
+{
+    static const RECT empty_rect;
+    RGNDATA *data;
+    DWORD size;
+    HWND hwnd;
+
+    if (XFindContext( thread_init_display(), surface->window, winContext, (char **)&hwnd ))
+        return;
+
+    if (hrgn)
+    {
+        if (!(size = NtGdiGetRegionData( hrgn, 0, NULL ))) return;
+        if (!(data = malloc( size ))) return;
+        if (!NtGdiGetRegionData( hrgn, size, data ))
+        {
+            free( data );
+            return;
+        }
+        SERVER_START_REQ( set_layer_region )
+        {
+            req->window = wine_server_user_handle( hwnd );
+            if (data->rdh.nCount)
+                wine_server_add_data( req, data->Buffer, data->rdh.nCount * sizeof(RECT) );
+            else
+                wine_server_add_data( req, &empty_rect, sizeof(empty_rect) );
+            wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        free( data );
+    }
+    else  /* clear existing region */
+    {
+        SERVER_START_REQ( set_layer_region )
+        {
+            req->window = wine_server_user_handle( hwnd );
+            wine_server_call( req );
+        }
+        SERVER_END_REQ;
+    }
+}
+
 /***********************************************************************
  *           update_surface_region
  */
@@ -1645,6 +1688,7 @@ static void update_surface_region( struct x11drv_window_surface *surface )
     if (!surface->is_argb && surface->color_key == CLR_INVALID)
     {
         XShapeCombineMask( gdi_display, surface->window, ShapeBounding, 0, 0, None, ShapeSet );
+        set_layer_region( surface, NULL );
         return;
     }
 
@@ -1755,6 +1799,7 @@ static void update_surface_region( struct x11drv_window_surface *surface )
         free( data );
     }
 
+    set_layer_region( surface, rgn );
     NtGdiDeleteObjectApp( rgn );
 #endif
 }
diff --git a/dlls/winex11.drv/clipboard.c b/dlls/winex11.drv/clipboard.c
index 087e0aa..3714e15 100644
--- a/dlls/winex11.drv/clipboard.c
+++ b/dlls/winex11.drv/clipboard.c
@@ -83,6 +83,7 @@
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "x11drv.h"
+#include "xfixes.h"
 
 #ifdef HAVE_X11_EXTENSIONS_XFIXES_H
 #include <X11/extensions/Xfixes.h>
@@ -199,7 +200,6 @@ static UINT rendered_formats;
 static ULONG last_clipboard_update;
 static struct clipboard_format **current_x11_formats;
 static unsigned int nb_current_x11_formats;
-static BOOL use_xfixes;
 
 Display *clipboard_display = NULL;
 
@@ -2170,28 +2170,6 @@ static BOOL selection_notify_event( HWND hwnd, XEvent *event )
 static void xfixes_init(void)
 {
 #ifdef SONAME_LIBXFIXES
-    typeof(XFixesSelectSelectionInput) *pXFixesSelectSelectionInput;
-    typeof(XFixesQueryExtension) *pXFixesQueryExtension;
-    typeof(XFixesQueryVersion) *pXFixesQueryVersion;
-
-    int event_base, error_base;
-    int major = 3, minor = 0;
-    void *handle;
-
-    handle = dlopen(SONAME_LIBXFIXES, RTLD_NOW);
-    if (!handle) return;
-
-    pXFixesQueryExtension = dlsym(handle, "XFixesQueryExtension");
-    if (!pXFixesQueryExtension) return;
-    pXFixesQueryVersion = dlsym(handle, "XFixesQueryVersion");
-    if (!pXFixesQueryVersion) return;
-    pXFixesSelectSelectionInput = dlsym(handle, "XFixesSelectSelectionInput");
-    if (!pXFixesSelectSelectionInput) return;
-
-    if (!pXFixesQueryExtension(clipboard_display, &event_base, &error_base))
-        return;
-    pXFixesQueryVersion(clipboard_display, &major, &minor);
-    use_xfixes = (major >= 1);
     if (!use_xfixes) return;
 
     pXFixesSelectSelectionInput(clipboard_display, import_window, x11drv_atom(CLIPBOARD),
@@ -2205,7 +2183,7 @@ static void xfixes_init(void)
                 XFixesSelectionWindowDestroyNotifyMask |
                 XFixesSelectionClientCloseNotifyMask);
     }
-    X11DRV_register_event_handler(event_base + XFixesSelectionNotify,
+    X11DRV_register_event_handler(xfixes_event_base + XFixesSelectionNotify,
             selection_notify_event, "XFixesSelectionNotify");
     TRACE("xfixes succesully initialized\n");
 #else
diff --git a/dlls/winex11.drv/desktop.c b/dlls/winex11.drv/desktop.c
index d6fa078..ef6f5ff 100644
--- a/dlls/winex11.drv/desktop.c
+++ b/dlls/winex11.drv/desktop.c
@@ -86,6 +86,8 @@ BOOL X11DRV_CreateDesktop( const WCHAR *name, UINT width, UINT height )
                          0, 0, width, height, 0, default_visual.depth, InputOutput,
                          default_visual.visual, CWEventMask | CWCursor | CWColormap, &win_attr );
     if (!win) return FALSE;
+
+    x11drv_xinput_enable( display, win, win_attr.event_mask );
     XFlush( display );
 
     X11DRV_init_desktop( win, width, height );
diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index aafb89a..98b1067 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -235,6 +235,13 @@ static Bool filter_event( Display *display, XEvent *event, char *arg )
         return (mask & QS_MOUSEBUTTON) != 0;
 #ifdef GenericEvent
     case GenericEvent:
+#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+        if (event->xcookie.extension == xinput2_opcode &&
+            (event->xcookie.evtype == XI_RawMotion ||
+             event->xcookie.evtype == XI_DeviceChanged))
+            return (mask & QS_MOUSEMOVE) != 0;
+#endif
+        return (mask & QS_SENDMESSAGE) != 0;
 #endif
     case MotionNotify:
     case EnterNotify:
@@ -311,6 +318,10 @@ static enum event_merge_action merge_raw_motion_events( XIRawEvent *prev, XIRawE
  */
 static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
 {
+#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+#endif
+
     switch (prev->type)
     {
     case ConfigureNotify:
@@ -342,19 +353,21 @@ static enum event_merge_action merge_events( XEvent *prev, XEvent *next )
         case GenericEvent:
             if (next->xcookie.extension != xinput2_opcode) break;
             if (next->xcookie.evtype != XI_RawMotion) break;
-            if (x11drv_thread_data()->warp_serial) break;
+            if (thread_data->xi2_rawinput_only) break;
+            if (thread_data->warp_serial) break;
             return MERGE_KEEP;
         }
         break;
     case GenericEvent:
         if (prev->xcookie.extension != xinput2_opcode) break;
         if (prev->xcookie.evtype != XI_RawMotion) break;
+        if (thread_data->xi2_rawinput_only) break;
         switch (next->type)
         {
         case GenericEvent:
             if (next->xcookie.extension != xinput2_opcode) break;
             if (next->xcookie.evtype != XI_RawMotion) break;
-            if (x11drv_thread_data()->warp_serial) break;
+            if (thread_data->warp_serial) break;
             return merge_raw_motion_events( prev->xcookie.data, next->xcookie.data );
 #endif
         }
@@ -572,13 +585,27 @@ static void set_input_focus( struct x11drv_win_data *data )
  */
 static void set_focus( Display *display, HWND hwnd, Time time )
 {
-    HWND focus;
+    HWND focus, old_active;
     Window win;
     GUITHREADINFO threadinfo;
 
+    old_active = NtUserGetForegroundWindow();
+
+    /* prevent recursion */
+    x11drv_thread_data()->active_window = hwnd;
+
     TRACE( "setting foreground window to %p\n", hwnd );
     NtUserSetForegroundWindow( hwnd );
 
+    /* Some applications expect that a being deactivated topmost window
+     * receives the WM_WINDOWPOSCHANGING/WM_WINDOWPOSCHANGED messages,
+     * and perform some specific actions. Chessmaster is one of such apps.
+     * Window Manager keeps a topmost window on top in z-oder, so there is
+     * no need to actually do anything, just send the messages.
+     */
+    if (old_active && (NtUserGetWindowLongW( old_active, GWL_EXSTYLE ) & WS_EX_TOPMOST))
+        NtUserSetWindowPos( old_active, hwnd, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOOWNERZORDER );
+
     threadinfo.cbSize = sizeof(threadinfo);
     NtUserGetGUIThreadInfo( 0, &threadinfo );
     focus = threadinfo.hwndFocus;
@@ -816,6 +843,8 @@ static void focus_out( Display *display , HWND hwnd )
 
     if (!is_current_process_focused())
     {
+        x11drv_thread_data()->active_window = 0;
+
         /* Abey : 6-Oct-99. Check again if the focus out window is the
            Foreground window, because in most cases the messages sent
            above must have already changed the foreground window, in which
@@ -942,6 +971,7 @@ static BOOL X11DRV_Expose( HWND hwnd, XEvent *xev )
 static BOOL X11DRV_MapNotify( HWND hwnd, XEvent *event )
 {
     struct x11drv_win_data *data;
+    BOOL is_embedded;
 
     if (event->xany.window == x11drv_thread_data()->clip_window) return TRUE;
 
@@ -953,7 +983,12 @@ static BOOL X11DRV_MapNotify( HWND hwnd, XEvent *event )
         if (hwndFocus && NtUserIsChild( hwnd, hwndFocus ))
             set_input_focus( data );
     }
+
+    is_embedded = data->embedded;
     release_win_data( data );
+
+    if (is_embedded)
+        NtUserEnableWindow( hwnd, TRUE );
     return TRUE;
 }
 
@@ -963,6 +998,17 @@ static BOOL X11DRV_MapNotify( HWND hwnd, XEvent *event )
  */
 static BOOL X11DRV_UnmapNotify( HWND hwnd, XEvent *event )
 {
+    struct x11drv_win_data *data;
+    BOOL is_embedded;
+
+    if (!(data = get_win_data( hwnd ))) return FALSE;
+
+    is_embedded = data->embedded;
+    release_win_data( data );
+
+    if (is_embedded)
+        NtUserEnableWindow( hwnd, FALSE );
+
     return TRUE;
 }
 
diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 43fb0ac..43b3946 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -31,6 +31,9 @@
 #include "winbase.h"
 #include "winreg.h"
 #include "x11drv.h"
+#include "xfixes.h"
+#include "xpresent.h"
+#include "xcomposite.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
@@ -243,18 +246,41 @@ static INT X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOID in_d
                     return TRUE;
                 }
                 break;
-            case X11DRV_FLUSH_GL_DRAWABLE:
-                if (in_count >= sizeof(struct x11drv_escape_flush_gl_drawable))
+            case X11DRV_PRESENT_DRAWABLE:
+                if (in_count >= sizeof(struct x11drv_escape_present_drawable))
                 {
-                    const struct x11drv_escape_flush_gl_drawable *data = in_data;
+                    const struct x11drv_escape_present_drawable *data = in_data;
                     RECT rect = physDev->dc_rect;
 
                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
                     if (data->flush) XFlush( gdi_display );
-                    XSetFunction( gdi_display, physDev->gc, GXcopy );
-                    XCopyArea( gdi_display, data->gl_drawable, physDev->drawable, physDev->gc,
-                               0, 0, rect.right, rect.bottom,
-                               physDev->dc_rect.left, physDev->dc_rect.top );
+
+#if defined(SONAME_LIBXPRESENT) && defined(SONAME_LIBXFIXES)
+                    if (use_xpresent && use_xfixes && usexcomposite)
+                    {
+                        XserverRegion update, valid;
+                        XRectangle xrect = {0, 0, rect.right - rect.left, rect.bottom - rect.top};
+                        Drawable drawable = data->drawable;
+                        update = pXFixesCreateRegionFromGC( gdi_display, physDev->gc );
+                        valid = pXFixesCreateRegion( gdi_display, &xrect, 1 );
+#ifdef SONAME_LIBXCOMPOSITE
+                        if (usexcomposite) drawable = pXCompositeNameWindowPixmap( gdi_display, drawable );
+#endif
+                        pXPresentPixmap( gdi_display, physDev->drawable, drawable, XNextRequest( gdi_display ),
+                                         valid, update, physDev->dc_rect.left, physDev->dc_rect.top, None, None,
+                                         None, 0, 0, 0, 0, NULL, 0 );
+                        pXFixesDestroyRegion( gdi_display, update );
+                        pXFixesDestroyRegion( gdi_display, valid );
+                    }
+                    else
+#endif
+                    {
+                        XSetFunction( gdi_display, physDev->gc, GXcopy );
+                        XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
+                                   0, 0, rect.right, rect.bottom,
+                                   physDev->dc_rect.left, physDev->dc_rect.top );
+                    }
+
                     add_device_bounds( physDev, &rect );
                     return TRUE;
                 }
@@ -316,6 +342,9 @@ static INT X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOID in_d
                     return TRUE;
                 }
                 break;
+            case X11DRV_FLUSH_GDI_DISPLAY:
+                XFlush( gdi_display );
+                return TRUE;
             default:
                 break;
             }
@@ -420,6 +449,7 @@ static const struct user_driver_funcs x11drv_funcs =
     .pProcessEvents = X11DRV_ProcessEvents,
     .pReleaseDC = X11DRV_ReleaseDC,
     .pScrollDC = X11DRV_ScrollDC,
+    .pSetActiveWindow = X11DRV_SetActiveWindow,
     .pSetCapture = X11DRV_SetCapture,
     .pSetDesktopWindow = X11DRV_SetDesktopWindow,
     .pSetFocus = X11DRV_SetFocus,
@@ -440,6 +470,7 @@ static const struct user_driver_funcs x11drv_funcs =
     .pSystemParametersInfo = X11DRV_SystemParametersInfo,
     .pwine_get_vulkan_driver = X11DRV_wine_get_vulkan_driver,
     .pwine_get_wgl_driver = X11DRV_wine_get_wgl_driver,
+    .pUpdateCandidatePos = X11DRV_UpdateCandidatePos,
     .pThreadDetach = X11DRV_ThreadDetach,
 };
 
diff --git a/dlls/winex11.drv/keyboard.c b/dlls/winex11.drv/keyboard.c
index dde7430..698734a 100644
--- a/dlls/winex11.drv/keyboard.c
+++ b/dlls/winex11.drv/keyboard.c
@@ -64,6 +64,46 @@ static const unsigned int ControlMask = 1 << 2;
 static int min_keycode, max_keycode, keysyms_per_keycode;
 static WORD keyc2vkey[256], keyc2scan[256];
 
+/* default scancode mapping if keyboard_scancode_detect is FALSE,
+ * as most common X11 implementation use hardware scancode + 8.
+ */
+static WORD keyc2scan[256] =
+{
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
+    0x0008, 0x0009, 0x000a, 0x000b, 0x000c, 0x000d, 0x000e, 0x000f,
+    0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,
+    0x0018, 0x0019, 0x001a, 0x001b, 0x001c, 0x001d, 0x001e, 0x001f,
+    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
+    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
+    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0136, 0x0037,
+    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
+    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0145, 0x0046, 0x0047,
+    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
+    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
+    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
+    0x011c, 0x011d, 0x0135, 0x0063, 0x0138, 0x0065, 0x0147, 0x0148,
+    0x0149, 0x014b, 0x014d, 0x014f, 0x0150, 0x0151, 0x0152, 0x0153,
+    0x0070, 0x0000, 0x0000, 0x0000, 0x0074, 0x0075, 0x0076, 0x0045,
+    0x0078, 0x0079, 0x007a, 0x007b, 0x007c, 0x015b, 0x015c, 0x015d,
+    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,
+    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,
+    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
+    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,
+    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x0000, 0x00a5, 0x00a6, 0x00a7,
+    0x00a8, 0x00a9, 0x00aa, 0x0000, 0x00ac, 0x00ad, 0x00ae, 0x00af,
+    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,
+    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,
+    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,
+    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
+    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,
+    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
+    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,
+    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
+    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,
+};
+
+
 static int NumLockMask, ScrollLockMask, AltGrMask; /* mask in the XKeyEvent state */
 
 static pthread_mutex_t kbd_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -928,7 +968,6 @@ static const struct {
 
  {0, NULL, NULL, NULL, NULL} /* sentinel */
 };
-static unsigned kbd_layout=0; /* index into above table of layouts */
 
 /* maybe more of these scancodes should be extended? */
                 /* extended must be set for ALT_R, CTRL_R,
@@ -1083,6 +1122,47 @@ static const WORD xfree86_vendor_key_vkey[256] =
     0, 0, 0, 0, 0, 0, 0, 0                                      /* 1008FFF8 */
 };
 
+int x11drv_find_keyboard_layout( const WCHAR *layout )
+{
+    int i, len;
+    char *tmp;
+
+    len = lstrlenW( layout );
+    if (!(tmp = malloc( len * 3 + 1 ))) return -1;
+    ntdll_wcstoumbs( layout, len + 1, tmp, len * 3 + 1, FALSE );
+
+    for (i = 0; main_key_tab[i].comment; i++)
+    {
+        const char *name = main_key_tab[i].comment;
+        if (!strcmp( name, tmp )) break;
+    }
+    free( tmp );
+
+    if (!main_key_tab[i].comment) return -1;
+    return i;
+}
+
+WCHAR *x11drv_get_keyboard_layout_list( DWORD *length )
+{
+    WCHAR *tmp, *layouts = calloc( 1, sizeof(WCHAR) );
+    int i;
+
+    for (i = 0, *length = 1; main_key_tab[i].comment; i++)
+    {
+        const char *name = main_key_tab[i].comment;
+        int len = strlen( name ) + 1;
+
+        if (!(tmp = realloc( layouts, (*length + len) * sizeof(WCHAR) ))) return layouts;
+        layouts = tmp;
+
+        asciiz_to_unicode( layouts + *length - 1, name );
+        layouts[*length + len - 1] = 0;
+        (*length) += len;
+    }
+
+    return layouts;
+}
+
 /* Returns the Windows virtual key code associated with the X event <e> */
 /* kbd_section must be held */
 static WORD EVENT_event_to_vkey( XIC xic, XKeyEvent *e)
@@ -1120,6 +1200,7 @@ static WORD EVENT_event_to_vkey( XIC xic, XKeyEvent *e)
  */
 static void X11DRV_send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, UINT flags, UINT time )
 {
+    RAWINPUT rawinput;
     INPUT input;
 
     TRACE_(key)( "hwnd %p vkey=%04x scan=%04x flags=%04x\n", hwnd, vkey, scan, flags );
@@ -1131,7 +1212,7 @@ static void X11DRV_send_keyboard_input( HWND hwnd, WORD vkey, WORD scan, UINT fl
     input.ki.time        = time;
     input.ki.dwExtraInfo = 0;
 
-    __wine_send_input( hwnd, &input, NULL );
+    __wine_send_input( hwnd, &input, &rawinput );
 }
 
 
@@ -1348,7 +1429,7 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
     char buf[24];
     char *Str = buf;
     KeySym keysym = 0;
-    WORD vkey = 0, bScan;
+    WORD vkey = 0, scan;
     DWORD dwFlags;
     int ascii_chars;
     XIC xic = X11DRV_get_ic( hwnd );
@@ -1419,10 +1500,10 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
     vkey = EVENT_event_to_vkey(xic,event);
     /* X returns keycode 0 for composed characters */
     if (!vkey && ascii_chars) vkey = VK_NONAME;
-    bScan = keyc2scan[event->keycode] & 0xFF;
+    scan = keyc2scan[event->keycode];
 
-    TRACE_(key)("keycode %u converted to vkey 0x%X scan %02x\n",
-                event->keycode, vkey, bScan);
+    TRACE_(key)("keycode %u converted to vkey 0x%X scan %04x\n",
+                event->keycode, vkey, scan);
 
     pthread_mutex_unlock( &kbd_mutex );
 
@@ -1430,11 +1511,11 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
 
     dwFlags = 0;
     if ( event->type == KeyRelease ) dwFlags |= KEYEVENTF_KEYUP;
-    if ( vkey & 0x100 )              dwFlags |= KEYEVENTF_EXTENDEDKEY;
+    if ( scan & 0x100 )             dwFlags |= KEYEVENTF_EXTENDEDKEY;
 
     update_lock_state( hwnd, vkey, event->state, event_time );
 
-    X11DRV_send_keyboard_input( hwnd, vkey & 0xff, bScan, dwFlags, event_time );
+    X11DRV_send_keyboard_input( hwnd, vkey & 0xff, scan & 0xff, dwFlags, event_time );
     return TRUE;
 }
 
@@ -1446,11 +1527,11 @@ BOOL X11DRV_KeyEvent( HWND hwnd, XEvent *xev )
  *  whichever matches most closely.
  * kbd_section must be held.
  */
-static void
+static int
 X11DRV_KEYBOARD_DetectLayout( Display *display )
 {
   unsigned current, match, mismatch, seq, i, syms;
-  int score, keyc, key, pkey, ok;
+  int score, keyc, key, pkey, ok, kbd_layout = 0;
   KeySym keysym = 0;
   const char (*lkey)[MAIN_LEN][4];
   unsigned max_seq = 0;
@@ -1547,6 +1628,7 @@ X11DRV_KEYBOARD_DetectLayout( Display *display )
         main_key_tab[kbd_layout].comment);
 
   TRACE("detected layout is \"%s\"\n", main_key_tab[kbd_layout].comment);
+  return kbd_layout;
 }
 
 
@@ -1582,7 +1664,7 @@ void X11DRV_InitKeyboard( Display *display )
         { 0x41, 0x5a }, /* VK_A - VK_Z */
         { 0, 0 }
     };
-    int vkey_range;
+    int vkey_range, kbd_layout;
 
     pthread_mutex_lock( &kbd_mutex );
     XDisplayKeycodes(display, &min_keycode, &max_keycode);
@@ -1614,8 +1696,9 @@ void X11DRV_InitKeyboard( Display *display )
     }
     XFreeModifiermap(mmp);
 
-    /* Detect the keyboard layout */
-    X11DRV_KEYBOARD_DetectLayout( display );
+    /* use the configured layout from registry or auto detect it */
+    kbd_layout = keyboard_layout;
+    if (kbd_layout == -1) kbd_layout = X11DRV_KEYBOARD_DetectLayout( display );
     lkey = main_key_tab[kbd_layout].key;
     syms = (keysyms_per_keycode > 4) ? 4 : keysyms_per_keycode;
 
@@ -1693,7 +1776,7 @@ void X11DRV_InitKeyboard( Display *display )
         }
         TRACE("keycode %u => vkey %04X\n", e2.keycode, vkey);
         keyc2vkey[e2.keycode] = vkey;
-        keyc2scan[e2.keycode] = scan;
+        if (keyboard_scancode_detect) keyc2scan[e2.keycode] = scan;
         if ((vkey & 0xff) && vkey_used[(vkey & 0xff)])
             WARN("vkey %04X is being used by more than one keycode\n", vkey);
         vkey_used[(vkey & 0xff)] = 1;
@@ -1804,7 +1887,7 @@ void X11DRV_InitKeyboard( Display *display )
 #undef VKEY_IF_NOT_USED
 
     /* If some keys still lack scancodes, assign some arbitrary ones to them now */
-    for (scan = 0x60, keyc = min_keycode; keyc <= max_keycode; keyc++)
+    for (scan = 0x60, keyc = min_keycode; keyboard_scancode_detect && keyc <= max_keycode; keyc++)
       if (keyc2vkey[keyc]&&!keyc2scan[keyc]) {
 	const char *ksname;
 	keysym = XkbKeycodeToKeysym( display, keyc, 0, 0 );
@@ -1846,13 +1929,24 @@ BOOL X11DRV_MappingNotify( HWND dummy, XEvent *event )
 {
     HWND hwnd;
 
-    XRefreshKeyboardMapping(&event->xmapping);
-    X11DRV_InitKeyboard( event->xmapping.display );
+    switch (event->xmapping.request)
+    {
+    case MappingModifier:
+    case MappingKeyboard:
+        XRefreshKeyboardMapping( &event->xmapping );
+        X11DRV_InitKeyboard( event->xmapping.display );
+
+        hwnd = get_focus();
+        if (!hwnd) hwnd = get_active_window();
+        NtUserPostMessage( hwnd, WM_INPUTLANGCHANGEREQUEST,
+                           0 /*FIXME*/, (LPARAM)NtUserGetKeyboardLayout(0) );
+        break;
+
+    case MappingPointer:
+        X11DRV_InitMouse( event->xmapping.display );
+        break;
+    }
 
-    hwnd = get_focus();
-    if (!hwnd) hwnd = get_active_window();
-    NtUserPostMessage( hwnd, WM_INPUTLANGCHANGEREQUEST,
-                       0 /*FIXME*/, (LPARAM)NtUserGetKeyboardLayout(0) );
     return TRUE;
 }
 
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 612fff9..65392c5 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -30,6 +30,9 @@
 #include <X11/Xlib.h>
 #include <X11/cursorfont.h>
 #include <stdarg.h>
+#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
+#include <X11/extensions/XInput.h>
+#endif
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
 #include <X11/extensions/XInput2.h>
 #endif
@@ -137,6 +140,14 @@ MAKE_FUNCPTR(XISelectEvents);
 #undef MAKE_FUNCPTR
 #endif
 
+#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
+#define MAKE_FUNCPTR(f) static typeof(f) * p##f
+MAKE_FUNCPTR(XOpenDevice);
+MAKE_FUNCPTR(XCloseDevice);
+MAKE_FUNCPTR(XGetDeviceButtonMapping);
+#undef MAKE_FUNCPTR
+#endif
+
 /***********************************************************************
  *		X11DRV_Xcursor_Init
  *
@@ -224,28 +235,97 @@ void set_window_cursor( Window window, HCURSOR handle )
     XFlush( gdi_display );
 }
 
+struct mouse_button_mapping
+{
+    int deviceid;
+    unsigned int button_count;
+    unsigned char buttons[256];
+};
+
+static struct mouse_button_mapping *pointer_mapping;
+static struct mouse_button_mapping *device_mapping;
+
+static void update_pointer_mapping( Display *display )
+{
+    struct mouse_button_mapping *tmp;
+
+    if (!(tmp = malloc( sizeof(*tmp) )))
+    {
+        WARN("Unable to allocate device mapping.\n");
+        return;
+    }
+
+    tmp->button_count = ARRAY_SIZE( tmp->buttons );
+    tmp->button_count = XGetPointerMapping( display, tmp->buttons, tmp->button_count );
+
+    tmp = InterlockedExchangePointer( (void**)&pointer_mapping, tmp );
+
+    free( tmp );
+}
+
+static void update_device_mapping( Display *display, int deviceid )
+{
+#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
+    struct mouse_button_mapping *tmp;
+    XDevice *device;
+
+    if (!(device = pXOpenDevice( display, deviceid )))
+    {
+        WARN( "Unable to open cursor device %d\n", deviceid );
+        return;
+    }
+
+    if (!(tmp = malloc( sizeof(*tmp) )))
+    {
+        WARN( "Unable to allocate device mapping.\n" );
+        pXCloseDevice( display, device );
+        return;
+    }
+
+    tmp->deviceid = deviceid;
+    tmp->button_count = ARRAY_SIZE( tmp->buttons );
+    tmp->button_count = pXGetDeviceButtonMapping( display, device, tmp->buttons, tmp->button_count );
+
+    tmp = InterlockedExchangePointer( (void**)&device_mapping, tmp );
+
+    free( tmp );
+
+    pXCloseDevice( display, device );
+#endif
+}
+
+void X11DRV_InitMouse( Display *display )
+{
+    update_pointer_mapping( display );
+}
+
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
 /***********************************************************************
  *              update_relative_valuators
  */
-static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuators)
+static void update_relative_valuators( XIAnyClassInfo **classes, int num_classes )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
-    int i;
+    XIValuatorClassInfo *valuator;
 
     thread_data->x_valuator.number = -1;
     thread_data->y_valuator.number = -1;
 
-    for (i = 0; i < n_valuators; i++)
+    while (num_classes--)
     {
-        XIValuatorClassInfo *class = (XIValuatorClassInfo *)valuators[i];
-        if (valuators[i]->type != XIValuatorClass) continue;
-        if (class->label == x11drv_atom( Rel_X ) ||
-            (!class->label && class->number == 0 && class->mode == XIModeRelative))
-            thread_data->x_valuator = *class;
-        else if (class->label == x11drv_atom( Rel_Y ) ||
-                 (!class->label && class->number == 1 && class->mode == XIModeRelative))
-            thread_data->y_valuator = *class;
+        valuator = (XIValuatorClassInfo *)classes[num_classes];
+        if (classes[num_classes]->type != XIValuatorClass) continue;
+        if (valuator->number == 0) thread_data->x_valuator = *valuator;
+        if (valuator->number == 1) thread_data->y_valuator = *valuator;
+    }
+
+    if (thread_data->x_valuator.number < 0 || thread_data->y_valuator.number < 0)
+        WARN( "X/Y axis valuators not found, ignoring RawMotion events\n" );
+    else if (thread_data->x_valuator.mode != thread_data->y_valuator.mode)
+    {
+        WARN( "Relative/Absolute mismatch between X/Y axis, ignoring RawMotion events\n" );
+        thread_data->x_valuator.number = -1;
+        thread_data->y_valuator.number = -1;
     }
 
     thread_data->x_valuator.value = 0;
@@ -254,87 +334,127 @@ static void update_relative_valuators(XIAnyClassInfo **valuators, int n_valuator
 
 
 /***********************************************************************
- *              enable_xinput2
+ *              x11drv_xinput_init
+ */
+void x11drv_xinput_init(void)
+{
+#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
+    struct x11drv_thread_data *data = x11drv_thread_data();
+    int major = 2, minor = 1;
+
+    if (data->xi2_state != xi_unknown) return;
+
+    if (xinput2_available &&
+        !pXIQueryVersion( data->display, &major, &minor ))
+    {
+        TRACE( "XInput2 %d.%d available\n", major, minor );
+        data->xi2_state = xi_disabled;
+    }
+    else
+    {
+        data->xi2_state = xi_unavailable;
+        WARN( "XInput 2.1 not available\n" );
+    }
+#endif
+}
+
+
+/***********************************************************************
+ *              x11drv_xinput_enable
  */
-static void enable_xinput2(void)
+void x11drv_xinput_enable( Display *display, Window window, long event_mask )
 {
     struct x11drv_thread_data *data = x11drv_thread_data();
     XIEventMask mask;
     XIDeviceInfo *pointer_info;
     unsigned char mask_bits[XIMaskLen(XI_LASTEVENT)];
+    enum xi2_state xi2_state = data ? data->xi2_state : xi_unknown;
     int count;
 
-    if (!xinput2_available) return;
+    TRACE( "state:%d window:%lx event_mask:%lx\n", xi2_state, window, event_mask );
 
-    if (data->xi2_state == xi_unknown)
+    if (xi2_state == xi_unavailable) return;
+
+    if (window != DefaultRootWindow( display ))
     {
-        int major = 2, minor = 0;
-        if (!pXIQueryVersion( data->display, &major, &minor )) data->xi2_state = xi_disabled;
-        else
-        {
-            data->xi2_state = xi_unavailable;
-            WARN( "X Input 2 not available\n" );
-        }
+        mask.mask     = mask_bits;
+        mask.mask_len = sizeof(mask_bits);
+        mask.deviceid = XIAllMasterDevices;
+        memset( mask_bits, 0, sizeof(mask_bits) );
+
+        pXISelectEvents( display, window, &mask, 1 );
+        XSelectInput( display, window, event_mask );
+        return;
     }
-    if (data->xi2_state == xi_unavailable) return;
-    if (!pXIGetClientPointer( data->display, None, &data->xi2_core_pointer )) return;
 
     mask.mask     = mask_bits;
     mask.mask_len = sizeof(mask_bits);
-    mask.deviceid = XIAllDevices;
+    mask.deviceid = XIAllMasterDevices;
     memset( mask_bits, 0, sizeof(mask_bits) );
     XISetMask( mask_bits, XI_DeviceChanged );
     XISetMask( mask_bits, XI_RawMotion );
-    XISetMask( mask_bits, XI_ButtonPress );
 
-    pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
+    if (data->xi2_rawinput_only)
+    {
+        XISetMask( mask_bits, XI_RawButtonPress );
+        XISetMask( mask_bits, XI_RawButtonRelease );
+    }
+    else
+    {
+        XISetMask( mask_bits, XI_ButtonPress );
+    }
+
+    pXISelectEvents( display, DefaultRootWindow( display ), &mask, 1 );
 
+    if (!data || !pXIGetClientPointer( data->display, None, &data->xi2_core_pointer )) return;
     pointer_info = pXIQueryDevice( data->display, data->xi2_core_pointer, &count );
     update_relative_valuators( pointer_info->classes, pointer_info->num_classes );
     pXIFreeDeviceInfo( pointer_info );
 
-    /* This device info list is only used to find the initial current slave if
-     * no XI_DeviceChanged events happened. If any hierarchy change occurred that
-     * might be relevant here (eg. user switching mice after (un)plugging), a
-     * XI_DeviceChanged event will point us to the right slave. So this list is
-     * safe to be obtained statically at enable_xinput2() time.
-     */
-    if (data->xi2_devices) pXIFreeDeviceInfo( data->xi2_devices );
-    data->xi2_devices = pXIQueryDevice( data->display, XIAllDevices, &data->xi2_device_count );
-    data->xi2_current_slave = 0;
-
     data->xi2_state = xi_enabled;
 }
 
 #endif
 
 /***********************************************************************
- *              disable_xinput2
+ *              x11drv_xinput_disable
  */
-static void disable_xinput2(void)
+void x11drv_xinput_disable( Display *display, Window window, long event_mask )
 {
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
     struct x11drv_thread_data *data = x11drv_thread_data();
+    enum xi2_state xi2_state = data ? data->xi2_state : xi_unknown;
     XIEventMask mask;
 
-    if (data->xi2_state != xi_enabled) return;
+    TRACE( "state:%d window:%lx event_mask:%lx\n", xi2_state, window, event_mask );
 
-    TRACE( "disabling\n" );
-    data->xi2_state = xi_disabled;
+    if (xi2_state == xi_unavailable) return;
+    if (data->xi2_rawinput_only) return;
+
+    if (window != DefaultRootWindow( display ))
+    {
+        mask.mask     = NULL;
+        mask.mask_len = 0;
+        mask.deviceid = XIAllMasterDevices;
+
+        pXISelectEvents( display, window, &mask, 1 );
+        XSelectInput( display, window, event_mask );
+        return;
+    }
 
     mask.mask = NULL;
     mask.mask_len = 0;
-    mask.deviceid = XIAllDevices;
+    mask.deviceid = XIAllMasterDevices;
+
+    pXISelectEvents( display, DefaultRootWindow( display ), &mask, 1 );
 
-    pXISelectEvents( data->display, DefaultRootWindow( data->display ), &mask, 1 );
-    pXIFreeDeviceInfo( data->xi2_devices );
+    if (!data) return;
     data->x_valuator.number = -1;
     data->y_valuator.number = -1;
     data->x_valuator.value = 0;
     data->y_valuator.value = 0;
-    data->xi2_devices = NULL;
     data->xi2_core_pointer = 0;
-    data->xi2_current_slave = 0;
+    data->xi2_state = xi_disabled;
 #endif
 }
 
@@ -367,7 +487,7 @@ static BOOL grab_clipping_window( const RECT *clip )
     }
 
     /* enable XInput2 unless we are already clipping */
-    if (!data->clipping_cursor) enable_xinput2();
+    if (!data->clipping_cursor) x11drv_xinput_enable( data->display, DefaultRootWindow( data->display ), PointerMotionMask );
 
     if (data->xi2_state != xi_enabled)
     {
@@ -407,7 +527,7 @@ static BOOL grab_clipping_window( const RECT *clip )
 
     if (!clipping_cursor)
     {
-        disable_xinput2();
+        x11drv_xinput_disable( data->display, DefaultRootWindow( data->display ), PointerMotionMask );
         return FALSE;
     }
     clip_rect = *clip;
@@ -436,7 +556,7 @@ void ungrab_clipping_window(void)
     if (clipping_cursor) XUngrabPointer( data->display, CurrentTime );
     clipping_cursor = FALSE;
     data->clipping_cursor = FALSE;
-    disable_xinput2();
+    x11drv_xinput_disable( data->display, DefaultRootWindow( data->display ), PointerMotionMask );
 }
 
 /***********************************************************************
@@ -1647,43 +1767,34 @@ static BOOL X11DRV_DeviceChanged( XGenericEventCookie *xev )
     if (event->reason != XISlaveSwitch) return FALSE;
 
     update_relative_valuators( event->classes, event->num_classes );
-    data->xi2_current_slave = event->sourceid;
+    update_device_mapping( event->display, event->sourceid );
+
     return TRUE;
 }
 
-static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input )
+static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input, RAWINPUT *rawinput )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     XIValuatorClassInfo *x = &thread_data->x_valuator, *y = &thread_data->y_valuator;
-    double x_value = 0, y_value = 0, x_scale, y_scale;
-    const double *values = event->valuators.values;
+    const double *values = event->valuators.values, *raw_values = event->raw_values;
+    double x_raw = 0, y_raw = 0, x_value = 0, y_value = 0, x_scale, y_scale;
     RECT virtual_rect;
     int i;
 
     if (x->number < 0 || y->number < 0) return FALSE;
     if (!event->valuators.mask_len) return FALSE;
     if (thread_data->xi2_state != xi_enabled) return FALSE;
+    if (event->deviceid != thread_data->xi2_core_pointer) return FALSE;
 
-    /* If there is no slave currently detected, no previous motion nor device
-     * change events were received. Look it up now on the device list in this
-     * case.
-     */
-    if (!thread_data->xi2_current_slave)
-    {
-        XIDeviceInfo *devices = thread_data->xi2_devices;
-
-        for (i = 0; i < thread_data->xi2_device_count; i++)
-        {
-            if (devices[i].use != XISlavePointer) continue;
-            if (devices[i].deviceid != event->deviceid) continue;
-            if (devices[i].attachment != thread_data->xi2_core_pointer) continue;
-            thread_data->xi2_current_slave = event->deviceid;
-            break;
-        }
-    }
-    if (event->deviceid != thread_data->xi2_current_slave) return FALSE;
+    if (x->mode == XIModeRelative && y->mode == XIModeRelative)
+        input->mi.dwFlags &= ~(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_VIRTUALDESK);
+    else if (x->mode == XIModeAbsolute && y->mode == XIModeAbsolute)
+        input->mi.dwFlags |= MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_VIRTUALDESK;
+    else
+        FIXME( "Unsupported relative/absolute X/Y axis mismatch\n." );
 
-    virtual_rect = NtUserGetVirtualScreenRect();
+    if (input->mi.dwFlags & MOUSEEVENTF_VIRTUALDESK) SetRect( &virtual_rect, 0, 0, 65535, 65535 );
+    else virtual_rect = NtUserGetVirtualScreenRect();
 
     if (x->max <= x->min) x_scale = 1;
     else x_scale = (virtual_rect.right - virtual_rect.left) / (x->max - x->min);
@@ -1695,20 +1806,30 @@ static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input )
         if (!XIMaskIsSet( event->valuators.mask, i )) continue;
         if (i == x->number)
         {
+            x_raw = *raw_values;
             x_value = *values;
-            x->value += x_value * x_scale;
+            if (x->mode == XIModeRelative) x->value += x_value * x_scale;
+            else x->value = (x_value - x->min) * x_scale;
         }
         if (i == y->number)
         {
+            y_raw = *raw_values;
             y_value = *values;
-            y->value += y_value * y_scale;
+            if (y->mode == XIModeRelative) y->value += y_value * y_scale;
+            else y->value = (y_value - y->min) * y_scale;
         }
+        raw_values++;
         values++;
     }
 
     input->mi.dx = round( x->value );
     input->mi.dy = round( y->value );
 
+    if (x->mode != XIModeAbsolute) rawinput->data.mouse.lLastX = x_raw;
+    else rawinput->data.mouse.lLastX = input->mi.dx;
+    if (y->mode != XIModeAbsolute) rawinput->data.mouse.lLastY = y_raw;
+    else rawinput->data.mouse.lLastY = input->mi.dy;
+
     TRACE( "event %f,%f value %f,%f input %d,%d\n", x_value, y_value, x->value, y->value,
            (int)input->mi.dx, (int)input->mi.dy );
 
@@ -1729,7 +1850,9 @@ static BOOL map_raw_event_coords( XIRawEvent *event, INPUT *input )
  */
 static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
 {
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
     XIRawEvent *event = xev->data;
+    RAWINPUT rawinput;
     INPUT input;
 
     if (broken_rawevents && is_old_motion_event( xev->serial ))
@@ -1745,21 +1868,96 @@ static BOOL X11DRV_RawMotion( XGenericEventCookie *xev )
     input.mi.dwExtraInfo = 0;
     input.mi.dx          = 0;
     input.mi.dy          = 0;
-    if (!map_raw_event_coords( event, &input )) return FALSE;
+    if (!map_raw_event_coords( event, &input, &rawinput )) return FALSE;
+
+    if (!thread_data->xi2_rawinput_only)
+        __wine_send_input( 0, &input, NULL );
+    else
+    {
+        rawinput.header.dwType = RIM_TYPEMOUSE;
+        rawinput.header.dwSize = offsetof(RAWINPUT, data) + sizeof(RAWMOUSE);
+        rawinput.header.hDevice = ULongToHandle(1); /* WINE_MOUSE_HANDLE */
+        rawinput.header.wParam = RIM_INPUT;
+        rawinput.data.mouse.usFlags = input.mi.dwFlags;
+        rawinput.data.mouse.ulRawButtons = 0;
+        rawinput.data.mouse.usButtonData = 0;
+        rawinput.data.mouse.usButtonFlags = 0;
+        rawinput.data.mouse.ulExtraInformation = 0;
+
+        input.type = INPUT_HARDWARE;
+        input.hi.uMsg = WM_INPUT;
+        input.hi.wParamH = 0;
+        input.hi.wParamL = 0;
+        if (rawinput.data.mouse.lLastX || rawinput.data.mouse.lLastY)
+            __wine_send_input( 0, &input, &rawinput );
+    }
 
-    __wine_send_input( 0, &input, NULL );
     return TRUE;
 }
 
-#endif /* HAVE_X11_EXTENSIONS_XINPUT2_H */
+/***********************************************************************
+ *           X11DRV_RawButtonEvent
+ */
+static BOOL X11DRV_RawButtonEvent( XGenericEventCookie *cookie )
+{
+    struct x11drv_thread_data *thread_data = x11drv_thread_data();
+    XIRawEvent *event = cookie->data;
+    int button = event->detail - 1;
+    RAWINPUT rawinput;
+    INPUT input;
+
+    if (!device_mapping || device_mapping->deviceid != event->sourceid)
+        update_device_mapping( event->display, event->sourceid );
+
+    if (button >= 0 && device_mapping)
+        button = device_mapping->buttons[button] - 1;
+
+    if (button >= 0 && pointer_mapping)
+        button = pointer_mapping->buttons[button] - 1;
+
+    if (button < 0 || button >= NB_BUTTONS) return FALSE;
+    if (thread_data->xi2_state != xi_enabled) return FALSE;
+    if (event->deviceid != thread_data->xi2_core_pointer) return FALSE;
+
+    TRACE( "raw button %u (raw: %u) %s\n", button, event->detail, event->evtype == XI_RawButtonRelease ? "up" : "down" );
 
+    rawinput.header.dwType = RIM_TYPEMOUSE;
+    rawinput.header.dwSize = offsetof(RAWINPUT, data) + sizeof(RAWMOUSE);
+    rawinput.header.hDevice = ULongToHandle(1); /* WINE_MOUSE_HANDLE */
+    rawinput.header.wParam = RIM_INPUT;
+    if (event->evtype == XI_RawButtonRelease)
+    {
+        rawinput.data.mouse.usFlags = button_up_flags[button];
+        rawinput.data.mouse.ulRawButtons = button_up_data[button];
+    }
+    else
+    {
+        rawinput.data.mouse.usFlags = button_down_flags[button];
+        rawinput.data.mouse.ulRawButtons = button_down_data[button];
+    }
+    rawinput.data.mouse.usButtonData = 0;
+    rawinput.data.mouse.usButtonFlags = 0;
+    rawinput.data.mouse.lLastX = 0;
+    rawinput.data.mouse.lLastY = 0;
+    rawinput.data.mouse.ulExtraInformation = 0;
+
+    input.type = INPUT_HARDWARE;
+    input.hi.uMsg = WM_INPUT;
+    input.hi.wParamH = 0;
+    input.hi.wParamL = 0;
+    if (rawinput.data.mouse.usFlags || rawinput.data.mouse.ulRawButtons)
+        __wine_send_input( 0, &input, &rawinput );
+    return TRUE;
+}
+
+#endif /* HAVE_X11_EXTENSIONS_XINPUT2_H */
 
 /***********************************************************************
- *              X11DRV_XInput2_Init
+ *              x11drv_xinput_load
  */
-void X11DRV_XInput2_Init(void)
+void x11drv_xinput_load(void)
 {
-#if defined(SONAME_LIBXI) && defined(HAVE_X11_EXTENSIONS_XINPUT2_H)
+#if defined(SONAME_LIBXI)
     int event, error;
     void *libxi_handle = dlopen( SONAME_LIBXI, RTLD_NOW );
 
@@ -1775,11 +1973,20 @@ void X11DRV_XInput2_Init(void)
         return; \
     }
 
+#ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
     LOAD_FUNCPTR(XIGetClientPointer);
     LOAD_FUNCPTR(XIFreeDeviceInfo);
     LOAD_FUNCPTR(XIQueryDevice);
     LOAD_FUNCPTR(XIQueryVersion);
     LOAD_FUNCPTR(XISelectEvents);
+#endif
+
+#ifdef HAVE_X11_EXTENSIONS_XINPUT_H
+    LOAD_FUNCPTR(XOpenDevice);
+    LOAD_FUNCPTR(XCloseDevice);
+    LOAD_FUNCPTR(XGetDeviceButtonMapping);
+#endif
+
 #undef LOAD_FUNCPTR
 
     xinput2_available = XQueryExtension( gdi_display, "XInputExtension", &xinput2_opcode, &event, &error );
@@ -1815,6 +2022,10 @@ BOOL X11DRV_GenericEvent( HWND hwnd, XEvent *xev )
     case XI_RawMotion:
         ret = X11DRV_RawMotion( event );
         break;
+    case XI_RawButtonPress:
+    case XI_RawButtonRelease:
+        ret = X11DRV_RawButtonEvent( event );
+        break;
 
     default:
         TRACE( "Unhandled event %#x\n", event->evtype );
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index d70f192..f534a73 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -414,6 +414,7 @@ static int GLXErrorHandler(Display *dpy, XErrorEvent *event, void *arg)
 static BOOL X11DRV_WineGL_InitOpenglInfo(void)
 {
     static const char legacy_extensions[] = " WGL_EXT_extensions_string WGL_EXT_swap_control";
+    static const char direct_extension[] = " WINE_EXT_direct_rendering";
 
     int screen = DefaultScreen(gdi_display);
     Window win = 0, root = 0;
@@ -469,16 +470,18 @@ static BOOL X11DRV_WineGL_InitOpenglInfo(void)
     }
     gl_renderer = (const char *)opengl_funcs.gl.p_glGetString(GL_RENDERER);
     gl_version  = (const char *)opengl_funcs.gl.p_glGetString(GL_VERSION);
+    glx_direct = pglXIsDirect(gdi_display, ctx);
     str = (const char *) opengl_funcs.gl.p_glGetString(GL_EXTENSIONS);
-    glExtensions = malloc( strlen(str) + sizeof(legacy_extensions) );
+    glExtensions = malloc( strlen(str)+sizeof(legacy_extensions)+sizeof(direct_extension) );
     strcpy(glExtensions, str);
     strcat(glExtensions, legacy_extensions);
+    if (glx_direct)
+        strcat(glExtensions, direct_extension);
 
     /* Get the common GLX version supported by GLX client and server ( major/minor) */
     pglXQueryVersion(gdi_display, &glxVersion[0], &glxVersion[1]);
 
     glxExtensions = pglXQueryExtensionsString(gdi_display, screen);
-    glx_direct = pglXIsDirect(gdi_display, ctx);
 
     TRACE("GL version             : %s.\n", gl_version);
     TRACE("GL renderer            : %s.\n", gl_renderer);
@@ -1980,20 +1983,20 @@ static BOOL glxdrv_wglShareLists(struct wgl_context *org, struct wgl_context *de
 
 static void wglFinish(void)
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
 
-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = FALSE;
 
     if ((gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.gl_drawable = gl->pixmap; break;
-        case DC_GL_CHILD_WIN:  escape.gl_drawable = gl->window; break;
+        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
         sync_context(ctx);
@@ -2001,26 +2004,26 @@ static void wglFinish(void)
     }
 
     pglFinish();
-    if (escape.gl_drawable)
+    if (escape.drawable)
         NtGdiExtEscape( ctx->hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
 static void wglFlush(void)
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
 
-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = FALSE;
 
     if ((gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.gl_drawable = gl->pixmap; break;
-        case DC_GL_CHILD_WIN:  escape.gl_drawable = gl->window; break;
+        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
         sync_context(ctx);
@@ -2028,7 +2031,7 @@ static void wglFlush(void)
     }
 
     pglFlush();
-    if (escape.gl_drawable)
+    if (escape.drawable)
         NtGdiExtEscape( ctx->hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 8d1da4d..55e3685 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -43,13 +43,15 @@
 #include "wine/vulkan_driver.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
-
-#ifdef SONAME_LIBVULKAN
 WINE_DECLARE_DEBUG_CHANNEL(fps);
 
+#ifndef SONAME_LIBVULKAN
+#define SONAME_LIBVULKAN ""
+#endif
+
 static pthread_mutex_t vulkan_mutex;
 
-static XContext vulkan_hwnd_context;
+static XContext vulkan_swapchain_context;
 
 #define VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR 1000004000
 
@@ -74,6 +76,7 @@ typedef struct VkXlibSurfaceCreateInfoKHR
     Window window;
 } VkXlibSurfaceCreateInfoKHR;
 
+static VkResult (*pvkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
 static VkResult (*pvkCreateXlibSurfaceKHR)(VkInstance, const VkXlibSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
@@ -94,6 +97,9 @@ static VkResult (*pvkGetPhysicalDeviceSurfaceSupportKHR)(VkPhysicalDevice, uint3
 static VkBool32 (*pvkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice, uint32_t, Display *, VisualID);
 static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
+static VkResult (*pvkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout);
+static VkResult (*pvkCreateFence)(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence);
+static void (*pvkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator);
 
 static void *X11DRV_get_vk_device_proc_addr(const char *name);
 static void *X11DRV_get_vk_instance_proc_addr(VkInstance instance, const char *name);
@@ -107,16 +113,26 @@ static void *vulkan_handle;
 
 static void wine_vk_init(void)
 {
-    init_recursive_mutex(&vulkan_mutex);
+    const char *libvulkan_candidates[] = {SONAME_LIBVULKAN,
+                                          "libvulkan.so.1",
+                                          "libvulkan.so",
+                                          NULL};
+    int i;
 
-    if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
+    for (i=0; libvulkan_candidates[i] && !vulkan_handle; i++)
+        vulkan_handle = dlopen(libvulkan_candidates[i], RTLD_NOW);
+
+    if (!vulkan_handle)
     {
-        ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
+        ERR("Failed to load vulkan library\n");
         return;
     }
 
+    init_recursive_mutex(&vulkan_mutex);
+
 #define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
 #define LOAD_OPTIONAL_FUNCPTR(f) p##f = dlsym(vulkan_handle, #f)
+    LOAD_FUNCPTR(vkAcquireNextImageKHR);
     LOAD_FUNCPTR(vkCreateInstance);
     LOAD_FUNCPTR(vkCreateSwapchainKHR);
     LOAD_FUNCPTR(vkCreateXlibSurfaceKHR);
@@ -137,10 +153,14 @@ static void wine_vk_init(void)
     LOAD_FUNCPTR(vkQueuePresentKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetDeviceGroupSurfacePresentModesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
+    LOAD_FUNCPTR(vkWaitForFences);
+    LOAD_FUNCPTR(vkCreateFence);
+    LOAD_FUNCPTR(vkDestroyFence);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
 
-    vulkan_hwnd_context = XUniqueContext();
+    vulkan_swapchain_context = XUniqueContext();
+
     return;
 
 fail:
@@ -220,18 +240,116 @@ static void wine_vk_surface_release(struct wine_vk_surface *surface)
     free(surface);
 }
 
-void wine_vk_surface_destroy(HWND hwnd)
+void wine_vk_surface_destroy(struct wine_vk_surface *surface)
+{
+    TRACE("Detaching surface %p, hwnd %p.\n", surface, surface->hwnd);
+    XReparentWindow(gdi_display, surface->window, get_dummy_parent(), 0, 0);
+    XSync(gdi_display, False);
+
+    if (surface->hdc) NtUserReleaseDC(surface->hwnd, surface->hdc);
+    surface->hwnd_thread_id = 0;
+    surface->hwnd = 0;
+    surface->hdc = 0;
+    wine_vk_surface_release(surface);
+}
+
+void destroy_vk_surface(HWND hwnd)
+{
+    struct wine_vk_surface *surface, *next;
+    pthread_mutex_lock(&vulkan_mutex);
+    LIST_FOR_EACH_ENTRY_SAFE(surface, next, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd)
+            continue;
+        wine_vk_surface_destroy(surface);
+    }
+    pthread_mutex_unlock(&vulkan_mutex);
+}
+
+static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL offscreen)
+{
+#ifdef SONAME_LIBXCOMPOSITE
+    if (usexcomposite)
+    {
+        if (!surface->offscreen && offscreen)
+        {
+            FIXME("Redirecting vulkan surface offscreen, expect degraded performance.\n");
+            pXCompositeRedirectWindow(gdi_display, surface->window, CompositeRedirectManual);
+        }
+        else if (surface->offscreen && !offscreen)
+        {
+            FIXME("Putting vulkan surface back onscreen, expect standard performance.\n");
+            pXCompositeUnredirectWindow(gdi_display, surface->window, CompositeRedirectManual);
+        }
+        surface->offscreen = offscreen;
+        return TRUE;
+    }
+#endif
+
+    if (offscreen) FIXME("Application requires child window rendering, which is not implemented yet!\n");
+    surface->offscreen = offscreen;
+    return !offscreen;
+}
+
+void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *changes)
 {
     struct wine_vk_surface *surface;
     pthread_mutex_lock(&vulkan_mutex);
-    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
-        surface->hwnd_thread_id = 0;
-        surface->hwnd = NULL;
-        wine_vk_surface_release(surface);
+        if (surface->hwnd != hwnd) continue;
+        if (surface->window != active) XConfigureWindow(gdi_display, surface->window, mask, changes);
+    }
+    pthread_mutex_unlock(&vulkan_mutex);
+}
+
+void sync_vk_surface(HWND hwnd, BOOL known_child)
+{
+    struct wine_vk_surface *surface;
+    DWORD surface_with_swapchain_count = 0;
+
+    pthread_mutex_lock(&vulkan_mutex);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        if (surface->swapchain_count) surface_with_swapchain_count++;
+        surface->known_child = known_child;
+    }
+    TRACE("hwnd %p surface_with_swapchain_count %u known_child %u\n", hwnd, surface_with_swapchain_count, known_child);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        if (surface_with_swapchain_count > 1) wine_vk_surface_set_offscreen(surface, TRUE);
+        else wine_vk_surface_set_offscreen(surface, known_child);
+    }
+    pthread_mutex_unlock(&vulkan_mutex);
+}
+
+Window wine_vk_active_surface(HWND hwnd)
+{
+    struct wine_vk_surface *surface, *active = NULL;
+    DWORD surface_with_swapchain_count = 0;
+    Window window;
+
+    pthread_mutex_lock(&vulkan_mutex);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        if (!surface->swapchain_count) continue;
+        active = surface;
+        surface_with_swapchain_count++;
+    }
+    if (!active) window = None;
+    else
+    {
+        TRACE("hwnd %p surface_with_swapchain_count %u known_child %u\n", hwnd, surface_with_swapchain_count, active->known_child);
+        if (surface_with_swapchain_count > 1) wine_vk_surface_set_offscreen(active, TRUE);
+        else wine_vk_surface_set_offscreen(active, active->known_child);
+        window = active->window;
     }
-    XDeleteContext(gdi_display, (XID)hwnd, vulkan_hwnd_context);
     pthread_mutex_unlock(&vulkan_mutex);
+
+    return window;
 }
 
 void vulkan_thread_detach(void)
@@ -244,11 +362,7 @@ void vulkan_thread_detach(void)
     {
         if (surface->hwnd_thread_id != thread_id)
             continue;
-
-        TRACE("Detaching surface %p, hwnd %p.\n", surface, surface->hwnd);
-        XReparentWindow(gdi_display, surface->window, get_dummy_parent(), 0, 0);
-        XSync(gdi_display, False);
-        wine_vk_surface_destroy(surface->hwnd);
+        wine_vk_surface_destroy(surface);
     }
     pthread_mutex_unlock(&vulkan_mutex);
 }
@@ -280,12 +394,77 @@ static VkResult X11DRV_vkCreateInstance(const VkInstanceCreateInfo *create_info,
     return res;
 }
 
+static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
+        VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
+        VkFence fence, uint32_t *image_index)
+{
+    static int once;
+    struct x11drv_escape_present_drawable escape;
+    struct wine_vk_surface *surface = NULL;
+    VkResult result;
+    VkFence orig_fence;
+    BOOL wait_fence = FALSE;
+    HDC hdc = 0;
+
+    pthread_mutex_lock(&vulkan_mutex);
+    if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
+    {
+        wine_vk_surface_grab(surface);
+        hdc = surface->hdc;
+    }
+    pthread_mutex_unlock(&vulkan_mutex);
+
+    if (!surface || !surface->offscreen)
+        wait_fence = FALSE;
+    else if (use_xpresent && use_xfixes && usexcomposite) /* X11DRV_PRESENT_DRAWABLE will use XPresentPixmap */
+        wait_fence = FALSE;
+    else if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR ||
+             surface->present_mode == VK_PRESENT_MODE_FIFO_KHR)
+        wait_fence = TRUE;
+
+    orig_fence = fence;
+    if (wait_fence && !fence)
+    {
+        VkFenceCreateInfo create_info;
+        create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
+        create_info.pNext = NULL;
+        create_info.flags = 0;
+        pvkCreateFence(device, &create_info, NULL, &fence);
+    }
+
+    result = pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+    if ((result == VK_SUCCESS || result == VK_SUBOPTIMAL_KHR) && hdc && surface && surface->offscreen)
+    {
+        if (wait_fence) pvkWaitForFences(device, 1, &fence, 0, timeout);
+        escape.code = X11DRV_PRESENT_DRAWABLE;
+        escape.drawable = surface->window;
+        escape.flush = TRUE;
+        NtGdiExtEscape(hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
+        if (wait_fence && surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR)
+            if (once++) FIXME("Application requires child window rendering with mailbox present mode, expect possible tearing!\n");
+    }
+
+    if (fence != orig_fence) pvkDestroyFence(device, fence, NULL);
+    if (surface) wine_vk_surface_release(surface);
+    return result;
+}
+
+static VkResult X11DRV_vkAcquireNextImage2KHR(VkDevice device,
+        const VkAcquireNextImageInfoKHR *acquire_info, uint32_t *image_index)
+{
+    static int once;
+    if (!once++) FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    return X11DRV_vkAcquireNextImageKHR(device, acquire_info->swapchain, acquire_info->timeout, acquire_info->semaphore, acquire_info->fence, image_index);
+}
+
 static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
         const VkSwapchainCreateInfoKHR *create_info,
         const VkAllocationCallbacks *allocator, VkSwapchainKHR *swapchain)
 {
-    struct wine_vk_surface *x11_surface = surface_from_handle(create_info->surface);
+    struct wine_vk_surface *other, *x11_surface = surface_from_handle(create_info->surface);
     VkSwapchainCreateInfoKHR create_info_host;
+    VkResult result;
+
     TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);
 
     if (allocator)
@@ -313,21 +492,17 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
-    /* TODO: support child window rendering. */
-    if (create_info->hwnd && NtUserGetAncestor(create_info->hwnd, GA_PARENT) != NtUserGetDesktopWindow())
-    {
-        FIXME("Application requires child window rendering, which is not implemented yet!\n");
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-
     x11_surface = calloc(1, sizeof(*x11_surface));
     if (!x11_surface)
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
     x11_surface->ref = 1;
     x11_surface->hwnd = create_info->hwnd;
+    x11_surface->known_child = FALSE;
+    x11_surface->swapchain_count = 0;
     if (x11_surface->hwnd)
     {
+        x11_surface->hdc = NtUserGetDCEx(x11_surface->hwnd, 0, DCX_USESTYLE);
         x11_surface->window = create_client_window(create_info->hwnd, &default_visual);
         x11_surface->hwnd_thread_id = NtUserGetWindowThread(x11_surface->hwnd, NULL);
     }
@@ -345,6 +520,18 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
         goto err;
     }
 
+    if (create_info->hwnd && (NtUserGetWindowRelative(create_info->hwnd, GW_CHILD) ||
+                              NtUserGetAncestor(create_info->hwnd, GA_PARENT) != NtUserGetDesktopWindow()))
+    {
+        x11_surface->known_child = TRUE;
+        TRACE("hwnd %p creating offscreen child window surface\n", x11_surface->hwnd);
+        if (!wine_vk_surface_set_offscreen(x11_surface, TRUE))
+        {
+            res = VK_ERROR_INCOMPATIBLE_DRIVER;
+            goto err;
+        }
+    }
+
     create_info_host.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
     create_info_host.pNext = NULL;
     create_info_host.flags = 0; /* reserved */
@@ -359,11 +546,6 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     }
 
     pthread_mutex_lock(&vulkan_mutex);
-    if (x11_surface->hwnd)
-    {
-        wine_vk_surface_destroy( x11_surface->hwnd );
-        XSaveContext(gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context, (char *)wine_vk_surface_grab(x11_surface));
-    }
     list_add_tail(&surface_list, &x11_surface->entry);
     pthread_mutex_unlock(&vulkan_mutex);
 
@@ -391,6 +573,7 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
         const VkAllocationCallbacks *allocator)
 {
     struct wine_vk_surface *x11_surface = surface_from_handle(surface);
+    HWND hwnd = x11_surface->hwnd;
 
     TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);
 
@@ -409,12 +592,23 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
 static void X11DRV_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain,
          const VkAllocationCallbacks *allocator)
 {
+    struct wine_vk_surface *surface;
+
     TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);
 
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
     pvkDestroySwapchainKHR(device, swapchain, NULL /* allocator */);
+
+    pthread_mutex_lock(&vulkan_mutex);
+    if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
+    {
+        surface->swapchain_count--;
+        wine_vk_surface_release(surface);
+    }
+    XDeleteContext(gdi_display, (XID)swapchain, vulkan_swapchain_context);
+    pthread_mutex_unlock(&vulkan_mutex);
 }
 
 static VkResult X11DRV_vkEnumerateInstanceExtensionProperties(const char *layer_name,
@@ -681,6 +875,8 @@ static VkSurfaceKHR X11DRV_wine_get_host_surface( VkSurfaceKHR surface )
 
 static const struct vulkan_funcs vulkan_funcs =
 {
+    X11DRV_vkAcquireNextImage2KHR,
+    X11DRV_vkAcquireNextImageKHR,
     X11DRV_vkCreateInstance,
     X11DRV_vkCreateSwapchainKHR,
     X11DRV_vkCreateWin32SurfaceKHR,
@@ -732,20 +928,3 @@ const struct vulkan_funcs *get_vulkan_driver(UINT version)
     return NULL;
 }
 
-#else /* No vulkan */
-
-const struct vulkan_funcs *get_vulkan_driver(UINT version)
-{
-    ERR("Wine was built without Vulkan support.\n");
-    return NULL;
-}
-
-void wine_vk_surface_destroy(HWND hwnd)
-{
-}
-
-void vulkan_thread_detach(void)
-{
-}
-
-#endif /* SONAME_LIBVULKAN */
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index a9d6dbf..30560fd 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -214,6 +214,25 @@ static BOOL has_owned_popups( HWND hwnd )
     return ret;
 }
 
+static BOOL is_actual_window_rect_mapped(const struct x11drv_win_data *data)
+{
+    XWindowAttributes attr;
+    Window child;
+    RECT rect;
+    POINT pt;
+    int x, y;
+
+    /* Query the X server for the actual position of the window,
+       as some WMs tend to mess with it, so we need to make sure
+       we aren't unmapping the window wrongly with a bogus rect */
+    XTranslateCoordinates(data->display, data->whole_window, root_window, 0, 0, &x, &y, &child);
+    XGetWindowAttributes(data->display, data->whole_window, &attr);
+
+    pt = root_to_virtual_screen(x - attr.x, y - attr.y);
+    SetRect(&rect, pt.x, pt.y, pt.x + attr.width, pt.y + attr.height);
+    return is_window_rect_mapped(&rect);
+}
+
 
 /***********************************************************************
  *              alloc_win_data
@@ -309,7 +328,7 @@ static unsigned long get_mwm_decorations( struct x11drv_win_data *data,
     if (data->shaped) return 0;
 
     if (ex_style & WS_EX_TOOLWINDOW) return 0;
-    if (ex_style & WS_EX_LAYERED) return 0;
+    if ((ex_style & (WS_EX_LAYERED | WS_EX_COMPOSITED)) == WS_EX_LAYERED) return 0;
 
     if ((style & WS_CAPTION) == WS_CAPTION)
     {
@@ -318,9 +337,6 @@ static unsigned long get_mwm_decorations( struct x11drv_win_data *data,
         if (style & WS_MINIMIZEBOX) ret |= MWM_DECOR_MINIMIZE;
         if (style & WS_MAXIMIZEBOX) ret |= MWM_DECOR_MAXIMIZE;
     }
-    if (ex_style & WS_EX_DLGMODALFRAME) ret |= MWM_DECOR_BORDER;
-    else if (style & WS_THICKFRAME) ret |= MWM_DECOR_BORDER | MWM_DECOR_RESIZEH;
-    else if ((style & (WS_DLGFRAME|WS_BORDER)) == WS_DLGFRAME) ret |= MWM_DECOR_BORDER;
     return ret;
 }
 
@@ -362,6 +378,7 @@ static void sync_window_style( struct x11drv_win_data *data )
         int mask = get_window_attributes( data, &attr );
 
         XChangeWindowAttributes( data->display, data->whole_window, mask, &attr );
+        x11drv_xinput_enable( data->display, data->whole_window, attr.event_mask );
     }
 }
 
@@ -424,14 +441,11 @@ static void sync_window_region( struct x11drv_win_data *data, HRGN win_region )
 
 
 /***********************************************************************
- *              sync_window_opacity
+ *              set_window_opacity
  */
-static void sync_window_opacity( Display *display, Window win,
-                                 COLORREF key, BYTE alpha, DWORD flags )
+static void set_window_opacity( Display *display, Window win, BYTE alpha )
 {
-    unsigned long opacity = 0xffffffff;
-
-    if (flags & LWA_ALPHA) opacity = (0xffffffff / 0xff) * alpha;
+    unsigned long opacity = (0xffffffff / 0xff) * alpha;
 
     if (opacity == 0xffffffff)
         XDeleteProperty( display, win, x11drv_atom(_NET_WM_WINDOW_OPACITY) );
@@ -1469,6 +1483,7 @@ static void sync_client_position( struct x11drv_win_data *data,
         TRACE( "setting client win %lx pos %d,%d,%dx%d changes=%x\n",
                data->client_window, changes.x, changes.y, changes.width, changes.height, mask );
         XConfigureWindow( gdi_display, data->client_window, mask, &changes );
+        resize_vk_surfaces( data->hwnd, data->client_window, mask, &changes );
     }
 }
 
@@ -1586,6 +1601,32 @@ Window get_dummy_parent(void)
 }
 
 
+/**********************************************************************
+ *		update_client_window
+ */
+void update_client_window( HWND hwnd )
+{
+    struct x11drv_win_data *data;
+    Window old_active;
+
+    if ((data = get_win_data( hwnd )))
+    {
+        old_active = data->client_window;
+        data->client_window = wine_vk_active_surface( hwnd );
+        if (data->client_window && data->whole_window && old_active != data->client_window)
+        {
+            TRACE( "%p reparent xwin %lx/%lx\n", data->hwnd, data->whole_window, data->client_window );
+            XReparentWindow( gdi_display, data->client_window, data->whole_window,
+                     data->client_rect.left - data->whole_rect.left,
+                     data->client_rect.top - data->whole_rect.top );
+        }
+        /* make sure any request that could use old client window has been flushed */
+        XFlush( data->display );
+        release_win_data( data );
+    }
+}
+
+
 /**********************************************************************
  *		create_dummy_client_window
  */
@@ -1717,6 +1758,7 @@ static void create_whole_window( struct x11drv_win_data *data )
                                         data->vis.visual, mask, &attr );
     if (!data->whole_window) goto done;
 
+    x11drv_xinput_enable( data->display, data->whole_window, attr.event_mask );
     set_initial_wm_hints( data->display, data->whole_window );
     set_wm_hints( data );
 
@@ -1732,7 +1774,7 @@ static void create_whole_window( struct x11drv_win_data *data )
 
     /* set the window opacity */
     if (!NtUserGetLayeredWindowAttributes( data->hwnd, &key, &alpha, &layered_flags )) layered_flags = 0;
-    sync_window_opacity( data->display, data->whole_window, key, alpha, layered_flags );
+    set_window_opacity( data->display, data->whole_window, (layered_flags & LWA_ALPHA) ? alpha : 0xff );
 
     XFlush( data->display );  /* make sure the window exists before we start painting to it */
 
@@ -1856,6 +1898,17 @@ void X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
 {
     struct x11drv_win_data *data;
     DWORD changed = style->styleNew ^ style->styleOld;
+    HWND parent = NtUserGetAncestor( hwnd, GA_PARENT );
+
+    if (offset == GWL_STYLE && (changed & WS_CHILD))
+    {
+        if (NtUserGetWindowRelative( parent, GW_CHILD ) ||
+            NtUserGetAncestor( parent, GA_PARENT ) != NtUserGetDesktopWindow())
+            sync_vk_surface( parent, TRUE );
+        else
+            sync_vk_surface( parent, FALSE );
+        sync_vk_surface( hwnd, style->styleNew & WS_CHILD );
+    }
 
     if (hwnd == NtUserGetDesktopWindow()) return;
     if (!(data = get_win_data( hwnd ))) return;
@@ -1867,7 +1920,7 @@ void X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
     {
         data->layered = FALSE;
         set_window_visual( data, &default_visual, FALSE );
-        sync_window_opacity( data->display, data->whole_window, 0, 0, 0 );
+        set_window_opacity( data->display, data->whole_window, 0xff );
         if (data->surface) set_surface_color_key( data->surface, CLR_INVALID );
     }
 done:
@@ -1882,6 +1935,11 @@ void X11DRV_DestroyWindow( HWND hwnd )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data;
+    HWND parent = NtUserGetAncestor( hwnd, GA_PARENT );
+
+    if (!NtUserGetWindowRelative( parent, GW_CHILD ) &&
+        NtUserGetAncestor( parent, GA_PARENT ) == NtUserGetDesktopWindow())
+        sync_vk_surface( parent, FALSE );
 
     if (!(data = get_win_data( hwnd ))) return;
 
@@ -1896,7 +1954,7 @@ void X11DRV_DestroyWindow( HWND hwnd )
     release_win_data( data );
     free( data );
     destroy_gl_drawable( hwnd );
-    wine_vk_surface_destroy( hwnd );
+    destroy_vk_surface( hwnd );
 }
 
 
@@ -2049,12 +2107,17 @@ BOOL X11DRV_CreateWindow( HWND hwnd )
         struct x11drv_thread_data *data = x11drv_init_thread_data();
         XSetWindowAttributes attr;
 
+        /* listen to raw xinput event in the desktop window thread */
+        data->xi2_rawinput_only = TRUE;
+        x11drv_xinput_enable( data->display, DefaultRootWindow( data->display ), PointerMotionMask );
+
         /* create the cursor clipping window */
         attr.override_redirect = TRUE;
         attr.event_mask = StructureNotifyMask | FocusChangeMask;
         data->clip_window = XCreateWindow( data->display, root_window, 0, 0, 1, 1, 0, 0,
                                            InputOnly, default_visual.visual,
                                            CWOverrideRedirect | CWEventMask, &attr );
+        x11drv_xinput_enable( data->display, data->clip_window, attr.event_mask );
         XFlush( data->display );
         NtUserSetProp( hwnd, clip_window_prop, (HANDLE)data->clip_window );
         X11DRV_DisplayDevices_RegisterEventHandlers();
@@ -2115,6 +2178,7 @@ static struct x11drv_win_data *X11DRV_create_win_data( HWND hwnd, const RECT *wi
      * that will need clipping support.
      */
     sync_gl_drawable( parent, TRUE );
+    sync_vk_surface( parent, TRUE );
 
     display = thread_init_display();
     init_clip_window();  /* make sure the clip window is initialized in this thread */
@@ -2476,6 +2540,54 @@ BOOL X11DRV_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update )
 }
 
 
+/***********************************************************************
+ *		SetActiveWindow  (X11DRV.@)
+ */
+void X11DRV_SetActiveWindow( HWND hwnd )
+{
+    struct x11drv_thread_data *thread_data = x11drv_init_thread_data();
+    struct x11drv_win_data *data;
+
+    TRACE("%p\n", hwnd);
+
+    if (thread_data->active_window == hwnd)
+    {
+        TRACE("ignoring activation for already active window %p\n", hwnd);
+        return;
+    }
+
+    if (!(data = get_win_data( hwnd ))) return;
+
+    if (data->mapped && data->managed && !data->iconic)
+    {
+        XEvent xev;
+        struct x11drv_win_data *active = get_win_data( thread_data->active_window );
+        DWORD timestamp = NtUserGetThreadInfo()->message_time - EVENT_x11_time_to_win32_time( 0 );
+
+        TRACE("setting _NET_ACTIVE_WINDOW to %p/%lx, current active %p/%lx\n",
+            data->hwnd, data->whole_window, active ? active->hwnd : NULL, active ? active->whole_window : 0 );
+
+        xev.xclient.type = ClientMessage;
+        xev.xclient.window = data->whole_window;
+        xev.xclient.message_type = x11drv_atom(_NET_ACTIVE_WINDOW);
+        xev.xclient.serial = 0;
+        xev.xclient.display = data->display;
+        xev.xclient.send_event = True;
+        xev.xclient.format = 32;
+
+        xev.xclient.data.l[0] = 1; /* source: application */
+        xev.xclient.data.l[1] = timestamp;
+        xev.xclient.data.l[2] = active ? active->whole_window : 0;
+        xev.xclient.data.l[3] = 0;
+        xev.xclient.data.l[4] = 0;
+        XSendEvent( data->display, root_window, False, SubstructureRedirectMask | SubstructureNotifyMask, &xev );
+
+        if (active) release_win_data( active );
+    }
+
+    release_win_data( data );
+}
+
 /***********************************************************************
  *		SetCapture  (X11DRV.@)
  */
@@ -2543,6 +2655,7 @@ done:
      * that will need clipping support.
      */
     sync_gl_drawable( parent, TRUE );
+    sync_vk_surface( parent, TRUE );
 
     fetch_icon_data( hwnd, 0, 0 );
 }
@@ -2728,7 +2841,8 @@ void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
     {
         if (((swp_flags & SWP_HIDEWINDOW) && !(new_style & WS_VISIBLE)) ||
             (!event_type && !(new_style & WS_MINIMIZE) &&
-             !is_window_rect_mapped( rectWindow ) && is_window_rect_mapped( &old_window_rect )))
+             !is_window_rect_mapped( rectWindow ) && is_window_rect_mapped( &old_window_rect ) &&
+             !is_actual_window_rect_mapped( data )))
         {
             release_win_data( data );
             unmap_window( hwnd );
@@ -2751,7 +2865,7 @@ void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags,
             BOOL needs_map = TRUE;
 
             /* layered windows are mapped only once their attributes are set */
-            if (NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED)
+            if ((NtUserGetWindowLongW( hwnd, GWL_EXSTYLE ) & (WS_EX_LAYERED | WS_EX_COMPOSITED)) == WS_EX_LAYERED)
                 needs_map = data->layered || IsRectEmpty( rectWindow );
             release_win_data( data );
             if (needs_icon) fetch_icon_data( hwnd, 0, 0 );
@@ -2905,7 +3019,7 @@ void X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWO
         set_window_visual( data, &default_visual, FALSE );
 
         if (data->whole_window)
-            sync_window_opacity( data->display, data->whole_window, key, alpha, flags );
+            set_window_opacity( data->display, data->whole_window, (flags & LWA_ALPHA) ? alpha : 0xff );
         if (data->surface)
             set_surface_color_key( data->surface, (flags & LWA_COLORKEY) ? key : CLR_INVALID );
 
@@ -2929,7 +3043,7 @@ void X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha, DWO
         Window win = X11DRV_get_whole_window( hwnd );
         if (win)
         {
-            sync_window_opacity( gdi_display, win, key, alpha, flags );
+            set_window_opacity( gdi_display, win, (flags & LWA_ALPHA) ? alpha : 0xff );
             if (flags & LWA_COLORKEY)
                 FIXME( "LWA_COLORKEY not supported on foreign process window %p\n", hwnd );
         }
@@ -2945,7 +3059,6 @@ BOOL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
 {
     struct window_surface *surface;
     struct x11drv_win_data *data;
-    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
     COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
     char buffer[FIELD_OFFSET( BITMAPINFO, bmiColors[256] )];
     BITMAPINFO *bmi = (BITMAPINFO *)buffer;
@@ -2973,6 +3086,10 @@ BOOL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
     }
     else set_surface_color_key( surface, color_key );
 
+    if (data->whole_window)
+        set_window_opacity( data->display, data->whole_window,
+                            (info->dwFlags & ULW_ALPHA) ? info->pblend->SourceConstantAlpha : 0xff );
+
     if (surface) window_surface_add_ref( surface );
     mapped = data->mapped;
     release_win_data( data );
@@ -3007,17 +3124,15 @@ BOOL X11DRV_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
     {
         intersect_rect( &rect, &rect, info->prcDirty );
         memcpy( src_bits, dst_bits, bmi->bmiHeader.biSizeImage );
-        NtGdiPatBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS );
     }
     src_rect = rect;
     if (info->pptSrc) OffsetRect( &src_rect, info->pptSrc->x, info->pptSrc->y );
     NtGdiTransformPoints( info->hdcSrc, (POINT *)&src_rect, (POINT *)&src_rect, 2, NtGdiDPtoLP );
 
-    if (info->dwFlags & ULW_ALPHA) blend = *info->pblend;
-    ret = NtGdiAlphaBlend( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+    ret = NtGdiStretchBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
                            info->hdcSrc, src_rect.left, src_rect.top,
                            src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
-                           *(DWORD *)&blend, 0 );
+                           SRCCOPY, 0 );
     if (ret)
     {
         memcpy( dst_bits, src_bits, bmi->bmiHeader.biSizeImage );
diff --git a/dlls/winex11.drv/wintab.c b/dlls/winex11.drv/wintab.c
index 6f1437f..b47bf36 100644
--- a/dlls/winex11.drv/wintab.c
+++ b/dlls/winex11.drv/wintab.c
@@ -905,6 +905,11 @@ static BOOL motion_event( HWND hwnd, XEvent *event )
                                             (abs(motion->axis_data[3]),
                                              abs(motion->axis_data[4])))
                                            * (gMsgPacket.pkStatus & TPS_INVERT?-1:1));
+
+    if (gMsgPacket.pkOrientation.orAltitude < 0)
+    {
+        FIXME("Negative orAltitude detected\n");
+    }
     gMsgPacket.pkNormalPressure = motion->axis_data[2];
     gMsgPacket.pkButtons = get_button_state(curnum);
     gMsgPacket.pkChanged = get_changed_state(&gMsgPacket);
@@ -931,6 +936,7 @@ static BOOL button_event( HWND hwnd, XEvent *event )
     gMsgPacket.pkTime = EVENT_x11_time_to_win32_time(button->time);
     gMsgPacket.pkSerialNumber = gSerial++;
     gMsgPacket.pkCursor = curnum;
+
     if (button->axes_count > 0) {
         gMsgPacket.pkX = button->axis_data[0];
         gMsgPacket.pkY = button->axis_data[1];
@@ -945,6 +951,12 @@ static BOOL button_event( HWND hwnd, XEvent *event )
         gMsgPacket.pkOrientation = last_packet.pkOrientation;
         gMsgPacket.pkNormalPressure = last_packet.pkNormalPressure;
     }
+
+    if (gMsgPacket.pkOrientation.orAltitude < 0)
+    {
+        FIXME("Negative orAltitude detected\n");
+    }
+
     gMsgPacket.pkButtons = get_button_state(curnum);
     gMsgPacket.pkChanged = get_changed_state(&gMsgPacket);
     send_message( hwndTabletDefault, WT_PACKET, gMsgPacket.pkSerialNumber, (LPARAM)hwnd );
@@ -987,6 +999,10 @@ static BOOL proximity_event( HWND hwnd, XEvent *event )
     gMsgPacket.pkOrientation.orAltitude = ((1000 - 15 * max(abs(proximity->axis_data[3]),
                                                             abs(proximity->axis_data[4])))
                                            * (gMsgPacket.pkStatus & TPS_INVERT?-1:1));
+    if (gMsgPacket.pkOrientation.orAltitude < 0)
+    {
+        FIXME("Negative orAltitude detected\n");
+    }
     gMsgPacket.pkNormalPressure = proximity->axis_data[2];
     gMsgPacket.pkButtons = get_button_state(curnum);
 
@@ -1140,6 +1156,17 @@ NTSTATUS x11drv_tablet_info( void *arg )
 
     if (!xinput_handle) return 0;
 
+    if(wCategory >= WTI_DSCTXS)
+    {
+        nIndex = wCategory - WTI_DSCTXS;
+        wCategory = WTI_DSCTXS;
+    }
+    else if(wCategory >= WTI_DDCTXS)
+    {
+        nIndex = wCategory - WTI_DDCTXS;
+        wCategory = WTI_DDCTXS;
+    }
+
     switch(wCategory)
     {
         case 0:
@@ -1183,6 +1210,62 @@ NTSTATUS x11drv_tablet_info( void *arg )
                     rc = 0;
             }
             break;
+        case WTI_STATUS:
+            switch (nIndex)
+            {
+                case STA_CONTEXTS:
+                {
+                    FIXME("STA_CONTEXTS unhandled\n");
+                    rc = 1;
+                    break;
+                }
+                case STA_SYSCTXS:
+                {
+                    FIXME("STA_SYSCTXS unhandled\n");
+                    rc = 1;
+                    break;
+                }
+                case STA_PKTRATE:
+                {
+                    FIXME("STA_PKTRATE unhandled\n");
+                    rc = 0;
+                    break;
+                }
+                case STA_PKTDATA:
+                {
+                    FIXME("STA_PKTDATA unhandled\n");
+                    rc = 0;
+                    break;
+                }
+                case STA_MANAGERS:
+                {
+                    FIXME("STA_MANAGERS unhandled\n");
+                    rc = 1;
+                    break;
+                }
+                case STA_SYSTEM:
+                {
+                    FIXME("STA_SYSTEM unhandled\n");
+                    rc = TRUE;
+                    break;
+                }
+                case STA_BUTTONUSE:
+                {
+                    FIXME("STA_BUTTONUSE unhandled\n");
+                    rc = 0;
+                    break;
+                }
+                case STA_SYSBTNUSE:
+                {
+                    FIXME("STA_SYSBTNUSE unhandled\n");
+                    rc = 0;
+                    break;
+                }
+                default:
+                    FIXME("WTI_STATUS unhandled index %i\n",nIndex);
+                    rc = 0;
+            }
+            break;
         case WTI_DEFSYSCTX:
         case WTI_DDCTXS:
         case WTI_DEFCONTEXT:
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index d5edb9b..8b0a650 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -233,6 +233,7 @@ extern void X11DRV_GetDC( HDC hdc, HWND hwnd, HWND top, const RECT *win_rect,
                           const RECT *top_rect, DWORD flags );
 extern void X11DRV_ReleaseDC( HWND hwnd, HDC hdc );
 extern BOOL X11DRV_ScrollDC( HDC hdc, INT dx, INT dy, HRGN update );
+extern void X11DRV_SetActiveWindow( HWND hwnd );
 extern void X11DRV_SetCapture( HWND hwnd, UINT flags );
 extern void X11DRV_SetDesktopWindow( HWND hwnd );
 extern void X11DRV_SetLayeredWindowAttributes( HWND hwnd, COLORREF key, BYTE alpha,
@@ -258,12 +259,16 @@ extern void X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flag
                                      struct window_surface *surface );
 extern BOOL X11DRV_SystemParametersInfo( UINT action, UINT int_param, void *ptr_param,
                                          UINT flags );
+extern void X11DRV_UpdateCandidatePos( HWND hwnd, const RECT *caret_rect );
 extern void X11DRV_ThreadDetach(void);
 
 /* X11 driver internal functions */
 
 extern void X11DRV_Xcursor_Init(void);
-extern void X11DRV_XInput2_Init(void);
+extern void x11drv_xinput_load(void);
+extern void x11drv_xinput_init(void);
+extern void x11drv_xinput_enable( Display *display, Window window, long event_mask );
+extern void x11drv_xinput_disable( Display *display, Window window, long event_mask );
 
 extern DWORD copy_image_bits( BITMAPINFO *info, BOOL is_r8g8b8, XImage *image,
                               const struct gdi_image_bits *src_bits, struct gdi_image_bits *dst_bits,
@@ -348,7 +353,8 @@ enum x11drv_escape_codes
     X11DRV_GET_DRAWABLE,     /* get current drawable for a DC */
     X11DRV_START_EXPOSURES,  /* start graphics exposures */
     X11DRV_END_EXPOSURES,    /* end graphics exposures */
-    X11DRV_FLUSH_GL_DRAWABLE /* flush changes made to the gl drawable */
+    X11DRV_PRESENT_DRAWABLE, /* present the drawable on screen */
+    X11DRV_FLUSH_GDI_DISPLAY /* flush the gdi display */
 };
 
 struct x11drv_escape_set_drawable
@@ -367,10 +373,10 @@ struct x11drv_escape_get_drawable
     int                      pixel_format; /* internal GL pixel format */
 };
 
-struct x11drv_escape_flush_gl_drawable
+struct x11drv_escape_present_drawable
 {
-    enum x11drv_escape_codes code;         /* escape code (X11DRV_FLUSH_GL_DRAWABLE) */
-    Drawable                 gl_drawable;  /* GL drawable */
+    enum x11drv_escape_codes code;         /* escape code (X11DRV_PRESENT_DRAWABLE) */
+    Drawable                 drawable;     /* GL / VK drawable */
     BOOL                     flush;        /* flush X11 before copying */
 };
 
@@ -378,11 +384,20 @@ struct x11drv_escape_flush_gl_drawable
  * X11 USER driver
  */
 
+enum xi2_state
+{
+    xi_unavailable = -1,
+    xi_unknown,
+    xi_disabled,
+    xi_enabled
+};
+
 struct x11drv_thread_data
 {
     Display *display;
     XEvent  *current_event;        /* event currently being processed */
     HWND     grab_hwnd;            /* window that currently grabs the mouse */
+    HWND     active_window;        /* active window */
     HWND     last_focus;           /* last window that had focus */
     HWND     keymapnotify_hwnd;    /* window that should receive modifier release events */
     XIM      xim;                  /* input method */
@@ -393,13 +408,11 @@ struct x11drv_thread_data
     Window   clip_window;          /* window used for cursor clipping */
     BOOL     clipping_cursor;      /* whether thread is currently clipping the cursor */
 #ifdef HAVE_X11_EXTENSIONS_XINPUT2_H
-    enum { xi_unavailable = -1, xi_unknown, xi_disabled, xi_enabled } xi2_state; /* XInput2 state */
-    void    *xi2_devices;          /* list of XInput2 devices (valid when state is enabled) */
-    int      xi2_device_count;
+    enum xi2_state xi2_state;      /* XInput2 state */
     XIValuatorClassInfo x_valuator;
     XIValuatorClassInfo y_valuator;
     int      xi2_core_pointer;     /* XInput2 core pointer id */
-    int      xi2_current_slave;    /* Current slave driving the Core pointer */
+    int      xi2_rawinput_only;
 #endif /* HAVE_X11_EXTENSIONS_XINPUT2_H */
 };
 
@@ -445,6 +458,8 @@ extern BOOL use_take_focus;
 extern BOOL use_primary_selection;
 extern BOOL use_system_cursors;
 extern BOOL grab_fullscreen;
+extern int keyboard_layout;
+extern BOOL keyboard_scancode_detect;
 extern BOOL usexcomposite;
 extern BOOL managed_mode;
 extern BOOL decorated_mode;
@@ -487,6 +502,7 @@ enum x11drv_atoms
     XATOM__ICC_PROFILE,
     XATOM__KDE_NET_WM_STATE_SKIP_SWITCHER,
     XATOM__MOTIF_WM_HINTS,
+    XATOM__NET_ACTIVE_WINDOW,
     XATOM__NET_STARTUP_INFO_BEGIN,
     XATOM__NET_STARTUP_INFO,
     XATOM__NET_SUPPORTED,
@@ -687,6 +703,7 @@ extern void retry_grab_clipping_window(void);
 extern void ungrab_clipping_window(void);
 extern void move_resize_window( HWND hwnd, int dir );
 extern void X11DRV_InitKeyboard( Display *display );
+extern void X11DRV_InitMouse( Display *display );
 extern BOOL X11DRV_ProcessEvents( DWORD mask );
 extern HWND *build_hwnd_list(void);
 
@@ -703,6 +720,11 @@ extern BOOL xinerama_get_fullscreen_monitors( const RECT *rect, long *indices );
 extern void xinerama_init( unsigned int width, unsigned int height );
 extern void init_recursive_mutex( pthread_mutex_t *mutex );
 
+/* keyboard.c */
+
+extern int x11drv_find_keyboard_layout( const WCHAR *layout );
+extern WCHAR *x11drv_get_keyboard_layout_list( DWORD *size );
+
 #define DEPTH_COUNT 3
 extern const unsigned int *depths;
 
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 25a36cb..d5ea27c 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -50,6 +50,8 @@
 #include "x11drv.h"
 #include "winreg.h"
 #include "xcomposite.h"
+#include "xfixes.h"
+#include "xpresent.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "wine/list.h"
@@ -71,10 +73,14 @@ Window root_window;
 BOOL usexvidmode = TRUE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
+BOOL use_xfixes = FALSE;
+BOOL use_xpresent = FALSE;
 BOOL use_take_focus = TRUE;
 BOOL use_primary_selection = FALSE;
 BOOL use_system_cursors = TRUE;
 BOOL grab_fullscreen = FALSE;
+int keyboard_layout = -1;
+BOOL keyboard_scancode_detect = FALSE;
 BOOL managed_mode = TRUE;
 BOOL decorated_mode = TRUE;
 BOOL private_color_map = FALSE;
@@ -85,6 +91,7 @@ BOOL shape_layered_windows = TRUE;
 int copy_default_colors = 128;
 int alloc_system_colors = 256;
 int xrender_error_base = 0;
+int xfixes_event_base = 0;
 char *process_name = NULL;
 WNDPROC client_foreign_window_proc = NULL;
 
@@ -153,6 +160,7 @@ static const char * const atom_names[NB_XATOMS - FIRST_XATOM] =
     "_ICC_PROFILE",
     "_KDE_NET_WM_STATE_SKIP_SWITCHER",
     "_MOTIF_WM_HINTS",
+    "_NET_ACTIVE_WINDOW",
     "_NET_STARTUP_INFO_BEGIN",
     "_NET_STARTUP_INFO",
     "_NET_SUPPORTED",
@@ -353,11 +361,61 @@ HKEY reg_open_key( HKEY root, const WCHAR *name, ULONG name_len )
     return NtOpenKeyEx( &ret, MAXIMUM_ALLOWED, &attr, 0 ) ? 0 : ret;
 }
 
+/* wrapper for NtCreateKey that creates the key recursively if necessary */
+static HKEY reg_create_key( HKEY root, const WCHAR *name, ULONG name_len,
+                            DWORD options, DWORD *disposition )
+{
+    UNICODE_STRING nameW = { name_len, name_len, (WCHAR *)name };
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status;
+    HANDLE ret;
 
-HKEY open_hkcu_key( const char *name )
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    status = NtCreateKey( &ret, MAXIMUM_ALLOWED, &attr, 0, NULL, options, disposition );
+    if (status == STATUS_OBJECT_NAME_NOT_FOUND)
+    {
+        static const WCHAR registry_rootW[] = { '\\','R','e','g','i','s','t','r','y','\\' };
+        DWORD pos = 0, i = 0, len = name_len / sizeof(WCHAR);
+
+        /* don't try to create registry root */
+        if (!root && len > ARRAY_SIZE(registry_rootW) &&
+            !memcmp( name, registry_rootW, sizeof(registry_rootW) ))
+            i += ARRAY_SIZE(registry_rootW);
+
+        while (i < len && name[i] != '\\') i++;
+        if (i == len) return 0;
+        for (;;)
+        {
+            unsigned int subkey_options = options;
+            if (i < len) subkey_options &= ~(REG_OPTION_CREATE_LINK | REG_OPTION_OPEN_LINK);
+            nameW.Buffer = (WCHAR *)name + pos;
+            nameW.Length = (i - pos) * sizeof(WCHAR);
+            status = NtCreateKey( &ret, MAXIMUM_ALLOWED, &attr, 0, NULL, subkey_options, disposition );
+
+            if (attr.RootDirectory != root) NtClose( attr.RootDirectory );
+            if (!NT_SUCCESS(status)) return 0;
+            if (i == len) break;
+            attr.RootDirectory = ret;
+            while (i < len && name[i] == '\\') i++;
+            pos = i;
+            while (i < len && name[i] != '\\') i++;
+        }
+    }
+    return ret;
+}
+
+static HKEY reg_open_hkcu_key( const char *name, BOOL create )
 {
     WCHAR bufferW[256];
     static HKEY hkcu;
+    DWORD disp;
+    HKEY key;
 
     if (!hkcu)
     {
@@ -382,9 +440,33 @@ HKEY open_hkcu_key( const char *name )
         hkcu = reg_open_key( NULL, bufferW, len * sizeof(WCHAR) );
     }
 
-    return reg_open_key( hkcu, bufferW, asciiz_to_unicode( bufferW, name ) - sizeof(WCHAR) );
+    if ((key = reg_open_key( hkcu, bufferW, asciiz_to_unicode( bufferW, name ) - sizeof(WCHAR) )) || !create) return key;
+    return reg_create_key( hkcu, bufferW, asciiz_to_unicode( bufferW, name ) - sizeof(WCHAR), 0, &disp );
 }
 
+HKEY open_hkcu_key( const char *name )
+{
+    return reg_open_hkcu_key( name, FALSE );
+}
+
+static HKEY create_hkcu_key( const char *name )
+{
+    return reg_open_hkcu_key( name, TRUE );
+}
+
+static BOOL set_reg_value( HKEY hkey, const WCHAR *name, UINT type, const void *value, DWORD count )
+{
+    unsigned int name_size = name ? lstrlenW( name ) * sizeof(WCHAR) : 0;
+    UNICODE_STRING nameW = { name_size, name_size, (WCHAR *)name };
+    return !NtSetValueKey( hkey, &nameW, 0, type, value, count );
+}
+
+static void set_reg_string_value( HKEY hkey, const char *name, const WCHAR *value, DWORD count )
+{
+    WCHAR nameW[64];
+    asciiz_to_unicode( nameW, name );
+    set_reg_value( hkey, nameW, REG_MULTI_SZ, value, count );
+}
 
 ULONG query_reg_value( HKEY hkey, const WCHAR *name, KEY_VALUE_PARTIAL_INFORMATION *info, ULONG size )
 {
@@ -446,7 +528,7 @@ static void setup_options(void)
     DWORD len;
 
     /* @@ Wine registry key: HKCU\Software\Wine\X11 Driver */
-    hkey = open_hkcu_key( "Software\\Wine\\X11 Driver" );
+    hkey = create_hkcu_key( "Software\\Wine\\X11 Driver" );
 
     /* open the app-specific key */
 
@@ -497,6 +579,16 @@ static void setup_options(void)
     if (!get_config_key( hkey, appkey, "GrabFullscreen", buffer, sizeof(buffer) ))
         grab_fullscreen = IS_OPTION_TRUE( buffer[0] );
 
+    if (!get_config_key( hkey, appkey, "KeyboardLayout", buffer, sizeof(buffer) ))
+        keyboard_layout = x11drv_find_keyboard_layout( buffer );
+
+    p = x11drv_get_keyboard_layout_list( &len );
+    if (p) set_reg_string_value( hkey, "KeyboardLayoutList", p, len * sizeof(WCHAR) );
+    free( p );
+
+    if (!get_config_key( hkey, appkey, "KeyboardScancodeDetect", buffer, sizeof(buffer) ))
+        keyboard_scancode_detect = IS_OPTION_TRUE( buffer[0] );
+
     if (!get_config_key( hkey, appkey, "ScreenDepth", buffer, sizeof(buffer) ))
         default_visual.depth = wcstol( buffer, NULL, 0 );
 
@@ -589,6 +681,116 @@ sym_not_found:
 }
 #endif /* defined(SONAME_LIBXCOMPOSITE) */
 
+#ifdef SONAME_LIBXFIXES
+
+#define MAKE_FUNCPTR(f) typeof(f) * p##f;
+MAKE_FUNCPTR(XFixesQueryExtension)
+MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesCreateRegion)
+MAKE_FUNCPTR(XFixesCreateRegionFromGC)
+MAKE_FUNCPTR(XFixesDestroyRegion)
+MAKE_FUNCPTR(XFixesSelectSelectionInput)
+#undef MAKE_FUNCPTR
+
+static void x11drv_load_xfixes(void)
+{
+    int event, error, major = 3, minor = 0;
+    void *xfixes;
+
+    if (!(xfixes = dlopen(SONAME_LIBXFIXES, RTLD_NOW)))
+    {
+        WARN("Xfixes library %s not found, disabled.\n", SONAME_LIBXFIXES);
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) \
+    if (!(p##f = dlsym(xfixes, #f)))                          \
+    {                                                         \
+        WARN("Xfixes function %s not found, disabled\n", #f); \
+        dlclose(xfixes);                                      \
+        return;                                               \
+    }
+    LOAD_FUNCPTR(XFixesQueryExtension)
+    LOAD_FUNCPTR(XFixesQueryVersion)
+    LOAD_FUNCPTR(XFixesCreateRegion)
+    LOAD_FUNCPTR(XFixesCreateRegionFromGC)
+    LOAD_FUNCPTR(XFixesDestroyRegion)
+    LOAD_FUNCPTR(XFixesSelectSelectionInput)
+#undef LOAD_FUNCPTR
+
+    if (!pXFixesQueryExtension(gdi_display, &event, &error))
+    {
+        WARN("Xfixes extension not found, disabled.\n");
+        dlclose(xfixes);
+        return;
+    }
+
+    if (!pXFixesQueryVersion(gdi_display, &major, &minor) ||
+        major < 2)
+    {
+        WARN("Xfixes version 2.0 not found, disabled.\n");
+        dlclose(xfixes);
+        return;
+    }
+
+    TRACE("Xfixes, error %d, event %d, version %d.%d found\n",
+          error, event, major, minor);
+    use_xfixes = TRUE;
+    xfixes_event_base = event;
+}
+#endif /* SONAME_LIBXFIXES */
+
+#ifdef SONAME_LIBXPRESENT
+
+#define MAKE_FUNCPTR(f) typeof(f) * p##f;
+MAKE_FUNCPTR(XPresentQueryExtension)
+MAKE_FUNCPTR(XPresentQueryVersion)
+MAKE_FUNCPTR(XPresentPixmap)
+#undef MAKE_FUNCPTR
+
+static void x11drv_load_xpresent(void)
+{
+    int opcode, event, error, major = 1, minor = 0;
+    void *xpresent;
+
+    if (!(xpresent = dlopen( SONAME_LIBXPRESENT, RTLD_NOW )))
+    {
+        WARN( "Xpresent library %s not found, disabled.\n", SONAME_LIBXPRESENT );
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) \
+    if (!(p##f = dlsym( xpresent, #f )))                          \
+    {                                                             \
+        WARN( "Xpresent function %s not found, disabled\n", #f ); \
+        dlclose( xpresent );                                      \
+        return;                                                   \
+    }
+    LOAD_FUNCPTR(XPresentQueryExtension)
+    LOAD_FUNCPTR(XPresentQueryVersion)
+    LOAD_FUNCPTR(XPresentPixmap)
+#undef LOAD_FUNCPTR
+
+    if (!pXPresentQueryExtension( gdi_display, &opcode, &event, &error ))
+    {
+        WARN("Xpresent extension not found, disabled.\n");
+        dlclose(xpresent);
+        return;
+    }
+
+    if (!pXPresentQueryVersion( gdi_display, &major, &minor ))
+    {
+        WARN("Xpresent version not found, disabled.\n");
+        dlclose(xpresent);
+        return;
+    }
+
+    TRACE( "Xpresent, opcode %d, error %d, event %d, version %d.%d found\n",
+           opcode, error, event, major, minor );
+    use_xpresent = TRUE;
+}
+#endif /* SONAME_LIBXPRESENT */
+
 static void init_visuals( Display *display, int screen )
 {
     int count;
@@ -694,13 +896,20 @@ static NTSTATUS x11drv_init( void *arg )
     X11DRV_XF86VM_Init();
     /* initialize XRandR */
     X11DRV_XRandR_Init();
+#ifdef SONAME_LIBXFIXES
+    x11drv_load_xfixes();
+#endif
+#ifdef SONAME_LIBXPRESENT
+    x11drv_load_xpresent();
+#endif
 #ifdef SONAME_LIBXCOMPOSITE
     X11DRV_XComposite_Init();
 #endif
-    X11DRV_XInput2_Init();
+    x11drv_xinput_load();
 
     XkbUseExtension( gdi_display, NULL, NULL );
     X11DRV_InitKeyboard( gdi_display );
+    X11DRV_InitMouse( gdi_display );
     if (use_xim) use_xim = xim_init( input_style );
 
     init_user_driver();
@@ -787,6 +996,8 @@ struct x11drv_thread_data *x11drv_init_thread_data(void)
 
     if (use_xim) xim_thread_attach( data );
 
+    x11drv_xinput_init();
+
     return data;
 }
 
diff --git a/dlls/winex11.drv/xim.c b/dlls/winex11.drv/xim.c
index c6a93eb..918b4a0 100644
--- a/dlls/winex11.drv/xim.c
+++ b/dlls/winex11.drv/xim.c
@@ -36,6 +36,7 @@
 #include "x11drv.h"
 #include "imm.h"
 #include "wine/debug.h"
+#include "wine/server.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(xim);
 
@@ -410,6 +411,49 @@ void xim_thread_attach( struct x11drv_thread_data *data )
     XRegisterIMInstantiateCallback( display, NULL, NULL, NULL, xim_open, (XPointer)data );
 }
 
+/***********************************************************************
+ *           X11DRV_UpdateCandidatePos
+ */
+void X11DRV_UpdateCandidatePos( HWND hwnd, const RECT *caret_rect )
+{
+    if (input_style & XIMPreeditPosition)
+    {
+        struct x11drv_win_data *data;
+        HWND parent;
+
+        for (parent = hwnd; parent && parent != NtUserGetDesktopWindow(); parent = NtUserGetAncestor( parent, GA_PARENT ))
+        {
+            if (!(data = get_win_data( parent ))) continue;
+            if (data->xic)
+            {
+                XVaNestedList preedit;
+                XPoint xpoint;
+                POINT pt;
+
+                pt.x = caret_rect->left;
+                pt.y = caret_rect->bottom;
+
+                if (hwnd != data->hwnd)
+                    NtUserMapWindowPoints( hwnd, data->hwnd, &pt, 1 );
+
+                if (NtUserGetWindowLongW( data->hwnd, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
+                    pt.x = data->client_rect.right - data->client_rect.left - 1 - pt.x;
+
+                xpoint.x = pt.x + data->client_rect.left - data->whole_rect.left;
+                xpoint.y = pt.y + data->client_rect.top - data->whole_rect.top;
+
+                preedit = XVaCreateNestedList( 0, XNSpotLocation, &xpoint, NULL );
+                if (preedit)
+                {
+                    XSetICValues( data->xic, XNPreeditAttributes, preedit, NULL );
+                    XFree( preedit );
+                }
+            }
+            release_win_data( data );
+        }
+    }
+}
+
 static BOOL xic_destroy( XIC xic, XPointer user, XPointer arg )
 {
     struct x11drv_win_data *data;
@@ -463,6 +507,32 @@ static XIC xic_create( XIM xim, HWND hwnd, Window win )
     XFree( preedit );
     XFree( status );
 
+    if (xic != NULL && (input_style & XIMPreeditPosition))
+    {
+        SERVER_START_REQ( set_caret_info )
+        {
+            req->flags  = 0;  /* don't set anything */
+            req->handle = 0;
+            req->x      = 0;
+            req->y      = 0;
+            req->hide   = 0;
+            req->state  = 0;
+            if (!wine_server_call_err( req ))
+            {
+                HWND hwnd;
+                RECT r;
+
+                hwnd      = wine_server_ptr_handle( reply->full_handle );
+                r.left    = reply->old_rect.left;
+                r.top     = reply->old_rect.top;
+                r.right   = reply->old_rect.right;
+                r.bottom  = reply->old_rect.bottom;
+                X11DRV_UpdateCandidatePos( hwnd, &r );
+            }
+        }
+        SERVER_END_REQ;
+    }
+
     return xic;
 }
 
@@ -472,6 +542,11 @@ XIC X11DRV_get_ic( HWND hwnd )
     XIM xim;
     XIC ret;
 
+    if (!x11drv_thread_data())
+    {
+        release_win_data( data );
+        return NULL;
+    }
     if (!(data = get_win_data( hwnd ))) return 0;
     x11drv_thread_data()->last_xic_hwnd = hwnd;
     if (!(ret = data->xic) && (xim = x11drv_thread_data()->xim))
diff --git a/dlls/wininet/http.c b/dlls/wininet/http.c
index ac3a195..b9d8688 100644
--- a/dlls/wininet/http.c
+++ b/dlls/wininet/http.c
@@ -649,10 +649,18 @@ static void HTTP_ProcessCookies( http_request_t *request )
     int HeaderIndex;
     int numCookies = 0;
     LPHTTPHEADERW setCookieHeader;
+    WCHAR *path, *tmp;
 
     if(request->hdr.dwFlags & INTERNET_FLAG_NO_COOKIES)
         return;
 
+    path = wcsdup(request->path);
+    if (!path)
+        return;
+
+    tmp = wcsrchr(path, '/');
+    if (tmp && tmp[1]) tmp[1] = 0;
+
     EnterCriticalSection( &request->headers_section );
 
     while((HeaderIndex = HTTP_GetCustomHeaderIndex(request, L"Set-Cookie", numCookies++, FALSE)) != -1)
@@ -671,10 +679,11 @@ static void HTTP_ProcessCookies( http_request_t *request )
 
         name = substr(setCookieHeader->lpszValue, data - setCookieHeader->lpszValue);
         data++;
-        set_cookie(substrz(request->server->name), substrz(request->path), name, substrz(data), INTERNET_COOKIE_HTTPONLY);
+        set_cookie(substrz(request->server->name), substrz(path), name, substrz(data), INTERNET_COOKIE_HTTPONLY);
     }
 
     LeaveCriticalSection( &request->headers_section );
+    free(path);
 }
 
 static void strip_spaces(LPWSTR start)
@@ -6225,130 +6234,131 @@ static LPWSTR * HTTP_InterpretHttpHeader(LPCWSTR buffer)
 
 static DWORD HTTP_ProcessHeader(http_request_t *request, LPCWSTR field, LPCWSTR value, DWORD dwModifier)
 {
-    LPHTTPHEADERW lphttpHdr = NULL;
+    LPHTTPHEADERW lphttpHdr;
     INT index;
     BOOL request_only = !!(dwModifier & HTTP_ADDHDR_FLAG_REQ);
-    DWORD res = ERROR_HTTP_INVALID_HEADER;
+    DWORD res = ERROR_SUCCESS;
 
     TRACE("--> %s: %s - 0x%08lx\n", debugstr_w(field), debugstr_w(value), dwModifier);
 
     EnterCriticalSection( &request->headers_section );
 
-    /* REPLACE wins out over ADD */
-    if (dwModifier & HTTP_ADDREQ_FLAG_REPLACE)
-        dwModifier &= ~HTTP_ADDREQ_FLAG_ADD;
+    index = HTTP_GetCustomHeaderIndex(request, field, 0, request_only);
+     if (index >= 0)
+     {
+         lphttpHdr = &request->custHeaders[index];
 
-    if (dwModifier & HTTP_ADDREQ_FLAG_ADD)
-        index = -1;
-    else
-        index = HTTP_GetCustomHeaderIndex(request, field, 0, request_only);
-
-    if (index >= 0)
-    {
-        if (dwModifier & HTTP_ADDREQ_FLAG_ADD_IF_NEW)
+        /* replace existing header if FLAG_REPLACE is given */
+        if (dwModifier & HTTP_ADDREQ_FLAG_REPLACE)
         {
-            LeaveCriticalSection( &request->headers_section );
-            return ERROR_HTTP_INVALID_HEADER;
-        }
-        lphttpHdr = &request->custHeaders[index];
-    }
-    else if (value)
-    {
-        HTTPHEADERW hdr;
+            HTTP_DeleteCustomHeader( request, index );
 
-        hdr.lpszField = (LPWSTR)field;
-        hdr.lpszValue = (LPWSTR)value;
-        hdr.wFlags = hdr.wCount = 0;
+            if (value && value[0])
+            {
+                HTTPHEADERW hdr;
 
-        if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
-            hdr.wFlags |= HDR_ISREQUEST;
+                hdr.lpszField = (LPWSTR)field;
+                hdr.lpszValue = (LPWSTR)value;
+                hdr.wFlags = hdr.wCount = 0;
 
-        res = HTTP_InsertCustomHeader(request, &hdr);
-        LeaveCriticalSection( &request->headers_section );
-        return res;
-    }
-    /* no value to delete */
-    else
-    {
-        LeaveCriticalSection( &request->headers_section );
-        return ERROR_SUCCESS;
-    }
+                if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
+                    hdr.wFlags |= HDR_ISREQUEST;
 
-    if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
-	    lphttpHdr->wFlags |= HDR_ISREQUEST;
-    else
-        lphttpHdr->wFlags &= ~HDR_ISREQUEST;
+                res = HTTP_InsertCustomHeader( request, &hdr );
+            }
 
-    if (dwModifier & HTTP_ADDREQ_FLAG_REPLACE)
-    {
-        HTTP_DeleteCustomHeader( request, index );
+            goto out;
+        }
 
-        if (value && value[0])
+        /* do not add new header if FLAG_ADD_IF_NEW is set */
+        if (dwModifier & HTTP_ADDREQ_FLAG_ADD_IF_NEW)
+         {
+            res = ERROR_HTTP_INVALID_HEADER; /* FIXME */
+            goto out;
+        }
+
+        /* handle appending to existing header */
+        if (dwModifier & COALESCEFLAGS)
         {
-            HTTPHEADERW hdr;
+            LPWSTR lpsztmp;
+            WCHAR ch = 0;
+            INT len = 0;
+            INT origlen = lstrlenW(lphttpHdr->lpszValue);
+            INT valuelen = lstrlenW(value);
+
+            /* FIXME: Should it really clear HDR_ISREQUEST? */
+             if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
+                lphttpHdr->wFlags |= HDR_ISREQUEST;
+            else
+                lphttpHdr->wFlags &= ~HDR_ISREQUEST;
+
+            if (dwModifier & HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA)
+            {
+                ch = ',';
+                lphttpHdr->wFlags |= HDR_COMMADELIMITED;
+            }
+            else if (dwModifier & HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON)
+            {
+                ch = ';';
+                lphttpHdr->wFlags |= HDR_COMMADELIMITED;
+            }
 
-            hdr.lpszField = (LPWSTR)field;
-            hdr.lpszValue = (LPWSTR)value;
-            hdr.wFlags = hdr.wCount = 0;
+            len = origlen + valuelen + ((ch > 0) ? 2 : 0);
 
-            if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
-                hdr.wFlags |= HDR_ISREQUEST;
+            lpsztmp = realloc(lphttpHdr->lpszValue, (len+1)*sizeof(WCHAR));
+            if (lpsztmp)
+            {
+                lphttpHdr->lpszValue = lpsztmp;
+                /* FIXME: Increment lphttpHdr->wCount. Perhaps lpszValue should be an array */
+                if (ch > 0)
+                {
+                    lphttpHdr->lpszValue[origlen] = ch;
+                    origlen++;
+                    lphttpHdr->lpszValue[origlen] = ' ';
+                    origlen++;
+                }
 
-            res = HTTP_InsertCustomHeader(request, &hdr);
-            LeaveCriticalSection( &request->headers_section );
-            return res;
-        }
+                memcpy(&lphttpHdr->lpszValue[origlen], value, valuelen*sizeof(WCHAR));
+                lphttpHdr->lpszValue[len] = '\0';
+            }
+            else
+             {
+                WARN("realloc (%d bytes) failed\n",len+1);
+                res = ERROR_OUTOFMEMORY;
+             }
 
-        LeaveCriticalSection( &request->headers_section );
-        return ERROR_SUCCESS;
-    }
-    else if (dwModifier & COALESCEFLAGS)
+            goto out;
+         }
+     }
+
+    /* FIXME: What about other combinations? */
+    if ((dwModifier & ~HTTP_ADDHDR_FLAG_REQ) == HTTP_ADDREQ_FLAG_REPLACE)
     {
-        LPWSTR lpsztmp;
-        WCHAR ch = 0;
-        INT len = 0;
-        INT origlen = lstrlenW(lphttpHdr->lpszValue);
-        INT valuelen = lstrlenW(value);
+        res = ERROR_HTTP_HEADER_NOT_FOUND;
+        goto out;
+    }
 
-        if (dwModifier & HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA)
-        {
-            ch = ',';
-            lphttpHdr->wFlags |= HDR_COMMADELIMITED;
-        }
-        else if (dwModifier & HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON)
-        {
-            ch = ';';
-            lphttpHdr->wFlags |= HDR_COMMADELIMITED;
-        }
+    /* FIXME: What if value == ""? */
+    if (value)
+    {
+        HTTPHEADERW hdr;
 
-        len = origlen + valuelen + ((ch > 0) ? 2 : 0);
+        hdr.lpszField = (LPWSTR)field;
+        hdr.lpszValue = (LPWSTR)value;
+        hdr.wFlags = hdr.wCount = 0;
 
-        lpsztmp = realloc(lphttpHdr->lpszValue, (len + 1) * sizeof(WCHAR));
-        if (lpsztmp)
-        {
-            lphttpHdr->lpszValue = lpsztmp;
-    /* FIXME: Increment lphttpHdr->wCount. Perhaps lpszValue should be an array */
-            if (ch > 0)
-            {
-                lphttpHdr->lpszValue[origlen] = ch;
-                origlen++;
-                lphttpHdr->lpszValue[origlen] = ' ';
-                origlen++;
-            }
+        if (dwModifier & HTTP_ADDHDR_FLAG_REQ)
+            hdr.wFlags |= HDR_ISREQUEST;
 
-            memcpy(&lphttpHdr->lpszValue[origlen], value, valuelen*sizeof(WCHAR));
-            lphttpHdr->lpszValue[len] = '\0';
-            res = ERROR_SUCCESS;
-        }
-        else
-        {
-            WARN("realloc (%d bytes) failed\n",len+1);
-            res = ERROR_OUTOFMEMORY;
-        }
+        res = HTTP_InsertCustomHeader( request, &hdr );
+        goto out;
     }
-    TRACE("<-- %ld\n", res);
-    LeaveCriticalSection( &request->headers_section );
-    return res;
+
+    /* FIXME: What if value == NULL? */
+out:
+     TRACE("<-- %ld\n", res);
+     LeaveCriticalSection( &request->headers_section );
+     return res;
 }
 
 /***********************************************************************
diff --git a/dlls/wininet/tests/http.c b/dlls/wininet/tests/http.c
index 9405991..7e89608 100644
--- a/dlls/wininet/tests/http.c
+++ b/dlls/wininet/tests/http.c
@@ -2402,6 +2402,22 @@ static const char largemsg[] =
 "Content-Length: %I64u\r\n"
 "\r\n";
 
+static const char okmsg_cookie_path[] =
+"HTTP/1.1 200 OK\r\n"
+"Date: Mon, 01 Dec 2008 13:44:34 GMT\r\n"
+"Server: winetest\r\n"
+"Content-Length: 0\r\n"
+"Set-Cookie: subcookie2=data; path=/test_cookie_set_path\r\n"
+"\r\n";
+
+static const char okmsg_cookie[] =
+"HTTP/1.1 200 OK\r\n"
+"Date: Mon, 01 Dec 2008 13:44:34 GMT\r\n"
+"Server: winetest\r\n"
+"Content-Length: 0\r\n"
+"Set-Cookie: testcookie=testvalue\r\n"
+"\r\n";
+
 static const char notokmsg[] =
 "HTTP/1.1 400 Bad Request\r\n"
 "Server: winetest\r\n"
@@ -2620,7 +2636,7 @@ static DWORD CALLBACK server_thread(LPVOID param)
         }
         if (strstr(buffer, "/testC"))
         {
-            if (strstr(buffer, "Cookie: cookie=biscuit"))
+            if (strstr(buffer, "cookie=biscuit"))
                 send(c, okmsg, sizeof okmsg-1, 0);
             else
                 send(c, notokmsg, sizeof notokmsg-1, 0);
@@ -2821,6 +2837,51 @@ static DWORD CALLBACK server_thread(LPVOID param)
             else
                 send(c, noauthmsg, sizeof noauthmsg-1, 0);
         }
+        if (strstr(buffer, "/test_cookie_path1"))
+        {
+            if (strstr(buffer, "subcookie=data"))
+                 send(c, okmsg, sizeof okmsg-1, 0);
+             else
+                 send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_path2"))
+        {
+            if (strstr(buffer, "subcookie2=data"))
+                 send(c, okmsg, sizeof okmsg-1, 0);
+             else
+                 send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_set_path"))
+        {
+            send(c, okmsg_cookie_path, sizeof okmsg_cookie_path-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_merge"))
+        {
+            if (strstr(buffer, "subcookie=data") &&
+                !strstr(buffer, "manual_cookie=test"))
+                 send(c, okmsg, sizeof okmsg-1, 0);
+             else
+                 send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_set_host_override"))
+        {
+            send(c, okmsg_cookie, sizeof okmsg_cookie-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_check_host_override"))
+        {
+            if (strstr(buffer, "Cookie:") && strstr(buffer, "testcookie=testvalue"))
+                send(c, okmsg, sizeof okmsg-1, 0);
+            else
+                send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
+        if (strstr(buffer, "/test_cookie_check_different_host"))
+        {
+            if (!strstr(buffer, "foo") &&
+                strstr(buffer, "cookie=biscuit"))
+                send(c, okmsg, sizeof okmsg-1, 0);
+            else
+                send(c, notokmsg, sizeof notokmsg-1, 0);
+        }
         if (strstr(buffer, "/test_host_override"))
         {
             if (strstr(buffer, host_header_override))
@@ -2852,12 +2913,27 @@ static DWORD CALLBACK server_thread(LPVOID param)
         {
             send(c, okmsg, sizeof(okmsg)-1, 0);
         }
+
         if (strstr(buffer, "HEAD /test_large_content"))
         {
             char msg[sizeof(largemsg) + 16];
             sprintf(msg, largemsg, content_length);
             send(c, msg, strlen(msg), 0);
         }
+        if (strstr(buffer, "HEAD /test_auth_host1"))
+        {
+            if (strstr(buffer, "Authorization: Basic dGVzdDE6cGFzcw=="))
+                send(c, okmsg, sizeof okmsg-1, 0);
+            else
+                send(c, noauthmsg, sizeof noauthmsg-1, 0);
+        }
+        if (strstr(buffer, "HEAD /test_auth_host2"))
+        {
+            if (strstr(buffer, "Authorization: Basic dGVzdDE6cGFzczI="))
+                send(c, okmsg, sizeof okmsg-1, 0);
+            else
+                send(c, noauthmsg, sizeof noauthmsg-1, 0);
+        }
         shutdown(c, 2);
         closesocket(c);
         c = -1;
@@ -3553,6 +3629,152 @@ static void test_header_override(int port)
         test_status_code(req, 400);
     }
 
+    InternetCloseHandle(req);
+    InternetSetCookieA("http://localhost", "cookie", "biscuit");
+    req = HttpOpenRequestA(con, NULL, "/testC", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_set_host_override", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_check_host_override", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_check_host_override", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetSetCookieA("http://test.local", "foo", "bar");
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_check_different_host", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_check_different_host", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetCloseHandle(con);
+    InternetCloseHandle(ses);
+
+    ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(ses != NULL, "InternetOpenA failed\n");
+
+    con = InternetConnectA(ses, "localhost", port, "test1", "pass", INTERNET_SERVICE_HTTP, 0, 0);
+    ok(con != NULL, "InternetConnectA failed %lu\n", GetLastError());
+
+    req = HttpOpenRequestA( con, "HEAD", "/test_auth_host1", NULL, NULL, NULL, 0, 0);
+    ok(req != NULL, "HttpOpenRequestA failed %lu\n", GetLastError());
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequestA failed %lu\n", GetLastError());
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetCloseHandle(con);
+    InternetCloseHandle(ses);
+
+    ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(ses != NULL, "InternetOpenA failed\n");
+
+    con = InternetConnectA( ses, "localhost", port, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
+    ok(con != NULL, "InternetConnectA failed %lu\n", GetLastError());
+
+    req = HttpOpenRequestA(con, "HEAD", "/test_auth_host1", NULL, NULL, NULL, 0, 0);
+    ok(req != NULL, "HttpOpenRequestA failed %lu\n", GetLastError());
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA( req, NULL, 0, NULL, 0 );
+    ok( ret, "HttpSendRequestA failed %lu\n", GetLastError() );
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetCloseHandle(con);
+    InternetCloseHandle(ses);
+
+    ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(ses != NULL, "InternetOpenA failed\n");
+
+    con = InternetConnectA(ses, "localhost", port, "test1", "pass2", INTERNET_SERVICE_HTTP, 0, 0);
+    ok(con != NULL, "InternetConnectA failed %lu\n", GetLastError());
+
+    req = HttpOpenRequestA(con, "HEAD", "/test_auth_host2", NULL, NULL, NULL, 0, 0);
+    ok(req != NULL, "HttpOpenRequestA failed %lu\n", GetLastError());
+
+    ret = HttpAddRequestHeadersA(req, host_header_override, ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequestA failed %lu\n", GetLastError());
+
+    test_status_code(req, 200);
+
+    InternetCloseHandle(req);
+    InternetCloseHandle(con);
+    InternetCloseHandle(ses);
+
+    ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
+    ok(ses != NULL, "InternetOpenA failed\n");
+
+    con = InternetConnectA(ses, "localhost", port, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 0);
+    ok(con != NULL, "InternetConnectA failed %lu\n", GetLastError());
+
+    req = HttpOpenRequestA(con, "HEAD", "/test_auth_host2", NULL, NULL, NULL, 0, 0);
+    ok(req != NULL, "HttpOpenRequestA failed %lu\n", GetLastError());
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequestA failed %lu\n", GetLastError());
+
+    test_status_code(req, 200);
+
     InternetCloseHandle(req);
     InternetCloseHandle(con);
     InternetCloseHandle(ses);
@@ -4334,7 +4556,7 @@ static void test_cookie_header(int port)
     HINTERNET ses, con, req;
     DWORD size, error;
     BOOL ret;
-    char buffer[64];
+    char buffer[256];
 
     ses = InternetOpenA("winetest", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
     ok(ses != NULL, "InternetOpen failed\n");
@@ -4362,7 +4584,7 @@ static void test_cookie_header(int port)
     size = sizeof(buffer);
     ret = HttpQueryInfoA(req, HTTP_QUERY_COOKIE | HTTP_QUERY_FLAG_REQUEST_HEADERS, buffer, &size, NULL);
     ok(ret, "HttpQueryInfo failed: %lu\n", GetLastError());
-    ok(!strcmp(buffer, "cookie=not biscuit"), "got '%s' expected \'cookie=not biscuit\'\n", buffer);
+    ok(!!strstr(buffer, "cookie=not biscuit"), "got '%s' expected \'cookie=not biscuit\'\n", buffer);
 
     ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
     ok(ret, "HttpSendRequest failed: %lu\n", GetLastError());
@@ -4373,9 +4595,61 @@ static void test_cookie_header(int port)
     size = sizeof(buffer);
     ret = HttpQueryInfoA(req, HTTP_QUERY_COOKIE | HTTP_QUERY_FLAG_REQUEST_HEADERS, buffer, &size, NULL);
     ok(ret, "HttpQueryInfo failed: %lu\n", GetLastError());
-    ok(!strcmp(buffer, "cookie=biscuit"), "got '%s' expected \'cookie=biscuit\'\n", buffer);
+    ok(!strstr(buffer, "cookie=not biscuit"), "'%s' should not contain \'cookie=not biscuit\'\n", buffer);
+    ok(!!strstr(buffer, "cookie=biscuit"), "'%s' should contain \'cookie=biscuit\'\n", buffer);
+
+    InternetCloseHandle(req);
+
+    InternetSetCookieA("http://localhost/testCCCC", "subcookie", "data");
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_path1", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
 
+    test_status_code(req, 200);
     InternetCloseHandle(req);
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_path1/abc", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+    InternetCloseHandle(req);
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_set_path", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+    InternetCloseHandle(req);
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_path2", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 400);
+    InternetCloseHandle(req);
+
+    req = HttpOpenRequestA(con, NULL, "/test_cookie_merge", NULL, NULL, NULL, INTERNET_FLAG_KEEP_CONNECTION, 0);
+    ok(req != NULL, "HttpOpenRequest failed\n");
+
+    ret = HttpAddRequestHeadersA(req, "Cookie: manual_cookie=test\r\n", ~0u, HTTP_ADDREQ_FLAG_ADD);
+    ok(ret, "HttpAddRequestHeaders failed: %lu\n", GetLastError());
+
+    ret = HttpSendRequestA(req, NULL, 0, NULL, 0);
+    ok(ret, "HttpSendRequest failed\n");
+
+    test_status_code(req, 200);
+    InternetCloseHandle(req);
+
     InternetCloseHandle(con);
     InternetCloseHandle(ses);
 }
diff --git a/dlls/winmm/mci.c b/dlls/winmm/mci.c
index 959801a..c56a69d 100644
--- a/dlls/winmm/mci.c
+++ b/dlls/winmm/mci.c
@@ -204,7 +204,7 @@ static LPWSTR MCI_strdupAtoW( LPCSTR str )
     return ret;
 }
 
-static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
+static DWORD MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
 {
     if (msg < DRV_RESERVED) return 0;
 
@@ -247,8 +247,12 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             MCI_ANIM_OPEN_PARMSW *mci_openW;
             DWORD_PTR *ptr;
 
+            if ((dwParam1 & (MCI_OPEN_TYPE|MCI_OPEN_TYPE_ID)) == MCI_OPEN_TYPE &&
+                (GetVersion() & 0x80000000) && IsBadStringPtrA(mci_openA->lpstrDeviceType, -1))
+                return MCIERR_MISSING_COMMAND_STRING;
+
             ptr = malloc(sizeof(DWORD_PTR) + sizeof(*mci_openW));
-            if (!ptr) return -1;
+            if (!ptr) return MCIERR_OUT_OF_MEMORY;
 
             *ptr++ = *dwParam2; /* save the previous pointer */
             *dwParam2 = (DWORD_PTR)ptr;
@@ -278,7 +282,7 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             if (HIWORD(dwParam1))
                 memcpy(&mci_openW->dwStyle, &mci_openA->dwStyle, sizeof(MCI_ANIM_OPEN_PARMSW) - sizeof(MCI_OPEN_PARMSW));
         }
-        return 1;
+        return 0;
 
     case MCI_WINDOW:
         if (dwParam1 & MCI_ANIM_WINDOW_TEXT)
@@ -286,8 +290,8 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             MCI_ANIM_WINDOW_PARMSA *mci_windowA = (MCI_ANIM_WINDOW_PARMSA *)*dwParam2;
             MCI_ANIM_WINDOW_PARMSW *mci_windowW;
 
-            mci_windowW = malloc(sizeof(*mci_windowW));
-            if (!mci_windowW) return -1;
+            mci_windowW = malloc( sizeof(*mci_windowW));
+            if (!mci_windowW) return MCIERR_OUT_OF_MEMORY;
 
             *dwParam2 = (DWORD_PTR)mci_windowW;
 
@@ -299,8 +303,6 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
                 mci_windowW->hWnd = mci_windowA->hWnd;
             if (dwParam1 & MCI_ANIM_WINDOW_STATE)
                 mci_windowW->nCmdShow = mci_windowA->nCmdShow;
-
-            return 1;
         }
         return 0;
 
@@ -312,7 +314,7 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             DWORD_PTR *ptr;
 
             ptr = malloc(sizeof(*mci_sysinfoW) + sizeof(DWORD_PTR));
-            if (!ptr) return -1;
+            if (!ptr) return MCIERR_OUT_OF_MEMORY;
 
             *ptr++ = *dwParam2; /* save the previous pointer */
             *dwParam2 = (DWORD_PTR)ptr;
@@ -326,7 +328,6 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             mci_sysinfoW->lpstrReturn = malloc(mci_sysinfoW->dwRetSize * sizeof(WCHAR));
             mci_sysinfoW->dwNumber = mci_sysinfoA->dwNumber;
             mci_sysinfoW->wDeviceType = mci_sysinfoA->wDeviceType;
-            return 1;
         }
         return 0;
     case MCI_INFO:
@@ -336,7 +337,7 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             DWORD_PTR *ptr;
 
             ptr = malloc(sizeof(*mci_infoW) + sizeof(DWORD_PTR));
-            if (!ptr) return -1;
+            if (!ptr) return MCIERR_OUT_OF_MEMORY;
 
             *ptr++ = *dwParam2; /* save the previous pointer */
             *dwParam2 = (DWORD_PTR)ptr;
@@ -350,8 +351,8 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             mci_infoW->lpstrReturn = malloc(mci_infoW->dwRetSize * sizeof(WCHAR));
             if (dwParam1 & MCI_DGV_INFO_ITEM)
                 mci_infoW->dwItem = mci_infoA->dwItem;
-            return 1;
         }
+        return 0;
     case MCI_SAVE:
     case MCI_LOAD:
     case MCI_CAPTURE:
@@ -361,7 +362,7 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             MCI_OVLY_LOAD_PARMSW *mci_loadW;
 
             mci_loadW = malloc(sizeof(*mci_loadW));
-            if (!mci_loadW) return -1;
+            if (!mci_loadW) return MCIERR_OUT_OF_MEMORY;
 
             *dwParam2 = (DWORD_PTR)mci_loadW;
             if (dwParam1 & MCI_NOTIFY)
@@ -372,8 +373,8 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
                 (MCI_CAPTURE == msg && dwParam1 & MCI_DGV_CAPTURE_AT) ||
                 (MCI_RESTORE == msg && dwParam1 & MCI_DGV_RESTORE_AT))
                 mci_loadW->rc = mci_loadA->rc;
-            return 1;
         }
+        return 0;
     case MCI_SOUND:
     case MCI_ESCAPE:
         {   /* All these commands have the same layout: callback + string */
@@ -381,14 +382,14 @@ static int MCI_MapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR *dwParam2)
             MCI_VD_ESCAPE_PARMSW *mci_vd_escapeW;
 
             mci_vd_escapeW = malloc(sizeof(*mci_vd_escapeW));
-            if (!mci_vd_escapeW) return -1;
+            if (!mci_vd_escapeW) return MCIERR_OUT_OF_MEMORY;
 
             *dwParam2 = (DWORD_PTR)mci_vd_escapeW;
             if (dwParam1 & MCI_NOTIFY)
                 mci_vd_escapeW->dwCallback = mci_vd_escapeA->dwCallback;
             mci_vd_escapeW->lpstrCommand = MCI_strdupAtoW(mci_vd_escapeA->lpstrCommand);
-            return 1;
         }
+        return 0;
     case MCI_SETAUDIO:
     case MCI_SETVIDEO:
         if (!(dwParam1 & (MCI_DGV_SETVIDEO_QUALITY | MCI_DGV_SETVIDEO_ALG
@@ -501,7 +502,6 @@ static void MCI_UnmapMsgAtoW(UINT msg, DWORD_PTR dwParam1, DWORD_PTR dwParam2,
         break;
 
     default:
-        FIXME("Message %s needs unmapping\n", MCI_MessageToString(msg));
         break;
     }
 }
@@ -2282,20 +2282,18 @@ DWORD WINAPI mciSendCommandW(MCIDEVICEID wDevID, UINT wMsg, DWORD_PTR dwParam1,
 DWORD WINAPI mciSendCommandA(MCIDEVICEID wDevID, UINT wMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
 {
     DWORD ret;
-    int mapped;
 
     TRACE("(%08x, %s, %08Ix, %08Ix)\n",
 	  wDevID, MCI_MessageToString(wMsg), dwParam1, dwParam2);
 
-    mapped = MCI_MapMsgAtoW(wMsg, dwParam1, &dwParam2);
-    if (mapped == -1)
+    ret = MCI_MapMsgAtoW(wMsg, dwParam1, &dwParam2);
+    if (ret)
     {
         FIXME("message %04x mapping failed\n", wMsg);
-        return MCIERR_OUT_OF_MEMORY;
+        return ret;
     }
-    ret = mciSendCommandW(wDevID, wMsg, dwParam1, dwParam2);
-    if (mapped)
-        MCI_UnmapMsgAtoW(wMsg, dwParam1, dwParam2, ret);
+     ret = mciSendCommandW(wDevID, wMsg, dwParam1, dwParam2);
+    MCI_UnmapMsgAtoW(wMsg, dwParam1, dwParam2, ret);
     return ret;
 }
 
diff --git a/dlls/winspool.drv/info.c b/dlls/winspool.drv/info.c
index 4552180..48392c4 100644
--- a/dlls/winspool.drv/info.c
+++ b/dlls/winspool.drv/info.c
@@ -2774,10 +2774,13 @@ BOOL WINAPI ClosePrinter(HANDLE hPrinter)
     if(printer)
     {
         TRACE("closing %s\n", debugstr_w(printer->name));
+
         if (printer->backend_printer) {
+            TRACE("Closing Bankend printer\n");
             backend->fpClosePrinter(printer->backend_printer);
         }
 
+        TRACE("Freeing Printer entry\n");
         free_printer_entry( printer );
         printer_handles[i - 1] = NULL;
         LeaveCriticalSection(&printer_handles_cs);
diff --git a/dlls/wintab32/context.c b/dlls/wintab32/context.c
index b432e90..65e28ec 100644
--- a/dlls/wintab32/context.c
+++ b/dlls/wintab32/context.c
@@ -406,7 +406,7 @@ static UINT WTInfoT(UINT wCategory, UINT nIndex, LPVOID lpOutput, BOOL bUnicode)
             pWTInfoW(wCategory, nIndex, &buf);
 
             /*  Handle system extents here, as we can use user32.dll code to set them */
-            if(wCategory == WTI_DEFSYSCTX)
+            if(wCategory == WTI_DEFSYSCTX || wCategory == WTI_DDCTXS)
             {
                 buf.lcSysExtX = GetSystemMetrics(SM_CXSCREEN);
                 buf.lcSysExtY = GetSystemMetrics(SM_CYSCREEN);
diff --git a/dlls/wintrust/tests/softpub.c b/dlls/wintrust/tests/softpub.c
index 4686176..2cb5d7a 100644
--- a/dlls/wintrust/tests/softpub.c
+++ b/dlls/wintrust/tests/softpub.c
@@ -1892,6 +1892,14 @@ static void test_multiple_signatures(void)
     DeleteFileW(pathW);
 }
 
+static void test_WTHelperGetProvCertFromChain(void)
+{
+    CRYPT_PROVIDER_CERT *cert;
+
+    cert = WTHelperGetProvCertFromChain(NULL, 0);
+    ok(!cert, "got certificate\n");
+}
+
 START_TEST(softpub)
 {
     InitFunctionPtrs();
@@ -1900,5 +1908,6 @@ START_TEST(softpub)
     test_wintrust();
     test_wintrust_digest();
     test_get_known_usages();
+    test_WTHelperGetProvCertFromChain();
     test_multiple_signatures();
 }
diff --git a/dlls/wintrust/wintrust_main.c b/dlls/wintrust/wintrust_main.c
index a5c5706..8847115 100644
--- a/dlls/wintrust/wintrust_main.c
+++ b/dlls/wintrust/wintrust_main.c
@@ -765,7 +765,7 @@ CRYPT_PROVIDER_CERT * WINAPI WTHelperGetProvCertFromChain(
 
     TRACE("(%p %ld)\n", pSgnr, idxCert);
 
-    if (idxCert >= pSgnr->csCertChain || !pSgnr->pasCertChain)
+    if (!pSgnr || idxCert >= pSgnr->csCertChain || !pSgnr->pasCertChain)
         return NULL;
     cert = &pSgnr->pasCertChain[idxCert];
     TRACE("returning %p\n", cert);
diff --git a/dlls/wsdapi/msgparams.c b/dlls/wsdapi/msgparams.c
index a96c213..333c2de 100644
--- a/dlls/wsdapi/msgparams.c
+++ b/dlls/wsdapi/msgparams.c
@@ -48,7 +48,7 @@ static inline IWSDMessageParametersImpl *impl_from_IWSDMessageParameters(IWSDMes
 
 static inline IWSDUdpMessageParametersImpl *impl_from_IWSDUdpMessageParameters(IWSDUdpMessageParameters *iface)
 {
-    return CONTAINING_RECORD(iface, IWSDUdpMessageParametersImpl, base.IWSDMessageParameters_iface);
+    return CONTAINING_RECORD((IWSDMessageParameters *)iface, IWSDUdpMessageParametersImpl, base.IWSDMessageParameters_iface);
 }
 
 /* IWSDMessageParameters implementation */
diff --git a/dlls/x3daudio1_7/Makefile.in b/dlls/x3daudio1_7/Makefile.in
index fd22a26..810b513 100644
--- a/dlls/x3daudio1_7/Makefile.in
+++ b/dlls/x3daudio1_7/Makefile.in
@@ -1,5 +1,6 @@
 EXTRADEFS = -DX3DAUDIO1_VER=7 -DXAUDIO2_VER=7
 MODULE    = x3daudio1_7.dll
+IMPORTLIB = x3daudio1_7
 PARENTSRC = ../xaudio2_7
 IMPORTS   = $(FAUDIO_PE_LIBS)
 EXTRAINCL = $(FAUDIO_PE_CFLAGS)
diff --git a/dlls/xactengine3_7/tests/Makefile.in b/dlls/xactengine3_7/tests/Makefile.in
index 54046e8..a749ff9 100644
--- a/dlls/xactengine3_7/tests/Makefile.in
+++ b/dlls/xactengine3_7/tests/Makefile.in
@@ -1,5 +1,6 @@
 TESTDLL = xactengine3_7.dll
-IMPORTS = ole32
+IMPORTS = ole32 x3daudio1_7
 
 SOURCES = \
+	rsrc.rc \
 	xact3.c
diff --git a/dlls/xactengine3_7/tests/xact3.c b/dlls/xactengine3_7/tests/xact3.c
index 48a5f0a..d1e168d 100644
--- a/dlls/xactengine3_7/tests/xact3.c
+++ b/dlls/xactengine3_7/tests/xact3.c
@@ -287,11 +287,72 @@ static void test_notifications(void)
     DeleteFileW(filename);
 }
 
+static void test_global_properties(void)
+{
+    HRESULT hr;
+    IXACT3Engine *engine;
+    XACTVARIABLEINDEX index;
+    XACTVARIABLEVALUE value;
+    HRSRC res;
+    void *ptr;
+    XACT_RUNTIME_PARAMETERS xparams = {0};
+    WAVEFORMATEXTENSIBLE format;
+    X3DAUDIO_HANDLE instance = {0};
+
+    hr = CoCreateInstance(&CLSID_XACTEngine, NULL, CLSCTX_INPROC_SERVER, &IID_IXACT3Engine, (void**)&engine);
+
+    if (FAILED(hr))
+    {
+        win_skip("IXACT3Engine Unsupported.\n");
+        return;
+    }
+
+    index = IXACT3Engine_GetGlobalVariableIndex(engine, "SpeedOfSound");
+    ok(index == XACTVARIABLEINDEX_INVALID , "Found variable 0x%08x\n", index);
+
+    res = FindResourceW(NULL, L"globals.xgs", (LPCWSTR)RT_RCDATA);
+
+    ptr = LockResource(LoadResource(GetModuleHandleA(NULL), res));
+
+    xparams.lookAheadTime = 250;
+    xparams.globalSettingsBufferSize = SizeofResource( GetModuleHandleA(NULL), res);
+    xparams.pGlobalSettingsBuffer = ptr;
+    hr = IXACT3Engine_Initialize(engine, &xparams);
+    ok(hr == S_OK ||
+        hr == XAUDIO2_E_INVALID_CALL /* Vista */, "got 0x%08lx\n", hr);
+    if (FAILED(hr))
+        goto end;
+
+    index = IXACT3Engine_GetGlobalVariableIndex(engine, "SpeedOfSound");
+    ok(index != XACTVARIABLEINDEX_INVALID, "Failed to find variable %d\n", index);
+
+    value = 0.1f;
+    hr = IXACT3Engine_GetGlobalVariable(engine, index, &value);
+    ok(hr == S_OK, "got 0x%08lx\n", hr);
+    ok(value == 0.0f, "got %f\n", value);
+
+    hr = IXACT3Engine_GetFinalMixFormat(engine, &format);
+    ok(hr == S_OK, "got 0x%08lx\n", hr);
+
+    /* Invalid SpeedOfSound value  */
+    X3DAudioInitialize(format.dwChannelMask, value, instance);
+    ok(instance[0] != 0, "got 0x%08x\n", instance[0]);
+
+    hr = IXACT3Engine_GetGlobalVariable(engine, index, &value);
+    ok(hr == S_OK, "got 0x%08lx\n", hr);
+    ok(value == 0.0f, "got %f\n", value);
+
+end:
+    IXACT3Engine_Release(engine);
+
+}
+
 START_TEST(xact3)
 {
     CoInitialize(NULL);
 
     test_interfaces();
+    test_global_properties();
     test_notifications();
 
     CoUninitialize();
diff --git a/dlls/xactengine3_7/xact_dll.c b/dlls/xactengine3_7/xact_dll.c
index cf67331..fa349e6 100644
--- a/dlls/xactengine3_7/xact_dll.c
+++ b/dlls/xactengine3_7/xact_dll.c
@@ -329,9 +329,17 @@ static HRESULT WINAPI IXACT3CueImpl_SetOutputVoiceMatrix(IXACT3Cue *iface,
         UINT32 DestinationChannels, const float *pLevelMatrix)
 {
     XACT3CueImpl *This = impl_from_IXACT3Cue(iface);
-    FIXME("(%p)->(%p %u %u %p): stub!\n", This, pDestinationVoice, SourceChannels,
+    uint32_t ret;
+
+    TRACE("(%p)->(%p %u %u %p)\n", This, pDestinationVoice, SourceChannels,
             DestinationChannels, pLevelMatrix);
-    return S_OK;
+    if (pDestinationVoice)
+        WARN("pDestinationVoice currently not supported\n");
+
+    ret = FACTCue_SetOutputVoiceMatrix(This->fact_cue, NULL, SourceChannels,
+        DestinationChannels, pLevelMatrix);
+
+    return ret ? E_FAIL : S_OK;
 }
 #endif
 
@@ -413,6 +421,7 @@ static HRESULT WINAPI IXACT3SoundBankImpl_Prepare(IXACT3SoundBank *iface,
     XACT3SoundBankImpl *This = impl_from_IXACT3SoundBank(iface);
     XACT3CueImpl *cue;
     FACTCue *fcue;
+
     UINT ret;
     HRESULT hr;
 
@@ -1319,8 +1328,44 @@ static HRESULT WINAPI IXACT3EngineImpl_PrepareInMemoryWave(IXACT3Engine *iface,
         IXACT3Wave **ppWave)
 {
     XACT3EngineImpl *This = impl_from_IXACT3Engine(iface);
-    FIXME("(%p): stub!\n", This);
-    return E_NOTIMPL;
+    XACT3WaveImpl *wave;
+    FACTWave *fwave = NULL;
+    FACTWaveBankEntry fact_wavebank;
+    UINT ret;
+
+    TRACE("(%p)->(0x%08lx, %p, %p, %p, %ld, %d, %p)\n", This, dwFlags, &entry, pdwSeekTable,
+          pbWaveData, dwPlayOffset, nLoopCount, ppWave);
+
+    fact_wavebank.dwFlagsAndDuration = entry.dwFlagsAndDuration;
+    fact_wavebank.Format.dwValue = entry.Format.dwValue;
+    fact_wavebank.PlayRegion.dwOffset = entry.PlayRegion.dwOffset;
+    fact_wavebank.PlayRegion.dwLength = entry.PlayRegion.dwLength;
+    fact_wavebank.LoopRegion.dwStartSample = entry.LoopRegion.dwStartSample;
+    fact_wavebank.LoopRegion.dwTotalSamples = entry.LoopRegion.dwTotalSamples;
+
+    ret = FACTAudioEngine_PrepareInMemoryWave(This->fact_engine, dwFlags, fact_wavebank,
+            (uint32_t *)pdwSeekTable, pbWaveData, dwPlayOffset, nLoopCount, &fwave);
+    if(ret != 0 || !fwave)
+    {
+        ERR("Failed to CreateWave: %d (%p)\n", ret, fwave);
+        return E_FAIL;
+    }
+
+    wave = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*wave));
+    if (!wave)
+    {
+        FACTWave_Destroy(fwave);
+        ERR("Failed to allocate XACT3WaveImpl!");
+        return E_OUTOFMEMORY;
+    }
+
+    wave->IXACT3Wave_iface.lpVtbl = &XACT3Wave_Vtbl;
+    wave->fact_wave = fwave;
+    *ppWave = &wave->IXACT3Wave_iface;
+
+    TRACE("Created Wave: %p\n", wave);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI IXACT3EngineImpl_PrepareStreamingWave(IXACT3Engine *iface,
@@ -1330,8 +1375,59 @@ static HRESULT WINAPI IXACT3EngineImpl_PrepareStreamingWave(IXACT3Engine *iface,
         IXACT3Wave **ppWave)
 {
     XACT3EngineImpl *This = impl_from_IXACT3Engine(iface);
-    FIXME("(%p): stub!\n", This);
-    return E_NOTIMPL;
+    XACT3WaveImpl *wave;
+    FACTWave *fwave = NULL;
+    FACTStreamingParameters fakeParms;
+    wrap_readfile_struct *fake;
+    FACTWaveBankEntry fact_wavebank;
+    UINT ret;
+
+    TRACE("(%p)->(0x%08lx, %p, %p, %ld, %p, %ld, %d, %p)\n", This, dwFlags, &entry, &streamingParams,
+            dwAlignment, pdwSeekTable, dwPlayOffset, nLoopCount, ppWave);
+
+    fake = (wrap_readfile_struct*) CoTaskMemAlloc(
+            sizeof(wrap_readfile_struct));
+    fake->engine = This;
+    fake->file = streamingParams.file;
+    fakeParms.file = fake;
+    fakeParms.flags = streamingParams.flags;
+    fakeParms.offset = streamingParams.offset;
+    fakeParms.packetSize = streamingParams.packetSize;
+
+    fact_wavebank.dwFlagsAndDuration = entry.dwFlagsAndDuration;
+    fact_wavebank.Format.dwValue = entry.Format.dwValue;
+    fact_wavebank.PlayRegion.dwOffset = entry.PlayRegion.dwOffset;
+    fact_wavebank.PlayRegion.dwLength = entry.PlayRegion.dwLength;
+    fact_wavebank.LoopRegion.dwStartSample = entry.LoopRegion.dwStartSample;
+    fact_wavebank.LoopRegion.dwTotalSamples = entry.LoopRegion.dwTotalSamples;
+
+    /* FAudio Prototype is incorrect and shouldn't take a buffer as an parameter,
+     *   passing through NULL to ensure it's not used.
+     */
+    ret = FACTAudioEngine_PrepareStreamingWave(This->fact_engine, dwFlags, fact_wavebank, fakeParms,
+            dwAlignment, (uint32_t *)pdwSeekTable, NULL, dwPlayOffset, nLoopCount, &fwave);
+
+    if(ret != 0 || !fwave)
+    {
+        ERR("Failed to CreateWave: %d (%p)\n", ret, fwave);
+        return E_FAIL;
+    }
+
+    wave = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*wave));
+    if (!wave)
+    {
+        FACTWave_Destroy(fwave);
+        ERR("Failed to allocate XACT3WaveImpl!");
+        return E_OUTOFMEMORY;
+    }
+
+    wave->IXACT3Wave_iface.lpVtbl = &XACT3Wave_Vtbl;
+    wave->fact_wave = fwave;
+    *ppWave = &wave->IXACT3Wave_iface;
+
+    TRACE("Created Wave: %p\n", wave);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI IXACT3EngineImpl_PrepareWave(IXACT3Engine *iface,
diff --git a/fonts/Makefile.in b/fonts/Makefile.in
index a582d7b..4a3860d 100644
--- a/fonts/Makefile.in
+++ b/fonts/Makefile.in
@@ -1,14 +1,18 @@
 SOURCES = \
+	arial.sfd \
+	cour.sfd \
 	courier.sfd \
 	fixedsys.sfd \
 	fixedsys_jp.sfd \
 	marlett.sfd \
 	ms_sans_serif.sfd \
+	msyh.sfd \
 	small_fonts.sfd \
 	small_fonts_jp.sfd \
 	symbol.sfd \
 	system.sfd \
 	tahoma.sfd \
 	tahomabd.sfd \
+	times.sfd \
 	webdings.sfd \
 	wingding.sfd
diff --git a/include/Makefile.in b/include/Makefile.in
index f70aeb9..1b86b84 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -583,6 +583,7 @@ SOURCES = \
 	ntdef.h \
 	ntdsapi.h \
 	ntgdi.h \
+	ntifs.h \
 	ntioring_x.h \
 	ntlsa.h \
 	ntquery.h \
@@ -728,6 +729,7 @@ SOURCES = \
 	srrestoreptapi.h \
 	sspi.h \
 	stamp-h.in \
+	stdole32.idl \
 	stgprop.h \
 	sti.h \
 	storage.h \
diff --git a/include/commctrl.h b/include/commctrl.h
index a54de13..e0b0e22 100644
--- a/include/commctrl.h
+++ b/include/commctrl.h
@@ -59,7 +59,7 @@ enum _LI_METRIC
 WINCOMMCTRLAPI HRESULT WINAPI LoadIconWithScaleDown(HINSTANCE, const WCHAR *, int, int, HICON *);
 WINCOMMCTRLAPI HRESULT WINAPI LoadIconMetric(HINSTANCE, const WCHAR *, int, HICON *);
 
-#define COMCTL32_VERSION                5  /* dll version */
+#define COMCTL32_VERSION                6  /* dll version */
 
 #define ICC_LISTVIEW_CLASSES   0x00000001  /* listview, header */
 #define ICC_TREEVIEW_CLASSES   0x00000002  /* treeview, tooltips */
diff --git a/include/config.h.in b/include/config.h.in
index cda76fc..90ac182 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -309,6 +309,9 @@
 /* Define to 1 if you have the `posix_fallocate' function. */
 #undef HAVE_POSIX_FALLOCATE
 
+/* Define to 1 if you have the `ppoll' function. */
+#undef HAVE_PPOLL
+
 /* Define to 1 if you have the `prctl' function. */
 #undef HAVE_PRCTL
 
@@ -369,6 +372,9 @@
 /* Define to 1 if `interface_id' is a member of `sg_io_hdr_t'. */
 #undef HAVE_SG_IO_HDR_T_INTERFACE_ID
 
+/* Define to 1 if you have the `shm_open' function. */
+#undef HAVE_SHM_OPEN
+
 /* Define to 1 if `si_fd' is a member of `siginfo_t'. */
 #undef HAVE_SIGINFO_T_SI_FD
 
@@ -504,6 +510,9 @@
 /* Define to 1 if you have the <sys/epoll.h> header file. */
 #undef HAVE_SYS_EPOLL_H
 
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#undef HAVE_SYS_EVENTFD_H
+
 /* Define to 1 if you have the <sys/event.h> header file. */
 #undef HAVE_SYS_EVENT_H
 
@@ -756,9 +765,6 @@
 /* Define to the soname of the libnetapi library. */
 #undef SONAME_LIBNETAPI
 
-/* Define to the soname of the libodbc library. */
-#undef SONAME_LIBODBC
-
 /* Define to the soname of the libOSMesa library. */
 #undef SONAME_LIBOSMESA
 
diff --git a/include/ddk/fltkernel.h b/include/ddk/fltkernel.h
index 49c9d55..e5483d5 100644
--- a/include/ddk/fltkernel.h
+++ b/include/ddk/fltkernel.h
@@ -653,7 +653,8 @@ typedef struct _FLT_REGISTRATION
     PFLT_SECTION_CONFLICT_NOTIFICATION_CALLBACK SectionNotificationCallback;
 } FLT_REGISTRATION, *PFLT_REGISTRATION;
 
-
+NTSTATUS WINAPI FltBuildDefaultSecurityDescriptor(PSECURITY_DESCRIPTOR *, ACCESS_MASK);
+void     WINAPI FltFreeSecurityDescriptor(PSECURITY_DESCRIPTOR);
 void*    WINAPI FltGetRoutineAddress(LPCSTR name);
 NTSTATUS WINAPI FltRegisterFilter(PDRIVER_OBJECT, const FLT_REGISTRATION *, PFLT_FILTER *);
 NTSTATUS WINAPI FltStartFiltering(PFLT_FILTER);
diff --git a/include/inseng.idl b/include/inseng.idl
index 8a3f4c4..8292741 100644
--- a/include/inseng.idl
+++ b/include/inseng.idl
@@ -1,5 +1,6 @@
 /*
  * Copyright 2015 Jacek Caban for CodeWeavers
+ * Copyright 2016 Michael MÃ¼ller
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -26,15 +27,231 @@ cpp_quote("#endif")
 
 interface IStream;
 
-/* FIXME: Add full declarations. */
-interface ICifComponent;
-interface IEnumCifComponents;
-interface ICifGroup;
-interface IEnumCifGroups;
-interface ICifMode;
-interface IEnumCifModes;
+cpp_quote("#define MAX_ID_LENGTH            48")
+cpp_quote("#define MAX_DISPLAYNAME_LENGTH   128")
 
-typedef struct {
+cpp_quote("#define URLF_DEFAULT                 0x0")
+cpp_quote("#define URLF_EXTRACT                 0x1")
+cpp_quote("#define URLF_RELATIVEURL             0x2")
+cpp_quote("#define URLF_DELETE_AFTER_EXTRACT    0x4")
+
+cpp_quote("#define ENGINESTATUS_NOTREADY    0x0")
+cpp_quote("#define ENGINESTATUS_LOADING     0x1")
+cpp_quote("#define ENGINESTATUS_INSTALLING  0x2")
+cpp_quote("#define ENGINESTATUS_READY       0x3")
+
+cpp_quote("#define SETACTION_NONE       0x0")
+cpp_quote("#define SETACTION_INSTALL    0x1")
+
+cpp_quote("#define INSTALLOPTIONS_NOCACHE               0x01")
+cpp_quote("#define INSTALLOPTIONS_DOWNLOAD              0x02")
+cpp_quote("#define INSTALLOPTIONS_INSTALL               0x04")
+cpp_quote("#define INSTALLOPTIONS_DONTALLOWXPLATFORM    0x08")
+cpp_quote("#define INSTALLOPTIONS_FORCEDEPENDENCIES     0x10")
+
+cpp_quote("#define EXECUTEJOB_SILENT                0x01")
+cpp_quote("#define EXECUTEJOB_DELETE_JOB            0x02")
+cpp_quote("#define EXECUTEJOB_VERIFYFILES           0x08")
+cpp_quote("#define EXECUTEJOB_IGNORETRUST           0x10")
+cpp_quote("#define EXECUTEJOB_IGNOREDOWNLOADERROR   0x20")
+cpp_quote("#define EXECUTEJOB_DONTALLOWCANCEL       0x40")
+
+cpp_quote("#define ENGINEPROBLEM_DOWNLOADFAIL   0x1")
+
+cpp_quote("#define PLATFORM_WIN95       0x01")
+cpp_quote("#define PLATFORM_WIN98       0x02")
+cpp_quote("#define PLATFORM_NT4         0x04")
+cpp_quote("#define PLATFORM_NT5         0x08")
+cpp_quote("#define PLATFORM_NT4ALPHA    0x10")
+cpp_quote("#define PLATFORM_NT5ALPHA    0x20")
+cpp_quote("#define PLATFORM_MILLEN      0x40")
+cpp_quote("#define PLATFORM_ALL         (PLATFORM_WIN95 | PLATFORM_WIN98 | PLATFORM_NT4 | PLATFORM_NT5 | PLATFORM_NT4ALPHA | PLATFORM_NT5ALPHA | PLATFORM_MILLEN)")
+
+enum InstallStatus
+{
+    INSTALLSTATUS_INITIALIZING,
+    INSTALLSTATUS_DEPENDENCY,
+    INSTALLSTATUS_DOWNLOADING,
+    INSTALLSTATUS_COPYING,
+    INSTALLSTATUS_RETRYING,
+    INSTALLSTATUS_CHECKINGTRUST,
+    INSTALLSTATUS_EXTRACTING,
+    INSTALLSTATUS_RUNNING,
+    INSTALLSTATUS_FINISHED,
+    INSTALLSTATUS_DOWNLOADFINISHED,
+};
+
+enum ComponentAction
+{
+    ActionNone,
+    ActionInstall,
+    ActionUninstall,
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifComponent
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetGUID(char *guid, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    HRESULT GetDetails(char *details, DWORD size);
+    HRESULT GetUrl(UINT index, char *url, DWORD size, DWORD *flags);
+    HRESULT GetFileExtractList(UINT index, char *extract, DWORD size);
+    HRESULT GetUrlCheckRange(UINT index, DWORD *min, DWORD *max);
+    HRESULT GetCommand(UINT index, char *cmd, DWORD cmd_size, char *switches, DWORD switch_size, DWORD *type);
+    HRESULT GetVersion(DWORD *version, DWORD *build);
+    HRESULT GetLocale(char *pszLocale, DWORD size);
+    HRESULT GetUninstallKey(char *key, DWORD size);
+    HRESULT GetInstalledSize(DWORD *win, DWORD *app);
+    DWORD GetDownloadSize();
+    DWORD GetExtractSize();
+    HRESULT GetSuccessKey(char *key, DWORD size);
+    HRESULT GetProgressKeys(char *progress, DWORD progress_size, char *cancel, DWORD cancel_size);
+    HRESULT IsActiveSetupAware();
+    HRESULT IsRebootRequired();
+    HRESULT RequiresAdminRights();
+    DWORD GetPriority();
+    HRESULT GetDependency(UINT index, char *id, DWORD buf, char *type, DWORD *ver, DWORD *build);
+    DWORD GetPlatform();
+    HRESULT GetMode(UINT index, char *mode, DWORD size);
+    HRESULT GetGroup(char *id, DWORD size);
+    HRESULT IsUIVisible();
+    HRESULT GetPatchID(char *id, DWORD size);
+    HRESULT GetDetVersion(char *dll, DWORD dll_size, char *entry, DWORD entry_size);
+    HRESULT GetTreatAsOneComponents(UINT index, char *id, DWORD buf);
+    HRESULT GetCustomData(char *key, char *data, DWORD size);
+    DWORD IsComponentInstalled();
+    HRESULT IsComponentDownloaded();
+    DWORD IsThisVersionInstalled(DWORD version, DWORD build, DWORD *ret_version, DWORD *ret_build);
+    DWORD GetInstallQueueState();
+    HRESULT SetInstallQueueState(DWORD state);
+    DWORD GetActualDownloadSize();
+    DWORD GetCurrentPriority();
+    HRESULT SetCurrentPriority(DWORD priority);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWComponent : ICifComponent
+{
+    HRESULT SetGUID(const char *guid);
+    HRESULT SetDescription(const char *desc);
+    HRESULT SetUrl(UINT index, const char *url, DWORD url_flags);
+    HRESULT SetCommand(UINT index, const char *cmd, const char *switches, DWORD type);
+    HRESULT SetVersion(const char *version);
+    HRESULT SetUninstallKey(const char *key);
+    HRESULT SetInstalledSize(DWORD win, DWORD app);
+    HRESULT SetDownloadSize(DWORD size);
+    HRESULT SetExtractSize(DWORD size);
+    HRESULT DeleteDependency(const char *id, char type);
+    HRESULT AddDependency(const char *id, char type);
+    HRESULT SetUIVisible(BOOL visible);
+    HRESULT SetGroup(const char *id);
+    HRESULT SetPlatform(DWORD platform);
+    HRESULT SetPriority(DWORD priority);
+    HRESULT SetReboot(BOOL reboot);
+    HRESULT DeleteFromModes(const char *mode);
+    HRESULT AddToMode(const char *mode);
+    HRESULT SetModes(const char *mode);
+    HRESULT CopyComponent(const char *ciffile);
+    HRESULT AddToTreatAsOne(const char *compid);
+    HRESULT SetDetails(const char *desc);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifComponents : IUnknown
+{
+    HRESULT Next(ICifComponent **);
+    HRESULT Reset();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifGroup
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    DWORD GetPriority();
+
+    HRESULT EnumComponents(IEnumCifComponents **, DWORD filter, void *pv);
+    DWORD GetCurrentPriority();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWGroup : ICifGroup
+{
+   HRESULT SetDescription(const char *desc);
+   HRESULT SetPriority(DWORD priority);
+   HRESULT SetDetails(const char *details);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifGroups : IUnknown
+{
+    HRESULT Next(ICifGroup **);
+    HRESULT Reset();
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifMode
+{
+    HRESULT GetID(char *id, DWORD size);
+    HRESULT GetDescription(char *desc, DWORD size);
+    HRESULT GetDetails(char *details, DWORD size);
+
+    HRESULT EnumComponents(IEnumCifComponents **, DWORD filter, void *pv);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWMode : ICifMode
+{
+    HRESULT SetDescription(const char *desc);
+    HRESULT SetDetails(const char *details);
+};
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface IEnumCifModes : IUnknown
+{
+    HRESULT Next(ICifMode **);
+    HRESULT Reset();
+};
+
+typedef struct
+{
     DWORD cbSize;
     DWORD dwInstallSize;
     DWORD dwWinDriveSize;
@@ -49,6 +266,15 @@ typedef struct {
     DWORD dwTotalDownloadSize;
 } COMPONENT_SIZES;
 
+typedef struct
+{
+    DWORD cbSize;
+    DWORD dwDownloadKBRemaining;
+    DWORD dwInstallKBRemaining;
+    DWORD dwDownloadSecsRemaining;
+    DWORD dwInstallSecsRemaining;
+} INSTALLPROGRESS;
+
 [
     uuid(6e449688-c509-11cf-aafa-00aa00b6015c),
     local
@@ -62,7 +288,24 @@ interface ICifFile : IUnknown
     HRESULT EnumModes(IEnumCifModes **cuf_modes, DWORD filter, void *pv);
     HRESULT FindMode(const char *id, ICifMode **p);
     HRESULT GetDescription(char *desc, DWORD size);
-    HRESULT GetDetDlls(char **dlls, DWORD size);
+    HRESULT GetDetDlls(char *dlls, DWORD size);
+}
+
+[
+    object,
+    local,
+    pointer_default(unique)
+]
+interface ICifRWFile : ICifFile
+{
+    HRESULT SetDescription(const char *desc);
+    HRESULT CreateComponent(const char *id, ICifRWComponent **p);
+    HRESULT CreateGroup(const char *id, ICifRWGroup **p);
+    HRESULT CreateMode(const char *id, ICifRWMode **p);
+    HRESULT DeleteComponent(const char *id);
+    HRESULT DeleteGroup(const char *id);
+    HRESULT DeleteMode(const char *id);
+    HRESULT Flush();
 }
 
 [
@@ -78,7 +321,7 @@ interface IInstallEngineCallback : IUnknown
            const char *msg_string, ULONG progress, ULONG max);
    HRESULT OnStopComponent(const char *id, HRESULT error, DWORD phrase, const char *string, DWORD status);
    HRESULT OnStopInstall(HRESULT error, const char *error_string, DWORD status);
-   HRESULT OnEngineProblem(DWORD problem, LPDWORD action);
+   HRESULT OnEngineProblem(DWORD problem, DWORD *action);
 }
 
 [
@@ -121,6 +364,16 @@ interface IInstallEngine2 : IInstallEngine
     HRESULT GetICifFile(ICifFile **cif_file);
 }
 
+[
+    uuid(6e449687-c509-11cf-aafa-00aa00b6015c),
+    local
+]
+interface IInstallEngineTiming : IUnknown
+{
+    HRESULT GetRates(DWORD *download, DWORD *install);
+    HRESULT GetInstallProgress(INSTALLPROGRESS *progress);
+}
+
 [
     helpstring("Microsoft Active Setup Engine"),
     threading(apartment),
@@ -134,3 +387,6 @@ coclass InstallEngine { }
     uuid(bfc880f1-7484-11d0-8309-00aa00b6015c)
 ]
 coclass DownloadSiteMgr { }
+
+cpp_quote("HRESULT WINAPI GetICifFileFromFile(ICifFile **, const char *);")
+cpp_quote("HRESULT WINAPI GetICifRWFileFromFile(ICifRWFile **, const char *);")
diff --git a/include/msxml2.idl b/include/msxml2.idl
index ede4113..85bb6a5 100644
--- a/include/msxml2.idl
+++ b/include/msxml2.idl
@@ -1612,15 +1612,6 @@ coclass FreeThreadedDOMDocument40
     [default, source] dispinterface XMLDOMDocumentEvents;
 }
 
-[
-    uuid(88d96a06-f192-11d4-a65f-0040963251e5),
-]
-coclass FreeThreadedDOMDocument60
-{
-    [default] interface IXMLDOMDocument3;
-    [default, source] dispinterface XMLDOMDocumentEvents;
-}
-
 [
     helpstring("Free threaded XML DOM Document"),
     progid("Msxml2.FreeThreadedDOMDocument"),
@@ -1662,14 +1653,6 @@ coclass XMLHTTP40
     [default] interface IXMLHTTPRequest;
 }
 
-[
-    uuid(88d96a0a-f192-11d4-a65f-0040963251e5)
-]
-coclass XMLHTTP60
-{
-    [default] interface IXMLHTTPRequest;
-}
-
 [
     helpstring("XML HTTP"),
     progid("Msxml2.XMLHTTP"),
@@ -1702,14 +1685,6 @@ coclass ServerXMLHTTP40
     [default] interface IServerXMLHTTPRequest2;
 }
 
-[
-    uuid(88d96a0b-f192-11d4-a65f-0040963251e5)
-]
-coclass ServerXMLHTTP60
-{
-    [default] interface IServerXMLHTTPRequest2;
-}
-
 [
     helpstring("Server XML HTTP"),
     progid("Msxml2.ServerXMLHTTP"),
@@ -1750,14 +1725,6 @@ coclass XMLSchemaCache40
     [default] interface IXMLDOMSchemaCollection2;
 }
 
-[
-    uuid(88d96a07-f192-11d4-a65f-0040963251e5)
-]
-coclass XMLSchemaCache60
-{
-    [default] interface IXMLDOMSchemaCollection2;
-}
-
 [
     helpstring("XML Schema Cache"),
     progid("Msxml2.XMLSchemaCache"),
@@ -1798,14 +1765,6 @@ coclass XSLTemplate40
     [default] interface IXSLTemplate;
 }
 
-[
-    uuid(88d96a08-f192-11d4-a65f-0040963251e5)
-]
-coclass XSLTemplate60
-{
-    [default] interface IXSLTemplate;
-}
-
 [
     helpstring("XSL Template"),
     progid("Msxml2.XSLTemplate"),
@@ -3297,15 +3256,6 @@ coclass SAXXMLReader40
     interface ISAXXMLReader;
 }
 
-[
-    uuid(88d96a0c-f192-11d4-a65f-0040963251e5)
-]
-coclass SAXXMLReader60
-{
-    [default] interface IVBSAXXMLReader;
-    interface ISAXXMLReader;
-}
-
 [
     helpstring("SAX XML Reader"),
     progid("Msxml2.SAXXMLReader"),
@@ -3380,26 +3330,6 @@ coclass MXHTMLWriter40
     interface IVBSAXLexicalHandler;
 }
 
-[
-    uuid(88d96a10-f192-11d4-a65f-0040963251e5)
-]
-coclass MXHTMLWriter60
-{
-    [default] interface IMXWriter;
-
-    interface ISAXContentHandler;
-    interface ISAXDeclHandler;
-    interface ISAXDTDHandler;
-    interface ISAXErrorHandler;
-    interface ISAXLexicalHandler;
-
-    interface IVBSAXContentHandler;
-    interface IVBSAXDeclHandler;
-    interface IVBSAXDTDHandler;
-    interface IVBSAXErrorHandler;
-    interface IVBSAXLexicalHandler;
-}
-
 [
     helpstring("MXXMLWriter 3.0"),
     progid("Msxml2.MXXMLWriter.3.0"),
@@ -3444,26 +3374,6 @@ coclass MXXMLWriter40
     interface IVBSAXLexicalHandler;
 }
 
-[
-    uuid(88d96a0f-f192-11d4-a65f-0040963251e5)
-]
-coclass MXXMLWriter60
-{
-    [default] interface IMXWriter;
-
-    interface ISAXContentHandler;
-    interface ISAXDeclHandler;
-    interface ISAXDTDHandler;
-    interface ISAXErrorHandler;
-    interface ISAXLexicalHandler;
-
-    interface IVBSAXContentHandler;
-    interface IVBSAXDeclHandler;
-    interface IVBSAXDTDHandler;
-    interface IVBSAXErrorHandler;
-    interface IVBSAXLexicalHandler;
-}
-
 [
     helpstring("MXXMLWriter"),
     progid("Msxml2.MXXMLWriter"),
@@ -3506,15 +3416,6 @@ coclass MXNamespaceManager40
     interface IMXNamespaceManager;
 }
 
-[
-    uuid(88d96a11-f192-11d4-a65f-0040963251e5)
-]
-coclass MXNamespaceManager60
-{
-    [default] interface IVBMXNamespaceManager;
-    interface IMXNamespaceManager;
-}
-
 [
     helpstring("SAXAttributes 3.0"),
     progid("Msxml2.SAXAttributes.3.0"),
@@ -3539,16 +3440,6 @@ coclass SAXAttributes40
     interface ISAXAttributes;
 }
 
-[
-    uuid(88d96a0e-f192-11d4-a65f-0040963251e5)
-]
-coclass SAXAttributes60
-{
-    [default] interface IMXAttributes;
-    interface IVBSAXAttributes;
-    interface ISAXAttributes;
-}
-
 [
     helpstring("SAXAttributes"),
     progid("Msxml2.SAXAttributes"),
diff --git a/include/msxml6.idl b/include/msxml6.idl
index d4a5c49..b2d8bd3 100644
--- a/include/msxml6.idl
+++ b/include/msxml6.idl
@@ -1715,17 +1715,6 @@ interface ISAXDeclHandler : IUnknown
         [in] int nSystemId);
 }
 
-[
-    helpstring("Free Threaded XML HTTP Request class 6.0"),
-    progid("Msxml2.FreeThreadedXMLHTTP60.6.0"),
-    threading(both),
-    uuid(88d96a09-f192-11d4-a65f-0040963251e5)
-]
-coclass FreeThreadedXMLHTTP60
-{
-    [default] interface IXMLHTTPRequest2;
-}
-
 [
     object,
     local,
@@ -3054,24 +3043,23 @@ interface ISchemaNotation;
 } __msxml6_ReferenceRemainingTypes__;
 
 [
-    helpstring("XML DOM Document 6.0"),
-    progid("Msxml2.DOMDocument.6.0"),
+    helpstring("Free Threaded XML HTTP Request class 6.0"),
+    progid("Msxml2.FreeThreadedXMLHTTP60.6.0"),
     threading(both),
-    uuid(88d96a05-f192-11d4-a65f-0040963251e5)
+    uuid(88d96a09-f192-11d4-a65f-0040963251e5)
 ]
-coclass DOMDocument60
+coclass FreeThreadedXMLHTTP60
 {
-    [default] interface IXMLDOMDocument3;
-    [default, source] dispinterface XMLDOMDocumentEvents;
+    [default] interface IXMLHTTPRequest2;
 }
 
 [
-    helpstring("Free threaded XML DOM Document 6.0"),
-    progid("Msxml2.FreeThreadedDOMDocument.6.0"),
+    helpstring("XML DOM Document 6.0"),
+    progid("Msxml2.DOMDocument.6.0"),
     threading(both),
-    uuid(88d96a06-f192-11d4-a65f-0040963251e5),
+    uuid(88d96a05-f192-11d4-a65f-0040963251e5)
 ]
-coclass FreeThreadedDOMDocument60
+coclass DOMDocument60
 {
     [default] interface IXMLDOMDocument3;
     [default, source] dispinterface XMLDOMDocumentEvents;
@@ -3182,6 +3170,18 @@ coclass XSLTemplate60
     [default] interface IXSLTemplate;
 }
 
+[
+    helpstring("Free threaded XML DOM Document 6.0"),
+    progid("Msxml2.FreeThreadedDOMDocument.6.0"),
+    threading(both),
+    uuid(88d96a06-f192-11d4-a65f-0040963251e5),
+]
+coclass FreeThreadedDOMDocument60
+{
+    [default] interface IXMLDOMDocument3;
+    [default, source] dispinterface XMLDOMDocumentEvents;
+}
+
 [
     helpstring("XML HTTP 6.0"),
     progid("Msxml2.XMLHTTP.6.0"),
diff --git a/include/setupapi.h b/include/setupapi.h
index 831efdd..031bd97 100644
--- a/include/setupapi.h
+++ b/include/setupapi.h
@@ -1426,6 +1426,18 @@ typedef enum {
 WINSETUPAPI void     WINAPI InstallHinfSectionA( HWND hwnd, HINSTANCE handle, PCSTR cmdline, INT show );
 WINSETUPAPI void     WINAPI InstallHinfSectionW( HWND hwnd, HINSTANCE handle, PCWSTR cmdline, INT show );
 #define                     InstallHinfSection WINELIB_NAME_AW(InstallHinfSection)
+WINSETUPAPI BOOL     WINAPI IsUserAdmin(VOID);
+WINSETUPAPI PWSTR    WINAPI MultiByteToUnicode(PCSTR lpMultiByteStr, UINT uCodePage);
+WINSETUPAPI VOID     WINAPI MyFree(PVOID lpMem);
+WINSETUPAPI PVOID    WINAPI MyMalloc(DWORD dwSize);
+WINSETUPAPI PVOID    WINAPI MyRealloc(PVOID lpSrc, DWORD dwSize);
+WINSETUPAPI DWORD    WINAPI OpenAndMapForRead(PCWSTR, PDWORD, PHANDLE, PHANDLE, PVOID *);
+WINSETUPAPI LONG     WINAPI QueryRegistryValue(HKEY, PCWSTR, PBYTE *, PDWORD, PDWORD);
+/* RetreiveFileSecurity is not a typo, as per Microsoft's dlls */
+WINSETUPAPI DWORD    WINAPI RetreiveFileSecurity(PCWSTR, PSECURITY_DESCRIPTOR *);
+WINSETUPAPI BOOL     WINAPI SetupAddInstallSectionToDiskSpaceListA(HDSKSPC, HINF, HINF, PCSTR, PVOID, UINT);
+WINSETUPAPI BOOL     WINAPI SetupAddInstallSectionToDiskSpaceListW(HDSKSPC, HINF, HINF, PCWSTR, PVOID, UINT);
+#define         SetupAddInstallSectionToDiskSpaceList WINELIB_NAME_AW(SetupAddInstallSectionToDiskSpaceList)
 WINSETUPAPI BOOL     WINAPI SetupAddSectionToDiskSpaceListA(HDSKSPC, HINF, HINF, PCSTR, UINT, PVOID, UINT);
 WINSETUPAPI BOOL     WINAPI SetupAddSectionToDiskSpaceListW(HDSKSPC, HINF, HINF, PCWSTR, UINT, PVOID, UINT);
 #define                     SetupAddSectionToDiskSpaceList WINELIB_NAME_AW(SetupAddSectionToDiskSpaceList)
diff --git a/include/windows.networking.connectivity.idl b/include/windows.networking.connectivity.idl
index 8c6489b..97727da 100644
--- a/include/windows.networking.connectivity.idl
+++ b/include/windows.networking.connectivity.idl
@@ -28,39 +28,343 @@ import "windows.foundation.idl";
 /* import "windows.networking.idl"; */
 import "windows.storage.streams.idl";
 
-namespace Windows.Networking.Connectivity {
-    interface IIPInformation;
-    interface INetworkAdapter;
-
-    runtimeclass IPInformation;
-    runtimeclass NetworkAdapter;
-
-    [
-        contract(Windows.Foundation.UniversalApiContract, 1.0),
-        exclusiveto(Windows.Networking.Connectivity.IPInformation),
-        uuid(d85145e0-138f-47d7-9b3a-36bb488cef33)
-    ]
-    interface IIPInformation : IInspectable
+namespace Windows
+{
+    namespace Foundation
     {
-        [propget] HRESULT NetworkAdapter([out, retval] Windows.Networking.Connectivity.NetworkAdapter **value);
-        [propget] HRESULT PrefixLength([out, retval] Windows.Foundation.IReference<BYTE> **value);
+        interface IClosable;
+
+        /*runtimeclass Uri;*/
     }
+}
 
-    [
-        contract(Windows.Foundation.UniversalApiContract, 1.0),
-        marshaling_behavior(agile)
-    ]
-    runtimeclass IPInformation
+namespace Windows
+{
+    namespace Networking
     {
-        [default] interface Windows.Networking.Connectivity.IIPInformation;
+        /*typedef enum DomainNameType DomainNameType;*/
+
+        /*runtimeclass EndpointPair;*/
+
+        /*runtimeclass HostName;*/
+
+        /*typedef enum HostNameSortOptions HostNameSortOptions;*/
     }
+}
 
-    [
-        contract(Windows.Foundation.UniversalApiContract, 1.0),
-        marshaling_behavior(agile),
-    ]
-    runtimeclass NetworkAdapter
+namespace Windows
+{
+    namespace Networking
     {
-        [default] interface Windows.Networking.Connectivity.INetworkAdapter;
+        namespace Connectivity
+        {
+            runtimeclass ConnectionCost;
+            runtimeclass ConnectionProfile;
+            runtimeclass DataPlanStatus;
+            runtimeclass DataPlanUsage;
+            runtimeclass DataUsage;
+            runtimeclass IPInformation;
+            runtimeclass LanIdentifier;
+            runtimeclass LanIdentifierData;
+            runtimeclass NetworkAdapter;
+            runtimeclass NetworkInformation;
+            runtimeclass NetworkSecuritySettings;
+            runtimeclass ProxyConfiguration;
+
+            typedef enum NetworkConnectivityLevel NetworkConnectivityLevel;
+            typedef enum NetworkCostType NetworkCostType;
+            typedef enum RoamingStates RoamingStates;
+            typedef enum NetworkAuthenticationType NetworkAuthenticationType;
+            typedef enum NetworkEncryptionType NetworkEncryptionType;
+
+            declare
+            {
+                interface Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.ConnectionProfile*>;
+                interface Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.LanIdentifier*>;
+                /*interface Windows.Foundation.Collections.IVectorView<Windows.Networking.HostName*>;*/
+                /*interface Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair*>;*/
+
+
+                /*interface Windows.Foundation.Collections.IIterable<Windows.Networking.EndpointPair*>;*/
+
+                /*interface Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ProxyConfiguration*>;*/
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum NetworkConnectivityLevel
+            {
+                None,
+                LocalAccess,
+                ConstrainedInternetAccess,
+                InternetAccess
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum NetworkCostType
+            {
+                Unknown,
+                Unrestricted,
+                Fixed,
+                Variable
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [flags]
+            enum RoamingStates
+            {
+                None       = 0x0,
+                NotRoaming = 0x1,
+                Roaming    = 0x2
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum NetworkAuthenticationType
+            {
+                None,
+                Unknown,
+                Open80211,
+                SharedKey80211,
+                Wpa,
+                WpaPsk,
+                WpaNone,
+                Rsna,
+                RsnaPsk,
+                Ihv
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum NetworkEncryptionType
+            {
+                None,
+                Unknown,
+                Wep,
+                Wep40,
+                Wep104,
+                Tkip,
+                Ccmp,
+                WpaUseGroup,
+                RsnUseGroup,
+                Ihv
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [uuid(71ba143f-598e-49d0-84eb-8febaedcc195)]
+            delegate HRESULT NetworkStatusChangedEventHandler([in] IInspectable* sender);
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.ConnectionProfile)]
+            [uuid(71ba143c-598e-49d0-84eb-8febaedcc195)]
+            interface IConnectionProfile : IInspectable
+            {
+                [propget] HRESULT ProfileName([out, retval] HSTRING* value);
+                HRESULT GetNetworkConnectivityLevel([out, retval] Windows.Networking.Connectivity.NetworkConnectivityLevel* value);
+                HRESULT GetNetworkNames([out, retval] Windows.Foundation.Collections.IVectorView<HSTRING>** value);
+                HRESULT GetConnectionCost([out, retval] Windows.Networking.Connectivity.ConnectionCost** value);
+                HRESULT GetDataPlanStatus([out, retval] Windows.Networking.Connectivity.DataPlanStatus** value);
+                [propget] HRESULT NetworkAdapter([out, retval] Windows.Networking.Connectivity.NetworkAdapter** value);
+                HRESULT GetLocalUsage([in] Windows.Foundation.DateTime start, [in] Windows.Foundation.DateTime end,
+                            [out, retval] Windows.Networking.Connectivity.DataUsage** value);
+                HRESULT GetLocalUsagePerRoamingStates([in] Windows.Foundation.DateTime start,
+                            [in] Windows.Foundation.DateTime end, [in] Windows.Networking.Connectivity.RoamingStates states,
+                            [out, retval] Windows.Networking.Connectivity.DataUsage** value);
+                [propget] HRESULT NetworkSecuritySettings([out, retval] Windows.Networking.Connectivity.NetworkSecuritySettings** value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.LanIdentifier)]
+            [uuid(48aa53aa-1108-4546-a6cb-9a74da4b7ba0)]
+            interface ILanIdentifier : IInspectable
+            {
+                [propget] HRESULT InfrastructureId([out, retval] Windows.Networking.Connectivity.LanIdentifierData** value);
+                [propget] HRESULT PortId([out, retval] Windows.Networking.Connectivity.LanIdentifierData** value);
+                [propget] HRESULT NetworkAdapterId([out, retval] GUID* value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.LanIdentifierData)]
+            [uuid(a74e83c3-d639-45be-a36a-c4e4aeaf6d9b)]
+            interface ILanIdentifierData : IInspectable
+            {
+                [propget] HRESULT Type([out, retval] UINT32* value);
+                [propget] HRESULT Value([out,retval] /*Windows.Foundation.Collections.IVectorView<BYTE>** */ BYTE **value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.IPInformation)]
+            [uuid(d85145e0-138f-47d7-9b3a-36bb488cef33)]
+            interface IIPInformation : IInspectable
+            {
+                [propget] HRESULT NetworkAdapter([out, retval] Windows.Networking.Connectivity.NetworkAdapter **value);
+                [propget] HRESULT PrefixLength([out, retval] Windows.Foundation.IReference<BYTE> **value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.NetworkInformation)]
+            [uuid(5074f851-950d-4165-9c15-365619481eea)]
+            interface INetworkInformationStatics : IInspectable
+            {
+                HRESULT GetConnectionProfiles([out, retval] Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.ConnectionProfile*>** value);
+                HRESULT GetInternetConnectionProfile([out, retval] Windows.Networking.Connectivity.ConnectionProfile** value);
+                HRESULT GetLanIdentifiers([out, retval] Windows.Foundation.Collections.IVectorView<Windows.Networking.Connectivity.LanIdentifier*>** value);
+                HRESULT GetHostNames([out, retval] /*Windows.Foundation.Collections.IVectorView<Windows.Networking.HostName*>** */ DWORD **value);
+                HRESULT GetProxyConfigurationAsync(/*[in] Windows.Foundation.Uri* */ char* uri,
+                                [out, retval] /*Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ProxyConfiguration*>** */ DWORD **value);
+                HRESULT GetSortedEndpointPairs([in] /* Windows.Foundation.Collections.IIterable<Windows.Networking.EndpointPair*>* */ DWORD *endpoint,
+                                [in] /*Windows.Networking.HostNameSortOptions*/ DWORD options,
+                                [out, retval] /*Windows.Foundation.Collections.IVectorView<Windows.Networking.EndpointPair*>** */ DWORD **value);
+                [eventadd] HRESULT NetworkStatusChanged([in] Windows.Networking.Connectivity.NetworkStatusChangedEventHandler* handler,
+                                [out, retval] EventRegistrationToken* eventCookie);
+                [eventremove] HRESULT NetworkStatusChanged([in] EventRegistrationToken cookie);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.ConnectionCost)]
+            [uuid(bad7d829-3416-4b10-a202-bac0b075bdae)]
+            interface IConnectionCost : IInspectable
+            {
+                [propget] HRESULT NetworkCostType([out, retval] Windows.Networking.Connectivity.NetworkCostType* value);
+                [propget] HRESULT Roaming([out, retval] boolean* value);
+                [propget] HRESULT OverDataLimit([out, retval] boolean* value);
+                [propget] HRESULT ApproachingDataLimit([out, retval] boolean* value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.DataUsage)]
+            [uuid(c1431dd3-b146-4d39-b959-0c69b096c512)]
+            interface IDataUsage : IInspectable
+            {
+                [propget] HRESULT BytesSent([out, retval] UINT64* value);
+                [propget] HRESULT BytesReceived([out, retval] UINT64* value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.NetworkAdapter)]
+            [uuid(3b542e03-5388-496c-a8a3-affd39aec2e6)]
+            interface INetworkAdapter : IInspectable
+            {
+                [propget] HRESULT OutboundMaxBitsPerSecond([out, retval] UINT64* value);
+                [propget] HRESULT InboundMaxBitsPerSecond([out ,retval] UINT64* value);
+                [propget] HRESULT IanaInterfaceType([out, retval] UINT32* value);
+                [propget] HRESULT NetworkItem([out, retval] /*Windows.Networking.Connectivity.NetworkItem** */ DWORD **value);
+                [propget] HRESULT NetworkAdapterId([out, retval] GUID* value);
+                HRESULT GetConnectedProfileAsync([out, retval] /*Windows.Foundation.IAsyncOperation<Windows.Networking.Connectivity.ConnectionProfile*>** */ DWORD **value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.NetworkSecuritySettings)]
+            [uuid(7CA07E8D-917B-4B5F-B84D-28F7A5AC5402)]
+            interface INetworkSecuritySettings : IInspectable
+            {
+                [propget] HRESULT NetworkAuthenticationType([out, retval] Windows.Networking.Connectivity.NetworkAuthenticationType* value);
+                [propget] HRESULT NetworkEncryptionType([out, retval] Windows.Networking.Connectivity.NetworkEncryptionType* value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.DataPlanUsage)]
+            [uuid(b921492d-3b44-47ff-b361-be59e69ed1b0)]
+            interface IDataPlanUsage : IInspectable
+            {
+                [propget] HRESULT MegabytesUsed([out] [retval] UINT32* value);
+                [propget] HRESULT LastSyncTime([out] [retval] Windows.Foundation.DateTime* value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [exclusiveto(Windows.Networking.Connectivity.DataPlanStatus)]
+            [uuid(977a8b8c-3885-40f3-8851-42cd2bd568bb)]
+            interface IDataPlanStatus : IInspectable
+            {
+                [propget] HRESULT DataPlanUsage([out, retval] Windows.Networking.Connectivity.DataPlanUsage** value);
+                [propget] HRESULT DataLimitInMegabytes([out, retval] /*Windows.Foundation.IReference<UINT32>** */ UINT32 **value);
+                [propget] HRESULT InboundBitsPerSecond([out, retval] /* Windows.Foundation.IReference<UINT64>** */ UINT64 **value);
+                [propget] HRESULT OutboundBitsPerSecond([out, retval] /* Windows.Foundation.IReference<UINT64>** */ UINT64 **value);
+                [propget] HRESULT NextBillingCycle([out, retval] /* Windows.Foundation.IReference<Windows.Foundation.DateTime>** */ UINT64 **value);
+                [propget] HRESULT MaxTransferSizeInMegabytes([out, retval] /*Windows.Foundation.IReference<UINT32>** */ UINT32 **value);
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass DataPlanStatus
+            {
+                [default] interface Windows.Networking.Connectivity.IDataPlanStatus;
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass DataUsage
+            {
+                [default] interface Windows.Networking.Connectivity.IDataUsage;
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass NetworkAdapter
+            {
+                [default] interface Windows.Networking.Connectivity.INetworkAdapter;
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass DataPlanUsage
+            {
+                [default] interface Windows.Networking.Connectivity.IDataPlanUsage;
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            [static(Windows.Networking.Connectivity.INetworkInformationStatics, Windows.Foundation.UniversalApiContract, 1.0)]
+            /*[static(Windows.Networking.Connectivity.INetworkInformationStatics2, Windows.Foundation.UniversalApiContract, 1.0)]*/
+            runtimeclass NetworkInformation
+            {
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass IPInformation
+            {
+                [default] interface Windows.Networking.Connectivity.IIPInformation;
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass NetworkSecuritySettings
+            {
+                [default] interface Windows.Networking.Connectivity.INetworkSecuritySettings;
+            }
+
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass ConnectionProfile
+            {
+                [default] interface Windows.Networking.Connectivity.IConnectionProfile;
+                [contract(Windows.Foundation.UniversalApiContract, 1.0)] interface Windows.Networking.Connectivity.IConnectionProfile2;
+                [contract(Windows.Foundation.UniversalApiContract, 1.0)] interface Windows.Networking.Connectivity.IConnectionProfile3;
+                [contract(Windows.Foundation.UniversalApiContract, 5.0)] interface Windows.Networking.Connectivity.IConnectionProfile4;
+                [contract(Windows.Foundation.UniversalApiContract, 7.0)] interface Windows.Networking.Connectivity.IConnectionProfile5;
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass ConnectionCost
+            {
+                [default] interface Windows.Networking.Connectivity.IConnectionCost;
+                [contract(Windows.Foundation.UniversalApiContract, 1.0)] interface Windows.Networking.Connectivity.IConnectionCost2;
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass LanIdentifier
+            {
+                [default] interface Windows.Networking.Connectivity.ILanIdentifier;
+            }
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            [marshaling_behavior(agile)]
+            runtimeclass LanIdentifierData
+            {
+                [default] interface Windows.Networking.Connectivity.ILanIdentifierData;
+            }
+
+        }
     }
 }
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index bd827c3..6435d20 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -331,6 +331,7 @@ struct user_driver_funcs
     BOOL    (*pProcessEvents)(DWORD);
     void    (*pReleaseDC)(HWND,HDC);
     BOOL    (*pScrollDC)(HDC,INT,INT,HRGN);
+    void    (*pSetActiveWindow)(HWND);
     void    (*pSetCapture)(HWND,UINT);
     void    (*pSetDesktopWindow)(HWND);
     void    (*pSetFocus)(HWND);
@@ -354,6 +355,8 @@ struct user_driver_funcs
     const struct vulkan_funcs * (*pwine_get_vulkan_driver)(UINT);
     /* opengl support */
     struct opengl_funcs * (*pwine_get_wgl_driver)(UINT);
+    /* IME functions */
+    void    (*pUpdateCandidatePos)(HWND, const RECT *);
     /* thread management */
     void    (*pThreadDetach)(void);
 };
diff --git a/include/wine/list.h b/include/wine/list.h
index 2e1d95f..c20b3ea 100644
--- a/include/wine/list.h
+++ b/include/wine/list.h
@@ -264,7 +264,13 @@ static inline void list_move_slice_tail( struct list *dst, struct list *begin, s
 
 /* get pointer to object containing list element */
 #undef LIST_ENTRY
-#define LIST_ENTRY(elem, type, field) \
-    ((type *)((char *)(elem) - offsetof(type, field)))
+#ifdef __GNUC__
+# define LIST_ENTRY(elem, type, field) ({               \
+     const typeof(((type *)0)->field) *__ptr = (elem);  \
+     (type *)((char *)__ptr - offsetof(type, field)); })
+#else
+# define LIST_ENTRY(elem, type, field) \
+     ((type *)((char *)(elem) - offsetof(type, field)))
+#endif
 
 #endif  /* __WINE_SERVER_LIST_H */
diff --git a/include/wine/rbtree.h b/include/wine/rbtree.h
index 81367f3..a751d0d 100644
--- a/include/wine/rbtree.h
+++ b/include/wine/rbtree.h
@@ -23,8 +23,14 @@
 #ifndef __WINE_WINE_RBTREE_H
 #define __WINE_WINE_RBTREE_H
 
-#define RB_ENTRY_VALUE(element, type, field) \
-    ((type *)((char *)(element) - offsetof(type, field)))
+#ifdef __GNUC__
+# define RB_ENTRY_VALUE(element, type, field) ({       \
+     const typeof(((type *)0)->field) *__ptr = (element);   \
+     (type *)((char *)__ptr - offsetof(type, field)); })
+#else
+# define RB_ENTRY_VALUE(element, type, field) \
+     ((type *)((char *)(element) - offsetof(type, field)))
+#endif
 
 struct rb_entry
 {
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 116c379..8b7f874 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -21,6 +21,8 @@ struct vulkan_funcs
      * needs to provide. Other function calls will be provided indirectly by dispatch
      * tables part of dispatchable Vulkan objects such as VkInstance or vkDevice.
      */
+    VkResult (*p_vkAcquireNextImage2KHR)(VkDevice, const VkAcquireNextImageInfoKHR *, uint32_t *);
+    VkResult (*p_vkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
     VkResult (*p_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
     VkResult (*p_vkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
     VkResult (*p_vkCreateWin32SurfaceKHR)(VkInstance, const VkWin32SurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
@@ -53,6 +55,10 @@ static inline void *get_vulkan_driver_device_proc_addr(
 
     name += 2;
 
+    if (!strcmp(name, "AcquireNextImage2KHR"))
+        return vulkan_funcs->p_vkAcquireNextImage2KHR;
+    if (!strcmp(name, "AcquireNextImageKHR"))
+        return vulkan_funcs->p_vkAcquireNextImageKHR;
     if (!strcmp(name, "CreateSwapchainKHR"))
         return vulkan_funcs->p_vkCreateSwapchainKHR;
     if (!strcmp(name, "DestroySwapchainKHR"))
diff --git a/include/winnt.h b/include/winnt.h
index e9fef20..d147f87 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -883,8 +883,14 @@ typedef struct DECLSPEC_ALIGN(8) MEM_EXTENDED_PARAMETER {
 #define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
 #define RTL_SIZEOF_THROUGH_FIELD(type, field) (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))
 
-#define CONTAINING_RECORD(address, type, field) \
-  ((type *)((PCHAR)(address) - offsetof(type, field)))
+#ifdef __GNUC__
+# define CONTAINING_RECORD(address, type, field) ({     \
+   const typeof(((type *)0)->field) *__ptr = (address); \
+   (type *)((PCHAR)__ptr - offsetof(type, field)); })
+#else
+# define CONTAINING_RECORD(address, type, field) \
+   ((type *)((PCHAR)(address) - offsetof(type, field)))
+#endif
 
 #define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
 #ifdef __WINESRC__
@@ -2495,6 +2501,7 @@ static FORCEINLINE struct _TEB * WINAPI NtCurrentTeb(void)
 #define IO_REPARSE_TAG_CLOUD_MASK       __MSABI_LONG(0x0000F000)
 #define IO_REPARSE_TAG_APPEXECLINK      __MSABI_LONG(0x8000001B)
 #define IO_REPARSE_TAG_GVFS             __MSABI_LONG(0x9000001C)
+#define IO_REPARSE_TAG_LX_SYMLINK       __MSABI_LONG(0xA000001D)
 #define IO_REPARSE_TAG_STORAGE_SYNC     __MSABI_LONG(0x8000001E)
 #define IO_REPARSE_TAG_WCI_TOMBSTONE    __MSABI_LONG(0xA000001F)
 #define IO_REPARSE_TAG_UNHANDLED        __MSABI_LONG(0x80000020)
diff --git a/libs/vkd3d/Makefile.in b/libs/vkd3d/Makefile.in
index dbc1059..448e9a0 100644
--- a/libs/vkd3d/Makefile.in
+++ b/libs/vkd3d/Makefile.in
@@ -17,6 +17,7 @@ SOURCES = \
 	libs/vkd3d-shader/d3dbc.c \
 	libs/vkd3d-shader/dxbc.c \
 	libs/vkd3d-shader/dxil.c \
+	libs/vkd3d-shader/fx.c \
 	libs/vkd3d-shader/glsl.c \
 	libs/vkd3d-shader/hlsl.c \
 	libs/vkd3d-shader/hlsl.l \
diff --git a/libs/vkd3d/include/private/vkd3d_common.h b/libs/vkd3d/include/private/vkd3d_common.h
index 34fde1a..979676c 100644
--- a/libs/vkd3d/include/private/vkd3d_common.h
+++ b/libs/vkd3d/include/private/vkd3d_common.h
@@ -52,6 +52,7 @@
 #define TAG_AON9 VKD3D_MAKE_TAG('A', 'o', 'n', '9')
 #define TAG_DXBC VKD3D_MAKE_TAG('D', 'X', 'B', 'C')
 #define TAG_DXIL VKD3D_MAKE_TAG('D', 'X', 'I', 'L')
+#define TAG_FX10 VKD3D_MAKE_TAG('F', 'X', '1', '0')
 #define TAG_ISG1 VKD3D_MAKE_TAG('I', 'S', 'G', '1')
 #define TAG_ISGN VKD3D_MAKE_TAG('I', 'S', 'G', 'N')
 #define TAG_OSG1 VKD3D_MAKE_TAG('O', 'S', 'G', '1')
@@ -80,7 +81,7 @@ static inline size_t align(size_t addr, size_t alignment)
 # ifdef __MINGW_PRINTF_FORMAT
 #  define VKD3D_PRINTF_FUNC(fmt, args) __attribute__((format(__MINGW_PRINTF_FORMAT, fmt, args)))
 # else
-#  define VKD3D_PRINTF_FUNC(fmt, args) /* __attribute__((format(printf, fmt, args))) */
+#  define VKD3D_PRINTF_FUNC(fmt, args) __attribute__((format(printf, fmt, args)))
 # endif
 # define VKD3D_UNUSED __attribute__((unused))
 # define VKD3D_UNREACHABLE __builtin_unreachable()
@@ -107,7 +108,7 @@ static inline unsigned int vkd3d_popcount(unsigned int v)
 {
 #ifdef _MSC_VER
     return __popcnt(v);
-#elif defined(__MINGW32__)
+#elif defined(HAVE_BUILTIN_POPCOUNT)
     return __builtin_popcount(v);
 #else
     v -= (v >> 1) & 0x55555555;
@@ -266,33 +267,53 @@ static inline int ascii_strcasecmp(const char *a, const char *b)
     return c_a - c_b;
 }
 
-#ifndef _WIN32
-# if HAVE_SYNC_ADD_AND_FETCH
-static inline LONG InterlockedIncrement(LONG volatile *x)
+static inline uint64_t vkd3d_atomic_add_fetch_u64(uint64_t volatile *x, uint64_t val)
 {
-    return __sync_add_and_fetch(x, 1);
+#if HAVE_SYNC_ADD_AND_FETCH
+    return __sync_add_and_fetch(x, val);
+#elif defined(_WIN32)
+    return InterlockedAdd64((LONG64 *)x, val);
+#else
+# error "vkd3d_atomic_add_fetch_u64() not implemented for this platform"
+#endif
 }
-static inline LONG64 InterlockedIncrement64(LONG64 volatile *x)
+
+static inline uint32_t vkd3d_atomic_add_fetch_u32(uint32_t volatile *x, uint32_t val)
 {
-    return __sync_add_and_fetch(x, 1);
+#if HAVE_SYNC_ADD_AND_FETCH
+    return __sync_add_and_fetch(x, val);
+#elif defined(_WIN32)
+    return InterlockedAdd((LONG *)x, val);
+#else
+# error "vkd3d_atomic_add_fetch_u32() not implemented for this platform"
+#endif
 }
-static inline LONG InterlockedAdd(LONG volatile *x, LONG val)
+
+static inline uint64_t vkd3d_atomic_increment_u64(uint64_t volatile *x)
 {
-    return __sync_add_and_fetch(x, val);
+    return vkd3d_atomic_add_fetch_u64(x, 1);
 }
-# else
-#  error "InterlockedIncrement() not implemented for this platform"
-# endif  /* HAVE_SYNC_ADD_AND_FETCH */
 
-# if HAVE_SYNC_SUB_AND_FETCH
-static inline LONG InterlockedDecrement(LONG volatile *x)
+static inline uint32_t vkd3d_atomic_decrement_u32(uint32_t volatile *x)
 {
-    return __sync_sub_and_fetch(x, 1);
+    return vkd3d_atomic_add_fetch_u32(x, ~0u);
 }
-# else
-#  error "InterlockedDecrement() not implemented for this platform"
-# endif
 
+static inline uint32_t vkd3d_atomic_increment_u32(uint32_t volatile *x)
+{
+    return vkd3d_atomic_add_fetch_u32(x, 1);
+}
+
+#ifndef _WIN32
+static inline LONG InterlockedIncrement(LONG volatile *x)
+{
+    return vkd3d_atomic_increment_u32((uint32_t *)x);
+}
+
+static inline LONG InterlockedDecrement(LONG volatile *x)
+{
+    return vkd3d_atomic_decrement_u32((uint32_t *)x);
+}
 #endif  /* _WIN32 */
 
 static inline void vkd3d_parse_version(const char *version, int *major, int *minor)
diff --git a/libs/vkd3d/include/private/vkd3d_debug.h b/libs/vkd3d/include/private/vkd3d_debug.h
index 6708cad..663fc31 100644
--- a/libs/vkd3d/include/private/vkd3d_debug.h
+++ b/libs/vkd3d/include/private/vkd3d_debug.h
@@ -104,6 +104,29 @@ static inline const char *debugstr_guid(const GUID *guid)
             guid->Data4[5], guid->Data4[6], guid->Data4[7]);
 }
 
+static inline const char *debugstr_hresult(HRESULT hr)
+{
+    switch (hr)
+    {
+#define TO_STR(u) case u: return #u;
+        TO_STR(S_OK)
+        TO_STR(S_FALSE)
+        TO_STR(E_NOTIMPL)
+        TO_STR(E_NOINTERFACE)
+        TO_STR(E_POINTER)
+        TO_STR(E_ABORT)
+        TO_STR(E_FAIL)
+        TO_STR(E_OUTOFMEMORY)
+        TO_STR(E_INVALIDARG)
+        TO_STR(DXGI_ERROR_NOT_FOUND)
+        TO_STR(DXGI_ERROR_MORE_DATA)
+        TO_STR(DXGI_ERROR_UNSUPPORTED)
+#undef TO_STR
+        default:
+            return vkd3d_dbg_sprintf("%#x", (int)hr);
+    }
+}
+
 unsigned int vkd3d_env_var_as_uint(const char *name, unsigned int default_value);
 
 struct vkd3d_debug_option
diff --git a/libs/vkd3d/include/vkd3d_shader.h b/libs/vkd3d/include/vkd3d_shader.h
index 290f908..a8cc3a3 100644
--- a/libs/vkd3d/include/vkd3d_shader.h
+++ b/libs/vkd3d/include/vkd3d_shader.h
@@ -196,6 +196,15 @@ enum vkd3d_shader_compile_option_fragment_coordinate_origin
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_FRAGMENT_COORDINATE_ORIGIN),
 };
 
+/** Advertises feature availability. \since 1.11 */
+enum vkd3d_shader_compile_option_feature_flags
+{
+    VKD3D_SHADER_COMPILE_OPTION_FEATURE_INT64         = 0x00000001,
+    VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLOAT64       = 0x00000002,
+
+    VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLAGS),
+};
+
 enum vkd3d_shader_compile_option_name
 {
     /**
@@ -253,6 +262,16 @@ enum vkd3d_shader_compile_option_name
      * \since 1.10
      */
     VKD3D_SHADER_COMPILE_OPTION_FRAGMENT_COORDINATE_ORIGIN = 0x00000009,
+    /**
+     * This option specifies the shader features available in the target
+     * environment. These are not extensions, i.e. they are always supported
+     * by the driver, but may not be supported by the available hardware.
+     *
+     * \a value is a member of enum vkd3d_shader_compile_option_feature_flags.
+     *
+     * \since 1.11
+     */
+    VKD3D_SHADER_COMPILE_OPTION_FEATURE = 0x0000000a,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPILE_OPTION_NAME),
 };
@@ -767,6 +786,11 @@ enum vkd3d_shader_target_type
      * An 'OpenGL Shading Language' shader. \since 1.3
      */
     VKD3D_SHADER_TARGET_GLSL,
+    /**
+     * Binary format used by Direct3D 9/10.x/11 effects profiles.
+     * Output is a raw FX section without container. \since 1.11
+     */
+    VKD3D_SHADER_TARGET_FX,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_TARGET_TYPE),
 };
@@ -853,6 +877,8 @@ enum vkd3d_shader_spirv_extension
     VKD3D_SHADER_SPIRV_EXTENSION_EXT_DESCRIPTOR_INDEXING,
     /** \since 1.3 */
     VKD3D_SHADER_SPIRV_EXTENSION_EXT_STENCIL_EXPORT,
+    /** \since 1.11 */
+    VKD3D_SHADER_SPIRV_EXTENSION_EXT_VIEWPORT_INDEX_LAYER,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_SPIRV_EXTENSION),
 };
@@ -1252,6 +1278,8 @@ enum vkd3d_shader_descriptor_range_flags
     VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE                    = 0x2,
     VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE = 0x4,
     VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_STATIC                      = 0x8,
+    /** \since 1.11 */
+    VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS = 0x10000,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_DESCRIPTOR_RANGE_FLAGS),
 };
@@ -1551,6 +1579,8 @@ enum vkd3d_shader_component_type
     VKD3D_SHADER_COMPONENT_BOOL     = 0x4,
     /** 64-bit IEEE floating-point. */
     VKD3D_SHADER_COMPONENT_DOUBLE   = 0x5,
+    /** 64-bit unsigned integer. \since 1.11 */
+    VKD3D_SHADER_COMPONENT_UINT64   = 0x6,
 
     VKD3D_FORCE_32_BIT_ENUM(VKD3D_SHADER_COMPONENT_TYPE),
 };
diff --git a/libs/vkd3d/libs/vkd3d-common/blob.c b/libs/vkd3d/libs/vkd3d-common/blob.c
index 71ab9a2..dbb26de 100644
--- a/libs/vkd3d/libs/vkd3d-common/blob.c
+++ b/libs/vkd3d/libs/vkd3d-common/blob.c
@@ -17,16 +17,18 @@
  */
 
 #define COBJMACROS
+
 #define CONST_VTABLE
 #include "vkd3d.h"
 #include "vkd3d_blob.h"
 #include "vkd3d_debug.h"
 #include "vkd3d_memory.h"
+#include "d3d12shader.h"
 
 struct vkd3d_blob
 {
     ID3D10Blob ID3DBlob_iface;
-    LONG refcount;
+    unsigned int refcount;
 
     void *buffer;
     SIZE_T size;
@@ -58,7 +60,7 @@ static HRESULT STDMETHODCALLTYPE vkd3d_blob_QueryInterface(ID3DBlob *iface, REFI
 static ULONG STDMETHODCALLTYPE vkd3d_blob_AddRef(ID3DBlob *iface)
 {
     struct vkd3d_blob *blob = impl_from_ID3DBlob(iface);
-    ULONG refcount = InterlockedIncrement(&blob->refcount);
+    unsigned int refcount = vkd3d_atomic_increment_u32(&blob->refcount);
 
     TRACE("%p increasing refcount to %u.\n", blob, refcount);
 
@@ -68,7 +70,7 @@ static ULONG STDMETHODCALLTYPE vkd3d_blob_AddRef(ID3DBlob *iface)
 static ULONG STDMETHODCALLTYPE vkd3d_blob_Release(ID3DBlob *iface)
 {
     struct vkd3d_blob *blob = impl_from_ID3DBlob(iface);
-    ULONG refcount = InterlockedDecrement(&blob->refcount);
+    unsigned int refcount = vkd3d_atomic_decrement_u32(&blob->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", blob, refcount);
 
diff --git a/libs/vkd3d/libs/vkd3d-common/debug.c b/libs/vkd3d/libs/vkd3d-common/debug.c
index aa7df5b..e12cd39 100644
--- a/libs/vkd3d/libs/vkd3d-common/debug.c
+++ b/libs/vkd3d/libs/vkd3d-common/debug.c
@@ -126,10 +126,10 @@ void vkd3d_dbg_set_log_callback(PFN_vkd3d_log callback)
 static char *get_buffer(void)
 {
     static char buffers[VKD3D_DEBUG_BUFFER_COUNT][VKD3D_DEBUG_BUFFER_SIZE];
-    static LONG buffer_index;
-    LONG current_index;
+    static unsigned int buffer_index;
+    unsigned int current_index;
 
-    current_index = InterlockedIncrement(&buffer_index) % ARRAY_SIZE(buffers);
+    current_index = vkd3d_atomic_increment_u32(&buffer_index) % ARRAY_SIZE(buffers);
     return buffers[current_index];
 }
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
index 82d1d71..af93939 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3d_asm.c
@@ -44,6 +44,7 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_BEM                             ] = "bem",
     [VKD3DSIH_BFI                             ] = "bfi",
     [VKD3DSIH_BFREV                           ] = "bfrev",
+    [VKD3DSIH_BRANCH                          ] = "branch",
     [VKD3DSIH_BREAK                           ] = "break",
     [VKD3DSIH_BREAKC                          ] = "breakc",
     [VKD3DSIH_BREAKP                          ] = "breakp",
@@ -197,8 +198,11 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_IMUL                            ] = "imul",
     [VKD3DSIH_INE                             ] = "ine",
     [VKD3DSIH_INEG                            ] = "ineg",
+    [VKD3DSIH_ISFINITE                        ] = "isfinite",
     [VKD3DSIH_ISHL                            ] = "ishl",
     [VKD3DSIH_ISHR                            ] = "ishr",
+    [VKD3DSIH_ISINF                           ] = "isinf",
+    [VKD3DSIH_ISNAN                           ] = "isnan",
     [VKD3DSIH_ITOD                            ] = "itod",
     [VKD3DSIH_ITOF                            ] = "itof",
     [VKD3DSIH_ITOI                            ] = "itoi",
@@ -241,6 +245,7 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_NRM                             ] = "nrm",
     [VKD3DSIH_OR                              ] = "or",
     [VKD3DSIH_PHASE                           ] = "phase",
+    [VKD3DSIH_PHI                             ] = "phi",
     [VKD3DSIH_POW                             ] = "pow",
     [VKD3DSIH_RCP                             ] = "rcp",
     [VKD3DSIH_REP                             ] = "rep",
@@ -278,7 +283,9 @@ static const char * const shader_opcode_names[] =
     [VKD3DSIH_SUB                             ] = "sub",
     [VKD3DSIH_SWAPC                           ] = "swapc",
     [VKD3DSIH_SWITCH                          ] = "switch",
+    [VKD3DSIH_SWITCH_MONOLITHIC               ] = "switch",
     [VKD3DSIH_SYNC                            ] = "sync",
+    [VKD3DSIH_TAN                             ] = "tan",
     [VKD3DSIH_TEX                             ] = "texld",
     [VKD3DSIH_TEXBEM                          ] = "texbem",
     [VKD3DSIH_TEXBEML                         ] = "texbeml",
@@ -364,6 +371,8 @@ struct vkd3d_d3d_asm_compiler
     struct vkd3d_string_buffer buffer;
     struct vkd3d_shader_version shader_version;
     struct vkd3d_d3d_asm_colours colours;
+    enum vsir_asm_dialect dialect;
+    const struct vkd3d_shader_instruction *current;
 };
 
 static int VKD3D_PRINTF_FUNC(2, 3) shader_addline(struct vkd3d_string_buffer *buffer, const char *format, ...)
@@ -437,6 +446,11 @@ static void shader_dump_sync_flags(struct vkd3d_d3d_asm_compiler *compiler, uint
         vkd3d_string_buffer_printf(&compiler->buffer, "_uglobal");
         sync_flags &= ~VKD3DSSF_GLOBAL_UAV;
     }
+    if (sync_flags & VKD3DSSF_THREAD_GROUP_UAV)
+    {
+        vkd3d_string_buffer_printf(&compiler->buffer, "_ugroup");
+        sync_flags &= ~VKD3DSSF_THREAD_GROUP_UAV;
+    }
     if (sync_flags & VKD3DSSF_GROUP_SHARED_MEMORY)
     {
         vkd3d_string_buffer_printf(&compiler->buffer, "_g");
@@ -606,7 +620,7 @@ static void shader_dump_resource_type(struct vkd3d_d3d_asm_compiler *compiler, e
         vkd3d_string_buffer_printf(&compiler->buffer, "unknown");
 }
 
-static void shader_dump_data_type(struct vkd3d_d3d_asm_compiler *compiler, const enum vkd3d_data_type *type)
+static void shader_dump_data_type(struct vkd3d_d3d_asm_compiler *compiler, enum vkd3d_data_type type)
 {
     static const char *const data_type_names[] =
     {
@@ -623,19 +637,31 @@ static void shader_dump_data_type(struct vkd3d_d3d_asm_compiler *compiler, const
         [VKD3D_DATA_DOUBLE   ] = "double",
         [VKD3D_DATA_CONTINUED] = "<continued>",
         [VKD3D_DATA_UNUSED   ] = "<unused>",
+        [VKD3D_DATA_UINT8    ] = "uint8",
+        [VKD3D_DATA_UINT64   ] = "uint64",
+        [VKD3D_DATA_BOOL     ] = "bool",
     };
+
     const char *name;
+
+    if (type < ARRAY_SIZE(data_type_names))
+        name = data_type_names[type];
+    else
+        name = "<unknown>";
+
+    vkd3d_string_buffer_printf(&compiler->buffer, "%s", name);
+}
+
+static void shader_dump_resource_data_type(struct vkd3d_d3d_asm_compiler *compiler, const enum vkd3d_data_type *type)
+{
     int i;
 
     vkd3d_string_buffer_printf(&compiler->buffer, "(");
 
     for (i = 0; i < 4; i++)
     {
-        if (type[i] < ARRAY_SIZE(data_type_names))
-            name = data_type_names[type[i]];
-        else
-            name = "unknown";
-        vkd3d_string_buffer_printf(&compiler->buffer, "%s%s", i == 0 ? "" : ",", name);
+        vkd3d_string_buffer_printf(&compiler->buffer, "%s", i == 0 ? "" : ",");
+        shader_dump_data_type(compiler, type[i]);
     }
 
     vkd3d_string_buffer_printf(&compiler->buffer, ")");
@@ -682,7 +708,7 @@ static void shader_dump_decl_usage(struct vkd3d_d3d_asm_compiler *compiler,
         if (semantic->resource.reg.reg.type == VKD3DSPR_UAV)
             shader_dump_uav_flags(compiler, flags);
         shader_addline(buffer, " ");
-        shader_dump_data_type(compiler, semantic->resource_data_type);
+        shader_dump_resource_data_type(compiler, semantic->resource_data_type);
     }
     else
     {
@@ -814,6 +840,13 @@ static void shader_print_uint_literal(struct vkd3d_d3d_asm_compiler *compiler,
             prefix, compiler->colours.literal, i, compiler->colours.reset, suffix);
 }
 
+static void shader_print_uint64_literal(struct vkd3d_d3d_asm_compiler *compiler,
+        const char *prefix, uint64_t i, const char *suffix)
+{
+    vkd3d_string_buffer_printf(&compiler->buffer, "%s%s%"PRIu64"%s%s",
+            prefix, compiler->colours.literal, i, compiler->colours.reset, suffix);
+}
+
 static void shader_print_hex_literal(struct vkd3d_d3d_asm_compiler *compiler,
         const char *prefix, unsigned int i, const char *suffix)
 {
@@ -828,6 +861,27 @@ static void shader_print_bool_literal(struct vkd3d_d3d_asm_compiler *compiler,
             compiler->colours.literal, b ? "true" : "false", compiler->colours.reset, suffix);
 }
 
+static void shader_print_untyped_literal(struct vkd3d_d3d_asm_compiler *compiler,
+        const char *prefix, uint32_t u, const char *suffix)
+{
+    union
+    {
+        uint32_t u;
+        float f;
+    } value;
+    unsigned int exponent = (u >> 23) & 0xff;
+
+    value.u = u;
+
+    if (exponent != 0 && exponent != 0xff)
+        return shader_print_float_literal(compiler, prefix, value.f, suffix);
+
+    if (u <= 10000)
+        return shader_print_uint_literal(compiler, prefix, value.u, suffix);
+
+    return shader_print_hex_literal(compiler, prefix, value.u, suffix);
+}
+
 static void shader_print_subscript(struct vkd3d_d3d_asm_compiler *compiler,
         unsigned int offset, const struct vkd3d_shader_src_param *rel_addr)
 {
@@ -1089,6 +1143,19 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
 
     if (reg->type == VKD3DSPR_IMMCONST)
     {
+        bool untyped = false;
+
+        switch (compiler->current->handler_idx)
+        {
+            case VKD3DSIH_MOV:
+            case VKD3DSIH_MOVC:
+                untyped = true;
+                break;
+
+            default:
+                break;
+        }
+
         shader_addline(buffer, "%s(", compiler->colours.reset);
         switch (reg->dimension)
         {
@@ -1096,15 +1163,18 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
                 switch (reg->data_type)
                 {
                     case VKD3D_DATA_FLOAT:
-                        shader_print_float_literal(compiler, "", reg->u.immconst_float[0], "");
+                        if (untyped)
+                            shader_print_untyped_literal(compiler, "", reg->u.immconst_u32[0], "");
+                        else
+                            shader_print_float_literal(compiler, "", reg->u.immconst_f32[0], "");
                         break;
                     case VKD3D_DATA_INT:
-                        shader_print_int_literal(compiler, "", reg->u.immconst_uint[0], "");
+                        shader_print_int_literal(compiler, "", reg->u.immconst_u32[0], "");
                         break;
                     case VKD3D_DATA_RESOURCE:
                     case VKD3D_DATA_SAMPLER:
                     case VKD3D_DATA_UINT:
-                        shader_print_uint_literal(compiler, "", reg->u.immconst_uint[0], "");
+                        shader_print_uint_literal(compiler, "", reg->u.immconst_u32[0], "");
                         break;
                     default:
                         shader_addline(buffer, "<unhandled data type %#x>", reg->data_type);
@@ -1116,24 +1186,34 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
                 switch (reg->data_type)
                 {
                     case VKD3D_DATA_FLOAT:
-                        shader_print_float_literal(compiler, "", reg->u.immconst_float[0], "");
-                        shader_print_float_literal(compiler, ", ", reg->u.immconst_float[1], "");
-                        shader_print_float_literal(compiler, ", ", reg->u.immconst_float[2], "");
-                        shader_print_float_literal(compiler, ", ", reg->u.immconst_float[3], "");
+                        if (untyped)
+                        {
+                            shader_print_untyped_literal(compiler, "", reg->u.immconst_u32[0], "");
+                            shader_print_untyped_literal(compiler, ", ", reg->u.immconst_u32[1], "");
+                            shader_print_untyped_literal(compiler, ", ", reg->u.immconst_u32[2], "");
+                            shader_print_untyped_literal(compiler, ", ", reg->u.immconst_u32[3], "");
+                        }
+                        else
+                        {
+                            shader_print_float_literal(compiler, "", reg->u.immconst_f32[0], "");
+                            shader_print_float_literal(compiler, ", ", reg->u.immconst_f32[1], "");
+                            shader_print_float_literal(compiler, ", ", reg->u.immconst_f32[2], "");
+                            shader_print_float_literal(compiler, ", ", reg->u.immconst_f32[3], "");
+                        }
                         break;
                     case VKD3D_DATA_INT:
-                        shader_print_int_literal(compiler, "", reg->u.immconst_uint[0], "");
-                        shader_print_int_literal(compiler, ", ", reg->u.immconst_uint[1], "");
-                        shader_print_int_literal(compiler, ", ", reg->u.immconst_uint[2], "");
-                        shader_print_int_literal(compiler, ", ", reg->u.immconst_uint[3], "");
+                        shader_print_int_literal(compiler, "", reg->u.immconst_u32[0], "");
+                        shader_print_int_literal(compiler, ", ", reg->u.immconst_u32[1], "");
+                        shader_print_int_literal(compiler, ", ", reg->u.immconst_u32[2], "");
+                        shader_print_int_literal(compiler, ", ", reg->u.immconst_u32[3], "");
                         break;
                     case VKD3D_DATA_RESOURCE:
                     case VKD3D_DATA_SAMPLER:
                     case VKD3D_DATA_UINT:
-                        shader_print_uint_literal(compiler, "", reg->u.immconst_uint[0], "");
-                        shader_print_uint_literal(compiler, ", ", reg->u.immconst_uint[1], "");
-                        shader_print_uint_literal(compiler, ", ", reg->u.immconst_uint[2], "");
-                        shader_print_uint_literal(compiler, ", ", reg->u.immconst_uint[3], "");
+                        shader_print_uint_literal(compiler, "", reg->u.immconst_u32[0], "");
+                        shader_print_uint_literal(compiler, ", ", reg->u.immconst_u32[1], "");
+                        shader_print_uint_literal(compiler, ", ", reg->u.immconst_u32[2], "");
+                        shader_print_uint_literal(compiler, ", ", reg->u.immconst_u32[3], "");
                         break;
                     default:
                         shader_addline(buffer, "<unhandled data type %#x>", reg->data_type);
@@ -1155,9 +1235,15 @@ static void shader_dump_register(struct vkd3d_d3d_asm_compiler *compiler, const
         {
             if (reg->data_type == VKD3D_DATA_DOUBLE)
             {
-                shader_print_double_literal(compiler, "", reg->u.immconst_double[0], "");
+                shader_print_double_literal(compiler, "", reg->u.immconst_f64[0], "");
                 if (reg->dimension == VSIR_DIMENSION_VEC4)
-                    shader_print_double_literal(compiler, ", ", reg->u.immconst_double[1], "");
+                    shader_print_double_literal(compiler, ", ", reg->u.immconst_f64[1], "");
+            }
+            else if (reg->data_type == VKD3D_DATA_UINT64)
+            {
+                shader_print_uint64_literal(compiler, "", reg->u.immconst_u64[0], "");
+                if (reg->dimension == VSIR_DIMENSION_VEC4)
+                    shader_print_uint64_literal(compiler, "", reg->u.immconst_u64[1], "");
             }
             else
             {
@@ -1265,6 +1351,32 @@ static void shader_print_non_uniform(struct vkd3d_d3d_asm_compiler *compiler, co
                 compiler->colours.modifier, compiler->colours.reset);
 }
 
+static void shader_dump_reg_type(struct vkd3d_d3d_asm_compiler *compiler,
+        const struct vkd3d_shader_register *reg)
+{
+    static const char *dimensions[] =
+    {
+        [VSIR_DIMENSION_NONE]   = "",
+        [VSIR_DIMENSION_SCALAR] = "s:",
+        [VSIR_DIMENSION_VEC4]   = "v4:",
+    };
+
+    struct vkd3d_string_buffer *buffer = &compiler->buffer;
+    const char *dimension;
+
+    if (compiler->dialect != VSIR_ASM_VSIR)
+        return;
+
+    if (reg->dimension < ARRAY_SIZE(dimensions))
+        dimension = dimensions[reg->dimension];
+    else
+        dimension = "??";
+
+    shader_addline(buffer, " <%s", dimension);
+    shader_dump_data_type(compiler, reg->data_type);
+    shader_addline(buffer, ">");
+}
+
 static void shader_dump_dst_param(struct vkd3d_d3d_asm_compiler *compiler,
         const struct vkd3d_shader_dst_param *param, bool is_declaration)
 {
@@ -1278,7 +1390,7 @@ static void shader_dump_dst_param(struct vkd3d_d3d_asm_compiler *compiler,
         static const char write_mask_chars[] = "xyzw";
 
         if (param->reg.data_type == VKD3D_DATA_DOUBLE)
-            write_mask = vkd3d_write_mask_32_from_64(write_mask);
+            write_mask = vsir_write_mask_32_from_64(write_mask);
 
         shader_addline(buffer, ".%s", compiler->colours.write_mask);
         if (write_mask & VKD3DSP_WRITEMASK_0)
@@ -1294,6 +1406,7 @@ static void shader_dump_dst_param(struct vkd3d_d3d_asm_compiler *compiler,
 
     shader_print_precision(compiler, &param->reg);
     shader_print_non_uniform(compiler, &param->reg);
+    shader_dump_reg_type(compiler, &param->reg);
 }
 
 static void shader_dump_src_param(struct vkd3d_d3d_asm_compiler *compiler,
@@ -1341,10 +1454,10 @@ static void shader_dump_src_param(struct vkd3d_d3d_asm_compiler *compiler,
     if (param->reg.type != VKD3DSPR_IMMCONST && param->reg.type != VKD3DSPR_IMMCONST64
             && param->reg.dimension == VSIR_DIMENSION_VEC4)
     {
-        unsigned int swizzle_x = vkd3d_swizzle_get_component(swizzle, 0);
-        unsigned int swizzle_y = vkd3d_swizzle_get_component(swizzle, 1);
-        unsigned int swizzle_z = vkd3d_swizzle_get_component(swizzle, 2);
-        unsigned int swizzle_w = vkd3d_swizzle_get_component(swizzle, 3);
+        unsigned int swizzle_x = vsir_swizzle_get_component(swizzle, 0);
+        unsigned int swizzle_y = vsir_swizzle_get_component(swizzle, 1);
+        unsigned int swizzle_z = vsir_swizzle_get_component(swizzle, 2);
+        unsigned int swizzle_w = vsir_swizzle_get_component(swizzle, 3);
 
         static const char swizzle_chars[] = "xyzw";
 
@@ -1367,6 +1480,7 @@ static void shader_dump_src_param(struct vkd3d_d3d_asm_compiler *compiler,
 
     shader_print_precision(compiler, &param->reg);
     shader_print_non_uniform(compiler, &param->reg);
+    shader_dump_reg_type(compiler, &param->reg);
 }
 
 static void shader_dump_ins_modifiers(struct vkd3d_d3d_asm_compiler *compiler,
@@ -1577,6 +1691,12 @@ static void shader_dump_instruction_flags(struct vkd3d_d3d_asm_compiler *compile
                 shader_addline(buffer, "p");
             break;
 
+        case VKD3DSIH_ISHL:
+        case VKD3DSIH_ISHR:
+        case VKD3DSIH_USHR:
+            if (ins->flags & VKD3DSI_SHIFT_UNMASKED)
+                shader_addline(buffer, "_unmasked");
+            /* fall through */
         default:
             shader_dump_precise_flags(compiler, ins->flags);
             break;
@@ -1631,6 +1751,8 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
     struct vkd3d_string_buffer *buffer = &compiler->buffer;
     unsigned int i;
 
+    compiler->current = ins;
+
     if (ins->predicate)
     {
         vkd3d_string_buffer_printf(buffer, "(");
@@ -1835,25 +1957,25 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
             vkd3d_string_buffer_printf(buffer, " %sc%u%s", compiler->colours.reg,
                     shader_get_float_offset(ins->dst[0].reg.type, ins->dst[0].reg.idx[0].offset),
                     compiler->colours.reset);
-            shader_print_float_literal(compiler, " = ", ins->src[0].reg.u.immconst_float[0], "");
-            shader_print_float_literal(compiler, ", ", ins->src[0].reg.u.immconst_float[1], "");
-            shader_print_float_literal(compiler, ", ", ins->src[0].reg.u.immconst_float[2], "");
-            shader_print_float_literal(compiler, ", ", ins->src[0].reg.u.immconst_float[3], "");
+            shader_print_float_literal(compiler, " = ", ins->src[0].reg.u.immconst_f32[0], "");
+            shader_print_float_literal(compiler, ", ", ins->src[0].reg.u.immconst_f32[1], "");
+            shader_print_float_literal(compiler, ", ", ins->src[0].reg.u.immconst_f32[2], "");
+            shader_print_float_literal(compiler, ", ", ins->src[0].reg.u.immconst_f32[3], "");
             break;
 
         case VKD3DSIH_DEFI:
             vkd3d_string_buffer_printf(buffer, " %si%u%s", compiler->colours.reg,
                     ins->dst[0].reg.idx[0].offset, compiler->colours.reset);
-            shader_print_int_literal(compiler, " = ", ins->src[0].reg.u.immconst_uint[0], "");
-            shader_print_int_literal(compiler, ", ", ins->src[0].reg.u.immconst_uint[1], "");
-            shader_print_int_literal(compiler, ", ", ins->src[0].reg.u.immconst_uint[2], "");
-            shader_print_int_literal(compiler, ", ", ins->src[0].reg.u.immconst_uint[3], "");
+            shader_print_int_literal(compiler, " = ", ins->src[0].reg.u.immconst_u32[0], "");
+            shader_print_int_literal(compiler, ", ", ins->src[0].reg.u.immconst_u32[1], "");
+            shader_print_int_literal(compiler, ", ", ins->src[0].reg.u.immconst_u32[2], "");
+            shader_print_int_literal(compiler, ", ", ins->src[0].reg.u.immconst_u32[3], "");
             break;
 
         case VKD3DSIH_DEFB:
             vkd3d_string_buffer_printf(buffer, " %sb%u%s", compiler->colours.reg,
                     ins->dst[0].reg.idx[0].offset, compiler->colours.reset);
-            shader_print_bool_literal(compiler, " = ", ins->src[0].reg.u.immconst_uint[0], "");
+            shader_print_bool_literal(compiler, " = ", ins->src[0].reg.u.immconst_u32[0], "");
             break;
 
         default:
@@ -1883,7 +2005,7 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
                     || ins->resource_data_type[1] != VKD3D_DATA_FLOAT
                     || ins->resource_data_type[2] != VKD3D_DATA_FLOAT
                     || ins->resource_data_type[3] != VKD3D_DATA_FLOAT)
-                shader_dump_data_type(compiler, ins->resource_data_type);
+                shader_dump_resource_data_type(compiler, ins->resource_data_type);
 
             for (i = 0; i < ins->dst_count; ++i)
             {
@@ -1904,12 +2026,16 @@ static void shader_dump_instruction(struct vkd3d_d3d_asm_compiler *compiler,
     shader_addline(buffer, "\n");
 }
 
-enum vkd3d_result vkd3d_dxbc_binary_to_text(const struct vkd3d_shader_instruction_array *instructions,
-        const struct vkd3d_shader_version *shader_version, const struct vkd3d_shader_compile_info *compile_info,
-        struct vkd3d_shader_code *out)
+enum vkd3d_result vkd3d_dxbc_binary_to_text(const struct vsir_program *program,
+        const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_code *out, enum vsir_asm_dialect dialect)
 {
+    const struct vkd3d_shader_version *shader_version = &program->shader_version;
     enum vkd3d_shader_compile_option_formatting_flags formatting;
-    struct vkd3d_d3d_asm_compiler compiler;
+    struct vkd3d_d3d_asm_compiler compiler =
+    {
+        .dialect = dialect,
+    };
     enum vkd3d_result result = VKD3D_OK;
     struct vkd3d_string_buffer *buffer;
     unsigned int indent, i, j;
@@ -1973,9 +2099,9 @@ enum vkd3d_result vkd3d_dxbc_binary_to_text(const struct vkd3d_shader_instructio
             shader_version->minor, compiler.colours.reset);
 
     indent = 0;
-    for (i = 0; i < instructions->count; ++i)
+    for (i = 0; i < program->instructions.count; ++i)
     {
-        struct vkd3d_shader_instruction *ins = &instructions->elements[i];
+        struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
 
         switch (ins->handler_idx)
         {
@@ -2002,6 +2128,7 @@ enum vkd3d_result vkd3d_dxbc_binary_to_text(const struct vkd3d_shader_instructio
         {
             case VKD3DSIH_ELSE:
             case VKD3DSIH_IF:
+            case VKD3DSIH_IFC:
             case VKD3DSIH_LOOP:
             case VKD3DSIH_SWITCH:
                 ++indent;
@@ -2028,13 +2155,12 @@ enum vkd3d_result vkd3d_dxbc_binary_to_text(const struct vkd3d_shader_instructio
     return result;
 }
 
-void vkd3d_shader_trace(const struct vkd3d_shader_instruction_array *instructions,
-        const struct vkd3d_shader_version *shader_version)
+void vkd3d_shader_trace(const struct vsir_program *program)
 {
     const char *p, *q, *end;
     struct vkd3d_shader_code code;
 
-    if (vkd3d_dxbc_binary_to_text(instructions, shader_version, NULL, &code) != VKD3D_OK)
+    if (vkd3d_dxbc_binary_to_text(program, NULL, &code, VSIR_ASM_VSIR) != VKD3D_OK)
         return;
 
     end = (const char *)code.code + code.size;
diff --git a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
index 3d13941..4ba001e 100644
--- a/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/d3dbc.c
@@ -414,6 +414,7 @@ static bool has_relative_address(uint32_t param)
 static const struct vkd3d_sm1_opcode_info *shader_sm1_get_opcode_info(
         const struct vkd3d_shader_sm1_parser *sm1, enum vkd3d_sm1_opcode opcode)
 {
+    const struct vkd3d_shader_version *version = &sm1->p.program.shader_version;
     const struct vkd3d_sm1_opcode_info *info;
     unsigned int i = 0;
 
@@ -424,8 +425,8 @@ static const struct vkd3d_sm1_opcode_info *shader_sm1_get_opcode_info(
             return NULL;
 
         if (opcode == info->sm1_opcode
-                && vkd3d_shader_ver_ge(&sm1->p.shader_version, info->min_version.major, info->min_version.minor)
-                && (vkd3d_shader_ver_le(&sm1->p.shader_version, info->max_version.major, info->max_version.minor)
+                && vkd3d_shader_ver_ge(version, info->min_version.major, info->min_version.minor)
+                && (vkd3d_shader_ver_le(version, info->max_version.major, info->max_version.minor)
                         || !info->max_version.major))
             return info;
     }
@@ -444,7 +445,7 @@ static uint32_t swizzle_from_sm1(uint32_t swizzle)
             shader_sm1_get_swizzle_component(swizzle, 3));
 }
 
-static void shader_sm1_parse_src_param(uint32_t param, const struct vkd3d_shader_src_param *rel_addr,
+static void shader_sm1_parse_src_param(uint32_t param, struct vkd3d_shader_src_param *rel_addr,
         struct vkd3d_shader_src_param *src)
 {
     enum vkd3d_shader_register_type reg_type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
@@ -465,7 +466,7 @@ static void shader_sm1_parse_src_param(uint32_t param, const struct vkd3d_shader
     src->modifiers = (param & VKD3D_SM1_SRC_MODIFIER_MASK) >> VKD3D_SM1_SRC_MODIFIER_SHIFT;
 }
 
-static void shader_sm1_parse_dst_param(uint32_t param, const struct vkd3d_shader_src_param *rel_addr,
+static void shader_sm1_parse_dst_param(uint32_t param, struct vkd3d_shader_src_param *rel_addr,
         struct vkd3d_shader_dst_param *dst)
 {
     enum vkd3d_shader_register_type reg_type = ((param & VKD3D_SM1_REGISTER_TYPE_MASK) >> VKD3D_SM1_REGISTER_TYPE_SHIFT)
@@ -482,9 +483,23 @@ static void shader_sm1_parse_dst_param(uint32_t param, const struct vkd3d_shader
         dst->reg.dimension = VSIR_DIMENSION_SCALAR;
     else
         dst->reg.dimension = VSIR_DIMENSION_VEC4;
-    dst->write_mask = (param & VKD3D_SM1_WRITEMASK_MASK) >> VKD3D_SM1_WRITEMASK_SHIFT;
     dst->modifiers = (param & VKD3D_SM1_DST_MODIFIER_MASK) >> VKD3D_SM1_DST_MODIFIER_SHIFT;
     dst->shift = (param & VKD3D_SM1_DSTSHIFT_MASK) >> VKD3D_SM1_DSTSHIFT_SHIFT;
+
+    switch (dst->reg.dimension)
+    {
+        case VSIR_DIMENSION_SCALAR:
+            dst->write_mask = VKD3DSP_WRITEMASK_0;
+            break;
+
+        case VSIR_DIMENSION_VEC4:
+            dst->write_mask = (param & VKD3D_SM1_WRITEMASK_MASK) >> VKD3D_SM1_WRITEMASK_SHIFT;
+            break;
+
+        default:
+            dst->write_mask = 0;
+            break;
+    }
 }
 
 static struct signature_element *find_signature_element(const struct shader_signature *signature,
@@ -518,8 +533,6 @@ static struct signature_element *find_signature_element_by_register_index(
     return NULL;
 }
 
-#define SM1_COLOR_REGISTER_OFFSET 8
-
 static bool add_signature_element(struct vkd3d_shader_sm1_parser *sm1, bool output,
         const char *name, unsigned int index, enum vkd3d_shader_sysval_semantic sysval,
         unsigned int register_index, bool is_dcl, unsigned int mask)
@@ -555,7 +568,7 @@ static bool add_signature_element(struct vkd3d_shader_sm1_parser *sm1, bool outp
     element->register_count = 1;
     element->mask = mask;
     element->used_mask = is_dcl ? 0 : mask;
-    if (sm1->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL && !output)
+    if (sm1->p.program.shader_version.type == VKD3D_SHADER_TYPE_PIXEL && !output)
         element->interpolation_mode = VKD3DSIM_LINEAR;
 
     return true;
@@ -585,20 +598,20 @@ static void add_signature_mask(struct vkd3d_shader_sm1_parser *sm1, bool output,
 static bool add_signature_element_from_register(struct vkd3d_shader_sm1_parser *sm1,
         const struct vkd3d_shader_register *reg, bool is_dcl, unsigned int mask)
 {
+    const struct vkd3d_shader_version *version = &sm1->p.program.shader_version;
     unsigned int register_index = reg->idx[0].offset;
 
     switch (reg->type)
     {
         case VKD3DSPR_TEMP:
-            if (sm1->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL
-                    && sm1->p.shader_version.major == 1 && !register_index)
+            if (version->type == VKD3D_SHADER_TYPE_PIXEL && version->major == 1 && !register_index)
                 return add_signature_element(sm1, true, "COLOR", 0, VKD3D_SHADER_SV_TARGET, 0, is_dcl, mask);
             return true;
 
         case VKD3DSPR_INPUT:
             /* For vertex shaders or sm3 pixel shaders, we should have already
              * had a DCL instruction. Otherwise, this is a colour input. */
-            if (sm1->p.shader_version.type == VKD3D_SHADER_TYPE_VERTEX || sm1->p.shader_version.major == 3)
+            if (version->type == VKD3D_SHADER_TYPE_VERTEX || version->major == 3)
             {
                 add_signature_mask(sm1, false, register_index, mask);
                 return true;
@@ -608,19 +621,19 @@ static bool add_signature_element_from_register(struct vkd3d_shader_sm1_parser *
 
         case VKD3DSPR_TEXTURE:
             /* For vertex shaders, this is ADDR. */
-            if (sm1->p.shader_version.type == VKD3D_SHADER_TYPE_VERTEX)
+            if (version->type == VKD3D_SHADER_TYPE_VERTEX)
                 return true;
             return add_signature_element(sm1, false, "TEXCOORD", register_index,
                     VKD3D_SHADER_SV_NONE, register_index, is_dcl, mask);
 
         case VKD3DSPR_OUTPUT:
-            if (sm1->p.shader_version.type == VKD3D_SHADER_TYPE_VERTEX)
+            if (version->type == VKD3D_SHADER_TYPE_VERTEX)
             {
                 /* For sm < 2 vertex shaders, this is TEXCRDOUT.
                  *
                  * For sm3 vertex shaders, this is OUTPUT, but we already
                  * should have had a DCL instruction. */
-                if (sm1->p.shader_version.major == 3)
+                if (version->major == 3)
                 {
                     add_signature_mask(sm1, true, register_index, mask);
                     return true;
@@ -647,15 +660,15 @@ static bool add_signature_element_from_register(struct vkd3d_shader_sm1_parser *
             {
                 case 0:
                     return add_signature_element(sm1, true, "POSITION", 0,
-                            VKD3D_SHADER_SV_POSITION, register_index, is_dcl, mask);
+                            VKD3D_SHADER_SV_POSITION, SM1_RASTOUT_REGISTER_OFFSET + register_index, is_dcl, mask);
 
                 case 1:
                     return add_signature_element(sm1, true, "FOG", 0,
-                            VKD3D_SHADER_SV_NONE, register_index, is_dcl, 0x1);
+                            VKD3D_SHADER_SV_NONE, SM1_RASTOUT_REGISTER_OFFSET + register_index, is_dcl, 0x1);
 
                 case 2:
                     return add_signature_element(sm1, true, "PSIZE", 0,
-                            VKD3D_SHADER_SV_NONE, register_index, is_dcl, 0x1);
+                            VKD3D_SHADER_SV_NONE, SM1_RASTOUT_REGISTER_OFFSET + register_index, is_dcl, 0x1);
 
                 default:
                     vkd3d_shader_parser_error(&sm1->p, VKD3D_SHADER_ERROR_D3DBC_INVALID_REGISTER_INDEX,
@@ -688,6 +701,7 @@ static bool add_signature_element_from_register(struct vkd3d_shader_sm1_parser *
 static bool add_signature_element_from_semantic(struct vkd3d_shader_sm1_parser *sm1,
         const struct vkd3d_shader_semantic *semantic)
 {
+    const struct vkd3d_shader_version *version = &sm1->p.program.shader_version;
     const struct vkd3d_shader_register *reg = &semantic->resource.reg.reg;
     enum vkd3d_shader_sysval_semantic sysval = VKD3D_SHADER_SV_NONE;
     unsigned int mask = semantic->resource.reg.write_mask;
@@ -719,13 +733,13 @@ static bool add_signature_element_from_semantic(struct vkd3d_shader_sm1_parser *
         return add_signature_element_from_register(sm1, reg, true, mask);
 
     /* sm2 pixel shaders use DCL but don't provide a semantic. */
-    if (sm1->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL && sm1->p.shader_version.major == 2)
+    if (version->type == VKD3D_SHADER_TYPE_PIXEL && version->major == 2)
         return add_signature_element_from_register(sm1, reg, true, mask);
 
     /* With the exception of vertex POSITION output, none of these are system
      * values. Pixel POSITION input is not equivalent to SV_Position; the closer
      * equivalent is VPOS, which is not declared as a semantic. */
-    if (sm1->p.shader_version.type == VKD3D_SHADER_TYPE_VERTEX
+    if (version->type == VKD3D_SHADER_TYPE_VERTEX
             && output && semantic->usage == VKD3D_DECL_USAGE_POSITION)
         sysval = VKD3D_SHADER_SV_POSITION;
 
@@ -751,13 +765,13 @@ static void record_constant_register(struct vkd3d_shader_sm1_parser *sm1,
 static void shader_sm1_scan_register(struct vkd3d_shader_sm1_parser *sm1,
         const struct vkd3d_shader_register *reg, unsigned int mask, bool from_def)
 {
-    struct vkd3d_shader_desc *desc = &sm1->p.shader_desc;
+    struct vsir_program *program = &sm1->p.program;
     uint32_t register_index = reg->idx[0].offset;
 
     switch (reg->type)
     {
         case VKD3DSPR_TEMP:
-            desc->temp_count = max(desc->temp_count, register_index + 1);
+            program->temp_count = max(program->temp_count, register_index + 1);
             break;
 
         case VKD3DSPR_CONST:
@@ -812,7 +826,7 @@ static void shader_sm1_read_param(struct vkd3d_shader_sm1_parser *sm1,
      * VS >= 2.0 have relative addressing (with token)
      * VS >= 1.0 < 2.0 have relative addressing (without token)
      * The version check below should work in general. */
-    if (sm1->p.shader_version.major < 2)
+    if (sm1->p.program.shader_version.major < 2)
     {
         *addr_token = (1u << 31)
                 | ((VKD3DSPR_ADDR << VKD3D_SM1_REGISTER_TYPE_SHIFT2) & VKD3D_SM1_REGISTER_TYPE_MASK2)
@@ -841,7 +855,7 @@ static void shader_sm1_skip_opcode(const struct vkd3d_shader_sm1_parser *sm1, co
     /* Version 2.0+ shaders may contain address tokens, but fortunately they
      * have a useful length mask - use it here. Version 1.x shaders contain no
      * such tokens. */
-    if (sm1->p.shader_version.major >= 2)
+    if (sm1->p.program.shader_version.major >= 2)
     {
         length = (opcode_token & VKD3D_SM1_INSTRUCTION_LENGTH_MASK) >> VKD3D_SM1_INSTRUCTION_LENGTH_SHIFT;
         *ptr += length;
@@ -871,7 +885,7 @@ static void shader_sm1_destroy(struct vkd3d_shader_parser *parser)
 {
     struct vkd3d_shader_sm1_parser *sm1 = vkd3d_shader_sm1_parser(parser);
 
-    shader_instruction_array_destroy(&parser->instructions);
+    vsir_program_cleanup(&parser->program);
     free_shader_desc(&sm1->p.shader_desc);
     vkd3d_free(sm1);
 }
@@ -987,7 +1001,7 @@ static void shader_sm1_read_immconst(struct vkd3d_shader_sm1_parser *sm1, const
     src_param->reg.idx[2].rel_addr = NULL;
     src_param->reg.idx_count = 0;
     src_param->reg.dimension = dimension;
-    memcpy(src_param->reg.u.immconst_uint, *ptr, count * sizeof(uint32_t));
+    memcpy(src_param->reg.u.immconst_u32, *ptr, count * sizeof(uint32_t));
     src_param->swizzle = VKD3D_SHADER_NO_SWIZZLE;
     src_param->modifiers = 0;
 
@@ -1063,12 +1077,12 @@ static void shader_sm1_validate_instruction(struct vkd3d_shader_sm1_parser *sm1,
     }
 }
 
-static unsigned int mask_from_swizzle(unsigned int swizzle)
+static unsigned int mask_from_swizzle(uint32_t swizzle)
 {
-    return (1u << vkd3d_swizzle_get_component(swizzle, 0))
-            | (1u << vkd3d_swizzle_get_component(swizzle, 1))
-            | (1u << vkd3d_swizzle_get_component(swizzle, 2))
-            | (1u << vkd3d_swizzle_get_component(swizzle, 3));
+    return (1u << vsir_swizzle_get_component(swizzle, 0))
+            | (1u << vsir_swizzle_get_component(swizzle, 1))
+            | (1u << vsir_swizzle_get_component(swizzle, 2))
+            | (1u << vsir_swizzle_get_component(swizzle, 3));
 }
 
 static void shader_sm1_read_instruction(struct vkd3d_shader_sm1_parser *sm1, struct vkd3d_shader_instruction *ins)
@@ -1097,7 +1111,7 @@ static void shader_sm1_read_instruction(struct vkd3d_shader_sm1_parser *sm1, str
         vkd3d_shader_parser_error(&sm1->p, VKD3D_SHADER_ERROR_D3DBC_INVALID_OPCODE,
                 "Invalid opcode %#x (token 0x%08x, shader version %u.%u).",
                 opcode_token & VKD3D_SM1_OPCODE_MASK, opcode_token,
-                sm1->p.shader_version.major, sm1->p.shader_version.minor);
+                sm1->p.program.shader_version.major, sm1->p.program.shader_version.minor);
         goto fail;
     }
 
@@ -1322,7 +1336,7 @@ int vkd3d_shader_sm1_parser_create(const struct vkd3d_shader_compile_info *compi
         return ret;
     }
 
-    instructions = &sm1->p.instructions;
+    instructions = &sm1->p.program.instructions;
     while (!shader_sm1_is_end(sm1))
     {
         if (!shader_instruction_array_reserve(instructions, instructions->count + 1))
@@ -1348,18 +1362,21 @@ int vkd3d_shader_sm1_parser_create(const struct vkd3d_shader_compile_info *compi
         sm1->p.shader_desc.flat_constant_count[i].external = get_external_constant_count(sm1, i);
 
     if (!sm1->p.failed)
-        vsir_validate(&sm1->p);
+        ret = vsir_validate(&sm1->p);
+
+    if (sm1->p.failed && ret >= 0)
+        ret = VKD3D_ERROR_INVALID_SHADER;
 
-    if (sm1->p.failed)
+    if (ret < 0)
     {
         WARN("Failed to parse shader.\n");
         shader_sm1_destroy(&sm1->p);
-        return VKD3D_ERROR_INVALID_SHADER;
+        return ret;
     }
 
     *parser = &sm1->p;
 
-    return VKD3D_OK;
+    return ret;
 }
 
 bool hlsl_sm1_register_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_semantic *semantic,
@@ -1374,7 +1391,7 @@ bool hlsl_sm1_register_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_sem
         enum vkd3d_shader_type shader_type;
         unsigned int major_version;
         D3DSHADER_PARAM_REGISTER_TYPE type;
-        DWORD offset;
+        unsigned int offset;
     }
     register_table[] =
     {
@@ -2253,7 +2270,7 @@ static void write_sm1_jump(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *b
         {
             struct hlsl_reg *reg = &jump->condition.node->reg;
 
-            struct sm1_instruction instr =
+            struct sm1_instruction sm1_instr =
             {
                 .opcode = D3DSIO_TEXKILL,
 
@@ -2263,7 +2280,7 @@ static void write_sm1_jump(struct hlsl_ctx *ctx, struct vkd3d_bytecode_buffer *b
                 .has_dst = 1,
             };
 
-            write_sm1_instruction(ctx, buffer, &instr);
+            write_sm1_instruction(ctx, buffer, &sm1_instr);
             break;
         }
 
@@ -2328,8 +2345,6 @@ static void write_sm1_resource_load(struct hlsl_ctx *ctx, struct vkd3d_bytecode_
 
     sm1_instr = (struct sm1_instruction)
     {
-        .opcode = D3DSIO_TEX,
-
         .dst.type = D3DSPR_TEMP,
         .dst.reg = instr->reg.id,
         .dst.writemask = instr->reg.writemask,
@@ -2345,8 +2360,22 @@ static void write_sm1_resource_load(struct hlsl_ctx *ctx, struct vkd3d_bytecode_
 
         .src_count = 2,
     };
-    if (load->load_type == HLSL_RESOURCE_SAMPLE_PROJ)
-        sm1_instr.opcode |= VKD3DSI_TEXLD_PROJECT << VKD3D_SM1_INSTRUCTION_FLAGS_SHIFT;
+
+    switch (load->load_type)
+    {
+        case HLSL_RESOURCE_SAMPLE:
+            sm1_instr.opcode = D3DSIO_TEX;
+            break;
+
+        case HLSL_RESOURCE_SAMPLE_PROJ:
+            sm1_instr.opcode = D3DSIO_TEX;
+            sm1_instr.opcode |= VKD3DSI_TEXLD_PROJECT << VKD3D_SM1_INSTRUCTION_FLAGS_SHIFT;
+            break;
+
+        default:
+            hlsl_fixme(ctx, &instr->loc, "Resource load type %u\n", load->load_type);
+            return;
+    }
 
     assert(instr->reg.allocated);
 
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxbc.c b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
index 7834c1e..37ebc73 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxbc.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxbc.c
@@ -130,13 +130,13 @@ static void skip_dword_unknown(const char **ptr, unsigned int count)
     }
 }
 
-static const char *shader_get_string(const char *data, size_t data_size, DWORD offset)
+static const char *shader_get_string(const char *data, size_t data_size, size_t offset)
 {
     size_t len, max_len;
 
     if (offset >= data_size)
     {
-        WARN("Invalid offset %#x (data size %#lx).\n", offset, (long)data_size);
+        WARN("Invalid offset %#zx (data size %#zx).\n", offset, data_size);
         return NULL;
     }
 
@@ -230,7 +230,7 @@ static int parse_dxbc(const struct vkd3d_shader_code *dxbc, struct vkd3d_shader_
         chunk_offset = read_u32(&ptr);
         TRACE("chunk %u at offset %#x\n", i, chunk_offset);
 
-        if (chunk_offset >= data_size || !require_space(chunk_offset, 2, sizeof(DWORD), data_size))
+        if (chunk_offset >= data_size || !require_space(chunk_offset, 2, sizeof(uint32_t), data_size))
         {
             WARN("Invalid chunk offset %#x (data size %zu).\n", chunk_offset, data_size);
             vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXBC_INVALID_CHUNK_OFFSET,
@@ -399,7 +399,8 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
 
     for (i = 0; i < count; ++i)
     {
-        uint32_t name_offset, mask;
+        size_t name_offset;
+        uint32_t mask;
 
         e[i].sort_index = i;
 
@@ -411,7 +412,7 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
         name_offset = read_u32(&ptr);
         if (!(e[i].semantic_name = shader_get_string(data, section->data.size, name_offset)))
         {
-            WARN("Invalid name offset %#x (data size %#zx).\n", name_offset, section->data.size);
+            WARN("Invalid name offset %#zx (data size %#zx).\n", name_offset, section->data.size);
             vkd3d_free(e);
             return VKD3D_ERROR_INVALID_ARGUMENT;
         }
@@ -431,10 +432,6 @@ static int shader_parse_signature(const struct vkd3d_shader_dxbc_section_desc *s
             case TAG_OSG5:
                 if (e[i].sysval_semantic == VKD3D_SHADER_SV_NONE)
                     e[i].sysval_semantic = map_fragment_output_sysval(e[i].semantic_name);
-                /* Fall through. */
-            case TAG_PCSG:
-            case TAG_PSG1:
-                e[i].used_mask = e[i].mask & ~e[i].used_mask;
                 break;
         }
 
@@ -596,7 +593,7 @@ static int shader_parse_descriptor_ranges(struct root_signature_parser_context *
     const char *ptr;
     unsigned int i;
 
-    if (!require_space(offset, 5 * count, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 5 * count, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u, count %u).\n", context->data_size, offset, count);
         return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -627,7 +624,8 @@ static void shader_validate_descriptor_range1(const struct vkd3d_shader_descript
             | VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE
             | VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE
             | VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE
-            | VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
+            | VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DATA_STATIC
+            | VKD3D_SHADER_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS);
 
     if (unknown_flags)
         FIXME("Unknown descriptor range flags %#x.\n", unknown_flags);
@@ -674,7 +672,7 @@ static int shader_parse_descriptor_table(struct root_signature_parser_context *c
     unsigned int count;
     const char *ptr;
 
-    if (!require_space(offset, 2, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 2, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u).\n", context->data_size, offset);
         return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -701,7 +699,7 @@ static int shader_parse_descriptor_table1(struct root_signature_parser_context *
     unsigned int count;
     const char *ptr;
 
-    if (!require_space(offset, 2, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 2, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u).\n", context->data_size, offset);
         return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -726,7 +724,7 @@ static int shader_parse_root_constants(struct root_signature_parser_context *con
 {
     const char *ptr;
 
-    if (!require_space(offset, 3, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 3, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u).\n", context->data_size, offset);
         return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -748,7 +746,7 @@ static int shader_parse_root_descriptor(struct root_signature_parser_context *co
 {
     const char *ptr;
 
-    if (!require_space(offset, 2, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 2, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u).\n", context->data_size, offset);
         return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -780,7 +778,7 @@ static int shader_parse_root_descriptor1(struct root_signature_parser_context *c
 {
     const char *ptr;
 
-    if (!require_space(offset, 3, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 3, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u).\n", context->data_size, offset);
         return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -806,7 +804,7 @@ static int shader_parse_root_parameters(struct root_signature_parser_context *co
     unsigned int i;
     int ret;
 
-    if (!require_space(offset, 3 * count, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 3 * count, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u, count %u).\n", context->data_size, offset, count);
         return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -848,13 +846,13 @@ static int shader_parse_root_parameters(struct root_signature_parser_context *co
 }
 
 static int shader_parse_root_parameters1(struct root_signature_parser_context *context,
-        uint32_t offset, DWORD count, struct vkd3d_shader_root_parameter1 *parameters)
+        uint32_t offset, unsigned int count, struct vkd3d_shader_root_parameter1 *parameters)
 {
     const char *ptr;
     unsigned int i;
     int ret;
 
-    if (!require_space(offset, 3 * count, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 3 * count, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u, count %u).\n", context->data_size, offset, count);
         return VKD3D_ERROR_INVALID_ARGUMENT;
@@ -901,7 +899,7 @@ static int shader_parse_static_samplers(struct root_signature_parser_context *co
     const char *ptr;
     unsigned int i;
 
-    if (!require_space(offset, 13 * count, sizeof(DWORD), context->data_size))
+    if (!require_space(offset, 13 * count, sizeof(uint32_t), context->data_size))
     {
         WARN("Invalid data size %#x (offset %u, count %u).\n", context->data_size, offset, count);
         return VKD3D_ERROR_INVALID_ARGUMENT;
diff --git a/libs/vkd3d/libs/vkd3d-shader/dxil.c b/libs/vkd3d/libs/vkd3d-shader/dxil.c
index beb9ae5..8a31d03 100644
--- a/libs/vkd3d/libs/vkd3d-shader/dxil.c
+++ b/libs/vkd3d/libs/vkd3d-shader/dxil.c
@@ -29,6 +29,9 @@ static const uint64_t MAX_ALIGNMENT_EXPONENT = 29;
 static const uint64_t GLOBALVAR_FLAG_IS_CONSTANT = 1;
 static const uint64_t GLOBALVAR_FLAG_EXPLICIT_TYPE = 2;
 static const unsigned int GLOBALVAR_ADDRESS_SPACE_SHIFT = 2;
+static const uint64_t ALLOCA_FLAG_IN_ALLOCA = 0x20;
+static const uint64_t ALLOCA_FLAG_EXPLICIT_TYPE = 0x40;
+static const uint64_t ALLOCA_ALIGNMENT_MASK = ALLOCA_FLAG_IN_ALLOCA - 1;
 static const unsigned int SHADER_DESCRIPTOR_TYPE_COUNT = 4;
 
 static const unsigned int dx_max_thread_group_size[3] = {1024, 1024, 64};
@@ -168,6 +171,35 @@ enum bitcode_linkage
     LINKAGE_INTERNAL  = 3,
 };
 
+enum dxil_resource_kind
+{
+    RESOURCE_KIND_INVALID                 =  0,
+    RESOURCE_KIND_TEXTURE1D               =  1,
+    RESOURCE_KIND_TEXTURE2D               =  2,
+    RESOURCE_KIND_TEXTURE2DMS             =  3,
+    RESOURCE_KIND_TEXTURE3D               =  4,
+    RESOURCE_KIND_TEXTURECUBE             =  5,
+    RESOURCE_KIND_TEXTURE1DARRAY          =  6,
+    RESOURCE_KIND_TEXTURE2DARRAY          =  7,
+    RESOURCE_KIND_TEXTURE2DMSARRAY        =  8,
+    RESOURCE_KIND_TEXTURECUBEARRAY        =  9,
+    RESOURCE_KIND_TYPEDBUFFER             = 10,
+    RESOURCE_KIND_RAWBUFFER               = 11,
+    RESOURCE_KIND_STRUCTUREDBUFFER        = 12,
+    RESOURCE_KIND_CBUFFER                 = 13,
+    RESOURCE_KIND_SAMPLER                 = 14,
+    RESOURCE_KIND_TBUFFER                 = 15,
+    RESOURCE_KIND_RTACCELERATIONSTRUCTURE = 16,
+    RESOURCE_KIND_FEEDBACKTEXTURE2D       = 17,
+    RESOURCE_KIND_FEEDBACKTEXTURE2DARRAY  = 18,
+};
+
+enum dxil_resource_type
+{
+    RESOURCE_TYPE_NON_RAW_STRUCTURED = 0,
+    RESOURCE_TYPE_RAW_STRUCTURED     = 1,
+};
+
 enum dxil_component_type
 {
     COMPONENT_TYPE_INVALID     =  0,
@@ -296,8 +328,41 @@ enum dx_intrinsic_opcode
 {
     DX_LOAD_INPUT                   =   4,
     DX_STORE_OUTPUT                 =   5,
+    DX_ISNAN                        =   8,
+    DX_ISINF                        =   9,
+    DX_ISFINITE                     =  10,
+    DX_COS                          =  12,
+    DX_SIN                          =  13,
+    DX_TAN                          =  14,
+    DX_EXP                          =  21,
+    DX_FRC                          =  22,
+    DX_LOG                          =  23,
+    DX_SQRT                         =  24,
+    DX_RSQRT                        =  25,
+    DX_ROUND_NE                     =  26,
+    DX_ROUND_NI                     =  27,
+    DX_ROUND_PI                     =  28,
+    DX_ROUND_Z                      =  29,
+    DX_BFREV                        =  30,
+    DX_COUNT_BITS                   =  31,
+    DX_FIRST_BIT_LO                 =  32,
+    DX_FIRST_BIT_HI                 =  33,
+    DX_FIRST_BIT_SHI                =  34,
+    DX_FMAX                         =  35,
+    DX_FMIN                         =  36,
+    DX_IMAX                         =  37,
+    DX_IMIN                         =  38,
+    DX_UMAX                         =  39,
+    DX_UMIN                         =  40,
     DX_CREATE_HANDLE                =  57,
     DX_CBUFFER_LOAD_LEGACY          =  59,
+    DX_BUFFER_LOAD                  =  68,
+    DX_DERIV_COARSEX                =  83,
+    DX_DERIV_COARSEY                =  84,
+    DX_DERIV_FINEX                  =  85,
+    DX_DERIV_FINEY                  =  86,
+    DX_LEGACY_F32TOF16              = 130,
+    DX_LEGACY_F16TOF32              = 131,
 };
 
 enum dxil_cast_code
@@ -439,6 +504,7 @@ struct dxil_record
 {
     unsigned int code;
     unsigned int operand_count;
+    const struct dxil_record *attachment;
     uint64_t operands[];
 };
 
@@ -448,18 +514,67 @@ struct sm6_symbol
     const char *name;
 };
 
+struct incoming_value
+{
+    const struct sm6_block *block;
+    struct vkd3d_shader_register reg;
+};
+
+struct sm6_phi
+{
+    struct vkd3d_shader_register reg;
+    struct incoming_value *incoming;
+    size_t incoming_capacity;
+    size_t incoming_count;
+};
+
+enum sm6_block_terminator_type
+{
+    TERMINATOR_UNCOND_BR,
+    TERMINATOR_COND_BR,
+    TERMINATOR_SWITCH,
+    TERMINATOR_RET,
+};
+
+struct terminator_case
+{
+    const struct sm6_block *block;
+    uint64_t value;
+    bool is_default;
+};
+
+struct sm6_block_terminator
+{
+    struct vkd3d_shader_register conditional_reg;
+    enum sm6_block_terminator_type type;
+    const struct sm6_block *true_block;
+    const struct sm6_block *false_block;
+    struct terminator_case *cases;
+    unsigned int case_count;
+};
+
 struct sm6_block
 {
     struct vkd3d_shader_instruction *instructions;
     size_t instruction_capacity;
     size_t instruction_count;
+
+    /* A nonzero id. */
+    unsigned int id;
+
+    struct sm6_phi *phi;
+    size_t phi_capacity;
+    size_t phi_count;
+
+    struct sm6_block_terminator terminator;
 };
 
 struct sm6_function
 {
     const struct sm6_value *declaration;
 
-    struct sm6_block *blocks[1];
+    struct sm6_block **blocks;
+    size_t block_capacity;
     size_t block_count;
 
     size_t value_count;
@@ -541,6 +656,11 @@ struct sm6_descriptor_info
     enum vkd3d_shader_descriptor_type type;
     unsigned int id;
     struct vkd3d_shader_register_range range;
+    enum vkd3d_shader_resource_type resource_type;
+    enum dxil_resource_kind kind;
+    enum vkd3d_data_type resource_data_type;
+    enum vkd3d_shader_register_type reg_type;
+    enum vkd3d_data_type reg_data_type;
 };
 
 struct sm6_parser
@@ -581,6 +701,7 @@ struct sm6_parser
     size_t descriptor_count;
 
     unsigned int indexable_temp_count;
+    unsigned int icb_count;
 
     struct sm6_value *values;
     size_t value_count;
@@ -796,6 +917,7 @@ static enum vkd3d_result sm6_parser_read_unabbrev_record(struct sm6_parser *sm6)
 
     record->code = code;
     record->operand_count = count;
+    record->attachment = NULL;
 
     for (i = 0; i < count; ++i)
         record->operands[i] = sm6_parser_read_vbr(sm6, 6);
@@ -1012,6 +1134,7 @@ static enum vkd3d_result sm6_parser_read_abbrev_record(struct sm6_parser *sm6, u
         if (!abbrev->operands[i + 1].read_operand(sm6, abbrev->operands[i + 1].context, &record->operands[i]))
             goto fail;
     record->operand_count = count;
+    record->attachment = NULL;
 
     /* An array can occur only as the last operand. */
     if (abbrev->is_array)
@@ -1210,7 +1333,7 @@ static size_t dxil_block_compute_module_decl_count(const struct dxil_block *bloc
     size_t i, count;
 
     for (i = 0, count = 0; i < block->record_count; ++i)
-        count += block->records[i]->code == MODULE_CODE_FUNCTION;
+        count += block->records[i]->code == MODULE_CODE_FUNCTION || block->records[i]->code == MODULE_CODE_GLOBALVAR;
     return count;
 }
 
@@ -1517,7 +1640,7 @@ static enum vkd3d_result sm6_parser_type_table_init(struct sm6_parser *sm6)
                     break;
                 }
 
-                if (!ascii_strcasecmp(struct_name, "dx.types.Handle"))
+                if (!strcmp(struct_name, "dx.types.Handle"))
                     sm6->handle_type = type;
 
                 type->u.struc->name = struct_name;
@@ -1572,6 +1695,11 @@ static bool sm6_type_is_bool_i16_i32_i64(const struct sm6_type *type)
     return type->class == TYPE_CLASS_INTEGER && (type->u.width == 1 || type->u.width >= 16);
 }
 
+static bool sm6_type_is_i16_i32_i64(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_INTEGER && type->u.width >= 16;
+}
+
 static bool sm6_type_is_bool(const struct sm6_type *type)
 {
     return type->class == TYPE_CLASS_INTEGER && type->u.width == 1;
@@ -1587,6 +1715,16 @@ static inline bool sm6_type_is_i32(const struct sm6_type *type)
     return type->class == TYPE_CLASS_INTEGER && type->u.width == 32;
 }
 
+static bool sm6_type_is_float(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_FLOAT && type->u.width == 32;
+}
+
+static bool sm6_type_is_f16_f32(const struct sm6_type *type)
+{
+    return type->class == TYPE_CLASS_FLOAT && (type->u.width == 16 || type->u.width == 32);
+}
+
 static inline bool sm6_type_is_floating_point(const struct sm6_type *type)
 {
     return type->class == TYPE_CLASS_FLOAT;
@@ -1844,12 +1982,12 @@ static unsigned int register_get_uint_value(const struct vkd3d_shader_register *
 
     if (reg->type == VKD3DSPR_IMMCONST64)
     {
-        if (reg->u.immconst_uint64[0] > UINT_MAX)
+        if (reg->u.immconst_u64[0] > UINT_MAX)
             FIXME("Truncating 64-bit value.\n");
-        return reg->u.immconst_uint64[0];
+        return reg->u.immconst_u64[0];
     }
 
-    return reg->u.immconst_uint[0];
+    return reg->u.immconst_u32[0];
 }
 
 static uint64_t register_get_uint64_value(const struct vkd3d_shader_register *reg)
@@ -1860,7 +1998,7 @@ static uint64_t register_get_uint64_value(const struct vkd3d_shader_register *re
     if (reg->dimension == VSIR_DIMENSION_VEC4)
         WARN("Returning vec4.x.\n");
 
-    return (reg->type == VKD3DSPR_IMMCONST64) ? reg->u.immconst_uint64[0] : reg->u.immconst_uint[0];
+    return (reg->type == VKD3DSPR_IMMCONST64) ? reg->u.immconst_u64[0] : reg->u.immconst_u32[0];
 }
 
 static inline bool sm6_value_is_function_dcl(const struct sm6_value *value)
@@ -1895,6 +2033,12 @@ static inline bool sm6_value_is_constant(const struct sm6_value *value)
     return sm6_value_is_register(value) && register_is_constant(&value->u.reg);
 }
 
+static bool sm6_value_is_constant_zero(const struct sm6_value *value)
+{
+    /* Constant vectors do not occur. */
+    return sm6_value_is_register(value) && register_is_scalar_constant_zero(&value->u.reg);
+}
+
 static inline bool sm6_value_is_undef(const struct sm6_value *value)
 {
     return sm6_value_is_register(value) && value->u.reg.type == VKD3DSPR_UNDEF;
@@ -1905,6 +2049,11 @@ static bool sm6_value_is_icb(const struct sm6_value *value)
     return value->value_type == VALUE_TYPE_ICB;
 }
 
+static bool sm6_value_is_ssa(const struct sm6_value *value)
+{
+    return sm6_value_is_register(value) && register_is_ssa(&value->u.reg);
+}
+
 static inline unsigned int sm6_value_get_constant_uint(const struct sm6_value *value)
 {
     if (!sm6_value_is_constant(value))
@@ -1912,11 +2061,25 @@ static inline unsigned int sm6_value_get_constant_uint(const struct sm6_value *v
     return register_get_uint_value(&value->u.reg);
 }
 
+static uint64_t sm6_value_get_constant_uint64(const struct sm6_value *value)
+{
+    if (!sm6_value_is_constant(value))
+        return UINT64_MAX;
+    return register_get_uint64_value(&value->u.reg);
+}
+
 static unsigned int sm6_parser_alloc_ssa_id(struct sm6_parser *sm6)
 {
     return sm6->ssa_next_id++;
 }
 
+static void instruction_init_with_resource(struct vkd3d_shader_instruction *ins,
+        enum vkd3d_shader_opcode handler_idx, const struct sm6_value *resource, struct sm6_parser *sm6)
+{
+    vsir_instruction_init(ins, &sm6->p.location, handler_idx);
+    ins->resource_type = resource->u.handle.d->resource_type;
+}
+
 static struct vkd3d_shader_src_param *instruction_src_params_alloc(struct vkd3d_shader_instruction *ins,
         unsigned int count, struct sm6_parser *sm6)
 {
@@ -2289,8 +2452,8 @@ static const struct sm6_value *sm6_parser_get_value_by_ref(struct sm6_parser *sm
 
 static bool sm6_parser_declare_function(struct sm6_parser *sm6, const struct dxil_record *record)
 {
+    const struct sm6_type *type, *ret_type;
     const unsigned int max_count = 15;
-    const struct sm6_type *ret_type;
     struct sm6_value *fn;
     unsigned int i, j;
 
@@ -2305,18 +2468,18 @@ static bool sm6_parser_declare_function(struct sm6_parser *sm6, const struct dxi
         fn->u.function.name = "";
     }
 
-    if (!(fn->type = sm6_parser_get_type(sm6, record->operands[0])))
+    if (!(type = sm6_parser_get_type(sm6, record->operands[0])))
         return false;
-    if (!sm6_type_is_function(fn->type))
+    if (!sm6_type_is_function(type))
     {
         WARN("Type is not a function.\n");
         return false;
     }
-    ret_type = fn->type->u.function->ret_type;
+    ret_type = type->u.function->ret_type;
 
-    if (!(fn->type = sm6_type_get_pointer_to_type(fn->type, ADDRESS_SPACE_DEFAULT, sm6)))
+    if (!(fn->type = sm6_type_get_pointer_to_type(type, ADDRESS_SPACE_DEFAULT, sm6)))
     {
-        WARN("Failed to get pointer type for type %u.\n", fn->type->class);
+        WARN("Failed to get pointer type for type %u.\n", type->class);
         return false;
     }
 
@@ -2412,7 +2575,7 @@ static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, co
         return VKD3D_ERROR_INVALID_SHADER;
     }
     size = max(size, sizeof(icb->data[0]));
-    count = type->u.array.count * size / sizeof(icb->data[0]);
+    count = operands ? type->u.array.count * size / sizeof(icb->data[0]) : 0;
 
     if (!(icb = vkd3d_malloc(offsetof(struct vkd3d_shader_immediate_constant_buffer, data[count]))))
     {
@@ -2421,7 +2584,7 @@ static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, co
                 "Out of memory allocating an immediate constant buffer of count %u.", count);
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
-    if (!shader_instruction_array_add_icb(&sm6->p.instructions, icb))
+    if (!shader_instruction_array_add_icb(&sm6->p.program.instructions, icb))
     {
         ERR("Failed to store icb object.\n");
         vkd3d_free(icb);
@@ -2433,9 +2596,14 @@ static enum vkd3d_result value_allocate_constant_array(struct sm6_value *dst, co
     dst->value_type = VALUE_TYPE_ICB;
     dst->u.icb = icb;
 
+    icb->register_idx = sm6->icb_count++;
     icb->data_type = vkd3d_data_type_from_sm6_type(elem_type);
     icb->element_count = type->u.array.count;
     icb->component_count = 1;
+    icb->is_null = !operands;
+
+    if (!operands)
+        return VKD3D_OK;
 
     count = type->u.array.count;
     if (size > sizeof(icb->data[0]))
@@ -2510,12 +2678,10 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
         switch (record->code)
         {
             case CST_CODE_NULL:
-                if (sm6_type_is_array(type))
+                if (sm6_type_is_array(type)
+                        && (ret = value_allocate_constant_array(dst, type, NULL, sm6)) < 0)
                 {
-                    FIXME("Constant null arrays are not supported.\n");
-                    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                            "Constant null arrays are not supported.");
-                    return VKD3D_ERROR_INVALID_SHADER;
+                    return ret;
                 }
                 /* For non-aggregates, register constant data is already zero-filled. */
                 break;
@@ -2532,9 +2698,9 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
 
                 value = decode_rotated_signed_value(record->operands[0]);
                 if (type->u.width <= 32)
-                    dst->u.reg.u.immconst_uint[0] = value & ((1ull << type->u.width) - 1);
+                    dst->u.reg.u.immconst_u32[0] = value & ((1ull << type->u.width) - 1);
                 else
-                    dst->u.reg.u.immconst_uint64[0] = value;
+                    dst->u.reg.u.immconst_u64[0] = value;
 
                 break;
 
@@ -2551,9 +2717,9 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
                 if (type->u.width == 16)
                     FIXME("Half float type is not supported yet.\n");
                 else if (type->u.width == 32)
-                    dst->u.reg.u.immconst_float[0] = bitcast_uint64_to_float(record->operands[0]);
+                    dst->u.reg.u.immconst_f32[0] = bitcast_uint64_to_float(record->operands[0]);
                 else if (type->u.width == 64)
-                    dst->u.reg.u.immconst_double[0] = bitcast_uint64_to_double(record->operands[0]);
+                    dst->u.reg.u.immconst_f64[0] = bitcast_uint64_to_double(record->operands[0]);
                 else
                     vkd3d_unreachable();
 
@@ -2588,6 +2754,13 @@ static enum vkd3d_result sm6_parser_constants_init(struct sm6_parser *sm6, const
                 break;
         }
 
+        if (record->attachment)
+        {
+            WARN("Ignoring metadata attachment.\n");
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                    "Ignoring a metadata attachment for a constant.");
+        }
+
         ++sm6->value_count;
     }
 
@@ -2607,12 +2780,12 @@ static bool bitcode_parse_alignment(uint64_t encoded_alignment, unsigned int *al
 
 static struct vkd3d_shader_instruction *sm6_parser_require_space(struct sm6_parser *sm6, size_t extra)
 {
-    if (!shader_instruction_array_reserve(&sm6->p.instructions, sm6->p.instructions.count + extra))
+    if (!shader_instruction_array_reserve(&sm6->p.program.instructions, sm6->p.program.instructions.count + extra))
     {
         ERR("Failed to allocate instruction.\n");
         return NULL;
     }
-    return &sm6->p.instructions.elements[sm6->p.instructions.count];
+    return &sm6->p.program.instructions.elements[sm6->p.program.instructions.count];
 }
 
 /* Space should be reserved before calling this. It is intended to require no checking of the returned pointer. */
@@ -2622,22 +2795,38 @@ static struct vkd3d_shader_instruction *sm6_parser_add_instruction(struct sm6_pa
     struct vkd3d_shader_instruction *ins = sm6_parser_require_space(sm6, 1);
     assert(ins);
     vsir_instruction_init(ins, &sm6->p.location, handler_idx);
-    ++sm6->p.instructions.count;
+    ++sm6->p.program.instructions.count;
     return ins;
 }
 
-static void sm6_parser_declare_indexable_temp(struct sm6_parser *sm6, const struct sm6_type *elem_type,
-        unsigned int count, unsigned int alignment, unsigned int init, struct sm6_value *dst)
+static void sm6_parser_declare_icb(struct sm6_parser *sm6, const struct sm6_type *elem_type, unsigned int count,
+        unsigned int alignment, unsigned int init, struct sm6_value *dst)
 {
     enum vkd3d_data_type data_type = vkd3d_data_type_from_sm6_type(elem_type);
     struct vkd3d_shader_instruction *ins;
 
-    ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_INDEXABLE_TEMP);
+    ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_IMMEDIATE_CONSTANT_BUFFER);
+    /* The icb value index will be resolved later so forward references can be handled. */
+    ins->declaration.icb = (void *)(intptr_t)init;
+    register_init_with_id(&dst->u.reg, VKD3DSPR_IMMCONSTBUFFER, data_type, init);
+}
+
+static void sm6_parser_declare_indexable_temp(struct sm6_parser *sm6, const struct sm6_type *elem_type,
+        unsigned int count, unsigned int alignment, bool has_function_scope, unsigned int init,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    enum vkd3d_data_type data_type = vkd3d_data_type_from_sm6_type(elem_type);
+
+    if (ins)
+        vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_DCL_INDEXABLE_TEMP);
+    else
+        ins = sm6_parser_add_instruction(sm6, VKD3DSIH_DCL_INDEXABLE_TEMP);
     ins->declaration.indexable_temp.register_idx = sm6->indexable_temp_count++;
     ins->declaration.indexable_temp.register_size = count;
     ins->declaration.indexable_temp.alignment = alignment;
     ins->declaration.indexable_temp.data_type = data_type;
     ins->declaration.indexable_temp.component_count = 1;
+    ins->declaration.indexable_temp.has_function_scope = has_function_scope;
     /* The initialiser value index will be resolved later so forward references can be handled. */
     ins->declaration.indexable_temp.initialiser = (void *)(uintptr_t)init;
 
@@ -2762,7 +2951,10 @@ static bool sm6_parser_declare_global(struct sm6_parser *sm6, const struct dxil_
 
     if (address_space == ADDRESS_SPACE_DEFAULT)
     {
-        sm6_parser_declare_indexable_temp(sm6, scalar_type, count, alignment, init, dst);
+        if (is_constant)
+            sm6_parser_declare_icb(sm6, scalar_type, count, alignment, init, dst);
+        else
+            sm6_parser_declare_indexable_temp(sm6, scalar_type, count, alignment, false, init, NULL, dst);
     }
     else if (address_space == ADDRESS_SPACE_GROUPSHARED)
     {
@@ -2790,31 +2982,37 @@ static const struct vkd3d_shader_immediate_constant_buffer *resolve_forward_init
 
     assert(index);
     --index;
-    if (!(value = sm6_parser_get_value_safe(sm6, index)) || !sm6_value_is_icb(value))
+    if (!(value = sm6_parser_get_value_safe(sm6, index)) || (!sm6_value_is_icb(value) && !sm6_value_is_undef(value)))
     {
         WARN("Invalid initialiser index %zu.\n", index);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
                 "Global variable initialiser value index %zu is invalid.", index);
         return NULL;
     }
-    else
+    else if (sm6_value_is_icb(value))
     {
         return value->u.icb;
     }
+    /* In VSIR, initialisation with undefined values of objects is implied, not explicit. */
+    return NULL;
 }
 
 static enum vkd3d_result sm6_parser_globals_init(struct sm6_parser *sm6)
 {
+    size_t i, count, base_value_idx = sm6->value_count;
     const struct dxil_block *block = &sm6->root_block;
     struct vkd3d_shader_instruction *ins;
     const struct dxil_record *record;
     enum vkd3d_result ret;
     uint64_t version;
-    size_t i;
 
     sm6->p.location.line = block->id;
     sm6->p.location.column = 0;
 
+    for (i = 0, count = 0; i < block->record_count; ++i)
+        count += block->records[i]->code == MODULE_CODE_GLOBALVAR;
+    sm6_parser_require_space(sm6, count);
+
     for (i = 0; i < block->record_count; ++i)
     {
         sm6->p.location.column = i;
@@ -2860,14 +3058,29 @@ static enum vkd3d_result sm6_parser_globals_init(struct sm6_parser *sm6)
     }
 
     /* Resolve initialiser forward references. */
-    for (i = 0; i < sm6->p.instructions.count; ++i)
+    for (i = 0; i < sm6->p.program.instructions.count; ++i)
     {
-        ins = &sm6->p.instructions.elements[i];
+        ins = &sm6->p.program.instructions.elements[i];
         if (ins->handler_idx == VKD3DSIH_DCL_INDEXABLE_TEMP && ins->declaration.indexable_temp.initialiser)
         {
             ins->declaration.indexable_temp.initialiser = resolve_forward_initialiser(
                     (uintptr_t)ins->declaration.indexable_temp.initialiser, sm6);
         }
+        else if (ins->handler_idx == VKD3DSIH_DCL_IMMEDIATE_CONSTANT_BUFFER)
+        {
+            ins->declaration.icb = resolve_forward_initialiser((uintptr_t)ins->declaration.icb, sm6);
+        }
+    }
+    for (i = base_value_idx; i < sm6->value_count; ++i)
+    {
+        const struct vkd3d_shader_immediate_constant_buffer *icb;
+        struct sm6_value *value = &sm6->values[i];
+
+        if (!sm6_value_is_register(value) || value->u.reg.type != VKD3DSPR_IMMCONSTBUFFER)
+            continue;
+
+        if ((icb = resolve_forward_initialiser(value->u.reg.idx[0].offset, sm6)))
+            value->u.reg.idx[0].offset = icb->register_idx;
     }
 
     return VKD3D_OK;
@@ -2908,45 +3121,6 @@ static void sm6_parser_init_signature(struct sm6_parser *sm6, const struct shade
     }
 }
 
-static void sm6_parser_emit_signature(struct sm6_parser *sm6, const struct shader_signature *s,
-        enum vkd3d_shader_opcode handler_idx, enum vkd3d_shader_opcode siv_handler_idx,
-        struct vkd3d_shader_dst_param *params)
-{
-    struct vkd3d_shader_instruction *ins;
-    struct vkd3d_shader_dst_param *param;
-    const struct signature_element *e;
-    unsigned int i;
-
-    for (i = 0; i < s->element_count; ++i)
-    {
-        e = &s->elements[i];
-
-        /* Do not check e->used_mask because in some cases it is zero for used elements.
-         * TODO: scan ahead for used I/O elements. */
-
-        if (e->sysval_semantic != VKD3D_SHADER_SV_NONE && e->sysval_semantic != VKD3D_SHADER_SV_TARGET)
-        {
-            ins = sm6_parser_add_instruction(sm6, siv_handler_idx);
-            param = &ins->declaration.register_semantic.reg;
-            ins->declaration.register_semantic.sysval_semantic = vkd3d_siv_from_sysval(e->sysval_semantic);
-        }
-        else
-        {
-            ins = sm6_parser_add_instruction(sm6, handler_idx);
-            param = &ins->declaration.dst;
-        }
-
-        ins->flags = e->interpolation_mode;
-        *param = params[i];
-
-        if (e->register_count > 1)
-        {
-            param->reg.idx[0].rel_addr = NULL;
-            param->reg.idx[0].offset = e->register_count;
-        }
-    }
-}
-
 static void sm6_parser_init_output_signature(struct sm6_parser *sm6, const struct shader_signature *output_signature)
 {
     sm6_parser_init_signature(sm6, output_signature, VKD3DSPR_OUTPUT, sm6->output_params);
@@ -2957,19 +3131,6 @@ static void sm6_parser_init_input_signature(struct sm6_parser *sm6, const struct
     sm6_parser_init_signature(sm6, input_signature, VKD3DSPR_INPUT, sm6->input_params);
 }
 
-static void sm6_parser_emit_output_signature(struct sm6_parser *sm6, const struct shader_signature *output_signature)
-{
-    sm6_parser_emit_signature(sm6, output_signature, VKD3DSIH_DCL_OUTPUT, VKD3DSIH_DCL_OUTPUT_SIV, sm6->output_params);
-}
-
-static void sm6_parser_emit_input_signature(struct sm6_parser *sm6, const struct shader_signature *input_signature)
-{
-    sm6_parser_emit_signature(sm6, input_signature,
-            (sm6->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL) ? VKD3DSIH_DCL_INPUT_PS : VKD3DSIH_DCL_INPUT,
-            (sm6->p.shader_version.type == VKD3D_SHADER_TYPE_PIXEL) ? VKD3DSIH_DCL_INPUT_PS_SIV : VKD3DSIH_DCL_INPUT_SIV,
-            sm6->input_params);
-}
-
 static const struct sm6_value *sm6_parser_next_function_definition(struct sm6_parser *sm6)
 {
     size_t i, count = sm6->function_count;
@@ -2992,6 +3153,107 @@ static struct sm6_block *sm6_block_create()
     return block;
 }
 
+static struct sm6_phi *sm6_block_phi_require_space(struct sm6_block *block, struct sm6_parser *sm6)
+{
+    struct sm6_phi *phi;
+
+    if (!vkd3d_array_reserve((void **)&block->phi, &block->phi_capacity, block->phi_count + 1, sizeof(*block->phi)))
+    {
+        ERR("Failed to allocate phi array.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory allocating a phi instruction.");
+        return NULL;
+    }
+    phi = &block->phi[block->phi_count++];
+
+    phi->incoming = NULL;
+    phi->incoming_capacity = 0;
+    phi->incoming_count = 0;
+
+    return phi;
+}
+
+struct function_emission_state
+{
+    struct sm6_block *code_block;
+    struct vkd3d_shader_instruction *ins;
+};
+
+static void sm6_parser_emit_alloca(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    const struct sm6_type *type[2], *elem_type;
+    const struct sm6_value *size;
+    unsigned int i, alignment;
+    uint64_t packed_operands;
+
+    if (!dxil_record_validate_operand_count(record, 4, 4, sm6))
+        return;
+
+    for (i = 0; i < 2; ++i)
+    {
+        if (!(type[i] = sm6_parser_get_type(sm6, record->operands[i])))
+            return;
+    }
+
+    packed_operands = record->operands[3];
+    if (packed_operands & ALLOCA_FLAG_IN_ALLOCA)
+        WARN("Ignoring in_alloca flag.\n");
+    if (!(packed_operands & ALLOCA_FLAG_EXPLICIT_TYPE))
+    {
+        FIXME("Unhandled implicit type.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Implicit result type for ALLOCA instructions is not supported.");
+        return;
+    }
+    packed_operands &= ~(ALLOCA_FLAG_IN_ALLOCA | ALLOCA_FLAG_EXPLICIT_TYPE);
+
+    if (!sm6_type_is_array(type[0]) || !sm6_type_is_numeric(elem_type = type[0]->u.array.elem_type))
+    {
+        WARN("Type is not a numeric array.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Result type of an ALLOCA instruction is not a numeric array.");
+        return;
+    }
+    /* The second type operand is the type of the allocation size operand, in case it is a
+     * forward reference. We only support a constant size, so no forward ref support is needed. */
+    if (!sm6_type_is_integer(type[1]))
+    {
+        WARN("Size operand type is not scalar integer.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "The type of the allocation size operand of an ALLOCA instruction is not scalar integer.");
+        return;
+    }
+
+    if (!(dst->type = sm6_type_get_pointer_to_type(type[0], ADDRESS_SPACE_DEFAULT, sm6)))
+    {
+        WARN("Failed to get pointer type for type class %u.\n", type[0]->class);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
+                "Module does not define a pointer type for an ALLOCA instruction.");
+        return;
+    }
+
+    if (!(size = sm6_parser_get_value_safe(sm6, record->operands[2])))
+        return;
+    /* A size of 1 means one instance of type[0], i.e. one array. */
+    if (sm6_value_get_constant_uint(size) != 1)
+    {
+        FIXME("Allocation size is not 1.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "ALLOCA instruction allocation sizes other than 1 are not supported.");
+        return;
+    }
+
+    if (!bitcode_parse_alignment(packed_operands & ALLOCA_ALIGNMENT_MASK, &alignment))
+        WARN("Invalid alignment %"PRIu64".\n", packed_operands);
+    packed_operands &= ~ALLOCA_ALIGNMENT_MASK;
+
+    if (packed_operands)
+        WARN("Ignoring flags %#"PRIx64".\n", packed_operands);
+
+    sm6_parser_declare_indexable_temp(sm6, elem_type, type[0]->u.array.count, alignment, true, 0, ins, dst);
+}
+
 static enum vkd3d_shader_opcode map_binary_op(uint64_t code, const struct sm6_type *type_a,
         const struct sm6_type *type_b, struct sm6_parser *sm6)
 {
@@ -3092,8 +3354,10 @@ static void sm6_parser_emit_binop(struct sm6_parser *sm6, const struct dxil_reco
     unsigned int i = 0;
 
     a = sm6_parser_get_value_by_ref(sm6, record, NULL, &i);
+    if (!a)
+        return;
     b = sm6_parser_get_value_by_ref(sm6, record, a->type, &i);
-    if (!a || !b)
+    if (!b)
         return;
 
     if (!dxil_record_validate_operand_count(record, i + 1, i + 2, sm6))
@@ -3167,14 +3431,181 @@ static void sm6_parser_emit_binop(struct sm6_parser *sm6, const struct dxil_reco
     }
     else
     {
+        if (handler_idx == VKD3DSIH_ISHL || handler_idx == VKD3DSIH_ISHR || handler_idx == VKD3DSIH_USHR)
+        {
+            /* DXC emits AND instructions where necessary to mask shift counts. Shift binops
+             * do not imply masking the shift as the TPF equivalents do. */
+            ins->flags |= VKD3DSI_SHIFT_UNMASKED;
+        }
         instruction_dst_param_init_ssa_scalar(ins, sm6);
     }
 }
 
-static void sm6_parser_emit_dx_cbuffer_load(struct sm6_parser *sm6, struct sm6_block *code_block,
-        enum dx_intrinsic_opcode op, const struct sm6_value **operands, struct vkd3d_shader_instruction *ins)
+static const struct sm6_block *sm6_function_get_block(const struct sm6_function *function, uint64_t index,
+        struct sm6_parser *sm6)
+{
+    if (index >= function->block_count)
+    {
+        WARN("Invalid code block index %#"PRIx64".\n", index);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Invalid code block index %#"PRIx64" for a control flow instruction.", index);
+        return NULL;
+    }
+    return function->blocks[index];
+}
+
+static void sm6_parser_emit_br(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct sm6_function *function, struct sm6_block *code_block, struct vkd3d_shader_instruction *ins)
+{
+    const struct sm6_value *value;
+    unsigned int i = 2;
+
+    if (record->operand_count != 1 && record->operand_count < 3)
+    {
+        WARN("Invalid operand count %u.\n", record->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Invalid operand count %u for a branch instruction.", record->operand_count);
+        return;
+    }
+
+    if (record->operand_count == 1)
+    {
+        code_block->terminator.type = TERMINATOR_UNCOND_BR;
+        code_block->terminator.true_block = sm6_function_get_block(function, record->operands[0], sm6);
+    }
+    else
+    {
+        if (!sm6->bool_type)
+        {
+            WARN("Bool type not found.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
+                    "Module does not define a boolean type for conditions.");
+            return;
+        }
+        if (!(value = sm6_parser_get_value_by_ref(sm6, record, sm6->bool_type, &i))
+                || !sm6_value_validate_is_bool(value, sm6))
+            return;
+        dxil_record_validate_operand_max_count(record, i, sm6);
+
+        code_block->terminator.type = TERMINATOR_COND_BR;
+        code_block->terminator.conditional_reg = value->u.reg;
+        code_block->terminator.true_block = sm6_function_get_block(function, record->operands[0], sm6);
+        code_block->terminator.false_block = sm6_function_get_block(function, record->operands[1], sm6);
+    }
+
+    ins->handler_idx = VKD3DSIH_NOP;
+}
+
+static enum vkd3d_shader_opcode map_dx_unary_op(enum dx_intrinsic_opcode op)
+{
+    switch (op)
+    {
+        case DX_ISNAN:
+            return VKD3DSIH_ISNAN;
+        case DX_ISINF:
+            return VKD3DSIH_ISINF;
+        case DX_ISFINITE:
+            return VKD3DSIH_ISFINITE;
+        case DX_TAN:
+            return VKD3DSIH_TAN;
+        case DX_EXP:
+            return VKD3DSIH_EXP;
+        case DX_FRC:
+            return VKD3DSIH_FRC;
+        case DX_LOG:
+            return VKD3DSIH_LOG;
+        case DX_SQRT:
+            return VKD3DSIH_SQRT;
+        case DX_RSQRT:
+            return VKD3DSIH_RSQ;
+        case DX_ROUND_NE:
+            return VKD3DSIH_ROUND_NE;
+        case DX_ROUND_NI:
+            return VKD3DSIH_ROUND_NI;
+        case DX_ROUND_PI:
+            return VKD3DSIH_ROUND_PI;
+        case DX_ROUND_Z:
+            return VKD3DSIH_ROUND_Z;
+        case DX_BFREV:
+            return VKD3DSIH_BFREV;
+        case DX_COUNT_BITS:
+            return VKD3DSIH_COUNTBITS;
+        case DX_FIRST_BIT_LO:
+            return VKD3DSIH_FIRSTBIT_LO;
+        case DX_FIRST_BIT_HI:
+            return VKD3DSIH_FIRSTBIT_HI;
+        case DX_FIRST_BIT_SHI:
+            return VKD3DSIH_FIRSTBIT_SHI;
+        case DX_DERIV_COARSEX:
+            return VKD3DSIH_DSX_COARSE;
+        case DX_DERIV_COARSEY:
+            return VKD3DSIH_DSY_COARSE;
+        case DX_DERIV_FINEX:
+            return VKD3DSIH_DSX_FINE;
+        case DX_DERIV_FINEY:
+            return VKD3DSIH_DSY_FINE;
+        case DX_LEGACY_F32TOF16:
+            return VKD3DSIH_F32TOF16;
+        case DX_LEGACY_F16TOF32:
+            return VKD3DSIH_F16TOF32;
+        default:
+            vkd3d_unreachable();
+    }
+}
+
+static void sm6_parser_emit_dx_unary(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
+{
+    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_src_param *src_param;
+
+    vsir_instruction_init(ins, &sm6->p.location, map_dx_unary_op(op));
+    src_param = instruction_src_params_alloc(ins, 1, sm6);
+    src_param_init_from_value(src_param, operands[0]);
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+}
+
+static enum vkd3d_shader_opcode map_dx_binary_op(enum dx_intrinsic_opcode op, const struct sm6_type *type)
+{
+    switch (op)
+    {
+        case DX_FMAX:
+            return type->u.width == 64 ? VKD3DSIH_DMAX : VKD3DSIH_MAX;
+        case DX_FMIN:
+            return type->u.width == 64 ? VKD3DSIH_DMIN : VKD3DSIH_MIN;
+        case DX_IMAX:
+            return VKD3DSIH_IMAX;
+        case DX_IMIN:
+            return VKD3DSIH_IMIN;
+        case DX_UMAX:
+            return VKD3DSIH_UMAX;
+        case DX_UMIN:
+            return VKD3DSIH_UMIN;
+        default:
+            vkd3d_unreachable();
+    }
+}
+
+static void sm6_parser_emit_dx_binary(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
+{
+    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_src_param *src_params;
+
+    vsir_instruction_init(ins, &sm6->p.location, map_dx_binary_op(op, operands[0]->type));
+    src_params = instruction_src_params_alloc(ins, 2, sm6);
+    src_param_init_from_value(&src_params[0], operands[0]);
+    src_param_init_from_value(&src_params[1], operands[1]);
+
+    instruction_dst_param_init_ssa_scalar(ins, sm6);
+}
+
+static void sm6_parser_emit_dx_cbuffer_load(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
 {
     struct sm6_value *dst = sm6_parser_get_current_value(sm6);
+    struct vkd3d_shader_instruction *ins = state->ins;
     struct vkd3d_shader_src_param *src_param;
     const struct sm6_value *buffer;
     const struct sm6_type *type;
@@ -3222,9 +3653,10 @@ static const struct sm6_descriptor_info *sm6_parser_get_descriptor(struct sm6_pa
     return NULL;
 }
 
-static void sm6_parser_emit_dx_create_handle(struct sm6_parser *sm6, struct sm6_block *code_block,
-        enum dx_intrinsic_opcode op, const struct sm6_value **operands, struct vkd3d_shader_instruction *ins)
+static void sm6_parser_emit_dx_create_handle(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
 {
+    struct vkd3d_shader_instruction *ins = state->ins;
     enum vkd3d_shader_descriptor_type type;
     const struct sm6_descriptor_info *d;
     struct vkd3d_shader_register *reg;
@@ -3246,9 +3678,9 @@ static void sm6_parser_emit_dx_create_handle(struct sm6_parser *sm6, struct sm6_
     dst->u.handle.d = d;
 
     reg = &dst->u.handle.reg;
-    /* Set idx_count to 3 for use with load instructions.
-     * TODO: set register type from resource type when other types are supported. */
-    vsir_register_init(reg, VKD3DSPR_CONSTBUFFER, VKD3D_DATA_FLOAT, 3);
+    /* Set idx_count to 3 for use with load/store instructions. */
+    vsir_register_init(reg, d->reg_type, d->reg_data_type, 3);
+    reg->dimension = VSIR_DIMENSION_VEC4;
     reg->idx[0].offset = id;
     register_index_address_init(&reg->idx[1], operands[2], sm6);
     reg->non_uniform = !!sm6_value_get_constant_uint(operands[3]);
@@ -3257,9 +3689,10 @@ static void sm6_parser_emit_dx_create_handle(struct sm6_parser *sm6, struct sm6_
     ins->handler_idx = VKD3DSIH_NOP;
 }
 
-static void sm6_parser_emit_dx_load_input(struct sm6_parser *sm6, struct sm6_block *code_block,
-        enum dx_intrinsic_opcode op, const struct sm6_value **operands, struct vkd3d_shader_instruction *ins)
+static void sm6_parser_emit_dx_load_input(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
 {
+    struct vkd3d_shader_instruction *ins = state->ins;
     struct vkd3d_shader_src_param *src_param;
     const struct shader_signature *signature;
     unsigned int row_index, column_index;
@@ -3289,35 +3722,93 @@ static void sm6_parser_emit_dx_load_input(struct sm6_parser *sm6, struct sm6_blo
     instruction_dst_param_init_ssa_scalar(ins, sm6);
 }
 
-static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, struct sm6_block *code_block,
-        enum dx_intrinsic_opcode op, const struct sm6_value **operands, struct vkd3d_shader_instruction *ins)
+static void sm6_parser_emit_dx_buffer_load(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
 {
-    struct vkd3d_shader_src_param *src_param;
-    struct vkd3d_shader_dst_param *dst_param;
-    const struct shader_signature *signature;
-    unsigned int row_index, column_index;
-    const struct signature_element *e;
-    const struct sm6_value *value;
-
-    row_index = sm6_value_get_constant_uint(operands[0]);
-    column_index = sm6_value_get_constant_uint(operands[2]);
+    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_src_param *src_params;
+    const struct sm6_value *resource;
 
-    signature = &sm6->p.shader_desc.output_signature;
-    if (row_index >= signature->element_count)
-    {
-        WARN("Invalid row index %u.\n", row_index);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                "Invalid output row index %u.", row_index);
+    resource = operands[0];
+    if (!sm6_value_validate_is_handle(resource, sm6))
         return;
-    }
-    e = &signature->elements[row_index];
 
-    if (column_index >= VKD3D_VEC4_SIZE)
+    if (resource->u.handle.d->kind != RESOURCE_KIND_TYPEDBUFFER)
     {
-        WARN("Invalid column index %u.\n", column_index);
-        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
-                "Invalid output column index %u.", column_index);
-        return;
+        WARN("Resource is not a typed buffer.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_INVALID_OPERATION,
+                "Resource for a typed buffer load is not a typed buffer.");
+    }
+
+    instruction_init_with_resource(ins, (resource->u.handle.d->type == VKD3D_SHADER_DESCRIPTOR_TYPE_UAV)
+            ? VKD3DSIH_LD_UAV_TYPED : VKD3DSIH_LD, resource, sm6);
+
+    src_params = instruction_src_params_alloc(ins, 2, sm6);
+    src_param_init_from_value(&src_params[0], operands[1]);
+    if (!sm6_value_is_undef(operands[2]))
+    {
+        /* Constant zero would be ok, but is not worth checking for unless it shows up. */
+        WARN("Ignoring structure offset.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Ignoring structure offset for a typed buffer load.");
+    }
+    src_param_init_vector_from_reg(&src_params[1], &resource->u.handle.reg);
+
+    instruction_dst_param_init_ssa_vector(ins, VKD3D_VEC4_SIZE, sm6);
+}
+
+static void sm6_parser_emit_dx_sincos(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
+{
+    struct sm6_value *dst = sm6_parser_get_current_value(sm6);
+    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_dst_param *dst_params;
+    struct vkd3d_shader_src_param *src_param;
+    unsigned int index;
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_SINCOS);
+    src_param = instruction_src_params_alloc(ins, 1, sm6);
+    src_param_init_from_value(src_param, operands[0]);
+
+    index = op == DX_COS;
+    dst_params = instruction_dst_params_alloc(ins, 2, sm6);
+    dst_param_init(&dst_params[0]);
+    dst_param_init(&dst_params[1]);
+    register_init_ssa_scalar(&dst_params[index].reg, dst->type, sm6);
+    vsir_register_init(&dst_params[index ^ 1].reg, VKD3DSPR_NULL, VKD3D_DATA_UNUSED, 0);
+    dst->u.reg = dst_params[index].reg;
+}
+
+static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
+        const struct sm6_value **operands, struct function_emission_state *state)
+{
+    struct vkd3d_shader_instruction *ins = state->ins;
+    struct vkd3d_shader_src_param *src_param;
+    struct vkd3d_shader_dst_param *dst_param;
+    const struct shader_signature *signature;
+    unsigned int row_index, column_index;
+    const struct signature_element *e;
+    const struct sm6_value *value;
+
+    row_index = sm6_value_get_constant_uint(operands[0]);
+    column_index = sm6_value_get_constant_uint(operands[2]);
+
+    signature = &sm6->p.shader_desc.output_signature;
+    if (row_index >= signature->element_count)
+    {
+        WARN("Invalid row index %u.\n", row_index);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Invalid output row index %u.", row_index);
+        return;
+    }
+    e = &signature->elements[row_index];
+
+    if (column_index >= VKD3D_VEC4_SIZE)
+    {
+        WARN("Invalid column index %u.\n", column_index);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Invalid output column index %u.", column_index);
+        return;
     }
 
     value = operands[3];
@@ -3344,31 +3835,70 @@ static void sm6_parser_emit_dx_store_output(struct sm6_parser *sm6, struct sm6_b
 
 struct sm6_dx_opcode_info
 {
-    const char ret_type;
+    const char *ret_type;
     const char *operand_info;
-    void (*handler)(struct sm6_parser *, struct sm6_block *, enum dx_intrinsic_opcode,
-            const struct sm6_value **, struct vkd3d_shader_instruction *);
+    void (*handler)(struct sm6_parser *, enum dx_intrinsic_opcode, const struct sm6_value **,
+            struct function_emission_state *);
 };
 
 /*
+    1 -> int1
     8 -> int8
     b -> constant int1
     c -> constant int8/16/32
     i -> int32
+    m -> int16/32/64
+    f -> float
+    e -> half/float
+    g -> half/float/double
     H -> handle
     v -> void
     o -> overloaded
+    R -> matches the return type
  */
 static const struct sm6_dx_opcode_info sm6_dx_op_table[] =
 {
-    [DX_CBUFFER_LOAD_LEGACY           ] = {'o', "Hi",   sm6_parser_emit_dx_cbuffer_load},
-    [DX_CREATE_HANDLE                 ] = {'H', "ccib", sm6_parser_emit_dx_create_handle},
-    [DX_LOAD_INPUT                    ] = {'o', "ii8i", sm6_parser_emit_dx_load_input},
-    [DX_STORE_OUTPUT                  ] = {'v', "ii8o", sm6_parser_emit_dx_store_output},
+    [DX_BFREV                         ] = {"m", "R",    sm6_parser_emit_dx_unary},
+    [DX_BUFFER_LOAD                   ] = {"o", "Hii",  sm6_parser_emit_dx_buffer_load},
+    [DX_CBUFFER_LOAD_LEGACY           ] = {"o", "Hi",   sm6_parser_emit_dx_cbuffer_load},
+    [DX_COS                           ] = {"g", "R",    sm6_parser_emit_dx_sincos},
+    [DX_COUNT_BITS                    ] = {"i", "m",    sm6_parser_emit_dx_unary},
+    [DX_CREATE_HANDLE                 ] = {"H", "ccib", sm6_parser_emit_dx_create_handle},
+    [DX_DERIV_COARSEX                 ] = {"e", "R",    sm6_parser_emit_dx_unary},
+    [DX_DERIV_COARSEY                 ] = {"e", "R",    sm6_parser_emit_dx_unary},
+    [DX_DERIV_FINEX                   ] = {"e", "R",    sm6_parser_emit_dx_unary},
+    [DX_DERIV_FINEY                   ] = {"e", "R",    sm6_parser_emit_dx_unary},
+    [DX_EXP                           ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_FIRST_BIT_HI                  ] = {"i", "m",    sm6_parser_emit_dx_unary},
+    [DX_FIRST_BIT_LO                  ] = {"i", "m",    sm6_parser_emit_dx_unary},
+    [DX_FIRST_BIT_SHI                 ] = {"i", "m",    sm6_parser_emit_dx_unary},
+    [DX_FMAX                          ] = {"g", "RR",   sm6_parser_emit_dx_binary},
+    [DX_FMIN                          ] = {"g", "RR",   sm6_parser_emit_dx_binary},
+    [DX_FRC                           ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_IMAX                          ] = {"m", "RR",   sm6_parser_emit_dx_binary},
+    [DX_IMIN                          ] = {"m", "RR",   sm6_parser_emit_dx_binary},
+    [DX_ISFINITE                      ] = {"1", "g",    sm6_parser_emit_dx_unary},
+    [DX_ISINF                         ] = {"1", "g",    sm6_parser_emit_dx_unary},
+    [DX_ISNAN                         ] = {"1", "g",    sm6_parser_emit_dx_unary},
+    [DX_LEGACY_F16TOF32               ] = {"f", "i",    sm6_parser_emit_dx_unary},
+    [DX_LEGACY_F32TOF16               ] = {"i", "f",    sm6_parser_emit_dx_unary},
+    [DX_LOAD_INPUT                    ] = {"o", "ii8i", sm6_parser_emit_dx_load_input},
+    [DX_LOG                           ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_ROUND_NE                      ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_ROUND_NI                      ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_ROUND_PI                      ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_ROUND_Z                       ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_RSQRT                         ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_SIN                           ] = {"g", "R",    sm6_parser_emit_dx_sincos},
+    [DX_SQRT                          ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_STORE_OUTPUT                  ] = {"v", "ii8o", sm6_parser_emit_dx_store_output},
+    [DX_TAN                           ] = {"g", "R",    sm6_parser_emit_dx_unary},
+    [DX_UMAX                          ] = {"m", "RR",   sm6_parser_emit_dx_binary},
+    [DX_UMIN                          ] = {"m", "RR",   sm6_parser_emit_dx_binary},
 };
 
 static bool sm6_parser_validate_operand_type(struct sm6_parser *sm6, const struct sm6_value *value, char info_type,
-        bool is_return)
+        const struct sm6_type *ret_type, bool is_return)
 {
     const struct sm6_type *type = value->type;
 
@@ -3380,6 +3910,8 @@ static bool sm6_parser_validate_operand_type(struct sm6_parser *sm6, const struc
         case 0:
             FIXME("Invalid operand count.\n");
             return false;
+        case '1':
+            return sm6_type_is_bool(type);
         case '8':
             return sm6_type_is_i8(type);
         case 'b':
@@ -3389,6 +3921,14 @@ static bool sm6_parser_validate_operand_type(struct sm6_parser *sm6, const struc
                     && type->u.width <= 32;
         case 'i':
             return sm6_type_is_i32(type);
+        case 'm':
+            return sm6_type_is_i16_i32_i64(type);
+        case 'f':
+            return sm6_type_is_float(type);
+        case 'e':
+            return sm6_type_is_f16_f32(type);
+        case 'g':
+            return sm6_type_is_floating_point(type);
         case 'H':
             return (is_return || sm6_value_is_handle(value)) && type == sm6->handle_type;
         case 'v':
@@ -3396,6 +3936,8 @@ static bool sm6_parser_validate_operand_type(struct sm6_parser *sm6, const struc
         case 'o':
             /* TODO: some type checking may be possible */
             return true;
+        case 'R':
+            return type == ret_type;
         default:
             FIXME("Unhandled operand code '%c'.\n", info_type);
             return false;
@@ -3410,7 +3952,8 @@ static bool sm6_parser_validate_dx_op(struct sm6_parser *sm6, enum dx_intrinsic_
 
     info = &sm6_dx_op_table[op];
 
-    if (!sm6_parser_validate_operand_type(sm6, dst, info->ret_type, true))
+    assert(info->ret_type[0]);
+    if (!sm6_parser_validate_operand_type(sm6, dst, info->ret_type[0], NULL, true))
     {
         WARN("Failed to validate return type for dx intrinsic id %u, '%s'.\n", op, name);
         /* Return type validation failure is not so critical. We only need to set
@@ -3420,7 +3963,7 @@ static bool sm6_parser_validate_dx_op(struct sm6_parser *sm6, enum dx_intrinsic_
     for (i = 0; i < operand_count; ++i)
     {
         const struct sm6_value *value = operands[i];
-        if (!sm6_parser_validate_operand_type(sm6, value, info->operand_info[i], false))
+        if (!sm6_parser_validate_operand_type(sm6, value, info->operand_info[i], dst->type, false))
         {
             WARN("Failed to validate operand %u for dx intrinsic id %u, '%s'.\n", i + 1, op, name);
             vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
@@ -3454,27 +3997,27 @@ static void sm6_parser_emit_unhandled(struct sm6_parser *sm6, struct vkd3d_shade
     /* dst->is_undefined is not set here because it flags only explicitly undefined values. */
 }
 
-static void sm6_parser_decode_dx_op(struct sm6_parser *sm6, struct sm6_block *code_block, enum dx_intrinsic_opcode op,
+static void sm6_parser_decode_dx_op(struct sm6_parser *sm6, enum dx_intrinsic_opcode op,
         const char *name, const struct sm6_value **operands, unsigned int operand_count,
-        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+        struct function_emission_state *state, struct sm6_value *dst)
 {
     if (op >= ARRAY_SIZE(sm6_dx_op_table) || !sm6_dx_op_table[op].operand_info)
     {
         FIXME("Unhandled dx intrinsic function id %u, '%s'.\n", op, name);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_UNHANDLED_INTRINSIC,
                 "Call to intrinsic function %s is unhandled.", name);
-        sm6_parser_emit_unhandled(sm6, ins, dst);
+        sm6_parser_emit_unhandled(sm6, state->ins, dst);
         return;
     }
 
     if (sm6_parser_validate_dx_op(sm6, op, name, operands, operand_count, dst))
-        sm6_dx_op_table[op].handler(sm6, code_block, op, operands, ins);
+        sm6_dx_op_table[op].handler(sm6, op, operands, state);
     else
-        sm6_parser_emit_unhandled(sm6, ins, dst);
+        sm6_parser_emit_unhandled(sm6, state->ins, dst);
 }
 
 static void sm6_parser_emit_call(struct sm6_parser *sm6, const struct dxil_record *record,
-        struct sm6_block *code_block, struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+        struct function_emission_state *state, struct sm6_value *dst)
 {
     const struct sm6_value *operands[DXIL_OP_MAX_OPERANDS];
     const struct sm6_value *fn_value, *op_value;
@@ -3556,8 +4099,8 @@ static void sm6_parser_emit_call(struct sm6_parser *sm6, const struct dxil_recor
                 "Expected a constant integer dx intrinsic function id.");
         return;
     }
-    sm6_parser_decode_dx_op(sm6, code_block, register_get_uint_value(&op_value->u.reg),
-            fn_value->u.function.name, &operands[1], operand_count - 1, ins, dst);
+    sm6_parser_decode_dx_op(sm6, register_get_uint_value(&op_value->u.reg),
+            fn_value->u.function.name, &operands[1], operand_count - 1, state, dst);
 }
 
 static enum vkd3d_shader_opcode sm6_map_cast_op(uint64_t code, const struct sm6_type *from,
@@ -3700,6 +4243,9 @@ static void sm6_parser_emit_cast(struct sm6_parser *sm6, const struct dxil_recor
     if (handler_idx == VKD3DSIH_NOP)
     {
         dst->u.reg = value->u.reg;
+        /* Set the result type for casts from 16-bit min precision. */
+        if (type->u.width != 16)
+            dst->u.reg.data_type = vkd3d_data_type_from_sm6_type(type);
         return;
     }
 
@@ -3775,8 +4321,10 @@ static void sm6_parser_emit_cmp2(struct sm6_parser *sm6, const struct dxil_recor
     }
 
     a = sm6_parser_get_value_by_ref(sm6, record, NULL, &i);
+    if (!a)
+        return;
     b = sm6_parser_get_value_by_ref(sm6, record, a->type, &i);
-    if (!a || !b)
+    if (!b)
         return;
 
     if (!dxil_record_validate_operand_count(record, i + 1, i + 2, sm6))
@@ -4053,6 +4601,102 @@ static void sm6_parser_emit_load(struct sm6_parser *sm6, const struct dxil_recor
     instruction_dst_param_init_ssa_scalar(ins, sm6);
 }
 
+static int phi_incoming_compare(const void *a, const void *b)
+{
+    const struct incoming_value *incoming_a = a, *incoming_b = b;
+
+    return (incoming_a->block > incoming_b->block) - (incoming_a->block < incoming_b->block);
+}
+
+static void sm6_parser_emit_phi(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct sm6_function *function, struct sm6_block *code_block, struct vkd3d_shader_instruction *ins,
+        struct sm6_value *dst)
+{
+    struct incoming_value *incoming;
+    const struct sm6_type *type;
+    struct sm6_phi *phi;
+    unsigned int i, j;
+    uint64_t src_idx;
+
+    if (!(record->operand_count & 1))
+    {
+        WARN("Invalid operand count %u.\n", record->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Invalid operand count %u for phi instruction.", record->operand_count);
+        return;
+    }
+
+    if (!(type = sm6_parser_get_type(sm6, record->operands[0])))
+        return;
+    if (!sm6_type_is_numeric(type))
+    {
+        /* dxc doesn't seem to use buffer/resource read return types here. */
+        FIXME("Only scalar numeric types are supported.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Result type class %u of a phi instruction is not scalar numeric.", type->class);
+        return;
+    }
+
+    dst->type = type;
+    register_init_ssa_scalar(&dst->u.reg, type, sm6);
+
+    if (!(phi = sm6_block_phi_require_space(code_block, sm6)))
+        return;
+    phi->reg = dst->u.reg;
+    phi->incoming_count = record->operand_count / 2u;
+
+    if (!vkd3d_array_reserve((void **)&phi->incoming, &phi->incoming_capacity, phi->incoming_count,
+            sizeof(*phi->incoming)))
+    {
+        ERR("Failed to allocate phi incoming array.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory allocating a phi incoming array.");
+        return;
+    }
+    incoming = phi->incoming;
+
+    for (i = 1; i < record->operand_count; i += 2)
+    {
+        src_idx = sm6->value_count - decode_rotated_signed_value(record->operands[i]);
+        /* May be a forward reference. */
+        if (src_idx >= sm6->cur_max_value)
+        {
+            WARN("Invalid value index %"PRIu64".\n", src_idx);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "Invalid value index %"PRIu64" for a phi incoming value.", src_idx);
+            return;
+        }
+
+        j = i / 2u;
+        /* Store the value index in the register for later resolution. */
+        incoming[j].reg.idx[0].offset = src_idx;
+        incoming[j].block = sm6_function_get_block(function, record->operands[i + 1], sm6);
+    }
+
+    ins->handler_idx = VKD3DSIH_NOP;
+
+    qsort(incoming, phi->incoming_count, sizeof(*incoming), phi_incoming_compare);
+
+    for (i = 1, j = 1; i < phi->incoming_count; ++i)
+    {
+        if (incoming[i].block != incoming[i - 1].block)
+        {
+            incoming[j++] = incoming[i];
+            continue;
+        }
+
+        if (incoming[i].reg.idx[0].offset != incoming[i - 1].reg.idx[0].offset)
+        {
+            WARN("PHI conflict.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "Two phi incomings have the same block but different values.");
+        }
+    }
+    /* if (j == 1) we should be able to set dst->u.reg to incoming[0].reg, but structurisation
+     * may potentially add new incomings. */
+    phi->incoming_count = j;
+}
+
 static void sm6_parser_emit_ret(struct sm6_parser *sm6, const struct dxil_record *record,
         struct sm6_block *code_block, struct vkd3d_shader_instruction *ins)
 {
@@ -4062,6 +4706,142 @@ static void sm6_parser_emit_ret(struct sm6_parser *sm6, const struct dxil_record
     if (record->operand_count)
         FIXME("Non-void return is not implemented.\n");
 
+    code_block->terminator.type = TERMINATOR_RET;
+
+    ins->handler_idx = VKD3DSIH_NOP;
+}
+
+static void sm6_parser_emit_store(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst)
+{
+    struct vkd3d_shader_src_param *src_param;
+    struct vkd3d_shader_dst_param *dst_param;
+    const struct sm6_type *pointee_type;
+    const struct sm6_value *ptr, *src;
+    unsigned int i = 0, alignment;
+    uint64_t alignment_code;
+
+    if (!(ptr = sm6_parser_get_value_by_ref(sm6, record, NULL, &i))
+            || !sm6_value_validate_is_register(ptr, sm6)
+            || !sm6_value_validate_is_pointer(ptr, sm6))
+    {
+        return;
+    }
+
+    pointee_type = ptr->type->u.pointer.type;
+    if (!(src = sm6_parser_get_value_by_ref(sm6, record, pointee_type, &i)))
+        return;
+    if (!sm6_value_validate_is_numeric(src, sm6))
+        return;
+
+    if (pointee_type != src->type)
+    {
+        WARN("Type mismatch.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                "Type mismatch in pointer store arguments.");
+    }
+
+    if (!dxil_record_validate_operand_count(record, i + 2, i + 2, sm6))
+        return;
+
+    alignment_code = record->operands[i++];
+    if (!bitcode_parse_alignment(alignment_code, &alignment))
+        WARN("Invalid alignment %"PRIu64".\n", alignment_code);
+
+    if (record->operands[i])
+        WARN("Ignoring volatile modifier.\n");
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_MOV);
+
+    src_param = instruction_src_params_alloc(ins, 1, sm6);
+    src_param_init_from_value(&src_param[0], src);
+
+    dst_param = instruction_dst_params_alloc(ins, 1, sm6);
+    dst_param_init(dst_param);
+    dst_param->reg = ptr->u.reg;
+    dst_param->reg.alignment = alignment;
+}
+
+static void sm6_parser_emit_switch(struct sm6_parser *sm6, const struct dxil_record *record,
+        struct sm6_function *function, struct sm6_block *code_block, struct vkd3d_shader_instruction *ins)
+{
+    struct sm6_block_terminator *terminator = &code_block->terminator;
+    const struct sm6_type *type;
+    const struct sm6_value *src;
+    unsigned int i = 1, j;
+
+    if (record->operand_count < 3 || !(record->operand_count & 1))
+    {
+        WARN("Invalid operand count %u.\n", record->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Invalid operand count %u for a switch instruction.", record->operand_count);
+        return;
+    }
+
+    if (!(type = sm6_parser_get_type(sm6, record->operands[0])))
+        return;
+
+    if (!(src = sm6_parser_get_value_by_ref(sm6, record, type, &i))
+            || !sm6_value_validate_is_register(src, sm6))
+        return;
+    assert(i == 2);
+
+    if (src->type != type)
+    {
+        WARN("Type mismatch.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                "The type of a switch selector value does not match the selector type.");
+    }
+    if (!sm6_type_is_integer(type))
+    {
+        WARN("Selector is not scalar integer.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                "Selector type class %u of a switch instruction is not scalar integer.", type->class);
+        return;
+    }
+
+    terminator->conditional_reg = src->u.reg;
+    terminator->type = TERMINATOR_SWITCH;
+
+    terminator->case_count = record->operand_count / 2u;
+    if (!(terminator->cases = vkd3d_calloc(terminator->case_count, sizeof(*terminator->cases))))
+    {
+        ERR("Failed to allocate case array.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                "Out of memory allocating a switch case array.");
+        return;
+    }
+
+    /* Executes 'operand_count / 2' times because operand_count is uneven. */
+    for (; i < record->operand_count; i += 2)
+    {
+        j = i / 2u - 1;
+        terminator->cases[j].block = sm6_function_get_block(function, record->operands[i], sm6);
+        /* For structurisation it is convenient to store the default in the case array. */
+        terminator->cases[j].is_default = !j;
+    }
+
+    for (i = 3; i < record->operand_count; i += 2)
+    {
+        if (!(src = sm6_parser_get_value_safe(sm6, record->operands[i])))
+            return;
+
+        if (src->type != type)
+        {
+            WARN("Type mismatch.\n");
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                    "The type of a switch case value does not match the selector type.");
+        }
+        if (!sm6_value_is_constant(src))
+        {
+            WARN("Case value is not a constant.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "A switch case value is not a constant.");
+        }
+
+        terminator->cases[i / 2u].value = sm6_value_get_constant_uint64(src);
+    }
+
     ins->handler_idx = VKD3DSIH_NOP;
 }
 
@@ -4115,6 +4895,12 @@ static bool sm6_metadata_value_is_string(const struct sm6_metadata_value *m)
     return m && m->type == VKD3D_METADATA_STRING;
 }
 
+static bool sm6_metadata_value_is_zero_or_undef(const struct sm6_metadata_value *m)
+{
+    return sm6_metadata_value_is_value(m)
+            && (sm6_value_is_undef(m->u.value) || sm6_value_is_constant_zero(m->u.value));
+}
+
 static bool sm6_metadata_get_uint_value(const struct sm6_parser *sm6,
         const struct sm6_metadata_value *m, unsigned int *u)
 {
@@ -4153,6 +4939,272 @@ static bool sm6_metadata_get_uint64_value(const struct sm6_parser *sm6,
     return true;
 }
 
+static void sm6_parser_metadata_attachment_block_init(struct sm6_parser *sm6, const struct dxil_block *target_block,
+        const struct dxil_block *block)
+{
+    struct dxil_record *target_record;
+    const struct dxil_record *record;
+    unsigned int i;
+    uint64_t index;
+
+    for (i = 0; i < block->record_count; ++i)
+    {
+        record = block->records[i];
+        if (record->code != METADATA_ATTACHMENT)
+        {
+            WARN("Ignoring record with code %u.\n", record->code);
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                    "Ignoring a metadata attachment record with code %u.", record->code);
+            continue;
+        }
+        if (!(record->operand_count & 1))
+        {
+            WARN("Ignoring function attachment.\n");
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                    "Ignoring a metadata function attachment.");
+            continue;
+        }
+
+        index = record->operands[0];
+        if (!target_block->record_count || index >= target_block->record_count - 1)
+        {
+            WARN("Invalid record index %"PRIu64".\n", index);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                    "Invalid record index %"PRIu64" for a metadata attachment.", index);
+            continue;
+        }
+        /* 'index' is an instruction index, but records[0] is DECLAREBLOCKS, not an instruction. */
+        target_record = target_block->records[index + 1];
+        if (target_record->attachment)
+        {
+            WARN("Overwriting record attachment.\n");
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                    "The target record for a metadata attachment already has an attachment.");
+        }
+        target_record->attachment = record;
+    }
+}
+
+static void sm6_parser_metadata_attachments_init(struct sm6_parser *sm6, const struct dxil_block *block)
+{
+    unsigned int i;
+
+    for (i = 0; i < block->child_block_count; ++i)
+    {
+        if (block->child_blocks[i]->id == METADATA_ATTACHMENT_BLOCK)
+            sm6_parser_metadata_attachment_block_init(sm6, block, block->child_blocks[i]);
+    }
+}
+
+static const struct sm6_metadata_value *sm6_parser_find_metadata_kind(const struct sm6_parser *sm6, uint64_t id)
+{
+    unsigned int i, j;
+
+    for (i = 0; i < ARRAY_SIZE(sm6->metadata_tables); ++i)
+    {
+        for (j = 0; j < sm6->metadata_tables[i].count; ++j)
+        {
+            if (sm6->metadata_tables[i].values[j].type == VKD3D_METADATA_KIND
+                    && sm6->metadata_tables[i].values[j].u.kind.id == id)
+                return &sm6->metadata_tables[i].values[j];
+        }
+    }
+
+    return NULL;
+}
+
+static const struct sm6_metadata_value *sm6_parser_metadata_get_value(const struct sm6_parser *sm6, uint64_t index)
+{
+    unsigned int i;
+
+    for (i = 0; i < ARRAY_SIZE(sm6->metadata_tables); ++i)
+    {
+        if (sm6->metadata_tables[i].count > index)
+            break;
+        index -= sm6->metadata_tables[i].count;
+    }
+
+    return (index < sm6->metadata_tables[i].count) ? &sm6->metadata_tables[i].values[index] : NULL;
+}
+
+static bool metadata_node_get_unary_uint(const struct sm6_metadata_node *node, unsigned int *operand,
+        struct sm6_parser *sm6)
+{
+    if (node->operand_count != 1)
+    {
+        FIXME("Ignoring node with %u operands.\n", node->operand_count);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                "Ignoring metadata attachment node with %u operands; expected unary.", node->operand_count);
+        return false;
+    }
+    if (!sm6_metadata_value_is_value(node->operands[0])
+            || !sm6_metadata_get_uint_value(sm6, node->operands[0], operand))
+    {
+        WARN("Failed to get operand value.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                "Failed to get a metadata attachment operand value; ignoring the attachment.");
+        return false;
+    }
+
+    return true;
+}
+
+static void metadata_attachment_record_apply(const struct dxil_record *record, enum bitcode_function_code func_code,
+        struct vkd3d_shader_instruction *ins, struct sm6_value *dst, struct sm6_parser *sm6)
+{
+    static const char *ignored_names[] =
+    {
+        "alias.scope",
+        "dx.controlflow.hints",
+        "llvm.loop",
+        "noalias",
+        "tbaa",
+        "range",
+    };
+    const struct sm6_metadata_node *node;
+    const struct sm6_metadata_value *m;
+    unsigned int i, j, operand;
+    bool ignored = false;
+    const char *name;
+
+    if (record->attachment)
+    {
+        WARN("Ignoring nested metadata attachment.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                "Ignoring a nested metadata attachment.");
+    }
+
+    assert(record->operand_count & 1);
+    for (i = 1; i < record->operand_count; i += 2)
+    {
+        if (!(m = sm6_parser_find_metadata_kind(sm6, record->operands[i])))
+        {
+            WARN("Failed to find metadata kind %"PRIx64".\n", record->operands[i]);
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                    "Failed to find metadata kind %"PRIx64" for an attachment.", record->operands[i]);
+            continue;
+        }
+        name = m->u.kind.name;
+
+        m = sm6_parser_metadata_get_value(sm6, record->operands[i + 1]);
+        if (!m || !sm6_metadata_value_is_node(m))
+        {
+            WARN("Failed to retrieve metadata attachment node.\n");
+            vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                    "Failed to retrieve a metadata attachment node.");
+            continue;
+        }
+        node = m->u.node;
+
+        if (!strcmp(name, "dx.precise"))
+        {
+            if (!sm6_value_is_register(dst))
+            {
+                WARN("Precise value is not a register.\n");
+                vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                        "A value marked as precise is not a register.");
+            }
+            else if (metadata_node_get_unary_uint(node, &operand, sm6) && operand)
+            {
+                ins->flags |= sm6_type_is_scalar(dst->type) ? VKD3DSI_PRECISE_X : VKD3DSI_PRECISE_XYZW;
+            }
+        }
+        else if (!strcmp(name, "dx.nonuniform"))
+        {
+            if (!sm6_value_is_register(dst))
+            {
+                WARN("Non-uniform value is not a register.\n");
+                vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                        "A value marked as non-uniform is not a register.");
+            }
+            else if (metadata_node_get_unary_uint(node, &operand, sm6))
+            {
+                dst->u.reg.non_uniform = !!operand;
+            }
+        }
+        else
+        {
+            for (j = 0; j < ARRAY_SIZE(ignored_names); ++j)
+                if (!strcmp(name, ignored_names[j]))
+                    break;
+            if (j == ARRAY_SIZE(ignored_names))
+            {
+                WARN("Ignoring metadata attachment '%s'.\n", name);
+                vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT,
+                        "Ignoring a metadata attachment named '%s'.", name);
+            }
+            ignored = true;
+        }
+
+        if (func_code != FUNC_CODE_INST_CALL && !ignored)
+            WARN("Metadata attachment target is not a function call.\n");
+    }
+}
+
+static bool sm6_function_blocks_reserve(struct sm6_function *function, unsigned int reserve)
+{
+    if (!vkd3d_array_reserve((void **)&function->blocks, &function->block_capacity,
+            reserve, sizeof(*function->blocks)))
+    {
+        ERR("Failed to allocate code block array.\n");
+        return false;
+    }
+    return true;
+}
+
+static struct sm6_block *sm6_function_create_block(struct sm6_function *function)
+{
+    struct sm6_block *block;
+
+    if (!(block = sm6_block_create()))
+        return NULL;
+
+    function->blocks[function->block_count++] = block;
+    /* Set the id to the array index + 1. */
+    block->id = function->block_count;
+
+    return block;
+}
+
+static enum vkd3d_result sm6_function_resolve_phi_incomings(const struct sm6_function *function,
+        struct sm6_parser *sm6)
+{
+    const struct sm6_block *block;
+    size_t i, j, block_idx;
+
+    for (block_idx = 0; block_idx < function->block_count; ++block_idx)
+    {
+        block = function->blocks[block_idx];
+
+        for (i = 0; i < block->phi_count; ++i)
+        {
+            struct sm6_phi *phi = &block->phi[i];
+            const struct sm6_value *src;
+
+            for (j = 0; j < phi->incoming_count; ++j)
+            {
+                src = &sm6->values[phi->incoming[j].reg.idx[0].offset];
+                if (!sm6_value_is_constant(src) && !sm6_value_is_undef(src) && !sm6_value_is_ssa(src))
+                {
+                    FIXME("PHI incoming value is not a constant or SSA register.\n");
+                    vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND,
+                            "A PHI incoming value is not a constant or SSA register.");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+                if (src->u.reg.data_type != phi->reg.data_type)
+                {
+                    WARN("Type mismatch.\n");
+                    vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                            "The type of a phi incoming value does not match the result type.");
+                }
+                phi->incoming[j].reg = src->u.reg;
+            }
+        }
+    }
+
+    return VKD3D_OK;
+}
+
 static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const struct dxil_block *block,
         struct sm6_function *function)
 {
@@ -4192,16 +5244,18 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const
         WARN("Function contains no blocks.\n");
         return VKD3D_ERROR_INVALID_SHADER;
     }
-    if (block_count > 1)
-    {
-        FIXME("Branched shaders are not supported yet.\n");
-        return VKD3D_ERROR_INVALID_SHADER;
-    }
 
-    if (!(function->blocks[0] = sm6_block_create()))
-    {
-        ERR("Failed to allocate code block.\n");
+    if (!sm6_function_blocks_reserve(function, block_count))
         return VKD3D_ERROR_OUT_OF_MEMORY;
+
+    /* Pre-allocate all blocks to simplify instruction parsing. */
+    for (i = 0; i < block_count; ++i)
+    {
+        if (!sm6_function_create_block(function))
+        {
+            ERR("Failed to allocate code block.\n");
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+        }
     }
     function->block_count = block_count;
     code_block = function->blocks[0];
@@ -4220,10 +5274,9 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const
             return VKD3D_ERROR_INVALID_SHADER;
         }
 
-        /* block->record_count - 1 is the instruction count, but some instructions
-         * can emit >1 IR instruction, so extra may be used. */
+        /* Some instructions can emit >1 IR instruction, so extra may be used. */
         if (!vkd3d_array_reserve((void **)&code_block->instructions, &code_block->instruction_capacity,
-                max(code_block->instruction_count + 1, block->record_count), sizeof(*code_block->instructions)))
+                code_block->instruction_count + 1, sizeof(*code_block->instructions)))
         {
             ERR("Failed to allocate instructions.\n");
             return VKD3D_ERROR_OUT_OF_MEMORY;
@@ -4240,12 +5293,22 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const
         record = block->records[i];
         switch (record->code)
         {
+            case FUNC_CODE_INST_ALLOCA:
+                sm6_parser_emit_alloca(sm6, record, ins, dst);
+                break;
             case FUNC_CODE_INST_BINOP:
                 sm6_parser_emit_binop(sm6, record, ins, dst);
                 break;
+            case FUNC_CODE_INST_BR:
+                sm6_parser_emit_br(sm6, record, function, code_block, ins);
+                is_terminator = true;
+                break;
             case FUNC_CODE_INST_CALL:
-                sm6_parser_emit_call(sm6, record, code_block, ins, dst);
+            {
+                struct function_emission_state state = {code_block, ins};
+                sm6_parser_emit_call(sm6, record, &state, dst);
                 break;
+            }
             case FUNC_CODE_INST_CAST:
                 sm6_parser_emit_cast(sm6, record, ins, dst);
                 break;
@@ -4261,11 +5324,21 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const
             case FUNC_CODE_INST_LOAD:
                 sm6_parser_emit_load(sm6, record, ins, dst);
                 break;
+            case FUNC_CODE_INST_PHI:
+                sm6_parser_emit_phi(sm6, record, function, code_block, ins, dst);
+                break;
             case FUNC_CODE_INST_RET:
                 sm6_parser_emit_ret(sm6, record, code_block, ins);
                 is_terminator = true;
                 ret_found = true;
                 break;
+            case FUNC_CODE_INST_STORE:
+                sm6_parser_emit_store(sm6, record, ins, dst);
+                break;
+            case FUNC_CODE_INST_SWITCH:
+                sm6_parser_emit_switch(sm6, record, function, code_block, ins);
+                is_terminator = true;
+                break;
             case FUNC_CODE_INST_VSELECT:
                 sm6_parser_emit_vselect(sm6, record, ins, dst);
                 break;
@@ -4278,6 +5351,9 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const
             return VKD3D_ERROR;
         assert(ins->handler_idx != VKD3DSIH_INVALID);
 
+        if (record->attachment)
+            metadata_attachment_record_apply(record->attachment, record->code, ins, dst, sm6);
+
         if (is_terminator)
         {
             ++block_idx;
@@ -4297,22 +5373,130 @@ static enum vkd3d_result sm6_parser_function_init(struct sm6_parser *sm6, const
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    return VKD3D_OK;
+    return sm6_function_resolve_phi_incomings(function, sm6);
 }
 
-static bool sm6_block_emit_instructions(struct sm6_block *block, struct sm6_parser *sm6)
+static void sm6_block_emit_terminator(const struct sm6_block *block, struct sm6_parser *sm6)
 {
-    struct vkd3d_shader_instruction *ins = sm6_parser_require_space(sm6, block->instruction_count + 1);
+    struct vkd3d_shader_src_param *src_params;
+    struct vkd3d_shader_instruction *ins;
+    unsigned int i, count;
 
-    if (!ins)
-        return false;
+    switch (block->terminator.type)
+    {
+        case TERMINATOR_UNCOND_BR:
+            if (!block->terminator.true_block)
+                return;
+            ins = sm6_parser_add_instruction(sm6, VKD3DSIH_BRANCH);
+            if (!(src_params = instruction_src_params_alloc(ins, 1, sm6)))
+                return;
+            vsir_src_param_init_label(&src_params[0], block->terminator.true_block->id);
+            break;
+
+        case TERMINATOR_COND_BR:
+            if (!block->terminator.true_block || !block->terminator.false_block)
+                return;
+            ins = sm6_parser_add_instruction(sm6, VKD3DSIH_BRANCH);
+            if (!(src_params = instruction_src_params_alloc(ins, 3, sm6)))
+                return;
+            src_param_init(&src_params[0]);
+            src_params[0].reg = block->terminator.conditional_reg;
+            vsir_src_param_init_label(&src_params[1], block->terminator.true_block->id);
+            vsir_src_param_init_label(&src_params[2], block->terminator.false_block->id);
+            break;
 
-    memcpy(ins, block->instructions, block->instruction_count * sizeof(*block->instructions));
-    sm6->p.instructions.count += block->instruction_count;
+        case TERMINATOR_SWITCH:
+            ins = sm6_parser_add_instruction(sm6, VKD3DSIH_SWITCH_MONOLITHIC);
+            if (!(src_params = instruction_src_params_alloc(ins, block->terminator.case_count * 2u + 1, sm6)))
+                return;
+            src_param_init(&src_params[0]);
+            src_params[0].reg = block->terminator.conditional_reg;
+            /* TODO: emit the merge block id. */
+            vsir_src_param_init_label(&src_params[2], 0);
 
-    sm6_parser_add_instruction(sm6, VKD3DSIH_RET);
+            for (i = 0, count = 3; i < block->terminator.case_count; ++i)
+            {
+                const struct terminator_case *switch_case;
+                const struct sm6_block *case_block;
 
-    return true;
+                switch_case = &block->terminator.cases[i];
+                if (!(case_block = switch_case->block))
+                {
+                    assert(sm6->p.failed);
+                    continue;
+                }
+                if (switch_case->is_default)
+                {
+                    vsir_src_param_init_label(&src_params[1], case_block->id);
+                    continue;
+                }
+
+                if (src_params[0].reg.data_type == VKD3D_DATA_UINT64)
+                {
+                    vsir_src_param_init(&src_params[count], VKD3DSPR_IMMCONST64, VKD3D_DATA_UINT64, 0);
+                    src_params[count++].reg.u.immconst_u64[0] = switch_case->value;
+                }
+                else
+                {
+                    if (switch_case->value > UINT_MAX)
+                    {
+                        WARN("Truncating 64-bit constant %"PRIx64".\n", switch_case->value);
+                        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_TYPE_MISMATCH,
+                                "Truncating 64-bit switch case value %"PRIx64" to 32 bits.", switch_case->value);
+                    }
+                    vsir_src_param_init(&src_params[count], VKD3DSPR_IMMCONST, VKD3D_DATA_UINT, 0);
+                    src_params[count++].reg.u.immconst_u32[0] = switch_case->value;
+                }
+                vsir_src_param_init_label(&src_params[count++], case_block->id);
+            }
+
+            break;
+
+        case TERMINATOR_RET:
+            sm6_parser_add_instruction(sm6, VKD3DSIH_RET);
+            break;
+
+        default:
+            vkd3d_unreachable();
+    }
+}
+
+static void sm6_block_emit_phi(const struct sm6_block *block, struct sm6_parser *sm6)
+{
+    struct vkd3d_shader_instruction *ins;
+    unsigned int i, j, incoming_count;
+    const struct sm6_phi *src_phi;
+
+    for (i = 0; i < block->phi_count; ++i)
+    {
+        struct vkd3d_shader_src_param *src_params;
+        struct vkd3d_shader_dst_param *dst_param;
+
+        src_phi = &block->phi[i];
+        incoming_count = src_phi->incoming_count;
+
+        ins = sm6_parser_add_instruction(sm6, VKD3DSIH_PHI);
+        if (!(src_params = instruction_src_params_alloc(ins, incoming_count * 2u, sm6)))
+            return;
+        if (!(dst_param = instruction_dst_params_alloc(ins, 1, sm6)))
+            return;
+
+        for (j = 0; j < incoming_count; ++j)
+        {
+            const struct sm6_block *incoming_block = src_phi->incoming[j].block;
+            unsigned int index = j * 2;
+
+            src_param_init(&src_params[index]);
+            src_params[index].reg = src_phi->incoming[j].reg;
+            if (incoming_block)
+                vsir_src_param_init_label(&src_params[index + 1], incoming_block->id);
+            else
+                assert(sm6->p.failed);
+        }
+
+        dst_param_init(dst_param);
+        dst_param->reg = src_phi->reg;
+    }
 }
 
 static enum vkd3d_result sm6_parser_module_init(struct sm6_parser *sm6, const struct dxil_block *block,
@@ -4331,6 +5515,8 @@ static enum vkd3d_result sm6_parser_module_init(struct sm6_parser *sm6, const st
     sm6->p.location.line = block->id;
     sm6->p.location.column = 0;
 
+    sm6_parser_metadata_attachments_init(sm6, block);
+
     switch (block->id)
     {
         case CONSTANTS_BLOCK:
@@ -4370,6 +5556,48 @@ static enum vkd3d_result sm6_parser_module_init(struct sm6_parser *sm6, const st
     return VKD3D_OK;
 }
 
+static void sm6_parser_emit_label(struct sm6_parser *sm6, unsigned int label_id)
+{
+    struct vkd3d_shader_src_param *src_param;
+    struct vkd3d_shader_instruction *ins;
+
+    ins = sm6_parser_add_instruction(sm6, VKD3DSIH_LABEL);
+
+    if (!(src_param = instruction_src_params_alloc(ins, 1, sm6)))
+        return;
+    vsir_src_param_init_label(src_param, label_id);
+}
+
+static enum vkd3d_result sm6_function_emit_blocks(const struct sm6_function *function, struct sm6_parser *sm6)
+{
+    unsigned int i;
+
+    sm6->p.program.block_count = function->block_count;
+
+    for (i = 0; i < function->block_count; ++i)
+    {
+        const struct sm6_block *block = function->blocks[i];
+
+        /* Space for the label and terminator. */
+        if (!sm6_parser_require_space(sm6, block->instruction_count + block->phi_count + 2))
+        {
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+                    "Out of memory emitting shader instructions.");
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+        }
+        sm6_parser_emit_label(sm6, block->id);
+        sm6_block_emit_phi(block, sm6);
+
+        memcpy(&sm6->p.program.instructions.elements[sm6->p.program.instructions.count], block->instructions,
+                block->instruction_count * sizeof(*block->instructions));
+        sm6->p.program.instructions.count += block->instruction_count;
+
+        sm6_block_emit_terminator(block, sm6);
+    }
+
+    return VKD3D_OK;
+}
+
 static bool sm6_parser_allocate_named_metadata(struct sm6_parser *sm6)
 {
     struct dxil_block *block;
@@ -4644,8 +5872,10 @@ static enum vkd3d_shader_minimum_precision minimum_precision_from_dxil_component
 static const enum vkd3d_shader_sysval_semantic sysval_semantic_table[] =
 {
     [SEMANTIC_KIND_ARBITRARY]            = VKD3D_SHADER_SV_NONE,
+    [SEMANTIC_KIND_VERTEXID]             = VKD3D_SHADER_SV_VERTEX_ID,
     [SEMANTIC_KIND_POSITION]             = VKD3D_SHADER_SV_POSITION,
-    [SEMANTIC_KIND_TARGET]               = VKD3D_SHADER_SV_NONE,
+    [SEMANTIC_KIND_ISFRONTFACE]          = VKD3D_SHADER_SV_IS_FRONT_FACE,
+    [SEMANTIC_KIND_TARGET]               = VKD3D_SHADER_SV_TARGET,
 };
 
 static enum vkd3d_shader_sysval_semantic sysval_semantic_from_dxil_semantic_kind(enum dxil_semantic_kind kind)
@@ -4727,6 +5957,288 @@ static bool sm6_parser_resources_load_register_range(struct sm6_parser *sm6,
     return true;
 }
 
+static bool resource_kind_is_texture(enum dxil_resource_kind kind)
+{
+    return kind >= RESOURCE_KIND_TEXTURE1D && kind <= RESOURCE_KIND_TEXTURECUBEARRAY;
+}
+
+static bool resource_kind_is_multisampled(enum dxil_resource_kind kind)
+{
+    return kind == RESOURCE_KIND_TEXTURE2DMS || kind == RESOURCE_KIND_TEXTURE2DMSARRAY;
+}
+
+static enum vkd3d_shader_resource_type shader_resource_type_from_dxil_resource_kind(enum dxil_resource_kind kind)
+{
+    if (resource_kind_is_texture(kind))
+        return kind + 1;
+
+    switch (kind)
+    {
+        case RESOURCE_KIND_TYPEDBUFFER:
+            return VKD3D_SHADER_RESOURCE_BUFFER;
+        default:
+            return VKD3D_SHADER_RESOURCE_NONE;
+    }
+}
+
+static const enum vkd3d_data_type data_type_table[] =
+{
+    [COMPONENT_TYPE_INVALID]     = VKD3D_DATA_UNUSED,
+    [COMPONENT_TYPE_I1]          = VKD3D_DATA_UNUSED,
+    [COMPONENT_TYPE_I16]         = VKD3D_DATA_INT,
+    [COMPONENT_TYPE_U16]         = VKD3D_DATA_UINT,
+    [COMPONENT_TYPE_I32]         = VKD3D_DATA_INT,
+    [COMPONENT_TYPE_U32]         = VKD3D_DATA_UINT,
+    [COMPONENT_TYPE_I64]         = VKD3D_DATA_UNUSED,
+    [COMPONENT_TYPE_U64]         = VKD3D_DATA_UNUSED,
+    [COMPONENT_TYPE_F16]         = VKD3D_DATA_FLOAT,
+    [COMPONENT_TYPE_F32]         = VKD3D_DATA_FLOAT,
+    [COMPONENT_TYPE_F64]         = VKD3D_DATA_DOUBLE,
+    [COMPONENT_TYPE_SNORMF16]    = VKD3D_DATA_SNORM,
+    [COMPONENT_TYPE_UNORMF16]    = VKD3D_DATA_UNORM,
+    [COMPONENT_TYPE_SNORMF32]    = VKD3D_DATA_SNORM,
+    [COMPONENT_TYPE_UNORMF32]    = VKD3D_DATA_UNORM,
+    [COMPONENT_TYPE_SNORMF64]    = VKD3D_DATA_DOUBLE,
+    [COMPONENT_TYPE_UNORMF64]    = VKD3D_DATA_DOUBLE,
+    [COMPONENT_TYPE_PACKEDS8X32] = VKD3D_DATA_UNUSED,
+    [COMPONENT_TYPE_PACKEDU8X32] = VKD3D_DATA_UNUSED,
+};
+
+static enum vkd3d_data_type vkd3d_data_type_from_dxil_component_type(enum dxil_component_type type,
+        struct sm6_parser *sm6)
+{
+    enum vkd3d_data_type data_type;
+
+    if (type >= ARRAY_SIZE(data_type_table) || (data_type = data_type_table[type]) == VKD3D_DATA_UNUSED)
+    {
+        FIXME("Unhandled component type %u.\n", type);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                "Resource descriptor component type %u is unhandled.", type);
+        return VKD3D_DATA_FLOAT;
+    }
+
+    return data_type;
+}
+
+static struct vkd3d_shader_resource *sm6_parser_resources_load_common_info(struct sm6_parser *sm6,
+        const struct sm6_metadata_value *type_value, bool is_uav, enum dxil_resource_kind kind,
+        const struct sm6_metadata_value *m, struct vkd3d_shader_instruction *ins)
+{
+    enum vkd3d_shader_resource_type resource_type;
+    enum dxil_resource_type dxil_resource_type;
+    const struct sm6_metadata_node *node;
+    enum vkd3d_data_type data_type;
+    unsigned int i, values[2];
+
+    if (!(resource_type = shader_resource_type_from_dxil_resource_kind(kind)))
+    {
+        FIXME("Unhandled resource kind %u.\n", kind);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                "Resource kind %u is unhandled.", kind);
+        return NULL;
+    }
+    ins->resource_type = resource_type;
+
+    if (!sm6_metadata_value_is_node(m))
+    {
+        WARN("Resource metadata list is not a node.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                "Resource descriptor metadata list is not a node.");
+        return NULL;
+    }
+
+    node = m->u.node;
+
+    if (node->operand_count < 2)
+    {
+        WARN("Invalid operand count %u.\n", node->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Invalid operand count %u for a resource descriptor.", node->operand_count);
+        return NULL;
+    }
+    if (node->operand_count > 2)
+    {
+        WARN("Ignoring %u extra operands.\n", node->operand_count - 2);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Ignoring %u extra operands for a resource descriptor.", node->operand_count - 2);
+    }
+
+    for (i = 0; i < 2; ++i)
+    {
+        if (!sm6_metadata_get_uint_value(sm6, node->operands[i], &values[i]))
+        {
+            WARN("Failed to load uint value at index %u.\n", i);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                    "A resource descriptor operand metadata value is not an integer.");
+            return NULL;
+        }
+    }
+
+    if ((dxil_resource_type = values[0]) == RESOURCE_TYPE_NON_RAW_STRUCTURED)
+    {
+        if (kind != RESOURCE_KIND_TYPEDBUFFER && !resource_kind_is_texture(kind))
+        {
+            WARN("Unhandled resource kind %u.\n", kind);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                    "Resource kind %u for a typed resource is unhandled.", kind);
+            return NULL;
+        }
+
+        data_type = vkd3d_data_type_from_dxil_component_type(values[1], sm6);
+        ins->handler_idx = is_uav ? VKD3DSIH_DCL_UAV_TYPED : VKD3DSIH_DCL;
+        for (i = 0; i < VKD3D_VEC4_SIZE; ++i)
+            ins->declaration.semantic.resource_data_type[i] = data_type;
+        ins->declaration.semantic.resource_type = resource_type;
+        ins->declaration.semantic.resource.reg.write_mask = VKD3DSP_WRITEMASK_ALL;
+
+        return &ins->declaration.semantic.resource;
+    }
+    else
+    {
+        FIXME("Unhandled resource type %u.\n", dxil_resource_type);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                "Resource type %u is unhandled.", dxil_resource_type);
+    }
+
+    return NULL;
+}
+
+static void init_resource_declaration(struct vkd3d_shader_resource *resource,
+        enum vkd3d_shader_register_type reg_type, enum vkd3d_data_type data_type, unsigned int id,
+        const struct vkd3d_shader_register_range *range)
+{
+    struct vkd3d_shader_dst_param *param = &resource->reg;
+
+    param->modifiers = 0;
+    param->shift = 0;
+    vsir_register_init(&param->reg, reg_type, data_type, 3);
+    param->reg.idx[0].offset = id;
+    param->reg.idx[1].offset = range->first;
+    param->reg.idx[2].offset = range->last;
+
+    resource->range = *range;
+}
+
+static enum vkd3d_result sm6_parser_resources_load_srv(struct sm6_parser *sm6,
+        const struct sm6_metadata_node *node, struct sm6_descriptor_info *d, struct vkd3d_shader_instruction *ins)
+{
+    struct vkd3d_shader_resource *resource;
+    unsigned int kind;
+
+    if (node->operand_count < 9)
+    {
+        WARN("Invalid operand count %u.\n", node->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Invalid operand count %u for an SRV descriptor.", node->operand_count);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    if (node->operand_count > 9)
+    {
+        WARN("Ignoring %u extra operands.\n", node->operand_count - 9);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Ignoring %u extra operands for an SRV descriptor.", node->operand_count - 9);
+    }
+
+    if (!sm6_metadata_get_uint_value(sm6, node->operands[6], &kind))
+    {
+        WARN("Failed to load resource type.\n");
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                "SRV resource type metadata value is not an integer.");
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_INVALID);
+
+    if (!(resource = sm6_parser_resources_load_common_info(sm6, node->operands[1], false, kind,
+            node->operands[8], ins)))
+    {
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    d->resource_type = ins->resource_type;
+    d->kind = kind;
+    d->reg_type = VKD3DSPR_RESOURCE;
+    d->reg_data_type = (ins->resource_type == VKD3D_SHADER_RESOURCE_BUFFER) ? VKD3D_DATA_UINT : VKD3D_DATA_RESOURCE;
+    d->resource_data_type = ins->declaration.semantic.resource_data_type[0];
+
+    init_resource_declaration(resource, VKD3DSPR_RESOURCE, d->reg_data_type, d->id, &d->range);
+
+    if (resource_kind_is_multisampled(kind))
+    {
+        if (!sm6_metadata_get_uint_value(sm6, node->operands[7], &ins->declaration.semantic.sample_count))
+        {
+            WARN("Failed to load sample count.\n");
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                    "SRV sample count metadata value is not an integer.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+    }
+    else if (!sm6_metadata_value_is_zero_or_undef(node->operands[7]))
+    {
+        WARN("Ignoring sample count value.\n");
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Ignoring an SRV descriptor sample count metadata value which is not constant zero or undefined.");
+    }
+
+    return VKD3D_OK;
+}
+
+static enum vkd3d_result sm6_parser_resources_load_uav(struct sm6_parser *sm6,
+        const struct sm6_metadata_node *node, struct sm6_descriptor_info *d, struct vkd3d_shader_instruction *ins)
+{
+    struct vkd3d_shader_resource *resource;
+    unsigned int i, values[4];
+
+    if (node->operand_count < 11)
+    {
+        WARN("Invalid operand count %u.\n", node->operand_count);
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_OPERAND_COUNT,
+                "Invalid operand count %u for a UAV descriptor.", node->operand_count);
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+    if (node->operand_count > 11)
+    {
+        WARN("Ignoring %u extra operands.\n", node->operand_count - 11);
+        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_IGNORING_OPERANDS,
+                "Ignoring %u extra operands for a UAV descriptor.", node->operand_count - 11);
+    }
+
+    for (i = 6; i < 10; ++i)
+    {
+        if (!sm6_metadata_get_uint_value(sm6, node->operands[i], &values[i - 6]))
+        {
+            WARN("Failed to load uint value at index %u.\n", i);
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
+                    "A UAV descriptor operand metadata value is not an integer.");
+            return VKD3D_ERROR_INVALID_SHADER;
+        }
+    }
+
+    vsir_instruction_init(ins, &sm6->p.location, VKD3DSIH_INVALID);
+    if (values[1])
+        ins->flags = VKD3DSUF_GLOBALLY_COHERENT;
+    if (values[2])
+        ins->flags |= VKD3DSUF_ORDER_PRESERVING_COUNTER;
+    if (values[3])
+        ins->flags |= VKD3DSUF_RASTERISER_ORDERED_VIEW;
+
+    if (!(resource = sm6_parser_resources_load_common_info(sm6, node->operands[1], true, values[0],
+            node->operands[10], ins)))
+    {
+        return VKD3D_ERROR_INVALID_SHADER;
+    }
+
+    d->resource_type = ins->resource_type;
+    d->kind = values[0];
+    d->reg_type = VKD3DSPR_UAV;
+    d->reg_data_type = (ins->resource_type == VKD3D_SHADER_RESOURCE_BUFFER) ? VKD3D_DATA_UINT : VKD3D_DATA_UAV;
+    d->resource_data_type = ins->declaration.semantic.resource_data_type[0];
+
+    init_resource_declaration(resource, VKD3DSPR_UAV, d->reg_data_type, d->id, &d->range);
+
+    return VKD3D_OK;
+}
+
 static enum vkd3d_result sm6_parser_resources_load_cbv(struct sm6_parser *sm6,
         const struct sm6_metadata_node *node, struct sm6_descriptor_info *d, struct vkd3d_shader_instruction *ins)
 {
@@ -4769,6 +6281,10 @@ static enum vkd3d_result sm6_parser_resources_load_cbv(struct sm6_parser *sm6,
 
     ins->declaration.cb.range = d->range;
 
+    d->reg_type = VKD3DSPR_CONSTBUFFER;
+    d->reg_data_type = VKD3D_DATA_FLOAT;
+    d->resource_data_type = VKD3D_DATA_FLOAT;
+
     return VKD3D_OK;
 }
 
@@ -4840,6 +6356,14 @@ static enum vkd3d_result sm6_parser_descriptor_type_init(struct sm6_parser *sm6,
                 if ((ret = sm6_parser_resources_load_cbv(sm6, node, d, ins)) < 0)
                     return ret;
                 break;
+            case VKD3D_SHADER_DESCRIPTOR_TYPE_SRV:
+                if ((ret = sm6_parser_resources_load_srv(sm6, node, d, ins)) < 0)
+                    return ret;
+                break;
+            case VKD3D_SHADER_DESCRIPTOR_TYPE_UAV:
+                if ((ret = sm6_parser_resources_load_uav(sm6, node, d, ins)) < 0)
+                    return ret;
+                break;
             default:
                 FIXME("Unsupported descriptor type %u.\n", type);
                 vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_RESOURCES,
@@ -4848,7 +6372,7 @@ static enum vkd3d_result sm6_parser_descriptor_type_init(struct sm6_parser *sm6,
         }
 
         ++sm6->descriptor_count;
-        ++sm6->p.instructions.count;
+        ++sm6->p.program.instructions.count;
     }
 
     return VKD3D_OK;
@@ -5198,9 +6722,9 @@ static enum vkd3d_result sm6_parser_emit_thread_group(struct sm6_parser *sm6, co
     unsigned int group_sizes[3];
     unsigned int i;
 
-    if (sm6->p.shader_version.type != VKD3D_SHADER_TYPE_COMPUTE)
+    if (sm6->p.program.shader_version.type != VKD3D_SHADER_TYPE_COMPUTE)
     {
-        WARN("Shader of type %#x has thread group dimensions.\n", sm6->p.shader_version.type);
+        WARN("Shader of type %#x has thread group dimensions.\n", sm6->p.program.shader_version.type);
         vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_PROPERTIES,
                 "Shader has thread group dimensions but is not a compute shader.");
         return VKD3D_ERROR_INVALID_SHADER;
@@ -5285,7 +6809,7 @@ static enum vkd3d_result sm6_parser_entry_point_init(struct sm6_parser *sm6)
 
     sm6->entry_point = value->u.function.name;
     if (!sm6_metadata_value_is_string(entry_node->operands[1])
-            || ascii_strcasecmp(sm6->entry_point, entry_node->operands[1]->u.string_value))
+            || strcmp(sm6->entry_point, entry_node->operands[1]->u.string_value))
     {
         WARN("Entry point function name %s mismatch.\n", sm6->entry_point);
         vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_ENTRY_POINT_MISMATCH,
@@ -5419,9 +6943,20 @@ static void sm6_symtab_cleanup(struct sm6_symbol *symbols, size_t count)
     vkd3d_free(symbols);
 }
 
+static void sm6_phi_destroy(struct sm6_phi *phi)
+{
+    vkd3d_free(phi->incoming);
+}
+
 static void sm6_block_destroy(struct sm6_block *block)
 {
+    unsigned int i;
+
     vkd3d_free(block->instructions);
+    for (i = 0; i < block->phi_count; ++i)
+        sm6_phi_destroy(&block->phi[i]);
+    vkd3d_free(block->phi);
+    vkd3d_free(block->terminator.cases);
     vkd3d_free(block);
 }
 
@@ -5433,6 +6968,7 @@ static void sm6_functions_cleanup(struct sm6_function *functions, size_t count)
     {
         for (j = 0; j < functions[i].block_count; ++j)
             sm6_block_destroy(functions[i].blocks[j]);
+        vkd3d_free(functions[i].blocks);
     }
     vkd3d_free(functions);
 }
@@ -5443,7 +6979,7 @@ static void sm6_parser_destroy(struct vkd3d_shader_parser *parser)
 
     dxil_block_destroy(&sm6->root_block);
     dxil_global_abbrevs_cleanup(sm6->abbrevs, sm6->abbrev_count);
-    shader_instruction_array_destroy(&parser->instructions);
+    vsir_program_cleanup(&parser->program);
     sm6_type_table_cleanup(sm6->types, sm6->type_count);
     sm6_symtab_cleanup(sm6->global_symbols, sm6->global_symbol_count);
     sm6_functions_cleanup(sm6->functions, sm6->function_count);
@@ -5463,7 +6999,7 @@ static struct sm6_function *sm6_parser_get_function(const struct sm6_parser *sm6
 {
     size_t i;
     for (i = 0; i < sm6->function_count; ++i)
-        if (!ascii_strcasecmp(sm6->functions[i].declaration->u.function.name, name))
+        if (!strcmp(sm6->functions[i].declaration->u.function.name, name))
             return &sm6->functions[i];
     return NULL;
 }
@@ -5538,7 +7074,7 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     if ((magic = sm6->start[0]) != BITCODE_MAGIC)
     {
         WARN("Unknown magic number 0x%08x.\n", magic);
-        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_UNKNOWN_MAGIC_NUMBER,
+        vkd3d_shader_warning(message_context, &location, VKD3D_SHADER_WARNING_DXIL_UNKNOWN_MAGIC_NUMBER,
                 "DXIL bitcode chunk magic number 0x%08x is not the expected 0x%08x.", magic, BITCODE_MAGIC);
     }
 
@@ -5547,7 +7083,7 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     if ((version.type = version_token >> 16) >= VKD3D_SHADER_TYPE_COUNT)
     {
         FIXME("Unknown shader type %#x.\n", version.type);
-        vkd3d_shader_parser_warning(&sm6->p, VKD3D_SHADER_WARNING_DXIL_UNKNOWN_SHADER_TYPE,
+        vkd3d_shader_warning(message_context, &location, VKD3D_SHADER_WARNING_DXIL_UNKNOWN_SHADER_TYPE,
                 "Unknown shader type %#x.", version.type);
     }
 
@@ -5573,10 +7109,10 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     if ((ret = dxil_block_init(block, NULL, sm6)) < 0)
     {
         if (ret == VKD3D_ERROR_OUT_OF_MEMORY)
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                     "Out of memory parsing DXIL bitcode chunk.");
         else if (ret == VKD3D_ERROR_INVALID_SHADER)
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_BITCODE,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_BITCODE,
                     "DXIL bitcode chunk has invalid bitcode.");
         else
             vkd3d_unreachable();
@@ -5606,10 +7142,10 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     if ((ret = sm6_parser_type_table_init(sm6)) < 0)
     {
         if (ret == VKD3D_ERROR_OUT_OF_MEMORY)
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                     "Out of memory parsing DXIL type table.");
         else if (ret == VKD3D_ERROR_INVALID_SHADER)
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_TYPE_TABLE,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_TYPE_TABLE,
                     "DXIL type table is invalid.");
         else
             vkd3d_unreachable();
@@ -5619,10 +7155,10 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     if ((ret = sm6_parser_symtab_init(sm6)) < 0)
     {
         if (ret == VKD3D_ERROR_OUT_OF_MEMORY)
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                     "Out of memory parsing DXIL value symbol table.");
         else if (ret == VKD3D_ERROR_INVALID_SHADER)
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_VALUE_SYMTAB,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_VALUE_SYMTAB,
                     "DXIL value symbol table is invalid.");
         else
             vkd3d_unreachable();
@@ -5633,7 +7169,7 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
             || !(sm6->input_params = shader_parser_get_dst_params(&sm6->p, input_signature->element_count)))
     {
         ERR("Failed to allocate input/output parameters.\n");
-        vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                 "Out of memory allocating input/output parameters.");
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
@@ -5642,7 +7178,7 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     if (!(sm6->functions = vkd3d_calloc(function_count, sizeof(*sm6->functions))))
     {
         ERR("Failed to allocate function array.\n");
-        vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                 "Out of memory allocating DXIL function array.");
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
@@ -5650,14 +7186,14 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     if (sm6_parser_compute_max_value_count(sm6, &sm6->root_block, 0) == SIZE_MAX)
     {
         WARN("Value array count overflowed.\n");
-        vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
                 "Overflow occurred in the DXIL module value count.");
         return VKD3D_ERROR_INVALID_SHADER;
     }
     if (!(sm6->values = vkd3d_calloc(sm6->value_capacity, sizeof(*sm6->values))))
     {
         ERR("Failed to allocate value array.\n");
-        vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                 "Out of memory allocating DXIL value array.");
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
@@ -5684,7 +7220,7 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
         if (j == ARRAY_SIZE(sm6->metadata_tables))
         {
             FIXME("Too many metadata tables.\n");
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_METADATA,
                     "A metadata table count greater than %zu is unsupported.", ARRAY_SIZE(sm6->metadata_tables));
             return VKD3D_ERROR_INVALID_SHADER;
         }
@@ -5702,24 +7238,22 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     if ((ret = sm6_parser_module_init(sm6, &sm6->root_block, 0)) < 0)
     {
         if (ret == VKD3D_ERROR_OUT_OF_MEMORY)
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                     "Out of memory parsing DXIL module.");
         else if (ret == VKD3D_ERROR_INVALID_SHADER)
-            vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
+            vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_INVALID_MODULE,
                     "DXIL module is invalid.");
         return ret;
     }
 
     if (!sm6_parser_require_space(sm6, output_signature->element_count + input_signature->element_count))
     {
-        vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
+        vkd3d_shader_parser_error(&sm6->p, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
                 "Out of memory emitting shader signature declarations.");
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
-    sm6_parser_emit_output_signature(sm6, output_signature);
-    sm6_parser_emit_input_signature(sm6, input_signature);
 
-    sm6->p.shader_desc.ssa_count = sm6->ssa_next_id;
+    sm6->p.program.ssa_count = sm6->ssa_next_id;
 
     if (!(fn = sm6_parser_get_function(sm6, sm6->entry_point)))
     {
@@ -5730,12 +7264,8 @@ static enum vkd3d_result sm6_parser_init(struct sm6_parser *sm6, const uint32_t
     }
 
     assert(sm6->function_count == 1);
-    if (!sm6_block_emit_instructions(fn->blocks[0], sm6))
-    {
-        vkd3d_shader_error(message_context, &location, VKD3D_SHADER_ERROR_DXIL_OUT_OF_MEMORY,
-                "Out of memory emitting shader instructions.");
-        return VKD3D_ERROR_OUT_OF_MEMORY;
-    }
+    if ((ret = sm6_function_emit_blocks(fn, sm6)) < 0)
+        return ret;
 
     dxil_block_destroy(&sm6->root_block);
 
@@ -5786,7 +7316,7 @@ int vkd3d_shader_sm6_parser_create(const struct vkd3d_shader_compile_info *compi
     vkd3d_free(byte_code);
 
     if (!sm6->p.failed && ret >= 0)
-        vsir_validate(&sm6->p);
+        ret = vsir_validate(&sm6->p);
 
     if (sm6->p.failed && ret >= 0)
         ret = VKD3D_ERROR_INVALID_SHADER;
diff --git a/libs/vkd3d/libs/vkd3d-shader/glsl.c b/libs/vkd3d/libs/vkd3d-shader/glsl.c
index f8d68b5..bdd03c1 100644
--- a/libs/vkd3d/libs/vkd3d-shader/glsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/glsl.c
@@ -91,7 +91,7 @@ static void vkd3d_glsl_handle_instruction(struct vkd3d_glsl_generator *generator
 }
 
 int vkd3d_glsl_generator_generate(struct vkd3d_glsl_generator *generator,
-        struct vkd3d_shader_parser *parser, struct vkd3d_shader_code *out)
+        struct vsir_program *program, struct vkd3d_shader_code *out)
 {
     unsigned int i;
     void *code;
@@ -100,10 +100,10 @@ int vkd3d_glsl_generator_generate(struct vkd3d_glsl_generator *generator,
     vkd3d_string_buffer_printf(&generator->buffer, "void main()\n{\n");
 
     generator->location.column = 0;
-    for (i = 0; i < parser->instructions.count; ++i)
+    for (i = 0; i < program->instructions.count; ++i)
     {
         generator->location.line = i + 1;
-        vkd3d_glsl_handle_instruction(generator, &parser->instructions.elements[i]);
+        vkd3d_glsl_handle_instruction(generator, &program->instructions.elements[i]);
     }
 
     if (generator->failed)
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.c b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
index da3bbda..04c3749 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.c
@@ -98,19 +98,22 @@ bool hlsl_add_var(struct hlsl_ctx *ctx, struct hlsl_ir_var *decl, bool local_var
     struct hlsl_scope *scope = ctx->cur_scope;
     struct hlsl_ir_var *var;
 
-    LIST_FOR_EACH_ENTRY(var, &scope->vars, struct hlsl_ir_var, scope_entry)
+    if (decl->name)
     {
-        if (!strcmp(decl->name, var->name))
-            return false;
-    }
-    if (local_var && scope->upper->upper == ctx->globals)
-    {
-        /* Check whether the variable redefines a function parameter. */
-        LIST_FOR_EACH_ENTRY(var, &scope->upper->vars, struct hlsl_ir_var, scope_entry)
+        LIST_FOR_EACH_ENTRY(var, &scope->vars, struct hlsl_ir_var, scope_entry)
         {
-            if (!strcmp(decl->name, var->name))
+            if (var->name && !strcmp(decl->name, var->name))
                 return false;
         }
+        if (local_var && scope->upper->upper == ctx->globals)
+        {
+            /* Check whether the variable redefines a function parameter. */
+            LIST_FOR_EACH_ENTRY(var, &scope->upper->vars, struct hlsl_ir_var, scope_entry)
+            {
+                if (var->name && !strcmp(decl->name, var->name))
+                    return false;
+            }
+        }
     }
 
     list_add_tail(&scope->vars, &decl->scope_entry);
@@ -123,7 +126,7 @@ struct hlsl_ir_var *hlsl_get_var(struct hlsl_scope *scope, const char *name)
 
     LIST_FOR_EACH_ENTRY(var, &scope->vars, struct hlsl_ir_var, scope_entry)
     {
-        if (!strcmp(name, var->name))
+        if (var->name && !strcmp(name, var->name))
             return var;
     }
     if (!scope->upper)
@@ -915,12 +918,17 @@ bool hlsl_types_are_equal(const struct hlsl_type *t1, const struct hlsl_type *t2
     if (t1->class == HLSL_CLASS_ARRAY)
         return t1->e.array.elements_count == t2->e.array.elements_count
                 && hlsl_types_are_equal(t1->e.array.type, t2->e.array.type);
+    if (t1->class == HLSL_CLASS_OBJECT)
+    {
+        if (t1->base_type == HLSL_TYPE_TECHNIQUE && t1->e.version != t2->e.version)
+            return false;
+    }
 
     return true;
 }
 
 struct hlsl_type *hlsl_type_clone(struct hlsl_ctx *ctx, struct hlsl_type *old,
-        unsigned int default_majority, unsigned int modifiers)
+        unsigned int default_majority, uint32_t modifiers)
 {
     struct hlsl_type *type;
 
@@ -945,6 +953,8 @@ struct hlsl_type *hlsl_type_clone(struct hlsl_ctx *ctx, struct hlsl_type *old,
         type->modifiers |= default_majority;
     type->sampler_dim = old->sampler_dim;
     type->is_minimum_precision = old->is_minimum_precision;
+    type->sample_count = old->sample_count;
+
     switch (old->class)
     {
         case HLSL_CLASS_ARRAY:
@@ -993,6 +1003,13 @@ struct hlsl_type *hlsl_type_clone(struct hlsl_ctx *ctx, struct hlsl_type *old,
             break;
         }
 
+        case HLSL_CLASS_OBJECT:
+            if (type->base_type == HLSL_TYPE_TECHNIQUE)
+                type->e.version = old->e.version;
+            if (old->base_type == HLSL_TYPE_TEXTURE || old->base_type == HLSL_TYPE_UAV)
+                type->e.resource_format = old->e.resource_format;
+            break;
+
         default:
             break;
     }
@@ -1030,7 +1047,7 @@ struct hlsl_ir_node *hlsl_new_copy(struct hlsl_ctx *ctx, struct hlsl_ir_node *no
 }
 
 struct hlsl_ir_var *hlsl_new_var(struct hlsl_ctx *ctx, const char *name, struct hlsl_type *type,
-        const struct vkd3d_shader_location *loc, const struct hlsl_semantic *semantic, unsigned int modifiers,
+        const struct vkd3d_shader_location *loc, const struct hlsl_semantic *semantic, uint32_t modifiers,
         const struct hlsl_reg_reservation *reg_reservation)
 {
     struct hlsl_ir_var *var;
@@ -1505,7 +1522,7 @@ struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, const struct
     return &store->node;
 }
 
-struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, DWORD s, unsigned int components,
+struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned int components,
         struct hlsl_ir_node *val, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_ir_swizzle *swizzle;
@@ -2246,7 +2263,7 @@ const char *debug_hlsl_type(struct hlsl_ctx *ctx, const struct hlsl_type *type)
     return ret;
 }
 
-struct vkd3d_string_buffer *hlsl_modifiers_to_string(struct hlsl_ctx *ctx, unsigned int modifiers)
+struct vkd3d_string_buffer *hlsl_modifiers_to_string(struct hlsl_ctx *ctx, uint32_t modifiers)
 {
     struct vkd3d_string_buffer *string;
 
@@ -2432,7 +2449,7 @@ const char *debug_hlsl_writemask(unsigned int writemask)
     return vkd3d_dbg_sprintf(".%s", string);
 }
 
-const char *debug_hlsl_swizzle(unsigned int swizzle, unsigned int size)
+const char *debug_hlsl_swizzle(uint32_t swizzle, unsigned int size)
 {
     static const char components[] = {'x', 'y', 'z', 'w'};
     char string[5];
@@ -3147,9 +3164,10 @@ void hlsl_add_function(struct hlsl_ctx *ctx, char *name, struct hlsl_ir_function
     rb_put(&ctx->functions, func->name, &func->entry);
 }
 
-unsigned int hlsl_map_swizzle(unsigned int swizzle, unsigned int writemask)
+uint32_t hlsl_map_swizzle(uint32_t swizzle, unsigned int writemask)
 {
-    unsigned int i, ret = 0;
+    uint32_t ret = 0;
+    unsigned int i;
 
     /* Leave replicate swizzles alone; some instructions need them. */
     if (swizzle == HLSL_SWIZZLE(X, X, X, X)
@@ -3169,7 +3187,7 @@ unsigned int hlsl_map_swizzle(unsigned int swizzle, unsigned int writemask)
     return ret;
 }
 
-unsigned int hlsl_swizzle_from_writemask(unsigned int writemask)
+uint32_t hlsl_swizzle_from_writemask(unsigned int writemask)
 {
     static const unsigned int swizzles[16] =
     {
@@ -3210,9 +3228,10 @@ unsigned int hlsl_combine_writemasks(unsigned int first, unsigned int second)
     return ret;
 }
 
-unsigned int hlsl_combine_swizzles(unsigned int first, unsigned int second, unsigned int dim)
+uint32_t hlsl_combine_swizzles(uint32_t first, uint32_t second, unsigned int dim)
 {
-    unsigned int ret = 0, i;
+    uint32_t ret = 0;
+    unsigned int i;
     for (i = 0; i < dim; ++i)
     {
         unsigned int s = hlsl_swizzle_get_component(second, i);
@@ -3346,15 +3365,28 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
     effect_types[] =
     {
         {"dword",           HLSL_CLASS_SCALAR, HLSL_TYPE_UINT,          1, 1},
-        {"float",           HLSL_CLASS_SCALAR, HLSL_TYPE_FLOAT,         1, 1},
         {"vector",          HLSL_CLASS_VECTOR, HLSL_TYPE_FLOAT,         4, 1},
         {"matrix",          HLSL_CLASS_MATRIX, HLSL_TYPE_FLOAT,         4, 4},
+        {"fxgroup",         HLSL_CLASS_OBJECT, HLSL_TYPE_EFFECT_GROUP,  1, 1},
+        {"pass",            HLSL_CLASS_OBJECT, HLSL_TYPE_PASS,          1, 1},
         {"STRING",          HLSL_CLASS_OBJECT, HLSL_TYPE_STRING,        1, 1},
         {"TEXTURE",         HLSL_CLASS_OBJECT, HLSL_TYPE_TEXTURE,       1, 1},
         {"PIXELSHADER",     HLSL_CLASS_OBJECT, HLSL_TYPE_PIXELSHADER,   1, 1},
         {"VERTEXSHADER",    HLSL_CLASS_OBJECT, HLSL_TYPE_VERTEXSHADER,  1, 1},
     };
 
+    static const struct
+    {
+        char *name;
+        unsigned int version;
+    }
+    technique_types[] =
+    {
+        {"technique",    9},
+        {"technique10", 10},
+        {"technique11", 11},
+    };
+
     for (bt = 0; bt <= HLSL_TYPE_LAST_SCALAR; ++bt)
     {
         for (y = 1; y <= 4; ++y)
@@ -3459,6 +3491,13 @@ static void declare_predefined_types(struct hlsl_ctx *ctx)
                 effect_types[i].base_type, effect_types[i].dimx, effect_types[i].dimy);
         hlsl_scope_add_type(ctx->globals, type);
     }
+
+    for (i = 0; i < ARRAY_SIZE(technique_types); ++i)
+    {
+        type = hlsl_new_type(ctx, technique_types[i].name, HLSL_CLASS_OBJECT, HLSL_TYPE_TECHNIQUE, 1, 1);
+        type->e.version = technique_types[i].version;
+        hlsl_scope_add_type(ctx->globals, type);
+    }
 }
 
 static bool hlsl_ctx_init(struct hlsl_ctx *ctx, const struct vkd3d_shader_compile_info *compile_info,
@@ -3594,7 +3633,13 @@ int hlsl_compile_shader(const struct vkd3d_shader_code *hlsl, const struct vkd3d
         return VKD3D_ERROR_NOT_IMPLEMENTED;
     }
 
-    if (compile_info->target_type == VKD3D_SHADER_TARGET_D3D_BYTECODE && profile->major_version > 3)
+    if (compile_info->target_type != VKD3D_SHADER_TARGET_FX && profile->type == VKD3D_SHADER_TYPE_EFFECT)
+    {
+        vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_HLSL_INCOMPATIBLE_PROFILE,
+                "The '%s' target profile is only compatible with the 'fx' target type.", profile->name);
+        return VKD3D_ERROR_INVALID_ARGUMENT;
+    }
+    else if (compile_info->target_type == VKD3D_SHADER_TARGET_D3D_BYTECODE && profile->major_version > 3)
     {
         vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_HLSL_INCOMPATIBLE_PROFILE,
                 "The '%s' target profile is incompatible with the 'd3dbc' target type.", profile->name);
@@ -3606,6 +3651,12 @@ int hlsl_compile_shader(const struct vkd3d_shader_code *hlsl, const struct vkd3d
                 "The '%s' target profile is incompatible with the 'dxbc-tpf' target type.", profile->name);
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
+    else if (compile_info->target_type == VKD3D_SHADER_TARGET_FX && profile->type != VKD3D_SHADER_TYPE_EFFECT)
+    {
+        vkd3d_shader_error(message_context, NULL, VKD3D_SHADER_ERROR_HLSL_INCOMPATIBLE_PROFILE,
+                "The '%s' target profile is incompatible with the 'fx' target type.", profile->name);
+        return VKD3D_ERROR_INVALID_ARGUMENT;
+    }
 
     if (!hlsl_ctx_init(&ctx, compile_info, profile, message_context))
         return VKD3D_ERROR_OUT_OF_MEMORY;
@@ -3630,6 +3681,14 @@ int hlsl_compile_shader(const struct vkd3d_shader_code *hlsl, const struct vkd3d
         return VKD3D_ERROR_NOT_IMPLEMENTED;
     }
 
+    if (ctx.profile->type == VKD3D_SHADER_TYPE_EFFECT)
+    {
+        ret = hlsl_emit_effect_binary(&ctx, out);
+
+        hlsl_ctx_cleanup(&ctx);
+        return ret;
+    }
+
     if ((func = hlsl_get_function(&ctx, entry_point)))
     {
         LIST_FOR_EACH_ENTRY(decl, &func->overloads, struct hlsl_ir_function_decl, entry)
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.h b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
index ca75a19..984ac7e 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.h
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.h
@@ -65,7 +65,7 @@
 #define HLSL_SWIZZLE_MASK (0x3u)
 #define HLSL_SWIZZLE_SHIFT(idx) (2u * (idx))
 
-static inline unsigned int hlsl_swizzle_get_component(unsigned int swizzle, unsigned int idx)
+static inline unsigned int hlsl_swizzle_get_component(uint32_t swizzle, unsigned int idx)
 {
     return (swizzle >> HLSL_SWIZZLE_SHIFT(idx)) & HLSL_SWIZZLE_MASK;
 }
@@ -95,6 +95,9 @@ enum hlsl_base_type
     HLSL_TYPE_UAV,
     HLSL_TYPE_PIXELSHADER,
     HLSL_TYPE_VERTEXSHADER,
+    HLSL_TYPE_PASS,
+    HLSL_TYPE_TECHNIQUE,
+    HLSL_TYPE_EFFECT_GROUP,
     HLSL_TYPE_STRING,
     HLSL_TYPE_VOID,
 };
@@ -138,8 +141,10 @@ struct hlsl_type
     struct rb_entry scope_entry;
 
     enum hlsl_type_class class;
-    /* If type is <= HLSL_CLASS_LAST_NUMERIC, then base_type is <= HLSL_TYPE_LAST_SCALAR.
-     * If type is HLSL_CLASS_OBJECT, then base_type is > HLSL_TYPE_LAST_SCALAR.
+    /* If class is <= HLSL_CLASS_LAST_NUMERIC, then base_type is <= HLSL_TYPE_LAST_SCALAR.
+     * If class is HLSL_CLASS_OBJECT, then base_type is > HLSL_TYPE_LAST_SCALAR.
+     * If class is HLSL_CLASS_OBJECT and base_type is HLSL_TYPE_TECHNIQUE, additional version
+     * field is used to distinguish between technique types.
      * Otherwise, base_type is not used. */
     enum hlsl_base_type base_type;
 
@@ -155,7 +160,7 @@ struct hlsl_type
     /* Bitfield for storing type modifiers, subset of HLSL_TYPE_MODIFIERS_MASK.
      * Modifiers that don't fall inside this mask are to be stored in the variable in
      *   hlsl_ir_var.modifiers, or in the struct field in hlsl_ir_field.modifiers. */
-    unsigned int modifiers;
+    uint32_t modifiers;
     /* Size of the type values on each dimension. For non-numeric types, they are set for the
      *   convenience of the sm1/sm4 backends.
      * If type is HLSL_CLASS_SCALAR, then both dimx = 1 and dimy = 1.
@@ -191,6 +196,8 @@ struct hlsl_type
         /* Format of the data contained within the type if the base_type is HLSL_TYPE_TEXTURE or
          *   HLSL_TYPE_UAV. */
         struct hlsl_type *resource_format;
+        /* Additional field to distinguish object types. Currently used only for technique types. */
+        unsigned int version;
     } e;
 
     /* Number of numeric register components used by one value of this type, for each regset.
@@ -234,7 +241,7 @@ struct hlsl_struct_field
     /* Bitfield for storing modifiers that are not in HLSL_TYPE_MODIFIERS_MASK (these are stored in
      *   type->modifiers instead) and that also are specific to the field and not the whole variable.
      *   In particular, interpolation modifiers. */
-    unsigned int storage_modifiers;
+    uint32_t storage_modifiers;
     /* Offset of the field within the type it belongs to, in register components, for each regset. */
     unsigned int reg_offset[HLSL_REGSET_LAST + 1];
 
@@ -392,7 +399,7 @@ struct hlsl_ir_var
     /* Buffer where the variable's value is stored, in case it is uniform. */
     struct hlsl_buffer *buffer;
     /* Bitfield for storage modifiers (type modifiers are stored in data_type->modifiers). */
-    unsigned int storage_modifiers;
+    uint32_t storage_modifiers;
     /* Optional reservations of registers and/or offsets for variables within constant buffers. */
     struct hlsl_reg_reservation reg_reservation;
 
@@ -400,6 +407,10 @@ struct hlsl_ir_var
     struct list scope_entry;
     /* Item entry in hlsl_ctx.extern_vars, if the variable is extern. */
     struct list extern_entry;
+    /* Scope that variable itself defines, used to provide a container for techniques and passes. */
+    struct hlsl_scope *scope;
+    /* Scope that contains annotations for this variable. */
+    struct hlsl_scope *annotations;
 
     /* Indexes of the IR instructions where the variable is first written and last read (liveness
      *   range). The IR instructions are numerated starting from 2, because 0 means unused, and 1
@@ -622,7 +633,7 @@ struct hlsl_ir_swizzle
 {
     struct hlsl_ir_node node;
     struct hlsl_src val;
-    DWORD swizzle;
+    uint32_t swizzle;
 };
 
 struct hlsl_ir_index
@@ -1160,6 +1171,7 @@ void hlsl_dump_function(struct hlsl_ctx *ctx, const struct hlsl_ir_function_decl
 
 int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry_func,
         enum vkd3d_shader_target_type target_type, struct vkd3d_shader_code *out);
+int hlsl_emit_effect_binary(struct hlsl_ctx *ctx, struct vkd3d_shader_code *out);
 
 bool hlsl_init_deref_from_index_chain(struct hlsl_ctx *ctx, struct hlsl_deref *deref, struct hlsl_ir_node *chain);
 bool hlsl_copy_deref(struct hlsl_ctx *ctx, struct hlsl_deref *deref, const struct hlsl_deref *other);
@@ -1250,7 +1262,7 @@ struct hlsl_ir_node *hlsl_new_resource_store(struct hlsl_ctx *ctx, const struct
         struct hlsl_ir_node *coords, struct hlsl_ir_node *value, const struct vkd3d_shader_location *loc);
 struct hlsl_type *hlsl_new_struct_type(struct hlsl_ctx *ctx, const char *name,
         struct hlsl_struct_field *fields, size_t field_count);
-struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, DWORD s, unsigned int components,
+struct hlsl_ir_node *hlsl_new_swizzle(struct hlsl_ctx *ctx, uint32_t s, unsigned int components,
         struct hlsl_ir_node *val, const struct vkd3d_shader_location *loc);
 struct hlsl_ir_var *hlsl_new_synthetic_var(struct hlsl_ctx *ctx, const char *template,
         struct hlsl_type *type, const struct vkd3d_shader_location *loc);
@@ -1264,7 +1276,7 @@ struct hlsl_ir_node *hlsl_new_uint_constant(struct hlsl_ctx *ctx, unsigned int n
 struct hlsl_ir_node *hlsl_new_unary_expr(struct hlsl_ctx *ctx, enum hlsl_ir_expr_op op, struct hlsl_ir_node *arg,
         const struct vkd3d_shader_location *loc);
 struct hlsl_ir_var *hlsl_new_var(struct hlsl_ctx *ctx, const char *name, struct hlsl_type *type,
-        const struct vkd3d_shader_location *loc, const struct hlsl_semantic *semantic, unsigned int modifiers,
+        const struct vkd3d_shader_location *loc, const struct hlsl_semantic *semantic, uint32_t modifiers,
         const struct hlsl_reg_reservation *reg_reservation);
 struct hlsl_ir_switch_case *hlsl_new_switch_case(struct hlsl_ctx *ctx, unsigned int value, bool is_default,
         struct hlsl_block *body, const struct vkd3d_shader_location *loc);
@@ -1286,7 +1298,7 @@ void hlsl_pop_scope(struct hlsl_ctx *ctx);
 bool hlsl_scope_add_type(struct hlsl_scope *scope, struct hlsl_type *type);
 
 struct hlsl_type *hlsl_type_clone(struct hlsl_ctx *ctx, struct hlsl_type *old,
-        unsigned int default_majority, unsigned int modifiers);
+        unsigned int default_majority, uint32_t modifiers);
 unsigned int hlsl_type_component_count(const struct hlsl_type *type);
 unsigned int hlsl_type_get_array_element_reg_size(const struct hlsl_type *type, enum hlsl_regset regset);
 struct hlsl_type *hlsl_type_get_component_type(struct hlsl_ctx *ctx, struct hlsl_type *type,
@@ -1304,10 +1316,10 @@ bool hlsl_types_are_equal(const struct hlsl_type *t1, const struct hlsl_type *t2
 const struct hlsl_type *hlsl_get_multiarray_element_type(const struct hlsl_type *type);
 unsigned int hlsl_get_multiarray_size(const struct hlsl_type *type);
 
-unsigned int hlsl_combine_swizzles(unsigned int first, unsigned int second, unsigned int dim);
+uint32_t hlsl_combine_swizzles(uint32_t first, uint32_t second, unsigned int dim);
 unsigned int hlsl_combine_writemasks(unsigned int first, unsigned int second);
-unsigned int hlsl_map_swizzle(unsigned int swizzle, unsigned int writemask);
-unsigned int hlsl_swizzle_from_writemask(unsigned int writemask);
+uint32_t hlsl_map_swizzle(uint32_t swizzle, unsigned int writemask);
+uint32_t hlsl_swizzle_from_writemask(unsigned int writemask);
 
 struct hlsl_type *hlsl_deref_get_type(struct hlsl_ctx *ctx, const struct hlsl_deref *deref);
 enum hlsl_regset hlsl_deref_get_regset(struct hlsl_ctx *ctx, const struct hlsl_deref *deref);
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.l b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
index fe83875..6cef0e0 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.l
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.l
@@ -89,6 +89,7 @@ else                    {return KW_ELSE;                }
 extern                  {return KW_EXTERN;              }
 false                   {return KW_FALSE;               }
 for                     {return KW_FOR;                 }
+fxgroup                 {return KW_FXGROUP;             }
 GeometryShader          {return KW_GEOMETRYSHADER;      }
 groupshared             {return KW_GROUPSHARED;         }
 if                      {return KW_IF;                  }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl.y b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
index 0dde4c1..8dc353e 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl.y
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl.y
@@ -40,7 +40,7 @@ struct parse_parameter
     const char *name;
     struct hlsl_semantic semantic;
     struct hlsl_reg_reservation reg_reservation;
-    unsigned int modifiers;
+    uint32_t modifiers;
 };
 
 struct parse_colon_attribute
@@ -75,7 +75,7 @@ struct parse_variable_def
     struct parse_initializer initializer;
 
     struct hlsl_type *basic_type;
-    unsigned int modifiers;
+    uint32_t modifiers;
     struct vkd3d_shader_location modifiers_loc;
 };
 
@@ -292,6 +292,21 @@ static bool implicit_compatible_data_types(struct hlsl_ctx *ctx, struct hlsl_typ
     return hlsl_types_are_componentwise_equal(ctx, src, dst);
 }
 
+static void check_condition_type(struct hlsl_ctx *ctx, const struct hlsl_ir_node *cond)
+{
+    const struct hlsl_type *type = cond->data_type;
+
+    if (type->class > HLSL_CLASS_LAST_NUMERIC || type->dimx > 1 || type->dimy > 1)
+    {
+        struct vkd3d_string_buffer *string;
+
+        if ((string = hlsl_type_to_string(ctx, type)))
+            hlsl_error(ctx, &cond->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                    "Condition type '%s' is not a scalar numeric type.", string->buffer);
+        hlsl_release_string_buffer(ctx, string);
+    }
+}
+
 static struct hlsl_ir_node *add_cast(struct hlsl_ctx *ctx, struct hlsl_block *block,
         struct hlsl_ir_node *node, struct hlsl_type *dst_type, const struct vkd3d_shader_location *loc)
 {
@@ -405,7 +420,7 @@ static struct hlsl_ir_node *add_implicit_conversion(struct hlsl_ctx *ctx, struct
     return add_cast(ctx, block, node, dst_type, loc);
 }
 
-static DWORD add_modifiers(struct hlsl_ctx *ctx, DWORD modifiers, DWORD mod,
+static uint32_t add_modifiers(struct hlsl_ctx *ctx, uint32_t modifiers, uint32_t mod,
         const struct vkd3d_shader_location *loc)
 {
     if (modifiers & mod)
@@ -431,6 +446,9 @@ static bool append_conditional_break(struct hlsl_ctx *ctx, struct hlsl_block *co
         return true;
 
     condition = node_from_block(cond_block);
+
+    check_condition_type(ctx, condition);
+
     if (!(not = hlsl_new_unary_expr(ctx, HLSL_OP1_LOGIC_NOT, condition, &condition->loc)))
         return false;
     hlsl_block_add_instr(cond_block, not);
@@ -487,27 +505,27 @@ static void resolve_loop_continue(struct hlsl_ctx *ctx, struct hlsl_block *block
         else if (instr->type == HLSL_IR_JUMP)
         {
             struct hlsl_ir_jump *jump = hlsl_ir_jump(instr);
-            struct hlsl_block block;
+            struct hlsl_block cond_block;
 
             if (jump->type != HLSL_IR_JUMP_UNRESOLVED_CONTINUE)
                 continue;
 
             if (type == LOOP_DO_WHILE)
             {
-                if (!hlsl_clone_block(ctx, &block, cond))
+                if (!hlsl_clone_block(ctx, &cond_block, cond))
                     return;
-                if (!append_conditional_break(ctx, &block))
+                if (!append_conditional_break(ctx, &cond_block))
                 {
-                    hlsl_block_cleanup(&block);
+                    hlsl_block_cleanup(&cond_block);
                     return;
                 }
-                list_move_before(&instr->entry, &block.instrs);
+                list_move_before(&instr->entry, &cond_block.instrs);
             }
             else if (type == LOOP_FOR)
             {
-                if (!hlsl_clone_block(ctx, &block, iter))
+                if (!hlsl_clone_block(ctx, &cond_block, iter))
                     return;
-                list_move_before(&instr->entry, &block.instrs);
+                list_move_before(&instr->entry, &cond_block.instrs);
             }
             jump->type = HLSL_IR_JUMP_CONTINUE;
         }
@@ -868,7 +886,7 @@ static const struct hlsl_struct_field *get_struct_field(const struct hlsl_struct
 }
 
 static struct hlsl_type *apply_type_modifiers(struct hlsl_ctx *ctx, struct hlsl_type *type,
-        unsigned int *modifiers, bool force_majority, const struct vkd3d_shader_location *loc)
+        uint32_t *modifiers, bool force_majority, const struct vkd3d_shader_location *loc)
 {
     unsigned int default_majority = 0;
     struct hlsl_type *new_type;
@@ -926,7 +944,7 @@ static bool shader_profile_version_lt(const struct hlsl_ctx *ctx, unsigned int m
 }
 
 static bool gen_struct_fields(struct hlsl_ctx *ctx, struct parse_fields *fields,
-        struct hlsl_type *type, unsigned int modifiers, struct list *defs)
+        struct hlsl_type *type, uint32_t modifiers, struct list *defs)
 {
     struct parse_variable_def *v, *v_next;
     size_t i = 0;
@@ -1019,7 +1037,7 @@ static bool add_typedef(struct hlsl_ctx *ctx, struct hlsl_type *const orig_type,
         }
         else
         {
-            unsigned int var_modifiers = 0;
+            uint32_t var_modifiers = 0;
 
             if (!(type = apply_type_modifiers(ctx, orig_type, &var_modifiers, true, &v->loc)))
             {
@@ -1096,6 +1114,83 @@ static bool add_func_parameter(struct hlsl_ctx *ctx, struct hlsl_func_parameters
     return true;
 }
 
+static bool add_pass(struct hlsl_ctx *ctx, const char *name, struct hlsl_scope *annotations,
+        const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_var *var;
+    struct hlsl_type *type;
+
+    type = hlsl_get_type(ctx->globals, "pass", false, false);
+    if (!(var = hlsl_new_var(ctx, name, type, loc, NULL, 0, NULL)))
+        return false;
+    var->annotations = annotations;
+
+    if (!hlsl_add_var(ctx, var, false))
+    {
+        struct hlsl_ir_var *old = hlsl_get_var(ctx->cur_scope, var->name);
+
+        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_REDEFINED,
+                "Identifier \"%s\" was already declared in this scope.", var->name);
+        hlsl_note(ctx, &old->loc, VKD3D_SHADER_LOG_ERROR, "\"%s\" was previously declared here.", old->name);
+        hlsl_free_var(var);
+        return false;
+    }
+
+    return true;
+}
+
+static bool add_technique(struct hlsl_ctx *ctx, const char *name, struct hlsl_scope *scope,
+        struct hlsl_scope *annotations, const char *typename, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_var *var;
+    struct hlsl_type *type;
+
+    type = hlsl_get_type(ctx->globals, typename, false, false);
+    if (!(var = hlsl_new_var(ctx, name, type, loc, NULL, 0, NULL)))
+        return false;
+    var->scope = scope;
+    var->annotations = annotations;
+
+    if (!hlsl_add_var(ctx, var, false))
+    {
+        struct hlsl_ir_var *old = hlsl_get_var(ctx->cur_scope, var->name);
+
+        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_REDEFINED,
+                "Identifier \"%s\" was already declared in this scope.", var->name);
+        hlsl_note(ctx, &old->loc, VKD3D_SHADER_LOG_ERROR, "\"%s\" was previously declared here.", old->name);
+        hlsl_free_var(var);
+        return false;
+    }
+
+    return true;
+}
+
+static bool add_effect_group(struct hlsl_ctx *ctx, const char *name, struct hlsl_scope *scope,
+        struct hlsl_scope *annotations, const struct vkd3d_shader_location *loc)
+{
+    struct hlsl_ir_var *var;
+    struct hlsl_type *type;
+
+    type = hlsl_get_type(ctx->globals, "fxgroup", false, false);
+    if (!(var = hlsl_new_var(ctx, name, type, loc, NULL, 0, NULL)))
+        return false;
+    var->scope = scope;
+    var->annotations = annotations;
+
+    if (!hlsl_add_var(ctx, var, false))
+    {
+        struct hlsl_ir_var *old = hlsl_get_var(ctx->cur_scope, var->name);
+
+        hlsl_error(ctx, &var->loc, VKD3D_SHADER_ERROR_HLSL_REDEFINED,
+                "Identifier \"%s\" was already declared in this scope.", var->name);
+        hlsl_note(ctx, &old->loc, VKD3D_SHADER_LOG_ERROR, "\"%s\" was previously declared here.", old->name);
+        hlsl_free_var(var);
+        return false;
+    }
+
+    return true;
+}
+
 static struct hlsl_reg_reservation parse_reg_reservation(const char *reg_string)
 {
     struct hlsl_reg_reservation reservation = {0};
@@ -1717,7 +1812,7 @@ static enum hlsl_ir_expr_op op_from_assignment(enum parse_assign_op op)
     return ops[op];
 }
 
-static bool invert_swizzle(unsigned int *swizzle, unsigned int *writemask, unsigned int *ret_width)
+static bool invert_swizzle(uint32_t *swizzle, unsigned int *writemask, unsigned int *ret_width)
 {
     unsigned int i, j, bit = 0, inverted = 0, width, new_writemask = 0, new_swizzle = 0;
 
@@ -1791,8 +1886,9 @@ static struct hlsl_ir_node *add_assignment(struct hlsl_ctx *ctx, struct hlsl_blo
         else if (lhs->type == HLSL_IR_SWIZZLE)
         {
             struct hlsl_ir_swizzle *swizzle = hlsl_ir_swizzle(lhs);
-            unsigned int width, s = swizzle->swizzle;
             struct hlsl_ir_node *new_swizzle;
+            uint32_t s = swizzle->swizzle;
+            unsigned int width;
 
             if (lhs->data_type->class == HLSL_CLASS_MATRIX)
                 hlsl_fixme(ctx, &lhs->loc, "Matrix assignment with a writemask.");
@@ -3553,7 +3649,7 @@ static bool intrinsic_tex(struct hlsl_ctx *ctx, const struct parse_initializer *
 {
     struct hlsl_resource_load_params load_params = { 0 };
     const struct hlsl_type *sampler_type;
-    struct hlsl_ir_node *coords, *load;
+    struct hlsl_ir_node *coords, *sample;
 
     if (params->args_count != 2 && params->args_count != 4)
     {
@@ -3688,9 +3784,9 @@ static bool intrinsic_tex(struct hlsl_ctx *ctx, const struct parse_initializer *
     load_params.format = hlsl_get_vector_type(ctx, HLSL_TYPE_FLOAT, 4);
     load_params.sampling_dim = dim;
 
-    if (!(load = hlsl_new_resource_load(ctx, &load_params, loc)))
+    if (!(sample = hlsl_new_resource_load(ctx, &load_params, loc)))
         return false;
-    hlsl_block_add_instr(params->instrs, load);
+    hlsl_block_add_instr(params->instrs, sample);
     return true;
 }
 
@@ -4034,6 +4130,89 @@ static struct hlsl_block *add_constructor(struct hlsl_ctx *ctx, struct hlsl_type
     return params->instrs;
 }
 
+static bool add_ternary(struct hlsl_ctx *ctx, struct hlsl_block *block,
+        struct hlsl_ir_node *cond, struct hlsl_ir_node *first, struct hlsl_ir_node *second)
+{
+    struct hlsl_ir_node *args[HLSL_MAX_OPERANDS] = {0};
+    struct hlsl_type *cond_type = cond->data_type;
+    struct hlsl_type *common_type;
+
+    if (cond_type->class > HLSL_CLASS_LAST_NUMERIC)
+    {
+        struct vkd3d_string_buffer *string;
+
+        if ((string = hlsl_type_to_string(ctx, cond_type)))
+            hlsl_error(ctx, &cond->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                    "Ternary condition type '%s' is not numeric.", string->buffer);
+        hlsl_release_string_buffer(ctx, string);
+    }
+
+    if (first->data_type->class <= HLSL_CLASS_LAST_NUMERIC
+            && second->data_type->class <= HLSL_CLASS_LAST_NUMERIC)
+    {
+        if (!(common_type = get_common_numeric_type(ctx, first, second, &first->loc)))
+            return false;
+
+        if (cond_type->dimx == 1 && cond_type->dimy == 1)
+        {
+            cond_type = hlsl_get_numeric_type(ctx, common_type->class,
+                    HLSL_TYPE_BOOL, common_type->dimx, common_type->dimy);
+            if (!(cond = add_implicit_conversion(ctx, block, cond, cond_type, &cond->loc)))
+                return false;
+        }
+        else if (common_type->dimx == 1 && common_type->dimy == 1)
+        {
+            common_type = hlsl_get_numeric_type(ctx, cond_type->class,
+                    common_type->base_type, cond_type->dimx, cond_type->dimy);
+        }
+        else if (cond_type->dimx != common_type->dimx || cond_type->dimy != common_type->dimy)
+        {
+            /* This condition looks wrong but is correct.
+             * floatN is compatible with float1xN, but not with floatNx1. */
+
+            struct vkd3d_string_buffer *cond_string, *value_string;
+
+            cond_string = hlsl_type_to_string(ctx, cond_type);
+            value_string = hlsl_type_to_string(ctx, common_type);
+            if (cond_string && value_string)
+                hlsl_error(ctx, &first->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                        "Ternary condition type '%s' is not compatible with value type '%s'.",
+                        cond_string->buffer, value_string->buffer);
+            hlsl_release_string_buffer(ctx, cond_string);
+            hlsl_release_string_buffer(ctx, value_string);
+        }
+
+        if (!(first = add_implicit_conversion(ctx, block, first, common_type, &first->loc)))
+            return false;
+
+        if (!(second = add_implicit_conversion(ctx, block, second, common_type, &second->loc)))
+            return false;
+    }
+    else
+    {
+        struct vkd3d_string_buffer *first_string, *second_string;
+
+        if (!hlsl_types_are_equal(first->data_type, second->data_type))
+        {
+            first_string = hlsl_type_to_string(ctx, first->data_type);
+            second_string = hlsl_type_to_string(ctx, second->data_type);
+            if (first_string && second_string)
+                hlsl_error(ctx, &first->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
+                        "Ternary argument types '%s' and '%s' do not match.",
+                        first_string->buffer, second_string->buffer);
+            hlsl_release_string_buffer(ctx, first_string);
+            hlsl_release_string_buffer(ctx, second_string);
+        }
+
+        common_type = first->data_type;
+    }
+
+    args[0] = cond;
+    args[1] = first;
+    args[2] = second;
+    return add_expr(ctx, block, HLSL_OP3_TERNARY, args, common_type, &first->loc);
+}
+
 static unsigned int hlsl_offset_dim_count(enum hlsl_sampler_dim dim)
 {
     switch (dim)
@@ -4844,7 +5023,7 @@ static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hls
     FLOAT floatval;
     bool boolval;
     char *name;
-    DWORD modifiers;
+    uint32_t modifiers;
     struct hlsl_ir_node *instr;
     struct hlsl_block *block;
     struct list *list;
@@ -4865,6 +5044,7 @@ static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hls
     struct hlsl_attribute *attr;
     struct parse_attribute_list attr_list;
     struct hlsl_ir_switch_case *switch_case;
+    struct hlsl_scope *scope;
 }
 
 %token KW_BLENDSTATE
@@ -4887,6 +5067,7 @@ static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hls
 %token KW_EXTERN
 %token KW_FALSE
 %token KW_FOR
+%token KW_FXGROUP
 %token KW_GEOMETRYSHADER
 %token KW_GROUPSHARED
 %token KW_IF
@@ -4989,6 +5170,8 @@ static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hls
 %token <name> STRING
 %token <name> TYPE_IDENTIFIER
 
+%type <scope> annotations_opt
+
 %type <arrays> arrays
 
 %type <assign_op> assign_op
@@ -5051,7 +5234,7 @@ static void check_duplicated_switch_cases(struct hlsl_ctx *ctx, const struct hls
 
 %type <name> any_identifier
 %type <name> var_identifier
-%type <name> technique_name
+%type <name> name_opt
 
 %type <parameter> parameter
 
@@ -5093,50 +5276,114 @@ hlsl_prog:
             destroy_block($2);
         }
     | hlsl_prog preproc_directive
-    | hlsl_prog technique
+    | hlsl_prog global_technique
+    | hlsl_prog effect_group
     | hlsl_prog ';'
 
-technique_name:
+name_opt:
       %empty
         {
             $$ = NULL;
         }
     | any_identifier
 
-pass_list:
+pass:
+      KW_PASS name_opt annotations_opt '{' '}'
+        {
+            if (!add_pass(ctx, $2, $3, &@1))
+                YYABORT;
+        }
+
+annotations_list:
+      variables_def_typed ';'
+    | annotations_list variables_def_typed ';'
+
+annotations_opt:
       %empty
+        {
+            $$ = NULL;
+        }
+    | '<' scope_start '>'
+        {
+            hlsl_pop_scope(ctx);
+            $$ = NULL;
+        }
+    | '<' scope_start annotations_list '>'
+        {
+            struct hlsl_scope *scope = ctx->cur_scope;
+
+            hlsl_pop_scope(ctx);
+            $$ = scope;
+        }
+
+pass_list:
+      pass
+    | pass_list pass
+
+passes:
+      scope_start
+    | scope_start pass_list
 
 technique9:
-      KW_TECHNIQUE technique_name '{' pass_list '}'
+      KW_TECHNIQUE name_opt annotations_opt '{' passes '}'
         {
-            hlsl_fixme(ctx, &@$, "Unsupported \'technique\' declaration.");
+            struct hlsl_scope *scope = ctx->cur_scope;
+            hlsl_pop_scope(ctx);
+
+            if (!add_technique(ctx, $2, scope, $3, "technique", &@1))
+                YYABORT;
         }
 
 technique10:
-      KW_TECHNIQUE10 technique_name '{' pass_list '}'
+      KW_TECHNIQUE10 name_opt annotations_opt '{' passes '}'
         {
+            struct hlsl_scope *scope = ctx->cur_scope;
+            hlsl_pop_scope(ctx);
+
             if (ctx->profile->type == VKD3D_SHADER_TYPE_EFFECT && ctx->profile->major_version == 2)
                 hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
                         "The 'technique10' keyword is invalid for this profile.");
 
-            hlsl_fixme(ctx, &@$, "Unsupported \'technique10\' declaration.");
+            if (!add_technique(ctx, $2, scope, $3, "technique10", &@1))
+                YYABORT;
         }
 
 technique11:
-      KW_TECHNIQUE11 technique_name '{' pass_list '}'
+      KW_TECHNIQUE11 name_opt annotations_opt '{' passes '}'
         {
+            struct hlsl_scope *scope = ctx->cur_scope;
+            hlsl_pop_scope(ctx);
+
             if (ctx->profile->type == VKD3D_SHADER_TYPE_EFFECT && ctx->profile->major_version == 2)
                 hlsl_error(ctx, &@1, VKD3D_SHADER_ERROR_HLSL_INVALID_SYNTAX,
                         "The 'technique11' keyword is invalid for this profile.");
 
-            hlsl_fixme(ctx, &@$, "Unsupported \'technique11\' declaration.");
+            if (!add_technique(ctx, $2, scope, $3, "technique11", &@1))
+                YYABORT;
         }
 
-technique:
+global_technique:
       technique9
     | technique10
     | technique11
 
+group_technique:
+      technique10
+    | technique11
+
+group_techniques:
+      group_technique
+    | group_techniques group_technique
+
+effect_group:
+      KW_FXGROUP any_identifier annotations_opt '{' scope_start group_techniques '}'
+        {
+            struct hlsl_scope *scope = ctx->cur_scope;
+            hlsl_pop_scope(ctx);
+            if (!(add_effect_group(ctx, $2, scope, $3, &@2)))
+                YYABORT;
+        }
+
 buffer_declaration:
       buffer_type any_identifier colon_attribute
         {
@@ -5282,7 +5529,7 @@ field:
       var_modifiers field_type variables_def ';'
         {
             struct hlsl_type *type;
-            unsigned int modifiers = $1;
+            uint32_t modifiers = $1;
 
             if (!(type = apply_type_modifiers(ctx, $2, &modifiers, true, &@1)))
                 YYABORT;
@@ -5435,7 +5682,7 @@ func_prototype_no_attrs:
     /* var_modifiers is necessary to avoid shift/reduce conflicts. */
       var_modifiers type var_identifier '(' parameters ')' colon_attribute
         {
-            unsigned int modifiers = $1;
+            uint32_t modifiers = $1;
             struct hlsl_ir_var *var;
             struct hlsl_type *type;
 
@@ -5709,7 +5956,7 @@ param_list:
 parameter:
       var_modifiers type_no_void any_identifier arrays colon_attribute
         {
-            unsigned int modifiers = $1;
+            uint32_t modifiers = $1;
             struct hlsl_type *type;
             unsigned int i;
 
@@ -6023,7 +6270,7 @@ typedef:
       KW_TYPEDEF var_modifiers typedef_type type_specs ';'
         {
             struct parse_variable_def *v, *v_next;
-            unsigned int modifiers = $2;
+            uint32_t modifiers = $2;
             struct hlsl_type *type;
 
             if (!(type = apply_type_modifiers(ctx, $3, &modifiers, false, &@2)))
@@ -6160,7 +6407,7 @@ variable_def:
 variable_def_typed:
       var_modifiers struct_spec variable_def
         {
-            unsigned int modifiers = $1;
+            uint32_t modifiers = $1;
             struct hlsl_type *type;
 
             if (!(type = apply_type_modifiers(ctx, $2, &modifiers, true, &@1)))
@@ -6175,7 +6422,7 @@ variable_def_typed:
         }
     | var_modifiers type variable_def
         {
-            unsigned int modifiers = $1;
+            uint32_t modifiers = $1;
             struct hlsl_type *type;
 
             if (!(type = apply_type_modifiers(ctx, $2, &modifiers, true, &@1)))
@@ -6516,6 +6763,15 @@ selection_statement:
                 }
             }
 
+            check_condition_type(ctx, condition);
+
+            if (!(condition = add_cast(ctx, $4, condition, hlsl_get_scalar_type(ctx, HLSL_TYPE_BOOL), &@4)))
+            {
+                destroy_block($6.then_block);
+                destroy_block($6.else_block);
+                YYABORT;
+            }
+
             if (!(instr = hlsl_new_if(ctx, condition, $6.then_block, $6.else_block, &@2)))
             {
                 destroy_block($6.then_block);
@@ -6524,15 +6780,7 @@ selection_statement:
             }
             destroy_block($6.then_block);
             destroy_block($6.else_block);
-            if (condition->data_type->dimx > 1 || condition->data_type->dimy > 1)
-            {
-                struct vkd3d_string_buffer *string;
 
-                if ((string = hlsl_type_to_string(ctx, condition->data_type)))
-                    hlsl_error(ctx, &instr->loc, VKD3D_SHADER_ERROR_HLSL_INVALID_TYPE,
-                            "if condition type %s is not scalar.", string->buffer);
-                hlsl_release_string_buffer(ctx, string);
-            }
             $$ = $4;
             hlsl_block_add_instr($$, instr);
         }
@@ -7112,27 +7360,13 @@ conditional_expr:
             struct hlsl_ir_node *cond = node_from_block($1);
             struct hlsl_ir_node *first = node_from_block($3);
             struct hlsl_ir_node *second = node_from_block($5);
-            struct hlsl_ir_node *args[HLSL_MAX_OPERANDS] = { 0 };
-            struct hlsl_type *common_type;
 
             hlsl_block_add_block($1, $3);
             hlsl_block_add_block($1, $5);
             destroy_block($3);
             destroy_block($5);
 
-            if (!(common_type = get_common_numeric_type(ctx, first, second, &@3)))
-                YYABORT;
-
-            if (!(first = add_implicit_conversion(ctx, $1, first, common_type, &@3)))
-                YYABORT;
-
-            if (!(second = add_implicit_conversion(ctx, $1, second, common_type, &@5)))
-                YYABORT;
-
-            args[0] = cond;
-            args[1] = first;
-            args[2] = second;
-            if (!add_expr(ctx, $1, HLSL_OP3_TERNARY, args, common_type, &@1))
+            if (!add_ternary(ctx, $1, cond, first, second))
                 YYABORT;
             $$ = $1;
         }
diff --git a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
index 4a62218..1fe141a 100644
--- a/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
+++ b/libs/vkd3d/libs/vkd3d-shader/hlsl_codegen.c
@@ -32,6 +32,11 @@ static struct hlsl_ir_node *new_offset_from_path_index(struct hlsl_ctx *ctx, str
     switch (type->class)
     {
         case HLSL_CLASS_VECTOR:
+            if (idx->type != HLSL_IR_CONSTANT)
+            {
+                hlsl_fixme(ctx, &idx->loc, "Non-constant vector addressing.");
+                break;
+            }
             *offset_component += hlsl_ir_constant(idx)->value.u[0].u;
             break;
 
@@ -263,7 +268,7 @@ static bool types_are_semantic_equivalent(struct hlsl_ctx *ctx, const struct hls
 }
 
 static struct hlsl_ir_var *add_semantic_var(struct hlsl_ctx *ctx, struct hlsl_ir_var *var,
-        struct hlsl_type *type, unsigned int modifiers, struct hlsl_semantic *semantic,
+        struct hlsl_type *type, uint32_t modifiers, struct hlsl_semantic *semantic,
         uint32_t index, bool output, const struct vkd3d_shader_location *loc)
 {
     struct hlsl_semantic new_semantic;
@@ -331,7 +336,7 @@ static struct hlsl_ir_var *add_semantic_var(struct hlsl_ctx *ctx, struct hlsl_ir
 }
 
 static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_load *lhs,
-        unsigned int modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index)
+        uint32_t modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index)
 {
     struct hlsl_type *type = lhs->node.data_type, *vector_type_src, *vector_type_dst;
     struct vkd3d_shader_location *loc = &lhs->node.loc;
@@ -395,7 +400,7 @@ static void prepend_input_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, s
 }
 
 static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_load *lhs,
-        unsigned int modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index)
+        uint32_t modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index)
 {
     struct vkd3d_shader_location *loc = &lhs->node.loc;
     struct hlsl_type *type = lhs->node.data_type;
@@ -411,7 +416,7 @@ static void prepend_input_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *
 
         for (i = 0; i < hlsl_type_element_count(type); ++i)
         {
-            unsigned int element_modifiers = modifiers;
+            uint32_t element_modifiers = modifiers;
 
             if (type->class == HLSL_CLASS_ARRAY)
             {
@@ -473,7 +478,7 @@ static void prepend_input_var_copy(struct hlsl_ctx *ctx, struct hlsl_block *bloc
 }
 
 static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_load *rhs,
-        unsigned int modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index)
+        uint32_t modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index)
 {
     struct hlsl_type *type = rhs->node.data_type, *vector_type;
     struct vkd3d_shader_location *loc = &rhs->node.loc;
@@ -529,7 +534,7 @@ static void append_output_copy(struct hlsl_ctx *ctx, struct hlsl_block *block, s
 }
 
 static void append_output_copy_recurse(struct hlsl_ctx *ctx, struct hlsl_block *block, struct hlsl_ir_load *rhs,
-        unsigned int modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index)
+        uint32_t modifiers, struct hlsl_semantic *semantic, uint32_t semantic_index)
 {
     struct vkd3d_shader_location *loc = &rhs->node.loc;
     struct hlsl_type *type = rhs->node.data_type;
@@ -1090,7 +1095,7 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         unsigned int dim_count = hlsl_sampler_dim_count(val->data_type->sampler_dim);
         struct hlsl_ir_node *coords = index->idx.node;
         struct hlsl_resource_load_params params = {0};
-        struct hlsl_ir_node *load;
+        struct hlsl_ir_node *resource_load;
 
         assert(coords->data_type->class == HLSL_CLASS_VECTOR);
         assert(coords->data_type->base_type == HLSL_TYPE_UINT);
@@ -1104,9 +1109,9 @@ static bool lower_index_loads(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr,
         params.coords = coords;
         params.format = val->data_type->e.resource_format;
 
-        if (!(load = hlsl_new_resource_load(ctx, &params, &instr->loc)))
+        if (!(resource_load = hlsl_new_resource_load(ctx, &params, &instr->loc)))
             return false;
-        hlsl_block_add_instr(block, load);
+        hlsl_block_add_instr(block, resource_load);
         return true;
     }
 
@@ -1519,7 +1524,7 @@ static void copy_propagation_set_value(struct hlsl_ctx *ctx, struct copy_propaga
 
 static bool copy_propagation_replace_with_single_instr(struct hlsl_ctx *ctx,
         const struct copy_propagation_state *state, const struct hlsl_ir_load *load,
-        unsigned int swizzle, struct hlsl_ir_node *instr)
+        uint32_t swizzle, struct hlsl_ir_node *instr)
 {
     const unsigned int instr_component_count = hlsl_type_component_count(instr->data_type);
     const struct hlsl_deref *deref = &load->src;
@@ -1527,7 +1532,7 @@ static bool copy_propagation_replace_with_single_instr(struct hlsl_ctx *ctx,
     struct hlsl_ir_node *new_instr = NULL;
     unsigned int time = load->node.index;
     unsigned int start, count, i;
-    unsigned int ret_swizzle = 0;
+    uint32_t ret_swizzle = 0;
 
     if (!hlsl_component_index_range_from_deref(ctx, deref, &start, &count))
         return false;
@@ -1573,7 +1578,7 @@ static bool copy_propagation_replace_with_single_instr(struct hlsl_ctx *ctx,
 
 static bool copy_propagation_replace_with_constant_vector(struct hlsl_ctx *ctx,
         const struct copy_propagation_state *state, const struct hlsl_ir_load *load,
-        unsigned int swizzle, struct hlsl_ir_node *instr)
+        uint32_t swizzle, struct hlsl_ir_node *instr)
 {
     const unsigned int instr_component_count = hlsl_type_component_count(instr->data_type);
     const struct hlsl_deref *deref = &load->src;
@@ -2239,7 +2244,7 @@ static bool fold_swizzle_chains(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr
     if (next_instr->type == HLSL_IR_SWIZZLE)
     {
         struct hlsl_ir_node *new_swizzle;
-        unsigned int combined_swizzle;
+        uint32_t combined_swizzle;
 
         combined_swizzle = hlsl_combine_swizzles(hlsl_ir_swizzle(next_instr)->swizzle,
                 swizzle->swizzle, instr->data_type->dimx);
@@ -2301,7 +2306,6 @@ static bool normalize_switch_cases(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
     struct hlsl_ir_switch_case *c, *def = NULL;
     bool missing_terminal_break = false;
     struct hlsl_ir_node *node;
-    struct hlsl_ir_jump *jump;
     struct hlsl_ir_switch *s;
 
     if (instr->type != HLSL_IR_SWITCH)
@@ -2320,10 +2324,7 @@ static bool normalize_switch_cases(struct hlsl_ctx *ctx, struct hlsl_ir_node *in
         {
             node = LIST_ENTRY(list_tail(&c->body.instrs), struct hlsl_ir_node, entry);
             if (node->type == HLSL_IR_JUMP)
-            {
-                jump = hlsl_ir_jump(node);
-                terminal_break = jump->type == HLSL_IR_JUMP_BREAK;
-            }
+                terminal_break = (hlsl_ir_jump(node)->type == HLSL_IR_JUMP_BREAK);
         }
 
         missing_terminal_break |= !terminal_break;
@@ -2482,6 +2483,38 @@ static bool lower_nonconstant_vector_derefs(struct hlsl_ctx *ctx, struct hlsl_ir
     return false;
 }
 
+static bool validate_nonconstant_vector_store_derefs(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, struct hlsl_block *block)
+{
+    struct hlsl_ir_node *idx;
+    struct hlsl_deref *deref;
+    struct hlsl_type *type;
+    unsigned int i;
+
+    if (instr->type != HLSL_IR_STORE)
+        return false;
+
+    deref = &hlsl_ir_store(instr)->lhs;
+    assert(deref->var);
+
+    if (deref->path_len == 0)
+        return false;
+
+    type = deref->var->data_type;
+    for (i = 0; i < deref->path_len - 1; ++i)
+        type = hlsl_get_element_type_from_path_index(ctx, type, deref->path[i].node);
+
+    idx = deref->path[deref->path_len - 1].node;
+
+    if (type->class == HLSL_CLASS_VECTOR && idx->type != HLSL_IR_CONSTANT)
+    {
+        /* We should turn this into an hlsl_error after we implement unrolling, because if we get
+         * here after that, it means that the HLSL is invalid. */
+        hlsl_fixme(ctx, &instr->loc, "Non-constant vector addressing on store. Unrolling may be missing.");
+    }
+
+    return false;
+}
+
 /* Lower combined samples and sampler variables to synthesized separated textures and samplers.
  * That is, translate SM1-style samples in the source to SM4-style samples in the bytecode. */
 static bool lower_combined_samples(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, void *context)
@@ -2857,6 +2890,12 @@ static bool lower_ternary(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
     first = expr->operands[1].node;
     second = expr->operands[2].node;
 
+    if (cond->data_type->class > HLSL_CLASS_VECTOR || instr->data_type->class > HLSL_CLASS_VECTOR)
+    {
+        hlsl_fixme(ctx, &instr->loc, "Lower ternary of type other than scalar or vector.\n");
+        return false;
+    }
+
     if (ctx->profile->major_version < 4 && ctx->profile->type == VKD3D_SHADER_TYPE_PIXEL)
     {
         struct hlsl_ir_node *abs, *neg;
@@ -3149,7 +3188,7 @@ static bool lower_int_dot(struct hlsl_ctx *ctx, struct hlsl_ir_node *instr, stru
 
         for (i = 0; i < dimx; ++i)
         {
-            unsigned int s = hlsl_swizzle_from_writemask(1 << i);
+            uint32_t s = hlsl_swizzle_from_writemask(1 << i);
 
             if (!(comps[i] = hlsl_new_swizzle(ctx, s, 1, mult, &instr->loc)))
                 return false;
@@ -4973,6 +5012,8 @@ int hlsl_emit_bytecode(struct hlsl_ctx *ctx, struct hlsl_ir_function_decl *entry
         lower_ir(ctx, lower_abs, body);
     }
 
+    lower_ir(ctx, validate_nonconstant_vector_store_derefs, body);
+
     /* TODO: move forward, remove when no longer needed */
     transform_derefs(ctx, replace_deref_path_with_offset, body);
     while (hlsl_transform_ir(ctx, hlsl_fold_constant_exprs, body, NULL));
diff --git a/libs/vkd3d/libs/vkd3d-shader/ir.c b/libs/vkd3d/libs/vkd3d-shader/ir.c
index 710811c..9079be4 100644
--- a/libs/vkd3d/libs/vkd3d-shader/ir.c
+++ b/libs/vkd3d/libs/vkd3d-shader/ir.c
@@ -18,15 +18,32 @@
 
 #include "vkd3d_shader_private.h"
 
+bool vsir_program_init(struct vsir_program *program, const struct vkd3d_shader_version *version, unsigned int reserve)
+{
+    program->shader_version = *version;
+    return shader_instruction_array_init(&program->instructions, reserve);
+}
+
+void vsir_program_cleanup(struct vsir_program *program)
+{
+    size_t i;
+
+    for (i = 0; i < program->block_name_count; ++i)
+        vkd3d_free((void *)program->block_names[i]);
+    vkd3d_free(program->block_names);
+    shader_instruction_array_destroy(&program->instructions);
+}
+
 static inline bool shader_register_is_phase_instance_id(const struct vkd3d_shader_register *reg)
 {
     return reg->type == VKD3DSPR_FORKINSTID || reg->type == VKD3DSPR_JOININSTID;
 }
 
-static bool shader_instruction_is_dcl(const struct vkd3d_shader_instruction *ins)
+static bool vsir_instruction_is_dcl(const struct vkd3d_shader_instruction *instruction)
 {
-    return (VKD3DSIH_DCL <= ins->handler_idx && ins->handler_idx <= VKD3DSIH_DCL_VERTICES_OUT)
-            || ins->handler_idx == VKD3DSIH_HS_DECLS;
+    enum vkd3d_shader_opcode handler_idx = instruction->handler_idx;
+    return (VKD3DSIH_DCL <= handler_idx && handler_idx <= VKD3DSIH_DCL_VERTICES_OUT)
+            || handler_idx == VKD3DSIH_HS_DECLS;
 }
 
 static void vkd3d_shader_instruction_make_nop(struct vkd3d_shader_instruction *ins)
@@ -36,6 +53,129 @@ static void vkd3d_shader_instruction_make_nop(struct vkd3d_shader_instruction *i
     vsir_instruction_init(ins, &location, VKD3DSIH_NOP);
 }
 
+static void remove_dcl_temps(struct vsir_program *program)
+{
+    unsigned int i;
+
+    for (i = 0; i < program->instructions.count; ++i)
+    {
+        struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
+
+        if (ins->handler_idx == VKD3DSIH_DCL_TEMPS)
+            vkd3d_shader_instruction_make_nop(ins);
+    }
+}
+
+static bool vsir_instruction_init_with_params(struct vkd3d_shader_parser *parser,
+        struct vkd3d_shader_instruction *ins, const struct vkd3d_shader_location *location,
+        enum vkd3d_shader_opcode handler_idx, unsigned int dst_count, unsigned int src_count)
+{
+    vsir_instruction_init(ins, location, handler_idx);
+    ins->dst_count = dst_count;
+    ins->src_count = src_count;
+
+    if (!(ins->dst = shader_parser_get_dst_params(parser, ins->dst_count)))
+    {
+        ERR("Failed to allocate %u destination parameters.\n", dst_count);
+        return false;
+    }
+
+    if (!(ins->src = shader_parser_get_src_params(parser, ins->src_count)))
+    {
+        ERR("Failed to allocate %u source parameters.\n", src_count);
+        return false;
+    }
+
+    memset(ins->dst, 0, sizeof(*ins->dst) * ins->dst_count);
+    memset(ins->src, 0, sizeof(*ins->src) * ins->src_count);
+    return true;
+}
+
+static enum vkd3d_result instruction_array_lower_texkills(struct vkd3d_shader_parser *parser)
+{
+    struct vsir_program *program = &parser->program;
+    struct vkd3d_shader_instruction_array *instructions = &program->instructions;
+    struct vkd3d_shader_instruction *texkill_ins, *ins;
+    unsigned int components_read = 3 + (program->shader_version.major >= 2);
+    unsigned int tmp_idx = ~0u;
+    unsigned int i, k;
+
+    for (i = 0; i < instructions->count; ++i)
+    {
+        texkill_ins = &instructions->elements[i];
+
+        if (texkill_ins->handler_idx != VKD3DSIH_TEXKILL)
+            continue;
+
+        if (!shader_instruction_array_insert_at(instructions, i + 1, components_read + 1))
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+
+        if (tmp_idx == ~0u)
+            tmp_idx = program->temp_count++;
+
+        /* tmp = ins->dst[0] < 0  */
+
+        ins = &instructions->elements[i + 1];
+        if (!vsir_instruction_init_with_params(parser, ins, &texkill_ins->location, VKD3DSIH_LTO, 1, 2))
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+
+        vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+        ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
+        ins->dst[0].reg.idx[0].offset = tmp_idx;
+        ins->dst[0].write_mask = VKD3DSP_WRITEMASK_ALL;
+
+        ins->src[0].reg = texkill_ins->dst[0].reg;
+        vsir_register_init(&ins->src[1].reg, VKD3DSPR_IMMCONST, VKD3D_DATA_FLOAT, 0);
+        ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
+        ins->src[1].reg.u.immconst_f32[0] = 0.0f;
+        ins->src[1].reg.u.immconst_f32[1] = 0.0f;
+        ins->src[1].reg.u.immconst_f32[2] = 0.0f;
+        ins->src[1].reg.u.immconst_f32[3] = 0.0f;
+
+        /* tmp.x = tmp.x || tmp.y */
+        /* tmp.x = tmp.x || tmp.z */
+        /* tmp.x = tmp.x || tmp.w, if sm >= 2.0 */
+
+        for (k = 1; k < components_read; ++k)
+        {
+            ins = &instructions->elements[i + 1 + k];
+            if (!(vsir_instruction_init_with_params(parser, ins, &texkill_ins->location, VKD3DSIH_OR, 1, 2)))
+                return VKD3D_ERROR_OUT_OF_MEMORY;
+
+            vsir_register_init(&ins->dst[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+            ins->dst[0].reg.dimension = VSIR_DIMENSION_VEC4;
+            ins->dst[0].reg.idx[0].offset = tmp_idx;
+            ins->dst[0].write_mask = VKD3DSP_WRITEMASK_0;
+
+            vsir_register_init(&ins->src[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+            ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
+            ins->src[0].reg.idx[0].offset = tmp_idx;
+            ins->src[0].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
+            vsir_register_init(&ins->src[1].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+            ins->src[1].reg.dimension = VSIR_DIMENSION_VEC4;
+            ins->src[1].reg.idx[0].offset = tmp_idx;
+            ins->src[1].swizzle = vkd3d_shader_create_swizzle(k, k, k, k);
+        }
+
+        /* discard_nz tmp.x */
+
+        ins = &instructions->elements[i + 1 + components_read];
+        if (!(vsir_instruction_init_with_params(parser, ins, &texkill_ins->location, VKD3DSIH_DISCARD, 0, 1)))
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+        ins->flags = VKD3D_SHADER_CONDITIONAL_OP_NZ;
+
+        vsir_register_init(&ins->src[0].reg, VKD3DSPR_TEMP, VKD3D_DATA_UINT, 1);
+        ins->src[0].reg.dimension = VSIR_DIMENSION_VEC4;
+        ins->src[0].reg.idx[0].offset = tmp_idx;
+        ins->src[0].swizzle = VKD3D_SHADER_SWIZZLE(X, X, X, X);
+
+        /* Make the original instruction no-op */
+        vkd3d_shader_instruction_make_nop(texkill_ins);
+    }
+
+    return VKD3D_OK;
+}
+
 static void shader_register_eliminate_phase_addressing(struct vkd3d_shader_register *reg,
         unsigned int instance_id)
 {
@@ -63,7 +203,7 @@ static void shader_instruction_eliminate_phase_instance_id(struct vkd3d_shader_i
         if (shader_register_is_phase_instance_id(reg))
         {
             vsir_register_init(reg, VKD3DSPR_IMMCONST, reg->data_type, 0);
-            reg->u.immconst_uint[0] = instance_id;
+            reg->u.immconst_u32[0] = instance_id;
             continue;
         }
         shader_register_eliminate_phase_addressing(reg, instance_id);
@@ -143,9 +283,6 @@ struct hull_flattener
 {
     struct vkd3d_shader_instruction_array instructions;
 
-    unsigned int max_temp_count;
-    unsigned int temp_dcl_idx;
-
     unsigned int instance_count;
     unsigned int phase_body_idx;
     enum vkd3d_shader_opcode phase;
@@ -203,23 +340,8 @@ static void flattener_eliminate_phase_related_dcls(struct hull_flattener *normal
         vkd3d_shader_instruction_make_nop(ins);
         return;
     }
-    else if (ins->handler_idx == VKD3DSIH_DCL_TEMPS && normaliser->phase != VKD3DSIH_INVALID)
-    {
-        /* Leave only the first temp declaration and set it to the max count later. */
-        if (!normaliser->max_temp_count)
-        {
-            normaliser->max_temp_count = ins->declaration.count;
-            normaliser->temp_dcl_idx = index;
-        }
-        else
-        {
-            normaliser->max_temp_count = max(normaliser->max_temp_count, ins->declaration.count);
-            vkd3d_shader_instruction_make_nop(ins);
-        }
-        return;
-    }
 
-    if (normaliser->phase == VKD3DSIH_INVALID || shader_instruction_is_dcl(ins))
+    if (normaliser->phase == VKD3DSIH_INVALID || vsir_instruction_is_dcl(ins))
         return;
 
     if (normaliser->phase_body_idx == ~0u)
@@ -312,6 +434,21 @@ void vsir_register_init(struct vkd3d_shader_register *reg, enum vkd3d_shader_reg
     reg->alignment = 0;
 }
 
+void vsir_src_param_init(struct vkd3d_shader_src_param *param, enum vkd3d_shader_register_type reg_type,
+        enum vkd3d_data_type data_type, unsigned int idx_count)
+{
+    vsir_register_init(&param->reg, reg_type, data_type, idx_count);
+    param->swizzle = 0;
+    param->modifiers = VKD3DSPSM_NONE;
+}
+
+void vsir_src_param_init_label(struct vkd3d_shader_src_param *param, unsigned int label_id)
+{
+    vsir_src_param_init(param, VKD3DSPR_LABEL, VKD3D_DATA_UINT, 1);
+    param->reg.dimension = VSIR_DIMENSION_NONE;
+    param->reg.idx[0].offset = label_id;
+}
+
 void vsir_instruction_init(struct vkd3d_shader_instruction *ins, const struct vkd3d_shader_location *location,
         enum vkd3d_shader_opcode handler_idx)
 {
@@ -320,6 +457,23 @@ void vsir_instruction_init(struct vkd3d_shader_instruction *ins, const struct vk
     ins->handler_idx = handler_idx;
 }
 
+static bool vsir_instruction_init_label(struct vkd3d_shader_instruction *ins, const struct vkd3d_shader_location *location,
+        unsigned int label_id, void *parser)
+{
+    struct vkd3d_shader_src_param *src_param;
+
+    if (!(src_param = shader_parser_get_src_params(parser, 1)))
+        return false;
+
+    vsir_src_param_init_label(src_param, label_id);
+
+    vsir_instruction_init(ins, location, VKD3DSIH_LABEL);
+    ins->src = src_param;
+    ins->src_count = 1;
+
+    return true;
+}
+
 static enum vkd3d_result instruction_array_flatten_hull_shader_phases(struct vkd3d_shader_instruction_array *src_instructions)
 {
     struct hull_flattener flattener = {*src_instructions};
@@ -339,9 +493,6 @@ static enum vkd3d_result instruction_array_flatten_hull_shader_phases(struct vkd
 
     if (flattener.phase != VKD3DSIH_INVALID)
     {
-        if (flattener.temp_dcl_idx)
-            instructions->elements[flattener.temp_dcl_idx].declaration.count = flattener.max_temp_count;
-
         if (!shader_instruction_array_reserve(&flattener.instructions, flattener.instructions.count + 1))
             return VKD3D_ERROR_OUT_OF_MEMORY;
         vsir_instruction_init(&instructions->elements[instructions->count++], &flattener.last_ret_location, VKD3DSIH_RET);
@@ -463,6 +614,7 @@ static enum vkd3d_result instruction_array_normalise_hull_shader_control_point_i
     struct vkd3d_shader_instruction_array *instructions;
     struct control_point_normaliser normaliser;
     unsigned int input_control_point_count;
+    struct vkd3d_shader_location location;
     struct vkd3d_shader_instruction *ins;
     enum vkd3d_result ret;
     unsigned int i, j;
@@ -488,10 +640,10 @@ static enum vkd3d_result instruction_array_normalise_hull_shader_control_point_i
                 normaliser.phase = ins->handler_idx;
                 break;
             default:
-                if (shader_instruction_is_dcl(ins))
+                if (vsir_instruction_is_dcl(ins))
                     break;
                 for (j = 0; j < ins->dst_count; ++j)
-                    shader_dst_param_normalise_outpointid((struct vkd3d_shader_dst_param *)&ins->dst[j], &normaliser);
+                    shader_dst_param_normalise_outpointid(&ins->dst[j], &normaliser);
                 break;
         }
     }
@@ -513,8 +665,10 @@ static enum vkd3d_result instruction_array_normalise_hull_shader_control_point_i
                 return VKD3D_OK;
             case VKD3DSIH_HS_FORK_PHASE:
             case VKD3DSIH_HS_JOIN_PHASE:
+                /* ins may be relocated if the instruction array expands. */
+                location = ins->location;
                 ret = control_point_normaliser_emit_hs_input(&normaliser, input_signature,
-                        input_control_point_count, i, &ins->location);
+                        input_control_point_count, i, &location);
                 *src_instructions = normaliser.instructions;
                 return ret;
             default:
@@ -530,13 +684,11 @@ struct io_normaliser
 {
     struct vkd3d_shader_instruction_array instructions;
     enum vkd3d_shader_type shader_type;
+    uint8_t major;
     struct shader_signature *input_signature;
     struct shader_signature *output_signature;
     struct shader_signature *patch_constant_signature;
 
-    unsigned int max_temp_count;
-    unsigned int temp_dcl_idx;
-
     unsigned int instance_count;
     unsigned int phase_body_idx;
     enum vkd3d_shader_opcode phase;
@@ -567,7 +719,7 @@ static bool io_normaliser_is_in_control_point_phase(const struct io_normaliser *
 static unsigned int shader_signature_find_element_for_reg(const struct shader_signature *signature,
         unsigned int reg_idx, unsigned int write_mask)
 {
-    unsigned int i;
+    unsigned int i, base_write_mask;
 
     for (i = 0; i < signature->element_count; ++i)
     {
@@ -579,7 +731,14 @@ static unsigned int shader_signature_find_element_for_reg(const struct shader_si
         }
     }
 
-    /* Validated in the TPF reader. */
+    /* Validated in the TPF reader, but failure in signature_element_range_expand_mask()
+     * can land us here on an unmatched vector mask. */
+    FIXME("Failed to find signature element for register index %u, mask %#x; using scalar mask.\n",
+            reg_idx, write_mask);
+    base_write_mask = 1u << vsir_write_mask_get_component_idx(write_mask);
+    if (base_write_mask != write_mask)
+        return shader_signature_find_element_for_reg(signature, reg_idx, base_write_mask);
+
     vkd3d_unreachable();
 }
 
@@ -590,19 +749,19 @@ struct signature_element *vsir_signature_find_element_for_reg(const struct shade
 }
 
 static unsigned int range_map_get_register_count(uint8_t range_map[][VKD3D_VEC4_SIZE],
-        unsigned int register_idx, unsigned int write_mask)
+        unsigned int register_idx, uint32_t write_mask)
 {
-    return range_map[register_idx][vkd3d_write_mask_get_component_idx(write_mask)];
+    return range_map[register_idx][vsir_write_mask_get_component_idx(write_mask)];
 }
 
 static void range_map_set_register_range(uint8_t range_map[][VKD3D_VEC4_SIZE], unsigned int register_idx,
-        unsigned int register_count, unsigned int write_mask, bool is_dcl_indexrange)
+        unsigned int register_count, uint32_t write_mask, bool is_dcl_indexrange)
 {
     unsigned int i, j, r, c, component_idx, component_count;
 
     assert(write_mask <= VKD3DSP_WRITEMASK_ALL);
-    component_idx = vkd3d_write_mask_get_component_idx(write_mask);
-    component_count = vkd3d_write_mask_component_count(write_mask);
+    component_idx = vsir_write_mask_get_component_idx(write_mask);
+    component_count = vsir_write_mask_component_count(write_mask);
 
     assert(register_idx < MAX_REG_OUTPUT && MAX_REG_OUTPUT - register_idx >= register_count);
 
@@ -746,12 +905,58 @@ static int signature_element_index_compare(const void *a, const void *b)
     return vkd3d_u32_compare(e->sort_index, f->sort_index);
 }
 
+static unsigned int signature_element_range_expand_mask(struct signature_element *e, unsigned int register_count,
+        uint8_t range_map[][VKD3D_VEC4_SIZE])
+{
+    unsigned int i, j, component_idx, component_count, merged_write_mask = e->mask;
+
+    /* dcl_indexrange instructions can declare a subset of the full mask, and the masks of
+     * the elements within the range may differ. TPF's handling of arrayed inputs with
+     * dcl_indexrange is really just a hack. Here we create a mask which covers all element
+     * masks, and check for collisions with other ranges. */
+
+    for (i = 1; i < register_count; ++i)
+        merged_write_mask |= e[i].mask;
+
+    if (merged_write_mask == e->mask)
+        return merged_write_mask;
+
+    /* Reaching this point is very rare to begin with, and collisions are even rarer or
+     * impossible. If the latter shows up, the fallback in shader_signature_find_element_for_reg()
+     * may be sufficient. */
+
+    component_idx = vsir_write_mask_get_component_idx(e->mask);
+    component_count = vsir_write_mask_component_count(e->mask);
+
+    for (i = e->register_index; i < e->register_index + register_count; ++i)
+    {
+        for (j = 0; j < component_idx; ++j)
+            if (range_map[i][j])
+                break;
+        for (j = component_idx + component_count; j < VKD3D_VEC4_SIZE; ++j)
+            if (range_map[i][j])
+                break;
+    }
+
+    if (i == register_count)
+    {
+        WARN("Expanding mask %#x to %#x for %s, base reg %u, count %u.\n", e->mask, merged_write_mask,
+                e->semantic_name, e->register_index, register_count);
+        return merged_write_mask;
+    }
+
+    WARN("Cannot expand mask %#x to %#x for %s, base reg %u, count %u.\n", e->mask, merged_write_mask,
+            e->semantic_name, e->register_index, register_count);
+    return e->mask;
+}
+
 static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map[][VKD3D_VEC4_SIZE],
         bool is_patch_constant)
 {
     unsigned int i, j, element_count, new_count, register_count;
     struct signature_element *elements;
     struct signature_element *e, *f;
+    bool used;
 
     element_count = s->element_count;
     if (!(elements = vkd3d_malloc(element_count * sizeof(*elements))))
@@ -772,14 +977,15 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
         if (range_map_get_register_count(range_map, e->register_index, e->mask) > 1)
             continue;
 
+        used = e->used_mask;
+
         for (; j < element_count; ++j)
         {
             f = &elements[j];
 
             /* Merge different components of the same register unless sysvals are different,
-             * interpolation modes are different, or it will be relative-addressed. */
+             * or it will be relative-addressed. */
             if (f->register_index != e->register_index || f->sysval_semantic != e->sysval_semantic
-                    || f->interpolation_mode != e->interpolation_mode
                     || range_map_get_register_count(range_map, f->register_index, f->mask) > 1)
                 break;
 
@@ -790,6 +996,16 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
             e->mask |= f->mask;
             e->used_mask |= f->used_mask;
             e->semantic_index = min(e->semantic_index, f->semantic_index);
+
+            /* The first element may have no interpolation mode if it is unused. Elements which
+             * actually have different interpolation modes are assigned different registers. */
+            if (f->used_mask && !used)
+            {
+                if (e->interpolation_mode && e->interpolation_mode != f->interpolation_mode)
+                    FIXME("Mismatching interpolation modes %u and %u.\n", e->interpolation_mode, f->interpolation_mode);
+                else
+                    e->interpolation_mode = f->interpolation_mode;
+            }
         }
     }
     element_count = new_count;
@@ -816,6 +1032,7 @@ static bool shader_signature_merge(struct shader_signature *s, uint8_t range_map
         {
             TRACE("Merging %s, base reg %u, count %u.\n", e->semantic_name, e->register_index, register_count);
             e->register_count = register_count;
+            e->mask = signature_element_range_expand_mask(e, register_count, range_map);
         }
     }
     element_count = new_count;
@@ -840,6 +1057,13 @@ static unsigned int shader_register_normalise_arrayed_addressing(struct vkd3d_sh
         reg->idx[id_idx + 1].rel_addr = NULL;
         reg->idx[id_idx + 1].offset = reg->idx[id_idx].offset;
         reg->idx[id_idx].offset -= register_index;
+        if (id_idx)
+        {
+            /* idx[id_idx] now contains the array index, which must be moved below the control point id. */
+            struct vkd3d_shader_register_index tmp = reg->idx[id_idx];
+            reg->idx[id_idx] = reg->idx[id_idx - 1];
+            reg->idx[id_idx - 1] = tmp;
+        }
         ++id_idx;
     }
     /* Otherwise we have no address for the arrayed register, so insert one. This happens e.g. where
@@ -864,39 +1088,70 @@ static bool shader_dst_param_io_normalise(struct vkd3d_shader_dst_param *dst_par
     const struct shader_signature *signature;
     const struct signature_element *e;
 
-    if ((reg->type == VKD3DSPR_OUTPUT && io_normaliser_is_in_fork_or_join_phase(normaliser))
-            || reg->type == VKD3DSPR_PATCHCONST)
-    {
-        signature = normaliser->patch_constant_signature;
-        /* Convert patch constant outputs to the patch constant register type to avoid the need
-         * to convert compiler symbols when accessed as inputs in a later stage. */
-        reg->type = VKD3DSPR_PATCHCONST;
-        dcl_params = normaliser->pc_dcl_params;
-    }
-    else if (reg->type == VKD3DSPR_OUTPUT || dst_param->reg.type == VKD3DSPR_COLOROUT)
-    {
-        signature = normaliser->output_signature;
-        reg->type = VKD3DSPR_OUTPUT;
-        dcl_params = normaliser->output_dcl_params;
-    }
-    else if (dst_param->reg.type == VKD3DSPR_INCONTROLPOINT || dst_param->reg.type == VKD3DSPR_INPUT)
-    {
-        signature = normaliser->input_signature;
-        reg->type = VKD3DSPR_INPUT;
-        dcl_params = normaliser->input_dcl_params;
-    }
-    else
+    switch (reg->type)
     {
-        return true;
+        case VKD3DSPR_OUTPUT:
+            reg_idx = reg->idx[reg->idx_count - 1].offset;
+            if (io_normaliser_is_in_fork_or_join_phase(normaliser))
+            {
+                signature = normaliser->patch_constant_signature;
+                /* Convert patch constant outputs to the patch constant register type to avoid the need
+                 * to convert compiler symbols when accessed as inputs in a later stage. */
+                reg->type = VKD3DSPR_PATCHCONST;
+                dcl_params = normaliser->pc_dcl_params;
+            }
+            else
+            {
+                signature = normaliser->output_signature;
+                dcl_params = normaliser->output_dcl_params;
+            }
+            break;
+
+        case VKD3DSPR_PATCHCONST:
+            reg_idx = reg->idx[reg->idx_count - 1].offset;
+            signature = normaliser->patch_constant_signature;
+            dcl_params = normaliser->pc_dcl_params;
+            break;
+
+        case VKD3DSPR_COLOROUT:
+            reg_idx = reg->idx[0].offset;
+            signature = normaliser->output_signature;
+            reg->type = VKD3DSPR_OUTPUT;
+            dcl_params = normaliser->output_dcl_params;
+            break;
+
+        case VKD3DSPR_INCONTROLPOINT:
+        case VKD3DSPR_INPUT:
+            reg_idx = reg->idx[reg->idx_count - 1].offset;
+            signature = normaliser->input_signature;
+            reg->type = VKD3DSPR_INPUT;
+            dcl_params = normaliser->input_dcl_params;
+            break;
+
+        case VKD3DSPR_ATTROUT:
+            reg_idx = SM1_COLOR_REGISTER_OFFSET + reg->idx[0].offset;
+            signature = normaliser->output_signature;
+            reg->type = VKD3DSPR_OUTPUT;
+            dcl_params = normaliser->output_dcl_params;
+            break;
+
+        case VKD3DSPR_RASTOUT:
+            reg_idx = SM1_RASTOUT_REGISTER_OFFSET + reg->idx[0].offset;
+            signature = normaliser->output_signature;
+            reg->type = VKD3DSPR_OUTPUT;
+            dcl_params = normaliser->output_dcl_params;
+            break;
+
+        default:
+            return true;
     }
 
     id_idx = reg->idx_count - 1;
-    reg_idx = reg->idx[id_idx].offset;
     write_mask = dst_param->write_mask;
     element_idx = shader_signature_find_element_for_reg(signature, reg_idx, write_mask);
     e = &signature->elements[element_idx];
 
-    dst_param->write_mask >>= vkd3d_write_mask_get_component_idx(e->mask);
+    dst_param->write_mask >>= vsir_write_mask_get_component_idx(e->mask);
     if (is_io_dcl)
     {
         /* Validated in the TPF reader. */
@@ -979,27 +1234,43 @@ static void shader_src_param_io_normalise(struct vkd3d_shader_src_param *src_par
     switch (reg->type)
     {
         case VKD3DSPR_PATCHCONST:
+            reg_idx = reg->idx[reg->idx_count - 1].offset;
             signature = normaliser->patch_constant_signature;
             break;
+
         case VKD3DSPR_INCONTROLPOINT:
             reg->type = VKD3DSPR_INPUT;
             /* fall through */
         case VKD3DSPR_INPUT:
+            if (normaliser->major < 3 && normaliser->shader_type == VKD3D_SHADER_TYPE_PIXEL)
+                reg_idx = SM1_COLOR_REGISTER_OFFSET + reg->idx[0].offset;
+            else
+                reg_idx = reg->idx[reg->idx_count - 1].offset;
             signature = normaliser->input_signature;
             break;
+
         case VKD3DSPR_OUTCONTROLPOINT:
             reg->type = VKD3DSPR_OUTPUT;
             /* fall through */
         case VKD3DSPR_OUTPUT:
+            reg_idx = reg->idx[reg->idx_count - 1].offset;
             signature = normaliser->output_signature;
             break;
+
+        case VKD3DSPR_TEXTURE:
+            if (normaliser->shader_type != VKD3D_SHADER_TYPE_PIXEL)
+                return;
+            reg->type = VKD3DSPR_INPUT;
+            reg_idx = reg->idx[0].offset;
+            signature = normaliser->input_signature;
+            break;
+
         default:
             return;
     }
 
     id_idx = reg->idx_count - 1;
-    reg_idx = reg->idx[id_idx].offset;
-    write_mask = VKD3DSP_WRITEMASK_0 << vkd3d_swizzle_get_component(src_param->swizzle, 0);
+    write_mask = VKD3DSP_WRITEMASK_0 << vsir_swizzle_get_component(src_param->swizzle, 0);
     element_idx = shader_signature_find_element_for_reg(signature, reg_idx, write_mask);
 
     e = &signature->elements[element_idx];
@@ -1008,10 +1279,10 @@ static void shader_src_param_io_normalise(struct vkd3d_shader_src_param *src_par
     reg->idx[id_idx].offset = element_idx;
     reg->idx_count = id_idx + 1;
 
-    if ((component_idx = vkd3d_write_mask_get_component_idx(e->mask)))
+    if ((component_idx = vsir_write_mask_get_component_idx(e->mask)))
     {
         for (i = 0; i < VKD3D_VEC4_SIZE; ++i)
-            if (vkd3d_swizzle_get_component(src_param->swizzle, i))
+            if (vsir_swizzle_get_component(src_param->swizzle, i))
                 src_param->swizzle -= component_idx << VKD3D_SHADER_SWIZZLE_SHIFT(i);
     }
 }
@@ -1062,32 +1333,34 @@ static void shader_instruction_normalise_io_params(struct vkd3d_shader_instructi
             memset(normaliser->pc_dcl_params, 0, sizeof(normaliser->pc_dcl_params));
             break;
         default:
-            if (shader_instruction_is_dcl(ins))
+            if (vsir_instruction_is_dcl(ins))
                 break;
             for (i = 0; i < ins->dst_count; ++i)
-                shader_dst_param_io_normalise((struct vkd3d_shader_dst_param *)&ins->dst[i], false, normaliser);
+                shader_dst_param_io_normalise(&ins->dst[i], false, normaliser);
             for (i = 0; i < ins->src_count; ++i)
-                shader_src_param_io_normalise((struct vkd3d_shader_src_param *)&ins->src[i], normaliser);
+                shader_src_param_io_normalise(&ins->src[i], normaliser);
             break;
     }
 }
 
 static enum vkd3d_result shader_normalise_io_registers(struct vkd3d_shader_parser *parser)
 {
-    struct io_normaliser normaliser = {parser->instructions};
+    struct io_normaliser normaliser = {parser->program.instructions};
+    struct vsir_program *program = &parser->program;
     struct vkd3d_shader_instruction *ins;
     bool has_control_point_phase;
     unsigned int i, j;
 
     normaliser.phase = VKD3DSIH_INVALID;
-    normaliser.shader_type = parser->shader_version.type;
+    normaliser.shader_type = program->shader_version.type;
+    normaliser.major = program->shader_version.major;
     normaliser.input_signature = &parser->shader_desc.input_signature;
     normaliser.output_signature = &parser->shader_desc.output_signature;
     normaliser.patch_constant_signature = &parser->shader_desc.patch_constant_signature;
 
-    for (i = 0, has_control_point_phase = false; i < parser->instructions.count; ++i)
+    for (i = 0, has_control_point_phase = false; i < program->instructions.count; ++i)
     {
-        ins = &parser->instructions.elements[i];
+        ins = &program->instructions.elements[i];
 
         switch (ins->handler_idx)
         {
@@ -1130,7 +1403,7 @@ static enum vkd3d_result shader_normalise_io_registers(struct vkd3d_shader_parse
             || !shader_signature_merge(&parser->shader_desc.output_signature, normaliser.output_range_map, false)
             || !shader_signature_merge(&parser->shader_desc.patch_constant_signature, normaliser.pc_range_map, true))
     {
-        parser->instructions = normaliser.instructions;
+        program->instructions = normaliser.instructions;
         return VKD3D_ERROR_OUT_OF_MEMORY;
     }
 
@@ -1138,8 +1411,8 @@ static enum vkd3d_result shader_normalise_io_registers(struct vkd3d_shader_parse
     for (i = 0; i < normaliser.instructions.count; ++i)
         shader_instruction_normalise_io_params(&normaliser.instructions.elements[i], &normaliser);
 
-    parser->instructions = normaliser.instructions;
-    parser->shader_desc.use_vocp = normaliser.use_vocp;
+    program->instructions = normaliser.instructions;
+    program->use_vocp = normaliser.use_vocp;
     return VKD3D_OK;
 }
 
@@ -1152,7 +1425,6 @@ struct flat_constant_def
 
 struct flat_constants_normaliser
 {
-    struct vkd3d_shader_parser *parser;
     struct flat_constant_def *defs;
     size_t def_count, defs_capacity;
 };
@@ -1215,7 +1487,7 @@ static void shader_register_normalise_flat_constants(struct vkd3d_shader_src_par
             param->reg.idx_count = 0;
             param->reg.dimension = VSIR_DIMENSION_VEC4;
             for (j = 0; j < 4; ++j)
-                param->reg.u.immconst_uint[j] = normaliser->defs[i].value[j];
+                param->reg.u.immconst_u32[j] = normaliser->defs[i].value[j];
             return;
         }
     }
@@ -1227,14 +1499,14 @@ static void shader_register_normalise_flat_constants(struct vkd3d_shader_src_par
     param->reg.idx_count = 3;
 }
 
-static enum vkd3d_result instruction_array_normalise_flat_constants(struct vkd3d_shader_parser *parser)
+static enum vkd3d_result instruction_array_normalise_flat_constants(struct vsir_program *program)
 {
-    struct flat_constants_normaliser normaliser = {.parser = parser};
+    struct flat_constants_normaliser normaliser = {0};
     unsigned int i, j;
 
-    for (i = 0; i < parser->instructions.count; ++i)
+    for (i = 0; i < program->instructions.count; ++i)
     {
-        struct vkd3d_shader_instruction *ins = &parser->instructions.elements[i];
+        struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
 
         if (ins->handler_idx == VKD3DSIH_DEF || ins->handler_idx == VKD3DSIH_DEFI || ins->handler_idx == VKD3DSIH_DEFB)
         {
@@ -1251,14 +1523,14 @@ static enum vkd3d_result instruction_array_normalise_flat_constants(struct vkd3d
 
             get_flat_constant_register_type((struct vkd3d_shader_register *)&ins->dst[0].reg, &def->set, &def->index);
             for (j = 0; j < 4; ++j)
-                def->value[j] = ins->src[0].reg.u.immconst_uint[j];
+                def->value[j] = ins->src[0].reg.u.immconst_u32[j];
 
             vkd3d_shader_instruction_make_nop(ins);
         }
         else
         {
             for (j = 0; j < ins->src_count; ++j)
-                shader_register_normalise_flat_constants((struct vkd3d_shader_src_param *)&ins->src[j], &normaliser);
+                shader_register_normalise_flat_constants(&ins->src[j], &normaliser);
         }
     }
 
@@ -1266,14 +1538,14 @@ static enum vkd3d_result instruction_array_normalise_flat_constants(struct vkd3d
     return VKD3D_OK;
 }
 
-static void remove_dead_code(struct vkd3d_shader_parser *parser)
+static void remove_dead_code(struct vsir_program *program)
 {
     size_t i, depth = 0;
     bool dead = false;
 
-    for (i = 0; i < parser->instructions.count; ++i)
+    for (i = 0; i < program->instructions.count; ++i)
     {
-        struct vkd3d_shader_instruction *ins = &parser->instructions.elements[i];
+        struct vkd3d_shader_instruction *ins = &program->instructions.elements[i];
 
         switch (ins->handler_idx)
         {
@@ -1360,15 +1632,15 @@ static enum vkd3d_result normalise_combined_samplers(struct vkd3d_shader_parser
 {
     unsigned int i;
 
-    for (i = 0; i < parser->instructions.count; ++i)
+    for (i = 0; i < parser->program.instructions.count; ++i)
     {
-        struct vkd3d_shader_instruction *ins = &parser->instructions.elements[i];
+        struct vkd3d_shader_instruction *ins = &parser->program.instructions.elements[i];
         struct vkd3d_shader_src_param *srcs;
 
         switch (ins->handler_idx)
         {
             case VKD3DSIH_TEX:
-                if (!(srcs = shader_src_param_allocator_get(&parser->instructions.src_params, 3)))
+                if (!(srcs = shader_src_param_allocator_get(&parser->program.instructions.src_params, 3)))
                     return VKD3D_ERROR_OUT_OF_MEMORY;
                 memset(srcs, 0, sizeof(*srcs) * 3);
 
@@ -1424,111 +1696,805 @@ static enum vkd3d_result normalise_combined_samplers(struct vkd3d_shader_parser
     return VKD3D_OK;
 }
 
-enum vkd3d_result vkd3d_shader_normalise(struct vkd3d_shader_parser *parser,
-        const struct vkd3d_shader_compile_info *compile_info)
+struct cf_flattener_if_info
 {
-    struct vkd3d_shader_instruction_array *instructions = &parser->instructions;
-    enum vkd3d_result result = VKD3D_OK;
-
-    if (parser->shader_desc.is_dxil)
-        return result;
+    struct vkd3d_shader_src_param *false_param;
+    unsigned int id;
+    uint32_t merge_block_id;
+    unsigned int else_block_id;
+};
 
-    if (parser->shader_version.type != VKD3D_SHADER_TYPE_PIXEL
-            && (result = remap_output_signature(parser, compile_info)) < 0)
-        return result;
+struct cf_flattener_loop_info
+{
+    unsigned int header_block_id;
+    unsigned int continue_block_id;
+    uint32_t merge_block_id;
+};
 
-    if (parser->shader_version.type == VKD3D_SHADER_TYPE_HULL
-            && (result = instruction_array_flatten_hull_shader_phases(instructions)) >= 0)
-    {
-        result = instruction_array_normalise_hull_shader_control_point_io(instructions,
-                &parser->shader_desc.input_signature);
-    }
-    if (result >= 0)
-        result = shader_normalise_io_registers(parser);
+struct cf_flattener_switch_case
+{
+    unsigned int value;
+    unsigned int block_id;
+};
 
-    if (result >= 0)
-        result = instruction_array_normalise_flat_constants(parser);
+struct cf_flattener_switch_info
+{
+    size_t ins_location;
+    const struct vkd3d_shader_src_param *condition;
+    unsigned int id;
+    unsigned int merge_block_id;
+    unsigned int default_block_id;
+    struct cf_flattener_switch_case *cases;
+    size_t cases_size;
+    unsigned int cases_count;
+};
 
-    if (result >= 0)
-        remove_dead_code(parser);
+struct cf_flattener_info
+{
+    union
+    {
+        struct cf_flattener_if_info if_;
+        struct cf_flattener_loop_info loop;
+        struct cf_flattener_switch_info switch_;
+    } u;
 
-    if (result >= 0)
-        result = normalise_combined_samplers(parser);
+    enum
+    {
+        VKD3D_BLOCK_IF,
+        VKD3D_BLOCK_LOOP,
+        VKD3D_BLOCK_SWITCH,
+    } current_block;
+    bool inside_block;
+};
 
-    if (result >= 0 && TRACE_ON())
-        vkd3d_shader_trace(instructions, &parser->shader_version);
+struct cf_flattener
+{
+    struct vkd3d_shader_parser *parser;
 
-    if (result >= 0 && !parser->failed)
-        vsir_validate(parser);
+    struct vkd3d_shader_location location;
+    bool allocation_failed;
 
-    if (result >= 0 && parser->failed)
-        result = VKD3D_ERROR_INVALID_SHADER;
+    struct vkd3d_shader_instruction *instructions;
+    size_t instruction_capacity;
+    size_t instruction_count;
 
-    return result;
-}
+    unsigned int block_id;
+    const char **block_names;
+    size_t block_name_capacity;
+    size_t block_name_count;
 
-struct validation_context
-{
-    struct vkd3d_shader_parser *parser;
-    size_t instruction_idx;
-    bool dcl_temps_found;
-    unsigned int temp_count;
-    enum vkd3d_shader_opcode phase;
+    unsigned int branch_id;
+    unsigned int loop_id;
+    unsigned int switch_id;
 
-    enum vkd3d_shader_opcode *blocks;
-    size_t depth;
-    size_t blocks_capacity;
+    unsigned int control_flow_depth;
+    struct cf_flattener_info *control_flow_info;
+    size_t control_flow_info_size;
 };
 
-static void VKD3D_PRINTF_FUNC(3, 4) validator_error(struct validation_context *ctx,
-        enum vkd3d_shader_error error, const char *format, ...)
+static struct vkd3d_shader_instruction *cf_flattener_require_space(struct cf_flattener *flattener, size_t count)
 {
-    struct vkd3d_string_buffer buf;
-    va_list args;
+    if (!vkd3d_array_reserve((void **)&flattener->instructions, &flattener->instruction_capacity,
+            flattener->instruction_count + count, sizeof(*flattener->instructions)))
+    {
+        ERR("Failed to allocate instructions.\n");
+        flattener->allocation_failed = true;
+        return NULL;
+    }
+    return &flattener->instructions[flattener->instruction_count];
+}
 
-    vkd3d_string_buffer_init(&buf);
+static bool cf_flattener_copy_instruction(struct cf_flattener *flattener,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    struct vkd3d_shader_instruction *dst_ins;
 
-    va_start(args, format);
-    vkd3d_string_buffer_vprintf(&buf, format, args);
-    va_end(args);
+    if (instruction->handler_idx == VKD3DSIH_NOP)
+        return true;
 
-    vkd3d_shader_parser_error(ctx->parser, error, "instruction %zu: %s", ctx->instruction_idx + 1, buf.buffer);
-    ERR("VSIR validation error: instruction %zu: %s\n", ctx->instruction_idx + 1, buf.buffer);
+    if (!(dst_ins = cf_flattener_require_space(flattener, 1)))
+        return false;
 
-    vkd3d_string_buffer_cleanup(&buf);
+    *dst_ins = *instruction;
+    ++flattener->instruction_count;
+    return true;
 }
 
-static void vsir_validate_src_param(struct validation_context *ctx,
-        const struct vkd3d_shader_src_param *src);
-
-static void vsir_validate_register(struct validation_context *ctx,
-        const struct vkd3d_shader_register *reg)
+static unsigned int cf_flattener_alloc_block_id(struct cf_flattener *flattener)
 {
-    unsigned int i, temp_count = ctx->temp_count;
-
-    /* SM1-3 shaders do not include a DCL_TEMPS instruction. */
-    if (ctx->parser->shader_version.major <= 3)
-        temp_count = ctx->parser->shader_desc.temp_count;
+    return ++flattener->block_id;
+}
 
-    if (reg->type >= VKD3DSPR_COUNT)
-        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE, "Invalid register type %#x.",
-                reg->type);
+static struct vkd3d_shader_src_param *instruction_src_params_alloc(struct vkd3d_shader_instruction *ins,
+        unsigned int count, struct cf_flattener *flattener)
+{
+    struct vkd3d_shader_src_param *params = shader_parser_get_src_params(flattener->parser, count);
+    if (!params)
+    {
+        flattener->allocation_failed = true;
+        return NULL;
+    }
+    ins->src = params;
+    ins->src_count = count;
+    return params;
+}
 
-    if (reg->precision >= VKD3D_SHADER_REGISTER_PRECISION_COUNT)
-        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_PRECISION, "Invalid register precision %#x.",
-                reg->precision);
+static void cf_flattener_emit_label(struct cf_flattener *flattener, unsigned int label_id)
+{
+    struct vkd3d_shader_instruction *ins;
 
-    if (reg->data_type >= VKD3D_DATA_COUNT)
-        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE, "Invalid register data type %#x.",
-                reg->data_type);
+    if (!(ins = cf_flattener_require_space(flattener, 1)))
+        return;
+    if (vsir_instruction_init_label(ins, &flattener->location, label_id, flattener->parser))
+        ++flattener->instruction_count;
+    else
+        flattener->allocation_failed = true;
+}
 
-    if (reg->dimension >= VSIR_DIMENSION_COUNT)
-        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION, "Invalid register dimension %#x.",
-                reg->dimension);
+/* For conditional branches, this returns the false target branch parameter. */
+static struct vkd3d_shader_src_param *cf_flattener_emit_branch(struct cf_flattener *flattener,
+        unsigned int merge_block_id, unsigned int continue_block_id,
+        const struct vkd3d_shader_src_param *condition, unsigned int true_id, unsigned int false_id,
+        unsigned int flags)
+{
+    struct vkd3d_shader_src_param *src_params, *false_branch_param;
+    struct vkd3d_shader_instruction *ins;
 
-    if (reg->idx_count > ARRAY_SIZE(reg->idx))
-        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid register index count %u.",
-                reg->idx_count);
+    if (!(ins = cf_flattener_require_space(flattener, 1)))
+        return NULL;
+    vsir_instruction_init(ins, &flattener->location, VKD3DSIH_BRANCH);
+
+    if (condition)
+    {
+        if (!(src_params = instruction_src_params_alloc(ins, 4 + !!continue_block_id, flattener)))
+            return NULL;
+        src_params[0] = *condition;
+        if (flags == VKD3D_SHADER_CONDITIONAL_OP_Z)
+        {
+            vsir_src_param_init_label(&src_params[1], false_id);
+            vsir_src_param_init_label(&src_params[2], true_id);
+            false_branch_param = &src_params[1];
+        }
+        else
+        {
+            vsir_src_param_init_label(&src_params[1], true_id);
+            vsir_src_param_init_label(&src_params[2], false_id);
+            false_branch_param = &src_params[2];
+        }
+        vsir_src_param_init_label(&src_params[3], merge_block_id);
+        if (continue_block_id)
+            vsir_src_param_init_label(&src_params[4], continue_block_id);
+    }
+    else
+    {
+        if (!(src_params = instruction_src_params_alloc(ins, merge_block_id ? 3 : 1, flattener)))
+            return NULL;
+        vsir_src_param_init_label(&src_params[0], true_id);
+        if (merge_block_id)
+        {
+            /* An unconditional branch may only have merge information for a loop, which
+             * must have both a merge block and continue block. */
+            vsir_src_param_init_label(&src_params[1], merge_block_id);
+            vsir_src_param_init_label(&src_params[2], continue_block_id);
+        }
+        false_branch_param = NULL;
+    }
+
+    ++flattener->instruction_count;
+
+    return false_branch_param;
+}
+
+static void cf_flattener_emit_conditional_branch_and_merge(struct cf_flattener *flattener,
+        const struct vkd3d_shader_src_param *condition, unsigned int true_id, unsigned int flags)
+{
+    unsigned int merge_block_id;
+
+    merge_block_id = cf_flattener_alloc_block_id(flattener);
+    cf_flattener_emit_branch(flattener, merge_block_id, 0, condition, true_id, merge_block_id, flags);
+    cf_flattener_emit_label(flattener, merge_block_id);
+}
+
+static void cf_flattener_emit_unconditional_branch(struct cf_flattener *flattener, unsigned int target_block_id)
+{
+    cf_flattener_emit_branch(flattener, 0, 0, NULL, target_block_id, 0, 0);
+}
+
+static struct cf_flattener_info *cf_flattener_push_control_flow_level(struct cf_flattener *flattener)
+{
+    if (!vkd3d_array_reserve((void **)&flattener->control_flow_info, &flattener->control_flow_info_size,
+            flattener->control_flow_depth + 1, sizeof(*flattener->control_flow_info)))
+    {
+        ERR("Failed to allocate control flow info structure.\n");
+        flattener->allocation_failed = true;
+        return NULL;
+    }
+
+    return &flattener->control_flow_info[flattener->control_flow_depth++];
+}
+
+static void cf_flattener_pop_control_flow_level(struct cf_flattener *flattener)
+{
+    struct cf_flattener_info *cf_info;
+
+    cf_info = &flattener->control_flow_info[--flattener->control_flow_depth];
+    memset(cf_info, 0, sizeof(*cf_info));
+}
+
+static struct cf_flattener_info *cf_flattener_find_innermost_loop(struct cf_flattener *flattener)
+{
+    int depth;
+
+    for (depth = flattener->control_flow_depth - 1; depth >= 0; --depth)
+    {
+        if (flattener->control_flow_info[depth].current_block == VKD3D_BLOCK_LOOP)
+            return &flattener->control_flow_info[depth];
+    }
+
+    return NULL;
+}
+
+static struct cf_flattener_info *cf_flattener_find_innermost_breakable_cf_construct(struct cf_flattener *flattener)
+{
+    int depth;
+
+    for (depth = flattener->control_flow_depth - 1; depth >= 0; --depth)
+    {
+        if (flattener->control_flow_info[depth].current_block == VKD3D_BLOCK_LOOP
+                || flattener->control_flow_info[depth].current_block == VKD3D_BLOCK_SWITCH)
+            return &flattener->control_flow_info[depth];
+    }
+
+    return NULL;
+}
+
+static void VKD3D_PRINTF_FUNC(3, 4) cf_flattener_create_block_name(struct cf_flattener *flattener,
+        unsigned int block_id, const char *fmt, ...)
+{
+    struct vkd3d_string_buffer buffer;
+    size_t block_name_count;
+    va_list args;
+
+    --block_id;
+
+    block_name_count = max(flattener->block_name_count, block_id + 1);
+    if (!vkd3d_array_reserve((void **)&flattener->block_names, &flattener->block_name_capacity,
+            block_name_count, sizeof(*flattener->block_names)))
+        return;
+    memset(&flattener->block_names[flattener->block_name_count], 0,
+            (block_name_count - flattener->block_name_count) * sizeof(*flattener->block_names));
+    flattener->block_name_count = block_name_count;
+
+    vkd3d_string_buffer_init(&buffer);
+    va_start(args, fmt);
+    vkd3d_string_buffer_vprintf(&buffer, fmt, args);
+    va_end(args);
+
+    flattener->block_names[block_id] = buffer.buffer;
+}
+
+static enum vkd3d_result cf_flattener_iterate_instruction_array(struct cf_flattener *flattener)
+{
+    bool main_block_open, is_hull_shader, after_declarations_section;
+    struct vkd3d_shader_parser *parser = flattener->parser;
+    struct vkd3d_shader_instruction_array *instructions;
+    struct vsir_program *program = &parser->program;
+    struct vkd3d_shader_instruction *dst_ins;
+    size_t i;
+
+    instructions = &program->instructions;
+    is_hull_shader = program->shader_version.type == VKD3D_SHADER_TYPE_HULL;
+    main_block_open = !is_hull_shader;
+    after_declarations_section = is_hull_shader;
+
+    if (!cf_flattener_require_space(flattener, instructions->count + 1))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
+
+    for (i = 0; i < instructions->count; ++i)
+    {
+        unsigned int loop_header_block_id, loop_body_block_id, continue_block_id, merge_block_id, true_block_id;
+        const struct vkd3d_shader_instruction *instruction = &instructions->elements[i];
+        const struct vkd3d_shader_src_param *src = instruction->src;
+        struct cf_flattener_info *cf_info;
+
+        flattener->location = instruction->location;
+
+        /* Declarations should occur before the first code block, which in hull shaders is marked by the first
+         * phase instruction, and in all other shader types begins with the first label instruction. */
+        if (!after_declarations_section && !vsir_instruction_is_dcl(instruction)
+                && instruction->handler_idx != VKD3DSIH_NOP)
+        {
+            after_declarations_section = true;
+            cf_flattener_emit_label(flattener, cf_flattener_alloc_block_id(flattener));
+        }
+
+        cf_info = flattener->control_flow_depth
+                ? &flattener->control_flow_info[flattener->control_flow_depth - 1] : NULL;
+
+        switch (instruction->handler_idx)
+        {
+            case VKD3DSIH_HS_CONTROL_POINT_PHASE:
+            case VKD3DSIH_HS_FORK_PHASE:
+            case VKD3DSIH_HS_JOIN_PHASE:
+                if (!cf_flattener_copy_instruction(flattener, instruction))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                if (instruction->handler_idx != VKD3DSIH_HS_CONTROL_POINT_PHASE || !instruction->flags)
+                    after_declarations_section = false;
+                break;
+
+            case VKD3DSIH_LABEL:
+                vkd3d_shader_parser_error(parser, VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED,
+                        "Aborting due to not yet implemented feature: Label instruction.");
+                return VKD3D_ERROR_NOT_IMPLEMENTED;
+
+            case VKD3DSIH_IF:
+                if (!(cf_info = cf_flattener_push_control_flow_level(flattener)))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+
+                true_block_id = cf_flattener_alloc_block_id(flattener);
+                merge_block_id = cf_flattener_alloc_block_id(flattener);
+                cf_info->u.if_.false_param = cf_flattener_emit_branch(flattener, merge_block_id, 0,
+                        src, true_block_id, merge_block_id, instruction->flags);
+                if (!cf_info->u.if_.false_param)
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+
+                cf_flattener_emit_label(flattener, true_block_id);
+
+                cf_info->u.if_.id = flattener->branch_id;
+                cf_info->u.if_.merge_block_id = merge_block_id;
+                cf_info->u.if_.else_block_id = 0;
+                cf_info->inside_block = true;
+                cf_info->current_block = VKD3D_BLOCK_IF;
+
+                cf_flattener_create_block_name(flattener, merge_block_id, "branch%u_merge", flattener->branch_id);
+                cf_flattener_create_block_name(flattener, true_block_id, "branch%u_true", flattener->branch_id);
+                ++flattener->branch_id;
+                break;
+
+            case VKD3DSIH_ELSE:
+                if (cf_info->inside_block)
+                    cf_flattener_emit_unconditional_branch(flattener, cf_info->u.if_.merge_block_id);
+
+                cf_info->u.if_.else_block_id = cf_flattener_alloc_block_id(flattener);
+                cf_info->u.if_.false_param->reg.idx[0].offset = cf_info->u.if_.else_block_id;
+
+                cf_flattener_create_block_name(flattener,
+                        cf_info->u.if_.else_block_id, "branch%u_false", cf_info->u.if_.id);
+                cf_flattener_emit_label(flattener, cf_info->u.if_.else_block_id);
+
+                cf_info->inside_block = true;
+                break;
+
+            case VKD3DSIH_ENDIF:
+                if (cf_info->inside_block)
+                    cf_flattener_emit_unconditional_branch(flattener, cf_info->u.if_.merge_block_id);
+
+                cf_flattener_emit_label(flattener, cf_info->u.if_.merge_block_id);
+
+                cf_flattener_pop_control_flow_level(flattener);
+                break;
+
+            case VKD3DSIH_LOOP:
+                if (!(cf_info = cf_flattener_push_control_flow_level(flattener)))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+
+                loop_header_block_id = cf_flattener_alloc_block_id(flattener);
+                loop_body_block_id = cf_flattener_alloc_block_id(flattener);
+                continue_block_id = cf_flattener_alloc_block_id(flattener);
+                merge_block_id = cf_flattener_alloc_block_id(flattener);
+
+                cf_flattener_emit_unconditional_branch(flattener, loop_header_block_id);
+                cf_flattener_emit_label(flattener, loop_header_block_id);
+                cf_flattener_emit_branch(flattener, merge_block_id, continue_block_id,
+                        NULL, loop_body_block_id, 0, 0);
+
+                cf_flattener_emit_label(flattener, loop_body_block_id);
+
+                cf_info->u.loop.header_block_id = loop_header_block_id;
+                cf_info->u.loop.continue_block_id = continue_block_id;
+                cf_info->u.loop.merge_block_id = merge_block_id;
+                cf_info->current_block = VKD3D_BLOCK_LOOP;
+                cf_info->inside_block = true;
+
+                cf_flattener_create_block_name(flattener, loop_header_block_id, "loop%u_header", flattener->loop_id);
+                cf_flattener_create_block_name(flattener, loop_body_block_id, "loop%u_body", flattener->loop_id);
+                cf_flattener_create_block_name(flattener, continue_block_id, "loop%u_continue", flattener->loop_id);
+                cf_flattener_create_block_name(flattener, merge_block_id, "loop%u_merge", flattener->loop_id);
+                ++flattener->loop_id;
+                break;
+
+            case VKD3DSIH_ENDLOOP:
+                if (cf_info->inside_block)
+                    cf_flattener_emit_unconditional_branch(flattener, cf_info->u.loop.continue_block_id);
+
+                cf_flattener_emit_label(flattener, cf_info->u.loop.continue_block_id);
+                cf_flattener_emit_unconditional_branch(flattener, cf_info->u.loop.header_block_id);
+                cf_flattener_emit_label(flattener, cf_info->u.loop.merge_block_id);
+
+                cf_flattener_pop_control_flow_level(flattener);
+                break;
+
+            case VKD3DSIH_SWITCH:
+                if (!(cf_info = cf_flattener_push_control_flow_level(flattener)))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+
+                merge_block_id = cf_flattener_alloc_block_id(flattener);
+
+                cf_info->u.switch_.ins_location = flattener->instruction_count;
+                cf_info->u.switch_.condition = src;
+
+                if (!(dst_ins = cf_flattener_require_space(flattener, 1)))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                vsir_instruction_init(dst_ins, &instruction->location, VKD3DSIH_SWITCH_MONOLITHIC);
+                ++flattener->instruction_count;
+
+                cf_info->u.switch_.id = flattener->switch_id;
+                cf_info->u.switch_.merge_block_id = merge_block_id;
+                cf_info->u.switch_.cases = NULL;
+                cf_info->u.switch_.cases_size = 0;
+                cf_info->u.switch_.cases_count = 0;
+                cf_info->u.switch_.default_block_id = 0;
+                cf_info->inside_block = false;
+                cf_info->current_block = VKD3D_BLOCK_SWITCH;
+
+                cf_flattener_create_block_name(flattener, merge_block_id, "switch%u_merge", flattener->switch_id);
+                ++flattener->switch_id;
+
+                if (!vkd3d_array_reserve((void **)&cf_info->u.switch_.cases, &cf_info->u.switch_.cases_size,
+                        10, sizeof(*cf_info->u.switch_.cases)))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+
+                break;
+
+            case VKD3DSIH_ENDSWITCH:
+            {
+                struct vkd3d_shader_src_param *src_params;
+                unsigned int j;
+
+                if (!cf_info->u.switch_.default_block_id)
+                    cf_info->u.switch_.default_block_id = cf_info->u.switch_.merge_block_id;
+
+                cf_flattener_emit_label(flattener, cf_info->u.switch_.merge_block_id);
+
+                /* The SWITCH instruction is completed when the endswitch
+                 * instruction is processed because we do not know the number
+                 * of case statements or the default block id in advance.*/
+                dst_ins = &flattener->instructions[cf_info->u.switch_.ins_location];
+                if (!(src_params = instruction_src_params_alloc(dst_ins, cf_info->u.switch_.cases_count * 2 + 3, flattener)))
+                {
+                    vkd3d_free(cf_info->u.switch_.cases);
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                }
+                src_params[0] = *cf_info->u.switch_.condition;
+                vsir_src_param_init_label(&src_params[1], cf_info->u.switch_.default_block_id);
+                vsir_src_param_init_label(&src_params[2], cf_info->u.switch_.merge_block_id);
+                for (j = 0; j < cf_info->u.switch_.cases_count; ++j)
+                {
+                    unsigned int index = j * 2 + 3;
+                    vsir_src_param_init(&src_params[index], VKD3DSPR_IMMCONST, VKD3D_DATA_UINT, 0);
+                    src_params[index].reg.u.immconst_u32[0] = cf_info->u.switch_.cases[j].value;
+                    vsir_src_param_init_label(&src_params[index + 1], cf_info->u.switch_.cases[j].block_id);
+                }
+                vkd3d_free(cf_info->u.switch_.cases);
+
+                cf_flattener_pop_control_flow_level(flattener);
+                break;
+            }
+
+            case VKD3DSIH_CASE:
+            {
+                unsigned int label_id, value;
+
+                if (src->swizzle != VKD3D_SHADER_SWIZZLE(X, X, X, X))
+                {
+                    WARN("Unexpected src swizzle %#x.\n", src->swizzle);
+                    vkd3d_shader_parser_error(parser, VKD3D_SHADER_ERROR_VSIR_INVALID_SWIZZLE,
+                            "The swizzle for a switch case value is not scalar X.");
+                }
+                value = *src->reg.u.immconst_u32;
+
+                if (!vkd3d_array_reserve((void **)&cf_info->u.switch_.cases, &cf_info->u.switch_.cases_size,
+                        cf_info->u.switch_.cases_count + 1, sizeof(*cf_info->u.switch_.cases)))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+
+                label_id = cf_flattener_alloc_block_id(flattener);
+                if (cf_info->inside_block) /* fall-through */
+                    cf_flattener_emit_unconditional_branch(flattener, label_id);
+
+                cf_info->u.switch_.cases[cf_info->u.switch_.cases_count].value = value;
+                cf_info->u.switch_.cases[cf_info->u.switch_.cases_count].block_id = label_id;
+                ++cf_info->u.switch_.cases_count;
+
+                cf_flattener_emit_label(flattener, label_id);
+                cf_flattener_create_block_name(flattener, label_id, "switch%u_case%u", cf_info->u.switch_.id, value);
+                cf_info->inside_block = true;
+                break;
+            }
+
+            case VKD3DSIH_DEFAULT:
+                cf_info->u.switch_.default_block_id = cf_flattener_alloc_block_id(flattener);
+                if (cf_info->inside_block) /* fall-through */
+                    cf_flattener_emit_unconditional_branch(flattener, cf_info->u.switch_.default_block_id);
+
+                cf_flattener_emit_label(flattener, cf_info->u.switch_.default_block_id);
+
+                cf_flattener_create_block_name(flattener, cf_info->u.switch_.default_block_id,
+                        "switch%u_default", cf_info->u.switch_.id);
+                cf_info->inside_block = true;
+                break;
+
+            case VKD3DSIH_BREAK:
+            {
+                struct cf_flattener_info *breakable_cf_info;
+
+                if (!(breakable_cf_info = cf_flattener_find_innermost_breakable_cf_construct(flattener)))
+                {
+                    FIXME("Unhandled break instruction.\n");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+
+                if (breakable_cf_info->current_block == VKD3D_BLOCK_LOOP)
+                {
+                    cf_flattener_emit_unconditional_branch(flattener, breakable_cf_info->u.loop.merge_block_id);
+                }
+                else if (breakable_cf_info->current_block == VKD3D_BLOCK_SWITCH)
+                {
+                    cf_flattener_emit_unconditional_branch(flattener, breakable_cf_info->u.switch_.merge_block_id);
+                }
+
+                cf_info->inside_block = false;
+                break;
+            }
+
+            case VKD3DSIH_BREAKP:
+            {
+                struct cf_flattener_info *loop_cf_info;
+
+                if (!(loop_cf_info = cf_flattener_find_innermost_loop(flattener)))
+                {
+                    ERR("Invalid 'breakc' instruction outside loop.\n");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+
+                cf_flattener_emit_conditional_branch_and_merge(flattener,
+                        src, loop_cf_info->u.loop.merge_block_id, instruction->flags);
+                break;
+            }
+
+            case VKD3DSIH_CONTINUE:
+            {
+                struct cf_flattener_info *loop_cf_info;
+
+                if (!(loop_cf_info = cf_flattener_find_innermost_loop(flattener)))
+                {
+                    ERR("Invalid 'continue' instruction outside loop.\n");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+
+                cf_flattener_emit_unconditional_branch(flattener, loop_cf_info->u.loop.continue_block_id);
+
+                cf_info->inside_block = false;
+                break;
+            }
+
+            case VKD3DSIH_CONTINUEP:
+            {
+                struct cf_flattener_info *loop_cf_info;
+
+                if (!(loop_cf_info = cf_flattener_find_innermost_loop(flattener)))
+                {
+                    ERR("Invalid 'continuec' instruction outside loop.\n");
+                    return VKD3D_ERROR_INVALID_SHADER;
+                }
+
+                cf_flattener_emit_conditional_branch_and_merge(flattener,
+                        src, loop_cf_info->u.loop.continue_block_id, instruction->flags);
+                break;
+            }
+
+            case VKD3DSIH_RET:
+                if (!cf_flattener_copy_instruction(flattener, instruction))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+
+                if (cf_info)
+                    cf_info->inside_block = false;
+                else
+                    main_block_open = false;
+                break;
+
+            default:
+                if (!cf_flattener_copy_instruction(flattener, instruction))
+                    return VKD3D_ERROR_OUT_OF_MEMORY;
+                break;
+        }
+    }
+
+    if (main_block_open)
+    {
+        if (!(dst_ins = cf_flattener_require_space(flattener, 1)))
+            return VKD3D_ERROR_OUT_OF_MEMORY;
+        vsir_instruction_init(dst_ins, &flattener->location, VKD3DSIH_RET);
+        ++flattener->instruction_count;
+    }
+
+    return flattener->allocation_failed ? VKD3D_ERROR_OUT_OF_MEMORY : VKD3D_OK;
+}
+
+static enum vkd3d_result flatten_control_flow_constructs(struct vkd3d_shader_parser *parser)
+{
+    struct vsir_program *program = &parser->program;
+    struct cf_flattener flattener = {0};
+    enum vkd3d_result result;
+
+    flattener.parser = parser;
+    result = cf_flattener_iterate_instruction_array(&flattener);
+
+    if (result >= 0)
+    {
+        vkd3d_free(parser->program.instructions.elements);
+        program->instructions.elements = flattener.instructions;
+        program->instructions.capacity = flattener.instruction_capacity;
+        program->instructions.count = flattener.instruction_count;
+        program->block_count = flattener.block_id;
+    }
+    else
+    {
+        vkd3d_free(flattener.instructions);
+    }
+
+    vkd3d_free(flattener.control_flow_info);
+    /* Simpler to always free these in vsir_program_cleanup(). */
+    program->block_names = flattener.block_names;
+    program->block_name_count = flattener.block_name_count;
+
+    return result;
+}
+
+enum vkd3d_result vkd3d_shader_normalise(struct vkd3d_shader_parser *parser,
+        const struct vkd3d_shader_compile_info *compile_info)
+{
+    struct vkd3d_shader_instruction_array *instructions = &parser->program.instructions;
+    enum vkd3d_result result = VKD3D_OK;
+
+    remove_dcl_temps(&parser->program);
+
+    if ((result = instruction_array_lower_texkills(parser)) < 0)
+        return result;
+
+    if (!parser->shader_desc.is_dxil)
+    {
+        if (parser->program.shader_version.type != VKD3D_SHADER_TYPE_PIXEL)
+        {
+            if ((result = remap_output_signature(parser, compile_info)) < 0)
+                return result;
+        }
+
+        if (parser->program.shader_version.type == VKD3D_SHADER_TYPE_HULL)
+        {
+            if ((result = instruction_array_flatten_hull_shader_phases(instructions)) < 0)
+                return result;
+
+            if ((result = instruction_array_normalise_hull_shader_control_point_io(instructions,
+                    &parser->shader_desc.input_signature)) < 0)
+                return result;
+        }
+
+        if ((result = shader_normalise_io_registers(parser)) < 0)
+            return result;
+
+        if ((result = instruction_array_normalise_flat_constants(&parser->program)) < 0)
+            return result;
+
+        remove_dead_code(&parser->program);
+
+        if ((result = flatten_control_flow_constructs(parser)) < 0)
+            return result;
+
+        if ((result = normalise_combined_samplers(parser)) < 0)
+            return result;
+    }
+
+    if (TRACE_ON())
+        vkd3d_shader_trace(&parser->program);
+
+    if (!parser->failed && (result = vsir_validate(parser)) < 0)
+        return result;
+
+    if (parser->failed)
+        result = VKD3D_ERROR_INVALID_SHADER;
+
+    return result;
+}
+
+struct validation_context
+{
+    struct vkd3d_shader_parser *parser;
+    const struct vsir_program *program;
+    size_t instruction_idx;
+    bool invalid_instruction_idx;
+    bool dcl_temps_found;
+    enum vkd3d_shader_opcode phase;
+    enum cf_type
+    {
+        CF_TYPE_UNKNOWN = 0,
+        CF_TYPE_STRUCTURED,
+        CF_TYPE_BLOCKS,
+    } cf_type;
+    bool inside_block;
+
+    struct validation_context_temp_data
+    {
+        enum vsir_dimension dimension;
+        size_t first_seen;
+    } *temps;
+
+    struct validation_context_ssa_data
+    {
+        enum vsir_dimension dimension;
+        size_t first_seen;
+        uint32_t write_mask;
+        uint32_t read_mask;
+        size_t first_assigned;
+    } *ssas;
+
+    enum vkd3d_shader_opcode *blocks;
+    size_t depth;
+    size_t blocks_capacity;
+};
+
+static void VKD3D_PRINTF_FUNC(3, 4) validator_error(struct validation_context *ctx,
+        enum vkd3d_shader_error error, const char *format, ...)
+{
+    struct vkd3d_string_buffer buf;
+    va_list args;
+
+    vkd3d_string_buffer_init(&buf);
+
+    va_start(args, format);
+    vkd3d_string_buffer_vprintf(&buf, format, args);
+    va_end(args);
+
+    if (ctx->invalid_instruction_idx)
+    {
+        vkd3d_shader_parser_error(ctx->parser, error, "%s", buf.buffer);
+        ERR("VSIR validation error: %s\n", buf.buffer);
+    }
+    else
+    {
+        vkd3d_shader_parser_error(ctx->parser, error, "instruction %zu: %s", ctx->instruction_idx + 1, buf.buffer);
+        ERR("VSIR validation error: instruction %zu: %s\n", ctx->instruction_idx + 1, buf.buffer);
+    }
+
+    vkd3d_string_buffer_cleanup(&buf);
+}
+
+static void vsir_validate_src_param(struct validation_context *ctx,
+        const struct vkd3d_shader_src_param *src);
+
+static void vsir_validate_register(struct validation_context *ctx,
+        const struct vkd3d_shader_register *reg)
+{
+    unsigned int i;
+
+    if (reg->type >= VKD3DSPR_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE, "Invalid register type %#x.",
+                reg->type);
+
+    if (reg->precision >= VKD3D_SHADER_REGISTER_PRECISION_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_PRECISION, "Invalid register precision %#x.",
+                reg->precision);
+
+    if (reg->data_type >= VKD3D_DATA_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE, "Invalid register data type %#x.",
+                reg->data_type);
+
+    if (reg->dimension >= VSIR_DIMENSION_COUNT)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION, "Invalid register dimension %#x.",
+                reg->dimension);
+
+    if (reg->idx_count > ARRAY_SIZE(reg->idx))
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid register index count %u.",
+                reg->idx_count);
 
     for (i = 0; i < min(reg->idx_count, ARRAY_SIZE(reg->idx)); ++i)
     {
@@ -1540,16 +2506,128 @@ static void vsir_validate_register(struct validation_context *ctx,
     switch (reg->type)
     {
         case VKD3DSPR_TEMP:
+        {
+            struct validation_context_temp_data *data;
+
             if (reg->idx_count != 1)
+            {
                 validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid index count %u for a TEMP register.",
                         reg->idx_count);
+                break;
+            }
 
-            if (reg->idx_count >= 1 && reg->idx[0].rel_addr)
+            if (reg->idx[0].rel_addr)
                 validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX, "Non-NULL relative address for a TEMP register.");
 
-            if (reg->idx_count >= 1 && reg->idx[0].offset >= temp_count)
+            if (reg->idx[0].offset >= ctx->parser->program.temp_count)
+            {
                 validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX, "TEMP register index %u exceeds the maximum count %u.",
-                        reg->idx[0].offset, temp_count);
+                        reg->idx[0].offset, ctx->parser->program.temp_count);
+                break;
+            }
+
+            data = &ctx->temps[reg->idx[0].offset];
+
+            if (reg->dimension == VSIR_DIMENSION_NONE)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION, "Invalid dimension NONE for a TEMP register.");
+                break;
+            }
+
+            /* TEMP registers can be scalar or vec4, provided that
+             * each individual register always appears with the same
+             * dimension. */
+            if (data->dimension == VSIR_DIMENSION_NONE)
+            {
+                data->dimension = reg->dimension;
+                data->first_seen = ctx->instruction_idx;
+            }
+            else if (data->dimension != reg->dimension)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION, "Invalid dimension %#x for a TEMP register: "
+                        "it has already been seen with dimension %#x at instruction %zu.",
+                        reg->dimension, data->dimension, data->first_seen);
+            }
+            break;
+        }
+
+        case VKD3DSPR_SSA:
+        {
+            struct validation_context_ssa_data *data;
+
+            if (reg->idx_count != 1)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid index count %u for a SSA register.",
+                        reg->idx_count);
+                break;
+            }
+
+            if (reg->idx[0].rel_addr)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX, "Non-NULL relative address for a SSA register.");
+
+            if (reg->idx[0].offset >= ctx->program->ssa_count)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX,
+                        "SSA register index %u exceeds the maximum count %u.",
+                        reg->idx[0].offset, ctx->program->ssa_count);
+                break;
+            }
+
+            data = &ctx->ssas[reg->idx[0].offset];
+
+            if (reg->dimension == VSIR_DIMENSION_NONE)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION, "Invalid dimension NONE for a SSA register.");
+                break;
+            }
+
+            /* SSA registers can be scalar or vec4, provided that each
+             * individual register always appears with the same
+             * dimension. */
+            if (data->dimension == VSIR_DIMENSION_NONE)
+            {
+                data->dimension = reg->dimension;
+                data->first_seen = ctx->instruction_idx;
+            }
+            else if (data->dimension != reg->dimension)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION, "Invalid dimension %#x for a SSA register: "
+                        "it has already been seen with dimension %#x at instruction %zu.",
+                        reg->dimension, data->dimension, data->first_seen);
+            }
+            break;
+        }
+
+        case VKD3DSPR_LABEL:
+            if (reg->precision != VKD3D_SHADER_REGISTER_PRECISION_DEFAULT)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_PRECISION, "Invalid precision %#x for a LABEL register.",
+                        reg->precision);
+
+            if (reg->data_type != VKD3D_DATA_UINT)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DATA_TYPE, "Invalid data type %#x for a LABEL register.",
+                        reg->data_type);
+
+            if (reg->dimension != VSIR_DIMENSION_NONE)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION, "Invalid dimension %#x for a LABEL register.",
+                        reg->dimension);
+
+            if (reg->idx_count != 1)
+            {
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX_COUNT, "Invalid index count %u for a LABEL register.",
+                        reg->idx_count);
+                break;
+            }
+
+            if (reg->idx[0].rel_addr)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX, "Non-NULL relative address for a LABEL register.");
+
+            /* Index == 0 is invalid, but it is temporarily allowed
+             * for intermediate stages. Once we support validation
+             * dialects we can selectively check for that. */
+            if (reg->idx[0].offset > ctx->program->block_count)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX,
+                        "LABEL register index %u exceeds the maximum count %u.",
+                        reg->idx[0].offset, ctx->program->block_count);
             break;
 
         case VKD3DSPR_NULL:
@@ -1584,6 +2662,26 @@ static void vsir_validate_dst_param(struct validation_context *ctx,
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK, "Destination has invalid write mask %#x.",
                 dst->write_mask);
 
+    switch (dst->reg.dimension)
+    {
+        case VSIR_DIMENSION_SCALAR:
+            if (dst->write_mask != VKD3DSP_WRITEMASK_0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK, "Scalar destination has invalid write mask %#x.",
+                    dst->write_mask);
+            break;
+
+        case VSIR_DIMENSION_VEC4:
+            if (dst->write_mask == 0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK, "Vec4 destination has empty write mask.");
+            break;
+
+        default:
+            if (dst->write_mask != 0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_WRITE_MASK, "Destination of dimension %u has invalid write mask %#x.",
+                    dst->reg.dimension, dst->write_mask);
+            break;
+    }
+
     if (dst->modifiers & ~VKD3DSPDM_MASK)
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_MODIFIERS, "Destination has invalid modifiers %#x.",
                 dst->modifiers);
@@ -1603,6 +2701,41 @@ static void vsir_validate_dst_param(struct validation_context *ctx,
             validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SHIFT, "Destination has invalid shift %#x.",
                     dst->shift);
     }
+
+    switch (dst->reg.type)
+    {
+        case VKD3DSPR_SSA:
+            if (dst->reg.idx[0].offset < ctx->parser->program.ssa_count)
+            {
+                struct validation_context_ssa_data *data = &ctx->ssas[dst->reg.idx[0].offset];
+
+                if (data->write_mask == 0)
+                {
+                    data->write_mask = dst->write_mask;
+                    data->first_assigned = ctx->instruction_idx;
+                }
+                else
+                {
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SSA_USAGE,
+                            "SSA register is already assigned at instruction %zu.",
+                            data->first_assigned);
+                }
+            }
+            break;
+
+        case VKD3DSPR_IMMCONST:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid IMMCONST register used as destination parameter.");
+            break;
+
+        case VKD3DSPR_IMMCONST64:
+            validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                    "Invalid IMMCONST64 register used as destination parameter.");
+            break;
+
+        default:
+            break;
+    }
 }
 
 static void vsir_validate_src_param(struct validation_context *ctx,
@@ -1614,9 +2747,30 @@ static void vsir_validate_src_param(struct validation_context *ctx,
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SWIZZLE, "Source has invalid swizzle %#x.",
                 src->swizzle);
 
+    if (src->reg.dimension != VSIR_DIMENSION_VEC4 && src->swizzle != 0)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SWIZZLE, "Source of dimension %u has invalid swizzle %#x.",
+                src->reg.dimension, src->swizzle);
+
     if (src->modifiers >= VKD3DSPSM_COUNT)
         validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_MODIFIERS, "Source has invalid modifiers %#x.",
                 src->modifiers);
+
+    switch (src->reg.type)
+    {
+        case VKD3DSPR_SSA:
+            if (src->reg.idx[0].offset < ctx->parser->program.ssa_count)
+            {
+                struct validation_context_ssa_data *data = &ctx->ssas[src->reg.idx[0].offset];
+                unsigned int i;
+
+                for (i = 0; i < VKD3D_VEC4_SIZE; ++i)
+                    data->read_mask |= (1u << vsir_swizzle_get_component(src->swizzle, i));
+            }
+            break;
+
+        default:
+            break;
+    }
 }
 
 static void vsir_validate_dst_count(struct validation_context *ctx,
@@ -1637,11 +2791,64 @@ static void vsir_validate_src_count(struct validation_context *ctx,
                 instruction->src_count, instruction->handler_idx, count);
 }
 
+static bool vsir_validate_src_min_count(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction, unsigned int count)
+{
+    if (instruction->src_count < count)
+    {
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SOURCE_COUNT,
+                "Invalid source count %u for an instruction of type %#x, expected at least %u.",
+                instruction->src_count, instruction->handler_idx, count);
+        return false;
+    }
+
+    return true;
+}
+
+static bool vsir_validate_src_max_count(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction, unsigned int count)
+{
+    if (instruction->src_count > count)
+    {
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SOURCE_COUNT,
+                "Invalid source count %u for an instruction of type %#x, expected at most %u.",
+                instruction->src_count, instruction->handler_idx, count);
+        return false;
+    }
+
+    return true;
+}
+
+static const char *name_from_cf_type(enum cf_type type)
+{
+    switch (type)
+    {
+        case CF_TYPE_STRUCTURED:
+            return "structured";
+        case CF_TYPE_BLOCKS:
+            return "block-based";
+        default:
+            vkd3d_unreachable();
+    }
+}
+
+static void vsir_validate_cf_type(struct validation_context *ctx,
+        const struct vkd3d_shader_instruction *instruction, enum cf_type expected_type)
+{
+    assert(ctx->cf_type != CF_TYPE_UNKNOWN);
+    assert(expected_type != CF_TYPE_UNKNOWN);
+    if (ctx->cf_type != expected_type)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "Invalid instruction %#x in %s shader.",
+                instruction->handler_idx, name_from_cf_type(ctx->cf_type));
+}
+
 static void vsir_validate_instruction(struct validation_context *ctx)
 {
-    const struct vkd3d_shader_instruction *instruction = &ctx->parser->instructions.elements[ctx->instruction_idx];
+    const struct vkd3d_shader_version *version = &ctx->program->shader_version;
+    const struct vkd3d_shader_instruction *instruction;
     size_t i;
 
+    instruction = &ctx->program->instructions.elements[ctx->instruction_idx];
     ctx->parser->location = instruction->location;
 
     for (i = 0; i < instruction->dst_count; ++i)
@@ -1664,26 +2871,68 @@ static void vsir_validate_instruction(struct validation_context *ctx)
         case VKD3DSIH_HS_JOIN_PHASE:
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 0);
-            if (ctx->parser->shader_version.type != VKD3D_SHADER_TYPE_HULL)
+            if (version->type != VKD3D_SHADER_TYPE_HULL)
                 validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER, "Phase instruction %#x is only valid in a hull shader.",
                         instruction->handler_idx);
             if (ctx->depth != 0)
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "Phase instruction %#x must appear to top level.",
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "Phase instruction %#x must appear to top level.",
                         instruction->handler_idx);
             ctx->phase = instruction->handler_idx;
             ctx->dcl_temps_found = false;
-            ctx->temp_count = 0;
             return;
 
         default:
             break;
     }
 
-    if (ctx->parser->shader_version.type == VKD3D_SHADER_TYPE_HULL &&
-            ctx->phase == VKD3DSIH_INVALID)
-        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER, "Instruction %#x appear before any phase instruction in a hull shader.",
+    if (version->type == VKD3D_SHADER_TYPE_HULL && ctx->phase == VKD3DSIH_INVALID)
+        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER,
+                "Instruction %#x appear before any phase instruction in a hull shader.",
                 instruction->handler_idx);
 
+    /* We support two different control flow types in shaders:
+     * block-based, like DXIL and SPIR-V, and structured, like D3DBC
+     * and TPF. The shader is detected as block-based when its first
+     * instruction, except for DCL_* and phases, is a LABEL. Currently
+     * we mandate that each shader is either purely block-based or
+     * purely structured. In principle we could allow structured
+     * constructs in a block, provided they are confined in a single
+     * block, but need for that hasn't arisen yet, so we don't. */
+    if (ctx->cf_type == CF_TYPE_UNKNOWN && !vsir_instruction_is_dcl(instruction))
+    {
+        if (instruction->handler_idx == VKD3DSIH_LABEL)
+            ctx->cf_type = CF_TYPE_BLOCKS;
+        else
+            ctx->cf_type = CF_TYPE_STRUCTURED;
+    }
+
+    if (ctx->cf_type == CF_TYPE_BLOCKS && !vsir_instruction_is_dcl(instruction))
+    {
+        switch (instruction->handler_idx)
+        {
+            case VKD3DSIH_LABEL:
+                if (ctx->inside_block)
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "Invalid LABEL instruction inside a block.");
+                ctx->inside_block = true;
+                break;
+
+            case VKD3DSIH_RET:
+            case VKD3DSIH_BRANCH:
+            case VKD3DSIH_SWITCH_MONOLITHIC:
+                if (!ctx->inside_block)
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "Invalid instruction %#x outside any block.",
+                            instruction->handler_idx);
+                ctx->inside_block = false;
+                break;
+
+            default:
+                if (!ctx->inside_block)
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "Invalid instruction %#x outside any block.",
+                            instruction->handler_idx);
+                break;
+        }
+    }
+
     switch (instruction->handler_idx)
     {
         case VKD3DSIH_DCL_TEMPS:
@@ -1691,14 +2940,15 @@ static void vsir_validate_instruction(struct validation_context *ctx)
             vsir_validate_src_count(ctx, instruction, 0);
             if (ctx->dcl_temps_found)
                 validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_DUPLICATE_DCL_TEMPS, "Duplicate DCL_TEMPS instruction.");
-            if (instruction->declaration.count > ctx->parser->shader_desc.temp_count)
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DCL_TEMPS, "Invalid DCL_TEMPS count %u, expected at most %u.",
-                        instruction->declaration.count, ctx->parser->shader_desc.temp_count);
+            if (instruction->declaration.count > ctx->program->temp_count)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DCL_TEMPS,
+                        "Invalid DCL_TEMPS count %u, expected at most %u.",
+                        instruction->declaration.count, ctx->program->temp_count);
             ctx->dcl_temps_found = true;
-            ctx->temp_count = instruction->declaration.count;
             break;
 
         case VKD3DSIH_IF:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 1);
             if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
@@ -1707,6 +2957,7 @@ static void vsir_validate_instruction(struct validation_context *ctx)
             break;
 
         case VKD3DSIH_IFC:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 2);
             if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
@@ -1715,41 +2966,46 @@ static void vsir_validate_instruction(struct validation_context *ctx)
             break;
 
         case VKD3DSIH_ELSE:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 0);
             if (ctx->depth == 0 || ctx->blocks[ctx->depth - 1] != VKD3DSIH_IF)
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ELSE instruction doesn't terminate IF block.");
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "ELSE instruction doesn't terminate IF block.");
             else
                 ctx->blocks[ctx->depth - 1] = instruction->handler_idx;
             break;
 
         case VKD3DSIH_ENDIF:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 0);
             if (ctx->depth == 0 || (ctx->blocks[ctx->depth - 1] != VKD3DSIH_IF && ctx->blocks[ctx->depth - 1] != VKD3DSIH_ELSE))
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ENDIF instruction doesn't terminate IF/ELSE block.");
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "ENDIF instruction doesn't terminate IF/ELSE block.");
             else
                 --ctx->depth;
             break;
 
         case VKD3DSIH_LOOP:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
-            vsir_validate_src_count(ctx, instruction, ctx->parser->shader_version.major <= 3 ? 2 : 0);
+            vsir_validate_src_count(ctx, instruction, version->major <= 3 ? 2 : 0);
             if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
                 return;
             ctx->blocks[ctx->depth++] = instruction->handler_idx;
             break;
 
         case VKD3DSIH_ENDLOOP:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 0);
             if (ctx->depth == 0 || ctx->blocks[ctx->depth - 1] != VKD3DSIH_LOOP)
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ENDLOOP instruction doesn't terminate LOOP block.");
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "ENDLOOP instruction doesn't terminate LOOP block.");
             else
                 --ctx->depth;
             break;
 
         case VKD3DSIH_REP:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 1);
             if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
@@ -1758,15 +3014,17 @@ static void vsir_validate_instruction(struct validation_context *ctx)
             break;
 
         case VKD3DSIH_ENDREP:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 0);
             if (ctx->depth == 0 || ctx->blocks[ctx->depth - 1] != VKD3DSIH_REP)
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ENDREP instruction doesn't terminate REP block.");
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "ENDREP instruction doesn't terminate REP block.");
             else
                 --ctx->depth;
             break;
 
         case VKD3DSIH_SWITCH:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 1);
             if (!vkd3d_array_reserve((void **)&ctx->blocks, &ctx->blocks_capacity, ctx->depth + 1, sizeof(*ctx->blocks)))
@@ -1775,35 +3033,223 @@ static void vsir_validate_instruction(struct validation_context *ctx)
             break;
 
         case VKD3DSIH_ENDSWITCH:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_STRUCTURED);
             vsir_validate_dst_count(ctx, instruction, 0);
             vsir_validate_src_count(ctx, instruction, 0);
             if (ctx->depth == 0 || ctx->blocks[ctx->depth - 1] != VKD3DSIH_SWITCH)
-                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "ENDSWITCH instruction doesn't terminate SWITCH block.");
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "ENDSWITCH instruction doesn't terminate SWITCH block.");
             else
                 --ctx->depth;
             break;
 
+        case VKD3DSIH_RET:
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 0);
+            break;
+
+        case VKD3DSIH_LABEL:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_BLOCKS);
+            vsir_validate_dst_count(ctx, instruction, 0);
+            vsir_validate_src_count(ctx, instruction, 1);
+            if (instruction->src_count >= 1 && !vsir_register_is_label(&instruction->src[0].reg))
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                        "Invalid register of type %#x in a LABEL instruction, expected LABEL.",
+                        instruction->src[0].reg.type);
+            break;
+
+        case VKD3DSIH_BRANCH:
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_BLOCKS);
+            vsir_validate_dst_count(ctx, instruction, 0);
+            if (!vsir_validate_src_min_count(ctx, instruction, 1))
+                break;
+            if (vsir_register_is_label(&instruction->src[0].reg))
+            {
+                /* Unconditional branch: parameters are jump label,
+                 * optional merge label, optional continue label. */
+                vsir_validate_src_max_count(ctx, instruction, 3);
+
+                for (i = 0; i < instruction->src_count; ++i)
+                {
+                    if (!vsir_register_is_label(&instruction->src[i].reg))
+                        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                                "Invalid register of type %#x in unconditional BRANCH instruction, expected LABEL.",
+                                instruction->src[i].reg.type);
+                }
+            }
+            else
+            {
+                /* Conditional branch: parameters are condition, true
+                 * jump label, false jump label, optional merge label,
+                 * optional continue label. */
+                vsir_validate_src_min_count(ctx, instruction, 3);
+                vsir_validate_src_max_count(ctx, instruction, 5);
+
+                for (i = 1; i < instruction->src_count; ++i)
+                {
+                    if (!vsir_register_is_label(&instruction->src[i].reg))
+                        validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                                "Invalid register of type %#x in conditional BRANCH instruction, expected LABEL.",
+                                instruction->src[i].reg.type);
+                }
+            }
+            break;
+
+        case VKD3DSIH_SWITCH_MONOLITHIC:
+        {
+            unsigned int case_count;
+
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_BLOCKS);
+            vsir_validate_dst_count(ctx, instruction, 0);
+            /* Parameters are source, default label, merge label and
+             * then pairs of constant value and case label. */
+            if (!vsir_validate_src_min_count(ctx, instruction, 3))
+                break;
+            if (instruction->src_count % 2 != 1)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SOURCE_COUNT,
+                        "Invalid source count %u for a monolithic SWITCH instruction, it must be an odd number.",
+                        instruction->src_count);
+
+            if (!vsir_register_is_label(&instruction->src[1].reg))
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                        "Invalid default label register of type %#x in monolithic SWITCH instruction, expected LABEL.",
+                        instruction->src[1].reg.type);
+
+            if (!vsir_register_is_label(&instruction->src[2].reg))
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                        "Invalid merge label register of type %#x in monolithic SWITCH instruction, expected LABEL.",
+                        instruction->src[2].reg.type);
+
+            case_count = (instruction->src_count - 3) / 2;
+
+            for (i = 0; i < case_count; ++i)
+            {
+                unsigned int value_idx = 3 + 2 * i;
+                unsigned int label_idx = 3 + 2 * i + 1;
+
+                if (!register_is_constant(&instruction->src[value_idx].reg))
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                            "Invalid value register for case %zu of type %#x in monolithic SWITCH instruction, "
+                            "expected IMMCONST or IMMCONST64.", i, instruction->src[value_idx].reg.type);
+
+                if (!vsir_register_is_label(&instruction->src[label_idx].reg))
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                            "Invalid label register for case %zu of type %#x in monolithic SWITCH instruction, "
+                            "expected LABEL.", i, instruction->src[value_idx].reg.type);
+            }
+            break;
+        }
+
+        case VKD3DSIH_PHI:
+        {
+            unsigned int incoming_count;
+
+            vsir_validate_cf_type(ctx, instruction, CF_TYPE_BLOCKS);
+            vsir_validate_dst_count(ctx, instruction, 1);
+            vsir_validate_src_min_count(ctx, instruction, 2);
+            if (instruction->src_count % 2 != 0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SOURCE_COUNT,
+                        "Invalid source count %u for a PHI instruction, it must be an even number.",
+                        instruction->src_count);
+            incoming_count = instruction->src_count / 2;
+
+            if (!register_is_ssa(&instruction->dst[0].reg))
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                        "Invalid destination of type %#x in PHI instruction, expected SSA.",
+                        instruction->dst[0].reg.type);
+
+            if (instruction->dst[0].reg.dimension != VSIR_DIMENSION_SCALAR)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION,
+                        "Invalid destination dimension %#x in PHI instruction, expected scalar.",
+                        instruction->dst[0].reg.dimension);
+
+            if (instruction->dst[0].modifiers != VKD3DSPDM_NONE)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_MODIFIERS,
+                        "Invalid modifiers %#x for the destination of a PHI instruction, expected none.",
+                        instruction->dst[0].modifiers);
+
+            if (instruction->dst[0].shift != 0)
+                validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SHIFT,
+                        "Invalid shift %#x for the destination of a PHI instruction, expected none.",
+                        instruction->dst[0].shift);
+
+            for (i = 0; i < incoming_count; ++i)
+            {
+                unsigned int value_idx = 2 * i;
+                unsigned int label_idx = 2 * i + 1;
+
+                if (!register_is_constant(&instruction->src[value_idx].reg) && !register_is_ssa(&instruction->src[value_idx].reg))
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                            "Invalid value register for incoming %zu of type %#x in PHI instruction, "
+                            "expected SSA, IMMCONST or IMMCONST64.", i, instruction->src[value_idx].reg.type);
+
+                if (instruction->src[value_idx].reg.dimension != VSIR_DIMENSION_SCALAR)
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_DIMENSION,
+                            "Invalid value dimension %#x for incoming %zu in PHI instruction, expected scalar.",
+                            instruction->src[value_idx].reg.dimension, i);
+
+                if (!vsir_register_is_label(&instruction->src[label_idx].reg))
+                    validator_error(ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_REGISTER_TYPE,
+                            "Invalid label register for case %zu of type %#x in PHI instruction, "
+                            "expected LABEL.", i, instruction->src[value_idx].reg.type);
+            }
+            break;
+        }
+
         default:
             break;
     }
 }
 
-void vsir_validate(struct vkd3d_shader_parser *parser)
+enum vkd3d_result vsir_validate(struct vkd3d_shader_parser *parser)
 {
     struct validation_context ctx =
     {
         .parser = parser,
+        .program = &parser->program,
         .phase = VKD3DSIH_INVALID,
     };
+    unsigned int i;
 
     if (!(parser->config_flags & VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION))
-        return;
+        return VKD3D_OK;
 
-    for (ctx.instruction_idx = 0; ctx.instruction_idx < parser->instructions.count; ++ctx.instruction_idx)
+    if (!(ctx.temps = vkd3d_calloc(ctx.program->temp_count, sizeof(*ctx.temps))))
+        goto fail;
+
+    if (!(ctx.ssas = vkd3d_calloc(ctx.program->ssa_count, sizeof(*ctx.ssas))))
+        goto fail;
+
+    for (ctx.instruction_idx = 0; ctx.instruction_idx < parser->program.instructions.count; ++ctx.instruction_idx)
         vsir_validate_instruction(&ctx);
 
+    ctx.invalid_instruction_idx = true;
+
     if (ctx.depth != 0)
-        validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING, "%zu nested blocks were not closed.", ctx.depth);
+        validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "%zu nested blocks were not closed.", ctx.depth);
+
+    if (ctx.inside_block)
+        validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW, "Last block was not closed.");
+
+    for (i = 0; i < ctx.program->ssa_count; ++i)
+    {
+        struct validation_context_ssa_data *data = &ctx.ssas[i];
+
+        if ((data->write_mask | data->read_mask) != data->write_mask)
+            validator_error(&ctx, VKD3D_SHADER_ERROR_VSIR_INVALID_SSA_USAGE,
+                    "SSA register %u has invalid read mask %#x, which is not a subset of the write mask %#x "
+                    "at the point of definition.", i, data->read_mask, data->write_mask);
+    }
+
+    vkd3d_free(ctx.blocks);
+    vkd3d_free(ctx.temps);
+    vkd3d_free(ctx.ssas);
+
+    return VKD3D_OK;
+
+fail:
+    vkd3d_free(ctx.blocks);
+    vkd3d_free(ctx.temps);
+    vkd3d_free(ctx.ssas);
 
-    free(ctx.blocks);
+    return VKD3D_ERROR_OUT_OF_MEMORY;
 }
diff --git a/libs/vkd3d/libs/vkd3d-shader/spirv.c b/libs/vkd3d/libs/vkd3d-shader/spirv.c
index c8a43ad..a86ca58 100644
--- a/libs/vkd3d/libs/vkd3d-shader/spirv.c
+++ b/libs/vkd3d/libs/vkd3d-shader/spirv.c
@@ -133,7 +133,7 @@ static void vkd3d_spirv_dump(const struct vkd3d_shader_code *spirv,
     }
 }
 
-static void vkd3d_spirv_validate(const struct vkd3d_shader_code *spirv,
+static bool vkd3d_spirv_validate(struct vkd3d_string_buffer *buffer, const struct vkd3d_shader_code *spirv,
         enum vkd3d_shader_spirv_environment environment)
 {
     spv_diagnostic diagnostic = NULL;
@@ -145,12 +145,13 @@ static void vkd3d_spirv_validate(const struct vkd3d_shader_code *spirv,
     if ((ret = spvValidateBinary(context, spirv->code, spirv->size / sizeof(uint32_t),
             &diagnostic)))
     {
-        FIXME("Failed to validate SPIR-V binary, ret %d.\n", ret);
-        FIXME("Diagnostic message: %s.\n", debugstr_a(diagnostic->error));
+        vkd3d_string_buffer_printf(buffer, "%s", diagnostic->error);
     }
 
     spvDiagnosticDestroy(diagnostic);
     spvContextDestroy(context);
+
+    return !ret;
 }
 
 #else
@@ -163,8 +164,11 @@ static enum vkd3d_result vkd3d_spirv_binary_to_text(const struct vkd3d_shader_co
 }
 static void vkd3d_spirv_dump(const struct vkd3d_shader_code *spirv,
         enum vkd3d_shader_spirv_environment environment) {}
-static void vkd3d_spirv_validate(const struct vkd3d_shader_code *spirv,
-        enum vkd3d_shader_spirv_environment environment) {}
+static bool vkd3d_spirv_validate(struct vkd3d_string_buffer *buffer, const struct vkd3d_shader_code *spirv,
+        enum vkd3d_shader_spirv_environment environment)
+{
+    return true;
+}
 
 #endif  /* HAVE_SPIRV_TOOLS */
 
@@ -851,20 +855,6 @@ static void vkd3d_spirv_end_function_stream_insertion(struct vkd3d_spirv_builder
     builder->insertion_location = ~(size_t)0;
 }
 
-struct vkd3d_spirv_op_branch_conditional
-{
-    uint32_t opcode;
-    uint32_t condition_id;
-    uint32_t true_label;
-    uint32_t false_label;
-};
-
-static struct vkd3d_spirv_op_branch_conditional *vkd3d_spirv_as_op_branch_conditional(
-        struct vkd3d_spirv_stream *stream, size_t location)
-{
-    return (struct vkd3d_spirv_op_branch_conditional *)&stream->words[location];
-}
-
 static void vkd3d_spirv_build_op_capability(struct vkd3d_spirv_stream *stream,
         SpvCapability cap)
 {
@@ -1194,6 +1184,16 @@ static uint32_t vkd3d_spirv_get_op_constant64(struct vkd3d_spirv_builder *builde
             (const uint32_t *)&value, 2, vkd3d_spirv_build_op_constant64);
 }
 
+static uint32_t vkd3d_spirv_build_op_constant_null(struct vkd3d_spirv_builder *builder, uint32_t result_type)
+{
+    return vkd3d_spirv_build_op_tr(builder, &builder->global_stream, SpvOpConstantNull, result_type);
+}
+
+static uint32_t vkd3d_spirv_get_op_constant_null(struct vkd3d_spirv_builder *builder, uint32_t result_type)
+{
+    return vkd3d_spirv_build_once1(builder, SpvOpConstantNull, result_type, vkd3d_spirv_build_op_constant_null);
+}
+
 static uint32_t vkd3d_spirv_build_op_constant_composite(struct vkd3d_spirv_builder *builder,
         uint32_t result_type, const uint32_t *constituents, unsigned int constituent_count)
 {
@@ -1515,6 +1515,25 @@ static uint32_t vkd3d_spirv_build_op_uless_than_equal(struct vkd3d_spirv_builder
             SpvOpULessThanEqual, result_type, operand0, operand1);
 }
 
+static uint32_t vkd3d_spirv_build_op_is_inf(struct vkd3d_spirv_builder *builder,
+        uint32_t result_type, uint32_t operand)
+{
+    return vkd3d_spirv_build_op_tr1(builder, &builder->function_stream, SpvOpIsInf, result_type, operand);
+}
+
+static uint32_t vkd3d_spirv_build_op_is_nan(struct vkd3d_spirv_builder *builder,
+        uint32_t result_type, uint32_t operand)
+{
+    return vkd3d_spirv_build_op_tr1(builder, &builder->function_stream, SpvOpIsNan, result_type, operand);
+}
+
+static uint32_t vkd3d_spirv_build_op_logical_equal(struct vkd3d_spirv_builder *builder,
+        uint32_t result_type, uint32_t operand0, uint32_t operand1)
+{
+    return vkd3d_spirv_build_op_tr2(builder, &builder->function_stream,
+            SpvOpLogicalEqual, result_type, operand0, operand1);
+}
+
 static uint32_t vkd3d_spirv_build_op_convert_utof(struct vkd3d_spirv_builder *builder,
         uint32_t result_type, uint32_t unsigned_value)
 {
@@ -1750,6 +1769,15 @@ static uint32_t vkd3d_spirv_build_op_glsl_std450_max(struct vkd3d_spirv_builder
             GLSLstd450NMax, operands, ARRAY_SIZE(operands));
 }
 
+static uint32_t vkd3d_spirv_build_op_glsl_std450_umin(struct vkd3d_spirv_builder *builder,
+        uint32_t result_type, uint32_t x, uint32_t y)
+{
+    uint32_t glsl_std450_id = vkd3d_spirv_get_glsl_std450_instr_set(builder);
+    uint32_t operands[] = {x, y};
+    return vkd3d_spirv_build_op_ext_inst(builder, result_type, glsl_std450_id,
+            GLSLstd450UMin, operands, ARRAY_SIZE(operands));
+}
+
 static uint32_t vkd3d_spirv_build_op_glsl_std450_nclamp(struct vkd3d_spirv_builder *builder,
         uint32_t result_type, uint32_t x, uint32_t min, uint32_t max)
 {
@@ -1783,6 +1811,8 @@ static uint32_t vkd3d_spirv_get_type_id(struct vkd3d_spirv_builder *builder,
                 break;
             case VKD3D_SHADER_COMPONENT_DOUBLE:
                 return vkd3d_spirv_get_op_type_float(builder, 64);
+            case VKD3D_SHADER_COMPONENT_UINT64:
+                return vkd3d_spirv_get_op_type_int(builder, 64, 0);
             default:
                 FIXME("Unhandled component type %#x.\n", component_type);
                 return 0;
@@ -1816,6 +1846,8 @@ static uint32_t vkd3d_spirv_get_type_id_for_data_type(struct vkd3d_spirv_builder
                 break;
             case VKD3D_DATA_DOUBLE:
                 return vkd3d_spirv_get_op_type_float(builder, 64);
+            case VKD3D_DATA_UINT64:
+                return vkd3d_spirv_get_op_type_int(builder, 64, 0);
             case VKD3D_DATA_BOOL:
                 return vkd3d_spirv_get_op_type_bool(builder);
             default:
@@ -1858,8 +1890,6 @@ static void vkd3d_spirv_builder_begin_main_function(struct vkd3d_spirv_builder *
 
     vkd3d_spirv_build_op_function(builder, void_id,
             builder->main_function_id, SpvFunctionControlMaskNone, function_type_id);
-    vkd3d_spirv_build_op_label(builder, vkd3d_spirv_alloc_id(builder));
-    builder->main_function_location = vkd3d_spirv_stream_current_location(&builder->function_stream);
 }
 
 static void vkd3d_spirv_builder_free(struct vkd3d_spirv_builder *builder)
@@ -1922,6 +1952,8 @@ static bool vkd3d_spirv_compile_module(struct vkd3d_spirv_builder *builder,
         vkd3d_spirv_build_op_extension(&stream, "SPV_EXT_descriptor_indexing");
     if (vkd3d_spirv_capability_is_enabled(builder, SpvCapabilityStencilExportEXT))
         vkd3d_spirv_build_op_extension(&stream, "SPV_EXT_shader_stencil_export");
+    if (vkd3d_spirv_capability_is_enabled(builder, SpvCapabilityShaderViewportIndexLayerEXT))
+        vkd3d_spirv_build_op_extension(&stream, "SPV_EXT_shader_viewport_index_layer");
 
     if (builder->ext_instr_set_glsl_450)
         vkd3d_spirv_build_op_ext_inst_import(&stream, builder->ext_instr_set_glsl_450, "GLSL.std.450");
@@ -2152,6 +2184,7 @@ static void vkd3d_symbol_make_register(struct vkd3d_symbol *symbol,
             break;
 
         case VKD3DSPR_IMMCONSTBUFFER:
+            symbol->key.reg.idx = reg->idx_count > 1 ? reg->idx[0].offset : 0;
             break;
 
         default:
@@ -2159,9 +2192,18 @@ static void vkd3d_symbol_make_register(struct vkd3d_symbol *symbol,
     }
 }
 
+static void vkd3d_symbol_make_io(struct vkd3d_symbol *symbol,
+        enum vkd3d_shader_register_type type, unsigned int index)
+{
+    symbol->type = VKD3D_SYMBOL_REGISTER;
+    memset(&symbol->key, 0, sizeof(symbol->key));
+    symbol->key.reg.type = type;
+    symbol->key.reg.idx = index;
+}
+
 static void vkd3d_symbol_set_register_info(struct vkd3d_symbol *symbol,
         uint32_t val_id, SpvStorageClass storage_class,
-        enum vkd3d_shader_component_type component_type, DWORD write_mask)
+        enum vkd3d_shader_component_type component_type, uint32_t write_mask)
 {
     symbol->id = val_id;
     symbol->descriptor_array = NULL;
@@ -2230,51 +2272,6 @@ static const char *debug_vkd3d_symbol(const struct vkd3d_symbol *symbol)
     }
 }
 
-struct vkd3d_if_cf_info
-{
-    size_t stream_location;
-    unsigned int id;
-    uint32_t merge_block_id;
-    uint32_t else_block_id;
-};
-
-struct vkd3d_loop_cf_info
-{
-    uint32_t header_block_id;
-    uint32_t continue_block_id;
-    uint32_t merge_block_id;
-};
-
-struct vkd3d_switch_cf_info
-{
-    size_t stream_location;
-    unsigned int id;
-    uint32_t selector_id;
-    uint32_t merge_block_id;
-    uint32_t default_block_id;
-    uint32_t *case_blocks;
-    size_t case_blocks_size;
-    unsigned int case_block_count;
-};
-
-struct vkd3d_control_flow_info
-{
-    union
-    {
-        struct vkd3d_if_cf_info if_;
-        struct vkd3d_loop_cf_info loop;
-        struct vkd3d_switch_cf_info switch_;
-    } u;
-
-    enum
-    {
-        VKD3D_BLOCK_IF,
-        VKD3D_BLOCK_LOOP,
-        VKD3D_BLOCK_SWITCH,
-    } current_block;
-    bool inside_block;
-};
-
 struct vkd3d_push_constant_buffer_binding
 {
     struct vkd3d_shader_register reg;
@@ -2328,13 +2325,6 @@ struct spirv_compiler
 
     enum vkd3d_shader_type shader_type;
 
-    unsigned int branch_id;
-    unsigned int loop_id;
-    unsigned int switch_id;
-    unsigned int control_flow_depth;
-    struct vkd3d_control_flow_info *control_flow_info;
-    size_t control_flow_info_size;
-
     struct vkd3d_shader_interface_info shader_interface;
     struct vkd3d_shader_descriptor_offset_info offset_info;
     uint32_t descriptor_offsets_member_id;
@@ -2343,8 +2333,7 @@ struct spirv_compiler
     struct vkd3d_push_constant_buffer_binding *push_constants;
     const struct vkd3d_shader_spirv_target_info *spirv_target_info;
 
-    bool main_block_open;
-    bool after_declarations_section;
+    bool prolog_emitted;
     struct shader_signature input_signature;
     struct shader_signature output_signature;
     struct shader_signature patch_constant_signature;
@@ -2358,13 +2347,16 @@ struct spirv_compiler
     uint32_t private_output_variable[MAX_REG_OUTPUT + 1]; /* 1 entry for oDepth */
     uint32_t private_output_variable_write_mask[MAX_REG_OUTPUT + 1]; /* 1 entry for oDepth */
     uint32_t epilogue_function_id;
+    uint32_t discard_function_id;
 
     uint32_t binding_idx;
 
     const struct vkd3d_shader_scan_descriptor_info1 *scan_descriptor_info;
     unsigned int input_control_point_count;
     unsigned int output_control_point_count;
+
     bool use_vocp;
+    bool emit_point_size;
 
     enum vkd3d_shader_opcode phase;
     bool emit_default_control_point_phase;
@@ -2376,12 +2368,21 @@ struct spirv_compiler
     struct vkd3d_shader_spec_constant *spec_constants;
     size_t spec_constants_size;
     enum vkd3d_shader_compile_option_formatting_flags formatting;
+    enum vkd3d_shader_compile_option_feature_flags features;
+    enum vkd3d_shader_api_version api_version;
     bool write_tess_geom_point_size;
 
     struct vkd3d_string_buffer_cache string_buffers;
 
     struct ssa_register_info *ssa_register_info;
     unsigned int ssa_register_count;
+
+    uint64_t config_flags;
+
+    uint32_t *block_label_ids;
+    unsigned int block_count;
+    const char **block_names;
+    size_t block_name_count;
 };
 
 static bool is_in_default_phase(const struct spirv_compiler *compiler)
@@ -2400,6 +2401,9 @@ static bool is_in_fork_or_join_phase(const struct spirv_compiler *compiler)
 }
 
 static void spirv_compiler_emit_initial_declarations(struct spirv_compiler *compiler);
+static size_t spirv_compiler_get_current_function_location(struct spirv_compiler *compiler);
+static void spirv_compiler_emit_main_prolog(struct spirv_compiler *compiler);
+static void spirv_compiler_emit_io_declarations(struct spirv_compiler *compiler);
 
 static const char *spirv_compiler_get_entry_point_name(const struct spirv_compiler *compiler)
 {
@@ -2410,8 +2414,6 @@ static const char *spirv_compiler_get_entry_point_name(const struct spirv_compil
 
 static void spirv_compiler_destroy(struct spirv_compiler *compiler)
 {
-    vkd3d_free(compiler->control_flow_info);
-
     vkd3d_free(compiler->output_info);
 
     vkd3d_free(compiler->push_constants);
@@ -2430,6 +2432,7 @@ static void spirv_compiler_destroy(struct spirv_compiler *compiler)
     shader_signature_cleanup(&compiler->patch_constant_signature);
 
     vkd3d_free(compiler->ssa_register_info);
+    vkd3d_free(compiler->block_label_ids);
 
     vkd3d_free(compiler);
 }
@@ -2437,7 +2440,8 @@ static void spirv_compiler_destroy(struct spirv_compiler *compiler)
 static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_version *shader_version,
         struct vkd3d_shader_desc *shader_desc, const struct vkd3d_shader_compile_info *compile_info,
         const struct vkd3d_shader_scan_descriptor_info1 *scan_descriptor_info,
-        struct vkd3d_shader_message_context *message_context, const struct vkd3d_shader_location *location)
+        struct vkd3d_shader_message_context *message_context, const struct vkd3d_shader_location *location,
+        uint64_t config_flags)
 {
     const struct shader_signature *patch_constant_signature = &shader_desc->patch_constant_signature;
     const struct shader_signature *output_signature = &shader_desc->output_signature;
@@ -2454,6 +2458,7 @@ static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_ve
     memset(compiler, 0, sizeof(*compiler));
     compiler->message_context = message_context;
     compiler->location = *location;
+    compiler->config_flags = config_flags;
 
     if ((target_info = vkd3d_find_struct(compile_info->next, SPIRV_TARGET_INFO)))
     {
@@ -2509,6 +2514,7 @@ static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_ve
                 break;
 
             case VKD3D_SHADER_COMPILE_OPTION_API_VERSION:
+                compiler->api_version = option->value;
                 break;
 
             case VKD3D_SHADER_COMPILE_OPTION_TYPED_UAV:
@@ -2533,12 +2539,20 @@ static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_ve
                     WARN("Ignoring unrecognised value %#x for option %#x.\n", option->value, option->name);
                 break;
 
+            case VKD3D_SHADER_COMPILE_OPTION_FEATURE:
+                compiler->features = option->value;
+                break;
+
             default:
                 WARN("Ignoring unrecognised option %#x with value %#x.\n", option->name, option->value);
                 break;
         }
     }
 
+    /* Explicit enabling of float64 was not required for API versions <= 1.10. */
+    if (compiler->api_version <= VKD3D_SHADER_API_VERSION_1_10)
+        compiler->features |= VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLOAT64;
+
     rb_init(&compiler->symbol_table, vkd3d_symbol_compare);
 
     compiler->shader_type = shader_version->type;
@@ -2546,6 +2560,8 @@ static struct spirv_compiler *spirv_compiler_create(const struct vkd3d_shader_ve
     if ((shader_interface = vkd3d_find_struct(compile_info->next, INTERFACE_INFO)))
     {
         compiler->xfb_info = vkd3d_find_struct(compile_info->next, TRANSFORM_FEEDBACK_INFO);
+        compiler->emit_point_size = compiler->xfb_info && compiler->xfb_info->element_count
+                && compiler->shader_type != VKD3D_SHADER_TYPE_GEOMETRY;
 
         compiler->shader_interface = *shader_interface;
         if (shader_interface->push_constant_buffer_count)
@@ -2759,6 +2775,14 @@ static struct vkd3d_string_buffer *vkd3d_shader_register_range_string(struct spi
     return buffer;
 }
 
+static uint32_t spirv_compiler_get_label_id(struct spirv_compiler *compiler, unsigned int block_id)
+{
+    --block_id;
+    if (!compiler->block_label_ids[block_id])
+        compiler->block_label_ids[block_id] = vkd3d_spirv_alloc_id(&compiler->spirv_builder);
+    return compiler->block_label_ids[block_id];
+}
+
 static struct vkd3d_shader_descriptor_binding spirv_compiler_get_descriptor_binding(
         struct spirv_compiler *compiler, const struct vkd3d_shader_register *reg,
         const struct vkd3d_shader_register_range *range, enum vkd3d_shader_resource_type resource_type,
@@ -2955,7 +2979,7 @@ static uint32_t spirv_compiler_get_constant64(struct spirv_compiler *compiler,
     assert(0 < component_count && component_count <= VKD3D_DVEC2_SIZE);
     type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
 
-    if (component_type != VKD3D_SHADER_COMPONENT_DOUBLE)
+    if (component_type != VKD3D_SHADER_COMPONENT_DOUBLE && component_type != VKD3D_SHADER_COMPONENT_UINT64)
     {
         FIXME("Unhandled component_type %#x.\n", component_type);
         return vkd3d_spirv_get_op_undef(builder, type_id);
@@ -3015,14 +3039,21 @@ static uint32_t spirv_compiler_get_constant_double_vector(struct spirv_compiler
             component_count, (const uint64_t *)values);
 }
 
+static uint32_t spirv_compiler_get_constant_uint64_vector(struct spirv_compiler *compiler,
+        uint64_t value, unsigned int component_count)
+{
+    const uint64_t values[] = {value, value};
+    return spirv_compiler_get_constant64(compiler, VKD3D_SHADER_COMPONENT_UINT64, component_count, values);
+}
+
 static uint32_t spirv_compiler_get_type_id_for_reg(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD write_mask)
+        const struct vkd3d_shader_register *reg, uint32_t write_mask)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
 
     return vkd3d_spirv_get_type_id(builder,
             vkd3d_component_type_from_data_type(reg->data_type),
-            vkd3d_write_mask_component_count(write_mask));
+            vsir_write_mask_component_count(write_mask));
 }
 
 static uint32_t spirv_compiler_get_type_id_for_dst(struct spirv_compiler *compiler,
@@ -3317,7 +3348,7 @@ static uint32_t spirv_compiler_emit_construct_vector(struct spirv_compiler *comp
 }
 
 static uint32_t spirv_compiler_emit_load_src(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_src_param *src, DWORD write_mask);
+        const struct vkd3d_shader_src_param *src, uint32_t write_mask);
 
 static uint32_t spirv_compiler_emit_register_addressing(struct spirv_compiler *compiler,
         const struct vkd3d_shader_register_index *reg_index)
@@ -3467,11 +3498,13 @@ static uint32_t spirv_compiler_get_descriptor_index(struct spirv_compiler *compi
             index_ids[0] = compiler->descriptor_offsets_member_id;
             index_ids[1] = spirv_compiler_get_constant_uint(compiler, push_constant_index);
             ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassPushConstant, type_id);
+            vkd3d_spirv_begin_function_stream_insertion(builder,
+                    spirv_compiler_get_current_function_location(compiler));
             ptr_id = vkd3d_spirv_build_op_in_bounds_access_chain(builder, ptr_type_id,
                     compiler->push_constants_var_id, index_ids, 2);
             offset_id = vkd3d_spirv_build_op_load(builder, type_id, ptr_id, SpvMemoryAccessMaskNone);
-            if (!compiler->control_flow_depth)
-                compiler->descriptor_offset_ids[push_constant_index] = offset_id;
+            vkd3d_spirv_end_function_stream_insertion(builder);
+            compiler->descriptor_offset_ids[push_constant_index] = offset_id;
         }
         index_id = vkd3d_spirv_build_op_iadd(builder, type_id, index_id, offset_id);
     }
@@ -3498,7 +3531,7 @@ static void spirv_compiler_emit_dereference_register(struct spirv_compiler *comp
     }
     else if (reg->type == VKD3DSPR_IMMCONSTBUFFER)
     {
-        indexes[index_count++] = spirv_compiler_emit_register_addressing(compiler, &reg->idx[0]);
+        indexes[index_count++] = spirv_compiler_emit_register_addressing(compiler, &reg->idx[reg->idx_count - 1]);
     }
     else if (reg->type == VKD3DSPR_IDXTEMP)
     {
@@ -3530,7 +3563,7 @@ static void spirv_compiler_emit_dereference_register(struct spirv_compiler *comp
 
     if (index_count)
     {
-        component_count = vkd3d_write_mask_component_count(register_info->write_mask);
+        component_count = vsir_write_mask_component_count(register_info->write_mask);
         type_id = vkd3d_spirv_get_type_id(builder, register_info->component_type, component_count);
         ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, register_info->storage_class, type_id);
         register_info->id = vkd3d_spirv_build_op_access_chain(builder, ptr_type_id,
@@ -3556,30 +3589,29 @@ static uint32_t spirv_compiler_get_register_id(struct spirv_compiler *compiler,
             SpvStorageClassPrivate, VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_VEC4_SIZE);
 }
 
-static bool vkd3d_swizzle_is_equal(unsigned int dst_write_mask,
-        unsigned int swizzle, unsigned int write_mask)
+static bool vkd3d_swizzle_is_equal(uint32_t dst_write_mask, uint32_t swizzle, uint32_t write_mask)
 {
     return vkd3d_compact_swizzle(VKD3D_SHADER_NO_SWIZZLE, dst_write_mask) == vkd3d_compact_swizzle(swizzle, write_mask);
 }
 
-static bool vkd3d_swizzle_is_scalar(unsigned int swizzle)
+static bool vkd3d_swizzle_is_scalar(uint32_t swizzle)
 {
-    unsigned int component_idx = vkd3d_swizzle_get_component(swizzle, 0);
-    return vkd3d_swizzle_get_component(swizzle, 1) == component_idx
-            && vkd3d_swizzle_get_component(swizzle, 2) == component_idx
-            && vkd3d_swizzle_get_component(swizzle, 3) == component_idx;
+    unsigned int component_idx = vsir_swizzle_get_component(swizzle, 0);
+    return vsir_swizzle_get_component(swizzle, 1) == component_idx
+            && vsir_swizzle_get_component(swizzle, 2) == component_idx
+            && vsir_swizzle_get_component(swizzle, 3) == component_idx;
 }
 
 static uint32_t spirv_compiler_emit_swizzle(struct spirv_compiler *compiler,
-        uint32_t val_id, unsigned int val_write_mask, enum vkd3d_shader_component_type component_type,
-        unsigned int swizzle, unsigned int write_mask)
+        uint32_t val_id, uint32_t val_write_mask, enum vkd3d_shader_component_type component_type,
+        uint32_t swizzle, uint32_t write_mask)
 {
     unsigned int i, component_idx, component_count, val_component_count;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id, components[VKD3D_VEC4_SIZE];
 
-    component_count = vkd3d_write_mask_component_count(write_mask);
-    val_component_count = vkd3d_write_mask_component_count(val_write_mask);
+    component_count = vsir_write_mask_component_count(write_mask);
+    val_component_count = vsir_write_mask_component_count(val_write_mask);
 
     if (component_count == val_component_count
             && (component_count == 1 || vkd3d_swizzle_is_equal(val_write_mask, swizzle, write_mask)))
@@ -3589,9 +3621,9 @@ static uint32_t spirv_compiler_emit_swizzle(struct spirv_compiler *compiler,
 
     if (component_count == 1)
     {
-        component_idx = vkd3d_write_mask_get_component_idx(write_mask);
-        component_idx = vkd3d_swizzle_get_component(swizzle, component_idx);
-        component_idx -= vkd3d_write_mask_get_component_idx(val_write_mask);
+        component_idx = vsir_write_mask_get_component_idx(write_mask);
+        component_idx = vsir_swizzle_get_component(swizzle, component_idx);
+        component_idx -= vsir_write_mask_get_component_idx(val_write_mask);
         return vkd3d_spirv_build_op_composite_extract1(builder, type_id, val_id, component_idx);
     }
 
@@ -3601,7 +3633,7 @@ static uint32_t spirv_compiler_emit_swizzle(struct spirv_compiler *compiler,
         {
             if (write_mask & (VKD3DSP_WRITEMASK_0 << i))
             {
-                assert(VKD3DSP_WRITEMASK_0 << vkd3d_swizzle_get_component(swizzle, i) == val_write_mask);
+                assert(VKD3DSP_WRITEMASK_0 << vsir_swizzle_get_component(swizzle, i) == val_write_mask);
                 components[component_idx++] = val_id;
             }
         }
@@ -3611,14 +3643,14 @@ static uint32_t spirv_compiler_emit_swizzle(struct spirv_compiler *compiler,
     for (i = 0, component_idx = 0; i < VKD3D_VEC4_SIZE; ++i)
     {
         if (write_mask & (VKD3DSP_WRITEMASK_0 << i))
-            components[component_idx++] = vkd3d_swizzle_get_component(swizzle, i);
+            components[component_idx++] = vsir_swizzle_get_component(swizzle, i);
     }
     return vkd3d_spirv_build_op_vector_shuffle(builder,
             type_id, val_id, val_id, components, component_count);
 }
 
 static uint32_t spirv_compiler_emit_vector_shuffle(struct spirv_compiler *compiler,
-        uint32_t vector1_id, uint32_t vector2_id, unsigned int swizzle, unsigned int write_mask,
+        uint32_t vector1_id, uint32_t vector2_id, uint32_t swizzle, uint32_t write_mask,
         enum vkd3d_shader_component_type component_type, unsigned int component_count)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
@@ -3631,9 +3663,9 @@ static uint32_t spirv_compiler_emit_vector_shuffle(struct spirv_compiler *compil
     for (i = 0; i < component_count; ++i)
     {
         if (write_mask & (VKD3DSP_WRITEMASK_0 << i))
-            components[i] = vkd3d_swizzle_get_component(swizzle, i);
+            components[i] = vsir_swizzle_get_component(swizzle, i);
         else
-            components[i] = VKD3D_VEC4_SIZE + vkd3d_swizzle_get_component(swizzle, i);
+            components[i] = VKD3D_VEC4_SIZE + vsir_swizzle_get_component(swizzle, i);
     }
 
     type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
@@ -3642,9 +3674,9 @@ static uint32_t spirv_compiler_emit_vector_shuffle(struct spirv_compiler *compil
 }
 
 static uint32_t spirv_compiler_emit_load_constant(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD swizzle, DWORD write_mask)
+        const struct vkd3d_shader_register *reg, uint32_t swizzle, uint32_t write_mask)
 {
-    unsigned int component_count = vkd3d_write_mask_component_count(write_mask);
+    unsigned int component_count = vsir_write_mask_component_count(write_mask);
     uint32_t values[VKD3D_VEC4_SIZE] = {0};
     unsigned int i, j;
 
@@ -3653,14 +3685,14 @@ static uint32_t spirv_compiler_emit_load_constant(struct spirv_compiler *compile
     if (reg->dimension == VSIR_DIMENSION_SCALAR)
     {
         for (i = 0; i < component_count; ++i)
-            values[i] = *reg->u.immconst_uint;
+            values[i] = *reg->u.immconst_u32;
     }
     else
     {
         for (i = 0, j = 0; i < VKD3D_VEC4_SIZE; ++i)
         {
             if (write_mask & (VKD3DSP_WRITEMASK_0 << i))
-                values[j++] = reg->u.immconst_uint[vkd3d_swizzle_get_component(swizzle, i)];
+                values[j++] = reg->u.immconst_u32[vsir_swizzle_get_component(swizzle, i)];
         }
     }
 
@@ -3669,9 +3701,9 @@ static uint32_t spirv_compiler_emit_load_constant(struct spirv_compiler *compile
 }
 
 static uint32_t spirv_compiler_emit_load_constant64(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD swizzle, DWORD write_mask)
+        const struct vkd3d_shader_register *reg, uint32_t swizzle, uint32_t write_mask)
 {
-    unsigned int component_count = vkd3d_write_mask_component_count(write_mask);
+    unsigned int component_count = vsir_write_mask_component_count(write_mask);
     uint64_t values[VKD3D_DVEC2_SIZE] = {0};
     unsigned int i, j;
 
@@ -3680,14 +3712,14 @@ static uint32_t spirv_compiler_emit_load_constant64(struct spirv_compiler *compi
     if (reg->dimension == VSIR_DIMENSION_SCALAR)
     {
         for (i = 0; i < component_count; ++i)
-            values[i] = *reg->u.immconst_uint64;
+            values[i] = *reg->u.immconst_u64;
     }
     else
     {
         for (i = 0, j = 0; i < VKD3D_DVEC2_SIZE; ++i)
         {
             if (write_mask & (VKD3DSP_WRITEMASK_0 << i))
-                values[j++] = reg->u.immconst_uint64[vkd3d_swizzle_get_component64(swizzle, i)];
+                values[j++] = reg->u.immconst_u64[vsir_swizzle_get_component64(swizzle, i)];
         }
     }
 
@@ -3696,9 +3728,9 @@ static uint32_t spirv_compiler_emit_load_constant64(struct spirv_compiler *compi
 }
 
 static uint32_t spirv_compiler_emit_load_undef(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD write_mask)
+        const struct vkd3d_shader_register *reg, uint32_t write_mask)
 {
-    unsigned int component_count = vkd3d_write_mask_component_count(write_mask);
+    unsigned int component_count = vsir_write_mask_component_count(write_mask);
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id;
 
@@ -3709,28 +3741,28 @@ static uint32_t spirv_compiler_emit_load_undef(struct spirv_compiler *compiler,
 }
 
 static uint32_t spirv_compiler_emit_load_scalar(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD swizzle, DWORD write_mask,
+        const struct vkd3d_shader_register *reg, uint32_t swizzle, uint32_t write_mask,
         const struct vkd3d_shader_register_info *reg_info)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id, ptr_type_id, index, reg_id, val_id;
     unsigned int component_idx, reg_component_count;
     enum vkd3d_shader_component_type component_type;
-    unsigned int skipped_component_mask;
+    uint32_t skipped_component_mask;
 
     assert(!register_is_constant_or_undef(reg));
-    assert(vkd3d_write_mask_component_count(write_mask) == 1);
+    assert(vsir_write_mask_component_count(write_mask) == 1);
 
-    component_idx = vkd3d_write_mask_get_component_idx(write_mask);
-    component_idx = vkd3d_swizzle_get_component(swizzle, component_idx);
+    component_idx = vsir_write_mask_get_component_idx(write_mask);
+    component_idx = vsir_swizzle_get_component(swizzle, component_idx);
     skipped_component_mask = ~reg_info->write_mask & ((VKD3DSP_WRITEMASK_0 << component_idx) - 1);
     if (skipped_component_mask)
-        component_idx -= vkd3d_write_mask_component_count(skipped_component_mask);
+        component_idx -= vsir_write_mask_component_count(skipped_component_mask);
     component_type = vkd3d_component_type_from_data_type(reg->data_type);
 
-    reg_component_count = vkd3d_write_mask_component_count(reg_info->write_mask);
+    reg_component_count = vsir_write_mask_component_count(reg_info->write_mask);
 
-    if (component_idx >= vkd3d_write_mask_component_count(reg_info->write_mask))
+    if (component_idx >= vsir_write_mask_component_count(reg_info->write_mask))
     {
         ERR("Invalid component_idx %u for register %#x, %u (write_mask %#x).\n",
                 component_idx, reg->type, reg->idx[0].offset, reg_info->write_mask);
@@ -3756,6 +3788,69 @@ static uint32_t spirv_compiler_emit_load_scalar(struct spirv_compiler *compiler,
     return val_id;
 }
 
+static uint32_t spirv_compiler_emit_constant_array(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_immediate_constant_buffer *icb, uint32_t *type_id_out)
+{
+    uint32_t *elements, elem_type_id, length_id, type_id, const_id;
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    enum vkd3d_shader_component_type component_type;
+    unsigned int i, element_count, component_count;
+
+    element_count = icb->element_count;
+
+    component_type = vkd3d_component_type_from_data_type(icb->data_type);
+    component_count = icb->component_count;
+    elem_type_id = vkd3d_spirv_get_type_id_for_data_type(builder, icb->data_type, component_count);
+    length_id = spirv_compiler_get_constant_uint(compiler, element_count);
+    type_id = vkd3d_spirv_get_op_type_array(builder, elem_type_id, length_id);
+
+    if (type_id_out)
+        *type_id_out = type_id;
+
+    if (icb->is_null)
+    {
+        /* All values are null. Workgroup memory initialisers require OpConstantNull. */
+        return vkd3d_spirv_get_op_constant_null(builder, type_id);
+    }
+
+    if (!(elements = vkd3d_calloc(element_count, sizeof(*elements))))
+    {
+        ERR("Failed to allocate %u elements.", element_count);
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_OUT_OF_MEMORY,
+                "Failed to allocate %u constant array elements.", element_count);
+        return 0;
+    }
+
+    switch (icb->data_type)
+    {
+        case VKD3D_DATA_FLOAT:
+        case VKD3D_DATA_INT:
+        case VKD3D_DATA_UINT:
+            for (i = 0; i < element_count; ++i)
+                elements[i] = spirv_compiler_get_constant(compiler, component_type, component_count,
+                        &icb->data[component_count * i]);
+            break;
+        case VKD3D_DATA_DOUBLE:
+        case VKD3D_DATA_UINT64:
+        {
+            uint64_t *data = (uint64_t *)icb->data;
+            for (i = 0; i < element_count; ++i)
+                elements[i] = spirv_compiler_get_constant64(compiler, component_type, component_count,
+                        &data[component_count * i]);
+            break;
+        }
+        default:
+            FIXME("Unhandled data type %u.\n", icb->data_type);
+            spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_TYPE,
+                    "Immediate constant buffer data type %u is unhandled.", icb->data_type);
+            break;
+    }
+
+    const_id = vkd3d_spirv_build_op_constant_composite(builder, type_id, elements, element_count);
+    vkd3d_free(elements);
+    return const_id;
+}
+
 static const struct ssa_register_info *spirv_compiler_get_ssa_register_info(const struct spirv_compiler *compiler,
         const struct vkd3d_shader_register *reg)
 {
@@ -3775,7 +3870,7 @@ static void spirv_compiler_set_ssa_register_info(const struct spirv_compiler *co
 
 static uint32_t spirv_compiler_emit_load_ssa_reg(struct spirv_compiler *compiler,
         const struct vkd3d_shader_register *reg, enum vkd3d_shader_component_type component_type,
-        unsigned int swizzle)
+        uint32_t swizzle)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     enum vkd3d_shader_component_type reg_component_type;
@@ -3785,7 +3880,12 @@ static uint32_t spirv_compiler_emit_load_ssa_reg(struct spirv_compiler *compiler
 
     ssa = spirv_compiler_get_ssa_register_info(compiler, reg);
     val_id = ssa->id;
-    assert(val_id);
+    if (!val_id)
+    {
+        /* Should only be from a missing instruction implementation. */
+        assert(compiler->failed);
+        return 0;
+    }
     assert(vkd3d_swizzle_is_scalar(swizzle));
 
     if (reg->dimension == VSIR_DIMENSION_SCALAR)
@@ -3801,19 +3901,19 @@ static uint32_t spirv_compiler_emit_load_ssa_reg(struct spirv_compiler *compiler
     }
 
     type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
-    component_idx = vkd3d_swizzle_get_component(swizzle, 0);
+    component_idx = vsir_swizzle_get_component(swizzle, 0);
     return vkd3d_spirv_build_op_composite_extract1(builder, type_id, val_id, component_idx);
 }
 
 static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD swizzle, DWORD write_mask)
+        const struct vkd3d_shader_register *reg, uint32_t swizzle, uint32_t write_mask)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     enum vkd3d_shader_component_type component_type;
     struct vkd3d_shader_register_info reg_info;
     unsigned int component_count;
-    unsigned int write_mask32;
     uint32_t type_id, val_id;
+    uint32_t write_mask32;
 
     if (reg->type == VKD3DSPR_IMMCONST)
         return spirv_compiler_emit_load_constant(compiler, reg, swizzle, write_mask);
@@ -3822,7 +3922,7 @@ static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
     else if (reg->type == VKD3DSPR_UNDEF)
         return spirv_compiler_emit_load_undef(compiler, reg, write_mask);
 
-    component_count = vkd3d_write_mask_component_count(write_mask);
+    component_count = vsir_write_mask_component_count(write_mask);
     component_type = vkd3d_component_type_from_data_type(reg->data_type);
 
     if (reg->type == VKD3DSPR_SSA)
@@ -3836,21 +3936,21 @@ static uint32_t spirv_compiler_emit_load_reg(struct spirv_compiler *compiler,
     assert(reg_info.component_type != VKD3D_SHADER_COMPONENT_DOUBLE);
     spirv_compiler_emit_dereference_register(compiler, reg, &reg_info);
 
-    write_mask32 = (reg->data_type == VKD3D_DATA_DOUBLE) ? vkd3d_write_mask_32_from_64(write_mask) : write_mask;
+    write_mask32 = data_type_is_64_bit(reg->data_type) ? vsir_write_mask_32_from_64(write_mask) : write_mask;
 
     /* Intermediate value (no storage class). */
     if (reg_info.storage_class == SpvStorageClassMax)
     {
         val_id = reg_info.id;
     }
-    else if (vkd3d_write_mask_component_count(write_mask32) == 1)
+    else if (vsir_write_mask_component_count(write_mask32) == 1)
     {
         return spirv_compiler_emit_load_scalar(compiler, reg, swizzle, write_mask, &reg_info);
     }
     else
     {
         type_id = vkd3d_spirv_get_type_id(builder,
-                reg_info.component_type, vkd3d_write_mask_component_count(reg_info.write_mask));
+                reg_info.component_type, vsir_write_mask_component_count(reg_info.write_mask));
         val_id = vkd3d_spirv_build_op_load(builder, type_id, reg_info.id, SpvMemoryAccessMaskNone);
     }
 
@@ -3882,7 +3982,7 @@ static void spirv_compiler_emit_execution_mode1(struct spirv_compiler *compiler,
 }
 
 static uint32_t spirv_compiler_emit_abs(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD write_mask, uint32_t val_id)
+        const struct vkd3d_shader_register *reg, uint32_t write_mask, uint32_t val_id)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id;
@@ -3896,7 +3996,7 @@ static uint32_t spirv_compiler_emit_abs(struct spirv_compiler *compiler,
 }
 
 static uint32_t spirv_compiler_emit_neg(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD write_mask, uint32_t val_id)
+        const struct vkd3d_shader_register *reg, uint32_t write_mask, uint32_t val_id)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id;
@@ -3904,7 +4004,7 @@ static uint32_t spirv_compiler_emit_neg(struct spirv_compiler *compiler,
     type_id = spirv_compiler_get_type_id_for_reg(compiler, reg, write_mask);
     if (reg->data_type == VKD3D_DATA_FLOAT || reg->data_type == VKD3D_DATA_DOUBLE)
         return vkd3d_spirv_build_op_fnegate(builder, type_id, val_id);
-    else if (reg->data_type == VKD3D_DATA_INT || reg->data_type == VKD3D_DATA_UINT)
+    else if (data_type_is_integer(reg->data_type))
         return vkd3d_spirv_build_op_snegate(builder, type_id, val_id);
 
     FIXME("Unhandled data type %#x.\n", reg->data_type);
@@ -3912,7 +4012,7 @@ static uint32_t spirv_compiler_emit_neg(struct spirv_compiler *compiler,
 }
 
 static uint32_t spirv_compiler_emit_src_modifier(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD write_mask,
+        const struct vkd3d_shader_register *reg, uint32_t write_mask,
         enum vkd3d_shader_src_modifier modifier, uint32_t val_id)
 {
     switch (modifier)
@@ -3935,7 +4035,7 @@ static uint32_t spirv_compiler_emit_src_modifier(struct spirv_compiler *compiler
 }
 
 static uint32_t spirv_compiler_emit_load_src(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_src_param *src, DWORD write_mask)
+        const struct vkd3d_shader_src_param *src, uint32_t write_mask)
 {
     uint32_t val_id;
 
@@ -3944,7 +4044,7 @@ static uint32_t spirv_compiler_emit_load_src(struct spirv_compiler *compiler,
 }
 
 static uint32_t spirv_compiler_emit_load_src_with_type(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_src_param *src, DWORD write_mask, enum vkd3d_shader_component_type component_type)
+        const struct vkd3d_shader_src_param *src, uint32_t write_mask, enum vkd3d_shader_component_type component_type)
 {
     struct vkd3d_shader_src_param src_param = *src;
 
@@ -3953,19 +4053,19 @@ static uint32_t spirv_compiler_emit_load_src_with_type(struct spirv_compiler *co
 }
 
 static void spirv_compiler_emit_store_scalar(struct spirv_compiler *compiler,
-        uint32_t dst_id, unsigned int dst_write_mask, enum vkd3d_shader_component_type component_type,
-        SpvStorageClass storage_class, unsigned int write_mask, uint32_t val_id)
+        uint32_t dst_id, uint32_t dst_write_mask, enum vkd3d_shader_component_type component_type,
+        SpvStorageClass storage_class, uint32_t write_mask, uint32_t val_id)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id, ptr_type_id, index;
     unsigned int component_idx;
 
-    if (vkd3d_write_mask_component_count(dst_write_mask) > 1)
+    if (vsir_write_mask_component_count(dst_write_mask) > 1)
     {
         type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
         ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, storage_class, type_id);
-        component_idx = vkd3d_write_mask_get_component_idx(write_mask);
-        component_idx -= vkd3d_write_mask_get_component_idx(dst_write_mask);
+        component_idx = vsir_write_mask_get_component_idx(write_mask);
+        component_idx -= vsir_write_mask_get_component_idx(dst_write_mask);
         index = spirv_compiler_get_constant_uint(compiler, component_idx);
         dst_id = vkd3d_spirv_build_op_in_bounds_access_chain1(builder, ptr_type_id, dst_id, index);
     }
@@ -3974,8 +4074,8 @@ static void spirv_compiler_emit_store_scalar(struct spirv_compiler *compiler,
 }
 
 static void spirv_compiler_emit_store(struct spirv_compiler *compiler,
-        uint32_t dst_id, unsigned int dst_write_mask, enum vkd3d_shader_component_type component_type,
-        SpvStorageClass storage_class, unsigned int write_mask, uint32_t val_id)
+        uint32_t dst_id, uint32_t dst_write_mask, enum vkd3d_shader_component_type component_type,
+        SpvStorageClass storage_class, uint32_t write_mask, uint32_t val_id)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     unsigned int component_count, dst_component_count;
@@ -3985,14 +4085,14 @@ static void spirv_compiler_emit_store(struct spirv_compiler *compiler,
 
     assert(write_mask);
 
-    component_count = vkd3d_write_mask_component_count(write_mask);
-    dst_component_count = vkd3d_write_mask_component_count(dst_write_mask);
+    component_count = vsir_write_mask_component_count(write_mask);
+    dst_component_count = vsir_write_mask_component_count(dst_write_mask);
 
     if (dst_component_count == 1 && component_count != 1)
     {
         type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
         val_id = vkd3d_spirv_build_op_composite_extract1(builder, type_id, val_id,
-                vkd3d_write_mask_get_component_idx(dst_write_mask));
+                vsir_write_mask_get_component_idx(dst_write_mask));
         write_mask &= dst_write_mask;
         component_count = 1;
     }
@@ -4029,12 +4129,12 @@ static void spirv_compiler_emit_store(struct spirv_compiler *compiler,
 }
 
 static void spirv_compiler_emit_store_reg(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, unsigned int write_mask, uint32_t val_id)
+        const struct vkd3d_shader_register *reg, uint32_t write_mask, uint32_t val_id)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     enum vkd3d_shader_component_type component_type;
     struct vkd3d_shader_register_info reg_info;
-    unsigned int src_write_mask = write_mask;
+    uint32_t src_write_mask = write_mask;
     uint32_t type_id;
 
     assert(!register_is_constant_or_undef(reg));
@@ -4052,10 +4152,10 @@ static void spirv_compiler_emit_store_reg(struct spirv_compiler *compiler,
     component_type = vkd3d_component_type_from_data_type(reg->data_type);
     if (component_type != reg_info.component_type)
     {
-        if (reg->data_type == VKD3D_DATA_DOUBLE)
-            src_write_mask = vkd3d_write_mask_32_from_64(write_mask);
+        if (data_type_is_64_bit(reg->data_type))
+            src_write_mask = vsir_write_mask_32_from_64(write_mask);
         type_id = vkd3d_spirv_get_type_id(builder, reg_info.component_type,
-                vkd3d_write_mask_component_count(src_write_mask));
+                vsir_write_mask_component_count(src_write_mask));
         val_id = vkd3d_spirv_build_op_bitcast(builder, type_id, val_id);
         component_type = reg_info.component_type;
     }
@@ -4065,9 +4165,9 @@ static void spirv_compiler_emit_store_reg(struct spirv_compiler *compiler,
 }
 
 static uint32_t spirv_compiler_emit_sat(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg, DWORD write_mask, uint32_t val_id)
+        const struct vkd3d_shader_register *reg, uint32_t write_mask, uint32_t val_id)
 {
-    unsigned int component_count = vkd3d_write_mask_component_count(write_mask);
+    unsigned int component_count = vsir_write_mask_component_count(write_mask);
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id, zero_id, one_id;
 
@@ -4102,7 +4202,7 @@ static void spirv_compiler_emit_store_dst(struct spirv_compiler *compiler,
 
 static void spirv_compiler_emit_store_dst_swizzled(struct spirv_compiler *compiler,
         const struct vkd3d_shader_dst_param *dst, uint32_t val_id,
-        enum vkd3d_shader_component_type component_type, DWORD swizzle)
+        enum vkd3d_shader_component_type component_type, uint32_t swizzle)
 {
     struct vkd3d_shader_dst_param typed_dst = *dst;
     val_id = spirv_compiler_emit_swizzle(compiler,
@@ -4118,7 +4218,7 @@ static void spirv_compiler_emit_store_dst_components(struct spirv_compiler *comp
         const struct vkd3d_shader_dst_param *dst, enum vkd3d_shader_component_type component_type,
         uint32_t *component_ids)
 {
-    unsigned int component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    unsigned int component_count = vsir_write_mask_component_count(dst->write_mask);
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id, val_id;
 
@@ -4137,16 +4237,16 @@ static void spirv_compiler_emit_store_dst_components(struct spirv_compiler *comp
 
 static void spirv_compiler_emit_store_dst_scalar(struct spirv_compiler *compiler,
         const struct vkd3d_shader_dst_param *dst, uint32_t val_id,
-        enum vkd3d_shader_component_type component_type, DWORD swizzle)
+        enum vkd3d_shader_component_type component_type, uint32_t swizzle)
 {
-    unsigned int component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    unsigned int component_count = vsir_write_mask_component_count(dst->write_mask);
     uint32_t component_ids[VKD3D_VEC4_SIZE];
     unsigned int component_idx, i;
 
-    component_idx = vkd3d_write_mask_get_component_idx(dst->write_mask);
+    component_idx = vsir_write_mask_get_component_idx(dst->write_mask);
     for (i = 0; i < component_count; ++i)
     {
-        if (vkd3d_swizzle_get_component(swizzle, component_idx + i))
+        if (vsir_swizzle_get_component(swizzle, component_idx + i))
             ERR("Invalid swizzle %#x for scalar value, write mask %#x.\n", swizzle, dst->write_mask);
 
         component_ids[i] = val_id;
@@ -4169,10 +4269,58 @@ static void spirv_compiler_decorate_builtin(struct spirv_compiler *compiler,
             spirv_compiler_emit_execution_mode(compiler, SpvExecutionModeDepthReplacing, NULL, 0);
             break;
         case SpvBuiltInLayer:
-            vkd3d_spirv_enable_capability(builder, SpvCapabilityGeometry);
+            switch (compiler->shader_type)
+            {
+                case VKD3D_SHADER_TYPE_PIXEL:
+                case VKD3D_SHADER_TYPE_GEOMETRY:
+                    vkd3d_spirv_enable_capability(builder, SpvCapabilityGeometry);
+                    break;
+
+                case VKD3D_SHADER_TYPE_VERTEX:
+                case VKD3D_SHADER_TYPE_DOMAIN:
+                    if (!spirv_compiler_is_target_extension_supported(compiler,
+                            VKD3D_SHADER_SPIRV_EXTENSION_EXT_VIEWPORT_INDEX_LAYER))
+                    {
+                        FIXME("The target environment does not support decoration Layer.\n");
+                        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_UNSUPPORTED_FEATURE,
+                                "Cannot use SV_RenderTargetArrayIndex. "
+                                "The target environment does not support decoration Layer.");
+                    }
+                    vkd3d_spirv_enable_capability(builder, SpvCapabilityShaderViewportIndexLayerEXT);
+                    break;
+
+                default:
+                    spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                            "Invalid use of SV_RenderTargetArrayIndex.");
+                    break;
+            }
             break;
         case SpvBuiltInViewportIndex:
-            vkd3d_spirv_enable_capability(builder, SpvCapabilityMultiViewport);
+            switch (compiler->shader_type)
+            {
+                case VKD3D_SHADER_TYPE_PIXEL:
+                case VKD3D_SHADER_TYPE_GEOMETRY:
+                    vkd3d_spirv_enable_capability(builder, SpvCapabilityMultiViewport);
+                    break;
+
+                case VKD3D_SHADER_TYPE_VERTEX:
+                case VKD3D_SHADER_TYPE_DOMAIN:
+                    if (!spirv_compiler_is_target_extension_supported(compiler,
+                            VKD3D_SHADER_SPIRV_EXTENSION_EXT_VIEWPORT_INDEX_LAYER))
+                    {
+                        FIXME("The target environment does not support decoration ViewportIndex.\n");
+                        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_UNSUPPORTED_FEATURE,
+                                "Cannot use SV_ViewportArrayIndex. "
+                                "The target environment does not support decoration ViewportIndex.");
+                    }
+                    vkd3d_spirv_enable_capability(builder, SpvCapabilityShaderViewportIndexLayerEXT);
+                    break;
+
+                default:
+                    spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                            "Invalid use of SV_ViewportArrayIndex.");
+                    break;
+            }
             break;
         case SpvBuiltInSampleId:
             vkd3d_spirv_enable_capability(builder, SpvCapabilitySampleRateShading);
@@ -4191,14 +4339,18 @@ static void spirv_compiler_decorate_builtin(struct spirv_compiler *compiler,
 }
 
 static void spirv_compiler_emit_interpolation_decorations(struct spirv_compiler *compiler,
-        uint32_t id, enum vkd3d_shader_interpolation_mode mode)
+        enum vkd3d_shader_component_type component_type, uint32_t id, enum vkd3d_shader_interpolation_mode mode)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
 
     switch (mode)
     {
         case VKD3DSIM_NONE:
-            break;
+            /* VUID-StandaloneSpirv-Flat-04744: integer or double types must be
+             * decorated 'Flat' for fragment shaders. */
+            if (compiler->shader_type != VKD3D_SHADER_TYPE_PIXEL || component_type == VKD3D_SHADER_COMPONENT_FLOAT)
+                break;
+            /* fall through */
         case VKD3DSIM_CONSTANT:
             vkd3d_spirv_build_op_decorate(builder, id, SpvDecorationFlat, NULL, 0);
             break;
@@ -4226,7 +4378,8 @@ static void spirv_compiler_emit_interpolation_decorations(struct spirv_compiler
 }
 
 static uint32_t spirv_compiler_emit_int_to_bool(struct spirv_compiler *compiler,
-        enum vkd3d_shader_conditional_op condition, unsigned int component_count, uint32_t val_id)
+        enum vkd3d_shader_conditional_op condition, enum vkd3d_data_type data_type,
+        unsigned int component_count, uint32_t val_id)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id;
@@ -4237,7 +4390,9 @@ static uint32_t spirv_compiler_emit_int_to_bool(struct spirv_compiler *compiler,
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_BOOL, component_count);
     op = condition & VKD3D_SHADER_CONDITIONAL_OP_Z ? SpvOpIEqual : SpvOpINotEqual;
     return vkd3d_spirv_build_op_tr2(builder, &builder->function_stream, op, type_id, val_id,
-            spirv_compiler_get_constant_uint_vector(compiler, 0, component_count));
+            data_type == VKD3D_DATA_UINT64
+            ? spirv_compiler_get_constant_uint64_vector(compiler, 0, component_count)
+            : spirv_compiler_get_constant_uint_vector(compiler, 0, component_count));
 }
 
 static uint32_t spirv_compiler_emit_bool_to_int(struct spirv_compiler *compiler,
@@ -4252,6 +4407,19 @@ static uint32_t spirv_compiler_emit_bool_to_int(struct spirv_compiler *compiler,
     return vkd3d_spirv_build_op_select(builder, type_id, val_id, true_id, false_id);
 }
 
+static uint32_t spirv_compiler_emit_bool_to_int64(struct spirv_compiler *compiler,
+        unsigned int component_count, uint32_t val_id, bool signedness)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    uint32_t type_id, true_id, false_id;
+
+    true_id = spirv_compiler_get_constant_uint64_vector(compiler, signedness ? UINT64_MAX : 1,
+            component_count);
+    false_id = spirv_compiler_get_constant_uint64_vector(compiler, 0, component_count);
+    type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_UINT64, component_count);
+    return vkd3d_spirv_build_op_select(builder, type_id, val_id, true_id, false_id);
+}
+
 static uint32_t spirv_compiler_emit_bool_to_float(struct spirv_compiler *compiler,
         unsigned int component_count, uint32_t val_id, bool signedness)
 {
@@ -4422,9 +4590,9 @@ vkd3d_register_builtins[] =
 };
 
 static void spirv_compiler_emit_register_execution_mode(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_register *reg)
+        enum vkd3d_shader_register_type type)
 {
-    switch (reg->type)
+    switch (type)
     {
         case VKD3DSPR_DEPTHOUTGE:
             spirv_compiler_emit_execution_mode(compiler, SpvExecutionModeDepthGreater, NULL, 0);
@@ -4437,9 +4605,9 @@ static void spirv_compiler_emit_register_execution_mode(struct spirv_compiler *c
                     VKD3D_SHADER_SPIRV_EXTENSION_EXT_STENCIL_EXPORT))
             {
                 FIXME("The target environment does not support stencil export.\n");
-                spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_STENCIL_EXPORT_UNSUPPORTED,
-                        "Cannot export stencil reference value for register id %u. "
-                        "The target environment does not support stencil export.", reg->idx[0].offset);
+                spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_UNSUPPORTED_FEATURE,
+                        "Cannot export stencil reference value. "
+                        "The target environment does not support stencil export.");
             }
             vkd3d_spirv_enable_capability(&compiler->spirv_builder, SpvCapabilityStencilExportEXT);
             spirv_compiler_emit_execution_mode(compiler, SpvExecutionModeStencilRefReplacingEXT, NULL, 0);
@@ -4635,7 +4803,7 @@ static uint32_t spirv_compiler_emit_builtin_variable_v(struct spirv_compiler *co
     assert(size_count <= ARRAY_SIZE(sizes));
     memcpy(sizes, array_sizes, size_count * sizeof(sizes[0]));
     array_sizes = sizes;
-    sizes[size_count - 1] = max(sizes[size_count - 1], builtin->spirv_array_size);
+    sizes[0] = max(sizes[0], builtin->spirv_array_size);
 
     id = spirv_compiler_emit_array_variable(compiler, &builder->global_stream, storage_class,
             builtin->component_type, builtin->component_count, array_sizes, size_count);
@@ -4674,17 +4842,16 @@ static unsigned int shader_signature_next_location(const struct shader_signature
 }
 
 static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_dst_param *dst)
+        enum vkd3d_shader_register_type reg_type, unsigned int element_idx)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    const struct vkd3d_shader_register *reg = &dst->reg;
     unsigned int component_idx, input_component_count;
     const struct signature_element *signature_element;
     const struct shader_signature *shader_signature;
     enum vkd3d_shader_component_type component_type;
     const struct vkd3d_spirv_builtin *builtin;
     enum vkd3d_shader_sysval_semantic sysval;
-    unsigned int write_mask, reg_write_mask;
+    uint32_t write_mask, reg_write_mask;
     struct vkd3d_symbol *symbol = NULL;
     uint32_t val_id, input_id, var_id;
     uint32_t type_id, float_type_id;
@@ -4693,31 +4860,26 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     struct rb_entry *entry = NULL;
     bool use_private_var = false;
     unsigned int array_sizes[2];
-    unsigned int element_idx;
 
-    assert(!reg->idx_count || !reg->idx[0].rel_addr);
-    assert(reg->idx_count < 2 || !reg->idx[1].rel_addr);
-
-    shader_signature = reg->type == VKD3DSPR_PATCHCONST
+    shader_signature = reg_type == VKD3DSPR_PATCHCONST
             ? &compiler->patch_constant_signature : &compiler->input_signature;
 
-    element_idx = reg->idx[reg->idx_count - 1].offset;
     signature_element = &shader_signature->elements[element_idx];
     sysval = signature_element->sysval_semantic;
     /* The Vulkan spec does not explicitly forbid passing varyings from the
      * TCS to the TES via builtins. However, Mesa doesn't seem to handle it
      * well, and we don't actually need them to be in builtins. */
-    if (compiler->shader_type == VKD3D_SHADER_TYPE_DOMAIN && reg->type != VKD3DSPR_PATCHCONST)
+    if (compiler->shader_type == VKD3D_SHADER_TYPE_DOMAIN && reg_type != VKD3DSPR_PATCHCONST)
         sysval = VKD3D_SHADER_SV_NONE;
 
     builtin = get_spirv_builtin_for_sysval(compiler, sysval);
 
-    array_sizes[0] = (reg->type == VKD3DSPR_PATCHCONST ? 0 : compiler->input_control_point_count);
-    array_sizes[1] = signature_element->register_count;
-    if (array_sizes[1] == 1 && !vsir_sysval_semantic_is_tess_factor(signature_element->sysval_semantic)
-            && (!vsir_sysval_semantic_is_clip_cull(signature_element->sysval_semantic) || array_sizes[0]))
+    array_sizes[0] = signature_element->register_count;
+    array_sizes[1] = (reg_type == VKD3DSPR_PATCHCONST ? 0 : compiler->input_control_point_count);
+    if (array_sizes[0] == 1 && !vsir_sysval_semantic_is_tess_factor(signature_element->sysval_semantic)
+            && (!vsir_sysval_semantic_is_clip_cull(signature_element->sysval_semantic) || array_sizes[1]))
     {
-        array_sizes[1] = 0;
+        array_sizes[0] = 0;
     }
 
     write_mask = signature_element->mask;
@@ -4731,8 +4893,8 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     else
     {
         component_type = signature_element->component_type;
-        input_component_count = vkd3d_write_mask_component_count(signature_element->mask);
-        component_idx = vkd3d_write_mask_get_component_idx(signature_element->mask);
+        input_component_count = vsir_write_mask_component_count(signature_element->mask);
+        component_idx = vsir_write_mask_get_component_idx(signature_element->mask);
     }
 
     if (needs_private_io_variable(builtin))
@@ -4742,13 +4904,13 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     }
     else
     {
-        component_idx = vkd3d_write_mask_get_component_idx(write_mask);
+        component_idx = vsir_write_mask_get_component_idx(write_mask);
         reg_write_mask = write_mask >> component_idx;
     }
 
     storage_class = SpvStorageClassInput;
 
-    vkd3d_symbol_make_register(&reg_symbol, reg);
+    vkd3d_symbol_make_io(&reg_symbol, reg_type, element_idx);
 
     if ((entry = rb_get(&compiler->symbol_table, &reg_symbol)))
     {
@@ -4756,7 +4918,7 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
          * duplicate declarations are: a single register split into multiple declarations having
          * different components, which should have been merged, and declarations in one phase
          * being repeated in another (i.e. vcp/vocp), which should have been deleted. */
-        if (reg->type != VKD3DSPR_INPUT || !is_in_fork_or_join_phase(compiler))
+        if (reg_type != VKD3DSPR_INPUT || !is_in_fork_or_join_phase(compiler))
             FIXME("Duplicate input definition found.\n");
         symbol = RB_ENTRY_VALUE(entry, struct vkd3d_symbol, entry);
         return symbol->id;
@@ -4765,7 +4927,7 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     if (builtin)
     {
         input_id = spirv_compiler_emit_builtin_variable_v(compiler, builtin, storage_class, array_sizes, 2);
-        if (reg->type == VKD3DSPR_PATCHCONST)
+        if (reg_type == VKD3DSPR_PATCHCONST)
             vkd3d_spirv_build_op_decorate(builder, input_id, SpvDecorationPatch, NULL, 0);
     }
     else
@@ -4775,7 +4937,7 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
         input_id = spirv_compiler_emit_array_variable(compiler, &builder->global_stream,
                 storage_class, component_type, input_component_count, array_sizes, 2);
         vkd3d_spirv_add_iface_variable(builder, input_id);
-        if (reg->type == VKD3DSPR_PATCHCONST)
+        if (reg_type == VKD3DSPR_PATCHCONST)
         {
             vkd3d_spirv_build_op_decorate(builder, input_id, SpvDecorationPatch, NULL, 0);
             location += shader_signature_next_location(&compiler->input_signature);
@@ -4784,7 +4946,8 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
         if (component_idx)
             vkd3d_spirv_build_op_decorate1(builder, input_id, SpvDecorationComponent, component_idx);
 
-        spirv_compiler_emit_interpolation_decorations(compiler, input_id, signature_element->interpolation_mode);
+        spirv_compiler_emit_interpolation_decorations(compiler, component_type, input_id,
+                signature_element->interpolation_mode);
     }
 
     var_id = input_id;
@@ -4802,12 +4965,14 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
     assert(!builtin || !builtin->spirv_array_size || use_private_var || array_sizes[0] || array_sizes[1]);
     spirv_compiler_put_symbol(compiler, &reg_symbol);
 
-    spirv_compiler_emit_register_debug_name(builder, var_id, reg);
+    vkd3d_spirv_build_op_name(builder, var_id, reg_type == VKD3DSPR_PATCHCONST ? "vpc%u" : "v%u", element_idx);
 
     if (use_private_var)
     {
-        struct vkd3d_shader_register dst_reg = *reg;
-        dst_reg.data_type = VKD3D_DATA_FLOAT;
+        struct vkd3d_shader_register dst_reg;
+
+        vsir_register_init(&dst_reg, reg_type, VKD3D_DATA_FLOAT, 1);
+        dst_reg.idx[0].offset = element_idx;
 
         type_id = vkd3d_spirv_get_type_id(builder, component_type, input_component_count);
 
@@ -4824,9 +4989,9 @@ static uint32_t spirv_compiler_emit_input(struct spirv_compiler *compiler,
 
         val_id = spirv_compiler_emit_swizzle(compiler, val_id,
                 vkd3d_write_mask_from_component_count(input_component_count),
-                VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_SHADER_NO_SWIZZLE, dst->write_mask >> component_idx);
+                VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_SHADER_NO_SWIZZLE, signature_element->mask >> component_idx);
 
-        spirv_compiler_emit_store_reg(compiler, &dst_reg, dst->write_mask, val_id);
+        spirv_compiler_emit_store_reg(compiler, &dst_reg, signature_element->mask, val_id);
     }
 
     return input_id;
@@ -4896,7 +5061,7 @@ static void calculate_clip_or_cull_distance_mask(const struct signature_element
         return;
     }
 
-    write_mask = e->mask >> vkd3d_write_mask_get_component_idx(e->mask);
+    write_mask = e->mask >> vsir_write_mask_get_component_idx(e->mask);
     *mask |= (write_mask & VKD3DSP_WRITEMASK_ALL) << (VKD3D_VEC4_SIZE * e->semantic_index);
 }
 
@@ -4995,7 +5160,7 @@ static void spirv_compiler_emit_output_register(struct spirv_compiler *compiler,
             SpvStorageClassOutput, builtin->component_type, write_mask);
     reg_symbol.info.reg.is_aggregate = builtin->spirv_array_size;
     spirv_compiler_put_symbol(compiler, &reg_symbol);
-    spirv_compiler_emit_register_execution_mode(compiler, reg);
+    spirv_compiler_emit_register_execution_mode(compiler, reg->type);
     spirv_compiler_emit_register_debug_name(builder, output_id, reg);
 }
 
@@ -5024,46 +5189,44 @@ static uint32_t spirv_compiler_emit_shader_phase_builtin_variable(struct spirv_c
     return id;
 }
 
-static void spirv_compiler_emit_output(struct spirv_compiler *compiler, const struct vkd3d_shader_dst_param *dst)
+static void spirv_compiler_emit_output(struct spirv_compiler *compiler,
+        enum vkd3d_shader_register_type reg_type, unsigned int element_idx)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    const struct vkd3d_shader_register *reg = &dst->reg;
     unsigned int component_idx, output_component_count;
     const struct signature_element *signature_element;
     enum vkd3d_shader_component_type component_type;
     const struct shader_signature *shader_signature;
     const struct vkd3d_spirv_builtin *builtin;
     enum vkd3d_shader_sysval_semantic sysval;
-    unsigned int write_mask, reg_write_mask;
+    uint32_t write_mask, reg_write_mask;
     bool use_private_variable = false;
     struct vkd3d_symbol reg_symbol;
     SpvStorageClass storage_class;
     unsigned int array_sizes[2];
-    unsigned int element_idx;
     bool is_patch_constant;
     uint32_t id, var_id;
 
-    is_patch_constant = is_in_fork_or_join_phase(compiler);
+    is_patch_constant = (reg_type == VKD3DSPR_PATCHCONST);
 
     shader_signature = is_patch_constant ? &compiler->patch_constant_signature : &compiler->output_signature;
 
-    element_idx = reg->idx[reg->idx_count - 1].offset;
     signature_element = &shader_signature->elements[element_idx];
     sysval = signature_element->sysval_semantic;
     /* Don't use builtins for TCS -> TES varyings. See spirv_compiler_emit_input(). */
     if (compiler->shader_type == VKD3D_SHADER_TYPE_HULL && !is_patch_constant)
         sysval = VKD3D_SHADER_SV_NONE;
-    array_sizes[0] = (reg->type == VKD3DSPR_PATCHCONST ? 0 : compiler->output_control_point_count);
-    array_sizes[1] = signature_element->register_count;
-    if (array_sizes[1] == 1 && !vsir_sysval_semantic_is_tess_factor(signature_element->sysval_semantic))
-        array_sizes[1] = 0;
+    array_sizes[0] = signature_element->register_count;
+    array_sizes[1] = (reg_type == VKD3DSPR_PATCHCONST ? 0 : compiler->output_control_point_count);
+    if (array_sizes[0] == 1 && !vsir_sysval_semantic_is_tess_factor(signature_element->sysval_semantic))
+        array_sizes[0] = 0;
 
-    builtin = vkd3d_get_spirv_builtin(compiler, dst->reg.type, sysval);
+    builtin = vkd3d_get_spirv_builtin(compiler, reg_type, sysval);
 
     write_mask = signature_element->mask;
 
-    component_idx = vkd3d_write_mask_get_component_idx(write_mask);
-    output_component_count = vkd3d_write_mask_component_count(write_mask);
+    component_idx = vsir_write_mask_get_component_idx(write_mask);
+    output_component_count = vsir_write_mask_component_count(write_mask);
     if (builtin)
     {
         component_type = builtin->component_type;
@@ -5077,15 +5240,18 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler, const st
 
     storage_class = SpvStorageClassOutput;
 
-    if (get_shader_output_swizzle(compiler, signature_element->register_index) != VKD3D_SHADER_NO_SWIZZLE
-            || (compiler->output_info[element_idx].id && compiler->output_info[element_idx].array_element_mask)
-            || needs_private_io_variable(builtin))
+    if (needs_private_io_variable(builtin))
+        use_private_variable = true;
+
+    if (!is_patch_constant
+            && (get_shader_output_swizzle(compiler, signature_element->register_index) != VKD3D_SHADER_NO_SWIZZLE
+            || (compiler->output_info[element_idx].id && compiler->output_info[element_idx].array_element_mask)))
     {
         use_private_variable = true;
     }
 
     reg_write_mask = write_mask >> component_idx;
-    vkd3d_symbol_make_register(&reg_symbol, reg);
+    vkd3d_symbol_make_io(&reg_symbol, reg_type, element_idx);
 
     if (rb_get(&compiler->symbol_table, &reg_symbol))
     {
@@ -5094,7 +5260,7 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler, const st
         return;
     }
 
-    if (compiler->output_info[element_idx].id)
+    if (!is_patch_constant && compiler->output_info[element_idx].id)
     {
         id = compiler->output_info[element_idx].id;
     }
@@ -5105,7 +5271,7 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler, const st
         else
             id = spirv_compiler_emit_builtin_variable_v(compiler, builtin, storage_class, array_sizes, 2);
 
-        spirv_compiler_emit_register_execution_mode(compiler, &dst->reg);
+        spirv_compiler_emit_register_execution_mode(compiler, reg_type);
     }
     else if (signature_element->target_location == SIGNATURE_TARGET_LOCATION_UNUSED)
     {
@@ -5146,8 +5312,11 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler, const st
 
     spirv_compiler_decorate_xfb_output(compiler, id, output_component_count, signature_element);
 
-    compiler->output_info[element_idx].id = id;
-    compiler->output_info[element_idx].component_type = component_type;
+    if (!is_patch_constant)
+    {
+        compiler->output_info[element_idx].id = id;
+        compiler->output_info[element_idx].component_type = component_type;
+    }
 
     var_id = id;
     if (use_private_variable)
@@ -5165,8 +5334,7 @@ static void spirv_compiler_emit_output(struct spirv_compiler *compiler, const st
 
     spirv_compiler_put_symbol(compiler, &reg_symbol);
 
-    if (!is_patch_constant)
-        spirv_compiler_emit_register_debug_name(builder, var_id, reg);
+    vkd3d_spirv_build_op_name(builder, var_id, reg_type == VKD3DSPR_PATCHCONST ? "vpc%u" : "o%u", element_idx);
 
     if (use_private_variable)
     {
@@ -5198,9 +5366,9 @@ static uint32_t spirv_compiler_get_output_array_index(struct spirv_compiler *com
 static void spirv_compiler_emit_store_shader_output(struct spirv_compiler *compiler,
         const struct shader_signature *signature, const struct signature_element *output,
         const struct vkd3d_shader_output_info *output_info,
-        uint32_t output_index_id, uint32_t val_id, unsigned int write_mask)
+        uint32_t output_index_id, uint32_t val_id, uint32_t write_mask)
 {
-    unsigned int dst_write_mask, use_mask, uninit_mask, swizzle, mask;
+    uint32_t dst_write_mask, use_mask, uninit_mask, swizzle, mask;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t type_id, zero_id, ptr_type_id, chain_id, object_id;
     const struct signature_element *element;
@@ -5222,7 +5390,7 @@ static void spirv_compiler_emit_store_shader_output(struct spirv_compiler *compi
             use_mask |= element->used_mask;
         }
     }
-    index = vkd3d_write_mask_get_component_idx(output->mask);
+    index = vsir_write_mask_get_component_idx(output->mask);
     dst_write_mask >>= index;
     use_mask >>= index;
     write_mask &= dst_write_mask;
@@ -5246,7 +5414,7 @@ static void spirv_compiler_emit_store_shader_output(struct spirv_compiler *compi
                 output_info->component_type, VKD3D_VEC4_SIZE, 0);
         val_id = spirv_compiler_emit_vector_shuffle(compiler,
                 zero_id, val_id, swizzle, uninit_mask, output_info->component_type,
-                vkd3d_write_mask_component_count(write_mask));
+                vsir_write_mask_component_count(write_mask));
     }
     else
     {
@@ -5258,7 +5426,7 @@ static void spirv_compiler_emit_store_shader_output(struct spirv_compiler *compi
     if (output_index_id)
     {
         type_id = vkd3d_spirv_get_type_id(builder,
-                output_info->component_type, vkd3d_write_mask_component_count(dst_write_mask));
+                output_info->component_type, vsir_write_mask_component_count(dst_write_mask));
         ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassOutput, type_id);
         output_id = vkd3d_spirv_build_op_access_chain1(builder, ptr_type_id, output_id, output_index_id);
     }
@@ -5412,7 +5580,6 @@ static void spirv_compiler_emit_initial_declarations(struct spirv_compiler *comp
     if (compiler->shader_type != VKD3D_SHADER_TYPE_HULL)
     {
         vkd3d_spirv_builder_begin_main_function(builder);
-        compiler->main_block_open = true;
     }
 }
 
@@ -5440,10 +5607,34 @@ static void spirv_compiler_emit_dcl_global_flags(struct spirv_compiler *compiler
 
     if (flags & (VKD3DSGF_ENABLE_DOUBLE_PRECISION_FLOAT_OPS | VKD3DSGF_ENABLE_11_1_DOUBLE_EXTENSIONS))
     {
-        vkd3d_spirv_enable_capability(&compiler->spirv_builder, SpvCapabilityFloat64);
+        if (compiler->features & VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLOAT64)
+        {
+            vkd3d_spirv_enable_capability(&compiler->spirv_builder, SpvCapabilityFloat64);
+        }
+        else
+        {
+            WARN("Unsupported 64-bit float ops.\n");
+            spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_UNSUPPORTED_FEATURE,
+                    "The target environment does not support 64-bit floating point.");
+        }
         flags &= ~(VKD3DSGF_ENABLE_DOUBLE_PRECISION_FLOAT_OPS | VKD3DSGF_ENABLE_11_1_DOUBLE_EXTENSIONS);
     }
 
+    if (flags & VKD3DSGF_ENABLE_INT64)
+    {
+        if (compiler->features & VKD3D_SHADER_COMPILE_OPTION_FEATURE_INT64)
+        {
+            vkd3d_spirv_enable_capability(&compiler->spirv_builder, SpvCapabilityInt64);
+        }
+        else
+        {
+            WARN("Unsupported 64-bit integer ops.\n");
+            spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_UNSUPPORTED_FEATURE,
+                    "The target environment does not support 64-bit integers.");
+        }
+        flags &= ~VKD3DSGF_ENABLE_INT64;
+    }
+
     if (flags & ~(VKD3DSGF_REFACTORING_ALLOWED | VKD3DSGF_ENABLE_RAW_AND_STRUCTURED_BUFFERS))
         FIXME("Unhandled global flags %#"PRIx64".\n", (uint64_t)flags);
     else
@@ -5493,39 +5684,43 @@ static void spirv_compiler_emit_dcl_indexable_temp(struct spirv_compiler *compil
 {
     const struct vkd3d_shader_indexable_temp *temp = &instruction->declaration.indexable_temp;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    uint32_t id, type_id, length_id, ptr_type_id, init_id = 0;
+    enum vkd3d_shader_component_type component_type;
     struct vkd3d_shader_register reg;
     struct vkd3d_symbol reg_symbol;
+    SpvStorageClass storage_class;
     size_t function_location;
-    uint32_t id;
 
-    if (temp->component_count != 4)
-        FIXME("Unhandled component count %u.\n", temp->component_count);
+    /* Indexable temps may be used by more than one function in hull shaders, and
+     * declarations generally should not occur within VSIR code blocks unless function
+     * scope is specified, e.g. DXIL alloca. */
+    storage_class = temp->has_function_scope ? SpvStorageClassFunction : SpvStorageClassPrivate;
 
     vsir_register_init(&reg, VKD3DSPR_IDXTEMP, VKD3D_DATA_FLOAT, 1);
     reg.idx[0].offset = temp->register_idx;
 
     if (temp->alignment)
         WARN("Ignoring alignment %u.\n", temp->alignment);
-    if (temp->initialiser)
-    {
-        FIXME("Initialisers are not supported.\n");
-        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED,
-                "Initialisers for indexable temps are not supported.");
-    }
 
     function_location = spirv_compiler_get_current_function_location(compiler);
     vkd3d_spirv_begin_function_stream_insertion(builder, function_location);
 
-    id = spirv_compiler_emit_array_variable(compiler, &builder->function_stream,
-            SpvStorageClassFunction, VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_VEC4_SIZE, &temp->register_size, 1);
+    component_type = vkd3d_component_type_from_data_type(temp->data_type);
+    type_id = vkd3d_spirv_get_type_id(builder, component_type, temp->component_count);
+    length_id = spirv_compiler_get_constant_uint(compiler, temp->register_size);
+    type_id = vkd3d_spirv_get_op_type_array(builder, type_id, length_id);
+    ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, storage_class, type_id);
+    if (temp->initialiser)
+        init_id = spirv_compiler_emit_constant_array(compiler, temp->initialiser, NULL);
+    id = vkd3d_spirv_build_op_variable(builder, &builder->function_stream, ptr_type_id, storage_class, init_id);
 
     spirv_compiler_emit_register_debug_name(builder, id, &reg);
 
     vkd3d_spirv_end_function_stream_insertion(builder);
 
     vkd3d_symbol_make_register(&reg_symbol, &reg);
-    vkd3d_symbol_set_register_info(&reg_symbol, id,
-            SpvStorageClassFunction, VKD3D_SHADER_COMPONENT_FLOAT, VKD3DSP_WRITEMASK_ALL);
+    vkd3d_symbol_set_register_info(&reg_symbol, id, storage_class,
+            component_type, vkd3d_write_mask_from_component_count(temp->component_count));
     spirv_compiler_put_symbol(compiler, &reg_symbol);
 }
 
@@ -5743,34 +5938,24 @@ static void spirv_compiler_emit_dcl_immediate_constant_buffer(struct spirv_compi
         const struct vkd3d_shader_instruction *instruction)
 {
     const struct vkd3d_shader_immediate_constant_buffer *icb = instruction->declaration.icb;
-    uint32_t *elements, length_id, type_id, const_id, ptr_type_id, icb_id;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    uint32_t type_id, const_id, ptr_type_id, icb_id;
     struct vkd3d_shader_register reg;
     struct vkd3d_symbol reg_symbol;
-    unsigned int i;
-
-    assert(icb->data_type == VKD3D_DATA_FLOAT);
-    assert(icb->component_count == VKD3D_VEC4_SIZE);
 
-    if (!(elements = vkd3d_calloc(icb->element_count, sizeof(*elements))))
-        return;
-    for (i = 0; i < icb->element_count; ++i)
-        elements[i] = spirv_compiler_get_constant(compiler,
-                VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_VEC4_SIZE, &icb->data[4 * i]);
-    type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, VKD3D_VEC4_SIZE);
-    length_id = spirv_compiler_get_constant_uint(compiler, icb->element_count);
-    type_id = vkd3d_spirv_get_op_type_array(builder, type_id, length_id);
-    const_id = vkd3d_spirv_build_op_constant_composite(builder, type_id, elements, icb->element_count);
+    const_id = spirv_compiler_emit_constant_array(compiler, icb, &type_id);
     ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassPrivate, type_id);
     icb_id = vkd3d_spirv_build_op_variable(builder, &builder->global_stream,
             ptr_type_id, SpvStorageClassPrivate, const_id);
     vkd3d_spirv_build_op_name(builder, icb_id, "icb");
-    vkd3d_free(elements);
 
-    vsir_register_init(&reg, VKD3DSPR_IMMCONSTBUFFER, VKD3D_DATA_FLOAT, 0);
+    /* Set an index count of 2 so vkd3d_symbol_make_register() uses idx[0] as a buffer id. */
+    vsir_register_init(&reg, VKD3DSPR_IMMCONSTBUFFER, VKD3D_DATA_FLOAT, 2);
+    reg.idx[0].offset = icb->register_idx;
     vkd3d_symbol_make_register(&reg_symbol, &reg);
     vkd3d_symbol_set_register_info(&reg_symbol, icb_id, SpvStorageClassPrivate,
-            VKD3D_SHADER_COMPONENT_FLOAT, VKD3DSP_WRITEMASK_ALL);
+                vkd3d_component_type_from_data_type(icb->data_type),
+                vkd3d_write_mask_from_component_count(icb->component_count));
     spirv_compiler_put_symbol(compiler, &reg_symbol);
 }
 
@@ -6052,6 +6237,9 @@ static void spirv_compiler_emit_resource_declaration(struct spirv_compiler *comp
         if (!(d->flags & VKD3D_SHADER_DESCRIPTOR_INFO_FLAG_UAV_READ))
             vkd3d_spirv_build_op_decorate(builder, var_id, SpvDecorationNonReadable, NULL, 0);
 
+        if (d->uav_flags & VKD3DSUF_GLOBALLY_COHERENT)
+            vkd3d_spirv_build_op_decorate(builder, var_id, SpvDecorationCoherent, NULL, 0);
+
         if (d->flags & VKD3D_SHADER_DESCRIPTOR_INFO_FLAG_UAV_COUNTER)
         {
             assert(structure_stride); /* counters are valid only for structured buffers */
@@ -6147,37 +6335,22 @@ static void spirv_compiler_emit_dcl_input(struct spirv_compiler *compiler,
 {
     const struct vkd3d_shader_dst_param *dst = &instruction->declaration.dst;
 
-    /* OUTPOINTID is handled in spirv_compiler_emit_hull_shader_builtins(). */
-    if (dst->reg.type == VKD3DSPR_INPUT || dst->reg.type == VKD3DSPR_PATCHCONST)
-        spirv_compiler_emit_input(compiler, dst);
-    else if (dst->reg.type != VKD3DSPR_OUTPOINTID)
+    /* INPUT and PATCHCONST are handled in spirv_compiler_emit_io_declarations().
+     * OUTPOINTID is handled in spirv_compiler_emit_hull_shader_builtins(). */
+    if (dst->reg.type != VKD3DSPR_INPUT && dst->reg.type != VKD3DSPR_PATCHCONST
+            && dst->reg.type != VKD3DSPR_OUTPOINTID)
         spirv_compiler_emit_input_register(compiler, dst);
 }
 
-static void spirv_compiler_emit_dcl_input_sysval(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
-{
-    spirv_compiler_emit_input(compiler, &instruction->declaration.register_semantic.reg);
-}
-
 static void spirv_compiler_emit_dcl_output(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
     const struct vkd3d_shader_dst_param *dst = &instruction->declaration.dst;
 
-    if (dst->reg.type == VKD3DSPR_OUTPUT
-            || (is_in_fork_or_join_phase(compiler) && dst->reg.type == VKD3DSPR_PATCHCONST))
-        spirv_compiler_emit_output(compiler, dst);
-    else
+    if (dst->reg.type != VKD3DSPR_OUTPUT && dst->reg.type != VKD3DSPR_PATCHCONST)
         spirv_compiler_emit_output_register(compiler, dst);
 }
 
-static void spirv_compiler_emit_dcl_output_siv(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
-{
-    spirv_compiler_emit_output(compiler, &instruction->declaration.register_semantic.reg);
-}
-
 static void spirv_compiler_emit_dcl_stream(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
@@ -6256,7 +6429,7 @@ static void spirv_compiler_emit_dcl_output_topology(struct spirv_compiler *compi
     {
         case VKD3D_PT_POINTLIST:
             mode = SpvExecutionModeOutputPoints;
-            spirv_compiler_emit_point_size(compiler);
+            compiler->emit_point_size = true;
             break;
         case VKD3D_PT_LINESTRIP:
             mode = SpvExecutionModeOutputLineStrip;
@@ -6377,7 +6550,6 @@ static void spirv_compiler_emit_default_control_point_phase(struct spirv_compile
 
 static void spirv_compiler_leave_shader_phase(struct spirv_compiler *compiler)
 {
-    const struct shader_signature *signature = &compiler->output_signature;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
 
     if (is_in_control_point_phase(compiler) && compiler->emit_default_control_point_phase)
@@ -6395,7 +6567,6 @@ static void spirv_compiler_leave_shader_phase(struct spirv_compiler *compiler)
 
         /* Fork and join phases share output registers (patch constants).
          * Control point phase has separate output registers. */
-        memset(compiler->output_info, 0, signature->element_count * sizeof(*compiler->output_info));
         memset(compiler->private_output_variable, 0, sizeof(compiler->private_output_variable));
         memset(compiler->private_output_variable_write_mask, 0, sizeof(compiler->private_output_variable_write_mask));
     }
@@ -6420,35 +6591,59 @@ static void spirv_compiler_enter_shader_phase(struct spirv_compiler *compiler,
     vkd3d_spirv_build_op_function(builder, void_id, function_id,
             SpvFunctionControlMaskNone, function_type_id);
 
-    vkd3d_spirv_build_op_label(builder, vkd3d_spirv_alloc_id(builder));
-
     compiler->phase = instruction->handler_idx;
     spirv_compiler_emit_shader_phase_name(compiler, function_id, NULL);
 
     phase = (instruction->handler_idx == VKD3DSIH_HS_CONTROL_POINT_PHASE)
         ? &compiler->control_point_phase : &compiler->patch_constant_phase;
     phase->function_id = function_id;
-    phase->function_location = vkd3d_spirv_stream_current_location(&builder->function_stream);
+    /* The insertion location must be set after the label is emitted. */
+    phase->function_location = 0;
 
     if (instruction->handler_idx == VKD3DSIH_HS_CONTROL_POINT_PHASE)
         compiler->emit_default_control_point_phase = instruction->flags;
 }
 
+static void spirv_compiler_initialise_block(struct spirv_compiler *compiler)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+
+    /* Insertion locations must point immediately after the function's initial label. */
+    if (compiler->shader_type == VKD3D_SHADER_TYPE_HULL)
+    {
+        struct vkd3d_shader_phase *phase = (compiler->phase == VKD3DSIH_HS_CONTROL_POINT_PHASE)
+            ? &compiler->control_point_phase : &compiler->patch_constant_phase;
+        if (!phase->function_location)
+            phase->function_location = vkd3d_spirv_stream_current_location(&builder->function_stream);
+    }
+    else if (!builder->main_function_location)
+    {
+        builder->main_function_location = vkd3d_spirv_stream_current_location(&builder->function_stream);
+    }
+
+    /* I/O declarations can result in emission of fixups, which must occur after the initial label. */
+    if (!compiler->prolog_emitted)
+    {
+        spirv_compiler_emit_main_prolog(compiler);
+        spirv_compiler_emit_io_declarations(compiler);
+        compiler->prolog_emitted = true;
+    }
+}
+
 static void spirv_compiler_emit_default_control_point_phase(struct spirv_compiler *compiler)
 {
     const struct shader_signature *output_signature = &compiler->output_signature;
     const struct shader_signature *input_signature = &compiler->input_signature;
+    uint32_t type_id, output_ptr_type_id, input_id, dst_id, invocation_id;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     enum vkd3d_shader_component_type component_type;
     struct vkd3d_shader_src_param invocation;
     struct vkd3d_shader_register input_reg;
-    uint32_t type_id, output_ptr_type_id;
-    uint32_t input_id, output_id, dst_id;
     unsigned int component_count;
-    unsigned int array_sizes[2];
-    uint32_t invocation_id;
     unsigned int i;
 
+    vkd3d_spirv_build_op_label(builder, vkd3d_spirv_alloc_id(builder));
+    spirv_compiler_initialise_block(compiler);
     invocation_id = spirv_compiler_emit_load_invocation_id(compiler);
 
     memset(&invocation, 0, sizeof(invocation));
@@ -6466,6 +6661,8 @@ static void spirv_compiler_emit_default_control_point_phase(struct spirv_compile
     {
         const struct signature_element *output = &output_signature->elements[i];
         const struct signature_element *input = &input_signature->elements[i];
+        struct vkd3d_shader_register_info output_reg_info;
+        struct vkd3d_shader_register output_reg;
 
         assert(input->mask == output->mask);
         assert(input->component_type == output->component_type);
@@ -6473,22 +6670,16 @@ static void spirv_compiler_emit_default_control_point_phase(struct spirv_compile
         input_reg.idx[1].offset = i;
         input_id = spirv_compiler_get_register_id(compiler, &input_reg);
 
+        vsir_register_init(&output_reg, VKD3DSPR_OUTPUT, VKD3D_DATA_FLOAT, 1);
+        output_reg.idx[0].offset = i;
+        spirv_compiler_get_register_info(compiler, &output_reg, &output_reg_info);
+
         component_type = output->component_type;
-        component_count = vkd3d_write_mask_component_count(output->mask);
+        component_count = vsir_write_mask_component_count(output->mask);
         type_id = vkd3d_spirv_get_type_id(builder, component_type, component_count);
-        if ((array_sizes[0] = (input->register_count > 1) ? input->register_count : 0))
-            type_id = vkd3d_spirv_get_op_type_array(builder, type_id, spirv_compiler_get_constant_uint(compiler,
-                    array_sizes[0]));
-
-        array_sizes[1] = compiler->output_control_point_count;
-        output_id = spirv_compiler_emit_array_variable(compiler, &builder->global_stream, SpvStorageClassOutput,
-                component_type, component_count, array_sizes, 2);
-        vkd3d_spirv_add_iface_variable(builder, output_id);
-        vkd3d_spirv_build_op_decorate1(builder, output_id, SpvDecorationLocation, output->register_index);
-        vkd3d_spirv_build_op_name(builder, output_id, "vocp%u", output->register_index);
-
         output_ptr_type_id = vkd3d_spirv_get_op_type_pointer(builder, SpvStorageClassOutput, type_id);
-        dst_id = vkd3d_spirv_build_op_access_chain1(builder, output_ptr_type_id, output_id, invocation_id);
+
+        dst_id = vkd3d_spirv_build_op_access_chain1(builder, output_ptr_type_id, output_reg_info.id, invocation_id);
 
         vkd3d_spirv_build_op_copy_memory(builder, dst_id, input_id, SpvMemoryAccessMaskNone);
     }
@@ -6547,7 +6738,11 @@ static void spirv_compiler_emit_hull_shader_main(struct spirv_compiler *compiler
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     uint32_t void_id;
 
+    /* If a patch constant function used descriptor indexing the offsets must be reloaded. */
+    memset(compiler->descriptor_offset_ids, 0, compiler->offset_info.descriptor_table_count
+            * sizeof(*compiler->descriptor_offset_ids));
     vkd3d_spirv_builder_begin_main_function(builder);
+    vkd3d_spirv_build_op_label(builder, vkd3d_spirv_alloc_id(builder));
 
     void_id = vkd3d_spirv_get_op_type_void(builder);
 
@@ -6591,14 +6786,18 @@ static SpvOp spirv_compiler_map_alu_instruction(const struct vkd3d_shader_instru
         {VKD3DSIH_INEG,       SpvOpSNegate},
         {VKD3DSIH_ISHL,       SpvOpShiftLeftLogical},
         {VKD3DSIH_ISHR,       SpvOpShiftRightArithmetic},
+        {VKD3DSIH_ISINF,      SpvOpIsInf},
+        {VKD3DSIH_ISNAN,      SpvOpIsNan},
         {VKD3DSIH_ITOD,       SpvOpConvertSToF},
         {VKD3DSIH_ITOF,       SpvOpConvertSToF},
+        {VKD3DSIH_ITOI,       SpvOpSConvert},
         {VKD3DSIH_MUL,        SpvOpFMul},
         {VKD3DSIH_NOT,        SpvOpNot},
         {VKD3DSIH_OR,         SpvOpBitwiseOr},
         {VKD3DSIH_USHR,       SpvOpShiftRightLogical},
         {VKD3DSIH_UTOD,       SpvOpConvertUToF},
         {VKD3DSIH_UTOF,       SpvOpConvertUToF},
+        {VKD3DSIH_UTOU,       SpvOpUConvert},
         {VKD3DSIH_XOR,        SpvOpBitwiseXor},
     };
     unsigned int i;
@@ -6650,6 +6849,10 @@ static void spirv_compiler_emit_bool_cast(struct spirv_compiler *compiler,
     {
         val_id = spirv_compiler_emit_bool_to_int(compiler, 1, val_id, instruction->handler_idx == VKD3DSIH_ITOI);
     }
+    else if (dst->reg.data_type == VKD3D_DATA_UINT64)
+    {
+        val_id = spirv_compiler_emit_bool_to_int64(compiler, 1, val_id, instruction->handler_idx == VKD3DSIH_ITOI);
+    }
     else
     {
         WARN("Unhandled data type %u.\n", dst->reg.data_type);
@@ -6715,11 +6918,11 @@ static enum vkd3d_result spirv_compiler_emit_alu_instruction(struct spirv_compil
      * Microsoft fxc will compile immediate constants larger than 5 bits.
      * Fixing up the constants would be more elegant, but the simplest way is
      * to let this handle constants too. */
-    if (instruction->handler_idx == VKD3DSIH_ISHL || instruction->handler_idx == VKD3DSIH_ISHR
-            || instruction->handler_idx == VKD3DSIH_USHR)
+    if (!(instruction->flags & VKD3DSI_SHIFT_UNMASKED) && (instruction->handler_idx == VKD3DSIH_ISHL
+            || instruction->handler_idx == VKD3DSIH_ISHR || instruction->handler_idx == VKD3DSIH_USHR))
     {
         uint32_t mask_id = spirv_compiler_get_constant_vector(compiler,
-                VKD3D_SHADER_COMPONENT_UINT, vkd3d_write_mask_component_count(dst->write_mask), 0x1f);
+                VKD3D_SHADER_COMPONENT_UINT, vsir_write_mask_component_count(dst->write_mask), 0x1f);
         src_ids[1] = vkd3d_spirv_build_op_and(builder, type_id, src_ids[1], mask_id);
     }
 
@@ -6732,6 +6935,23 @@ static enum vkd3d_result spirv_compiler_emit_alu_instruction(struct spirv_compil
     return VKD3D_OK;
 }
 
+static void spirv_compiler_emit_isfinite(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    const struct vkd3d_shader_dst_param *dst = instruction->dst;
+    const struct vkd3d_shader_src_param *src = instruction->src;
+    uint32_t type_id, src_id, isinf_id, isnan_id, val_id;
+
+    type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
+    src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
+    /* OpIsFinite is only available in Kernel mode. */
+    isinf_id = vkd3d_spirv_build_op_is_inf(builder, type_id, src_id);
+    isnan_id = vkd3d_spirv_build_op_is_nan(builder, type_id, src_id);
+    val_id = vkd3d_spirv_build_op_logical_equal(builder, type_id, isinf_id, isnan_id);
+    spirv_compiler_emit_store_dst(compiler, dst, val_id);
+}
+
 static enum GLSLstd450 spirv_compiler_map_ext_glsl_instruction(
         const struct vkd3d_shader_instruction *instruction)
 {
@@ -6762,6 +6982,7 @@ static enum GLSLstd450 spirv_compiler_map_ext_glsl_instruction(
         {VKD3DSIH_ROUND_Z,         GLSLstd450Trunc},
         {VKD3DSIH_RSQ,             GLSLstd450InverseSqrt},
         {VKD3DSIH_SQRT,            GLSLstd450Sqrt},
+        {VKD3DSIH_TAN,             GLSLstd450Tan},
         {VKD3DSIH_UMAX,            GLSLstd450UMax},
         {VKD3DSIH_UMIN,            GLSLstd450UMin},
     };
@@ -6779,13 +7000,13 @@ static enum GLSLstd450 spirv_compiler_map_ext_glsl_instruction(
 static void spirv_compiler_emit_ext_glsl_instruction(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
+    uint32_t instr_set_id, type_id, val_id, rev_val_id, uint_max_id, condition_id;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     const struct vkd3d_shader_dst_param *dst = instruction->dst;
     const struct vkd3d_shader_src_param *src = instruction->src;
     uint32_t src_id[SPIRV_MAX_SRC_COUNT];
-    uint32_t instr_set_id, type_id, val_id;
+    unsigned int i, component_count;
     enum GLSLstd450 glsl_inst;
-    unsigned int i;
 
     glsl_inst = spirv_compiler_map_ext_glsl_instruction(instruction);
     if (glsl_inst == GLSLstd450Bad)
@@ -6811,8 +7032,13 @@ static void spirv_compiler_emit_ext_glsl_instruction(struct spirv_compiler *comp
             || instruction->handler_idx == VKD3DSIH_FIRSTBIT_SHI)
     {
         /* In D3D bits are numbered from the most significant bit. */
-        val_id = vkd3d_spirv_build_op_isub(builder, type_id,
-                spirv_compiler_get_constant_uint(compiler, 31), val_id);
+        component_count = vsir_write_mask_component_count(dst->write_mask);
+        uint_max_id = spirv_compiler_get_constant_uint_vector(compiler, UINT32_MAX, component_count);
+        condition_id = vkd3d_spirv_build_op_tr2(builder, &builder->function_stream, SpvOpIEqual,
+                vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_BOOL, component_count), val_id, uint_max_id);
+        rev_val_id = vkd3d_spirv_build_op_isub(builder, type_id,
+                spirv_compiler_get_constant_uint_vector(compiler, 31, component_count), val_id);
+        val_id = vkd3d_spirv_build_op_select(builder, type_id, condition_id, val_id, rev_val_id);
     }
 
     spirv_compiler_emit_store_dst(compiler, dst, val_id);
@@ -6849,7 +7075,7 @@ static void spirv_compiler_emit_mov(struct spirv_compiler *compiler,
         return;
     }
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     if (component_count != 1 && component_count != VKD3D_VEC4_SIZE
             && dst_reg_info.write_mask == VKD3DSP_WRITEMASK_ALL)
     {
@@ -6863,7 +7089,7 @@ static void spirv_compiler_emit_mov(struct spirv_compiler *compiler,
         for (i = 0; i < ARRAY_SIZE(components); ++i)
         {
             if (dst->write_mask & (VKD3DSP_WRITEMASK_0 << i))
-                components[i] = VKD3D_VEC4_SIZE + vkd3d_swizzle_get_component(src->swizzle, i);
+                components[i] = VKD3D_VEC4_SIZE + vsir_swizzle_get_component(src->swizzle, i);
             else
                 components[i] = i;
         }
@@ -6877,6 +7103,11 @@ static void spirv_compiler_emit_mov(struct spirv_compiler *compiler,
 
 general_implementation:
     val_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
+    if (dst->reg.data_type != src->reg.data_type)
+    {
+        val_id = vkd3d_spirv_build_op_bitcast(builder, vkd3d_spirv_get_type_id_for_data_type(builder,
+                dst->reg.data_type, vsir_write_mask_component_count(dst->write_mask)), val_id);
+    }
     spirv_compiler_emit_store_dst(compiler, dst, val_id);
 }
 
@@ -6893,12 +7124,12 @@ static void spirv_compiler_emit_movc(struct spirv_compiler *compiler,
     src1_id = spirv_compiler_emit_load_src(compiler, &src[1], dst->write_mask);
     src2_id = spirv_compiler_emit_load_src(compiler, &src[2], dst->write_mask);
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
 
     if (src[0].reg.data_type != VKD3D_DATA_BOOL)
         condition_id = spirv_compiler_emit_int_to_bool(compiler,
-                VKD3D_SHADER_CONDITIONAL_OP_NZ, component_count, condition_id);
+                VKD3D_SHADER_CONDITIONAL_OP_NZ, src[0].reg.data_type, component_count, condition_id);
     val_id = vkd3d_spirv_build_op_select(builder, type_id, condition_id, src1_id, src2_id);
 
     spirv_compiler_emit_store_dst(compiler, dst, val_id);
@@ -6919,11 +7150,11 @@ static void spirv_compiler_emit_swapc(struct spirv_compiler *compiler,
     src1_id = spirv_compiler_emit_load_src(compiler, &src[1], dst->write_mask);
     src2_id = spirv_compiler_emit_load_src(compiler, &src[2], dst->write_mask);
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, component_count);
 
     condition_id = spirv_compiler_emit_int_to_bool(compiler,
-            VKD3D_SHADER_CONDITIONAL_OP_NZ, component_count, condition_id);
+            VKD3D_SHADER_CONDITIONAL_OP_NZ, src[0].reg.data_type, component_count, condition_id);
 
     val_id = vkd3d_spirv_build_op_select(builder, type_id, condition_id, src2_id, src1_id);
     spirv_compiler_emit_store_dst(compiler, &dst[0], val_id);
@@ -6940,9 +7171,9 @@ static void spirv_compiler_emit_dot(struct spirv_compiler *compiler,
     enum vkd3d_shader_component_type component_type;
     uint32_t type_id, val_id, src_ids[2];
     unsigned int component_count, i;
-    DWORD write_mask;
+    uint32_t write_mask;
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     component_type = vkd3d_component_type_from_data_type(dst->reg.data_type);
 
     if (instruction->handler_idx == VKD3DSIH_DP4)
@@ -6980,7 +7211,7 @@ static void spirv_compiler_emit_rcp(struct spirv_compiler *compiler,
     uint32_t type_id, src_id, val_id, div_id;
     unsigned int component_count;
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
 
     src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
@@ -7060,7 +7291,7 @@ static void spirv_compiler_emit_imad(struct spirv_compiler *compiler,
     uint32_t type_id, val_id, src_ids[3];
     unsigned int i, component_count;
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_INT, component_count);
 
     for (i = 0; i < ARRAY_SIZE(src_ids); ++i)
@@ -7087,16 +7318,18 @@ static void spirv_compiler_emit_int_div(struct spirv_compiler *compiler,
 
     if (dst[0].reg.type != VKD3DSPR_NULL)
     {
-        component_count = vkd3d_write_mask_component_count(dst[0].write_mask);
+        component_count = vsir_write_mask_component_count(dst[0].write_mask);
         type_id = spirv_compiler_get_type_id_for_dst(compiler, &dst[0]);
 
         src0_id = spirv_compiler_emit_load_src(compiler, &src[0], dst[0].write_mask);
         src1_id = spirv_compiler_emit_load_src(compiler, &src[1], dst[0].write_mask);
 
         condition_id = spirv_compiler_emit_int_to_bool(compiler,
-                VKD3D_SHADER_CONDITIONAL_OP_NZ, component_count, src1_id);
-        uint_max_id = spirv_compiler_get_constant_uint_vector(compiler,
-                0xffffffff, component_count);
+                VKD3D_SHADER_CONDITIONAL_OP_NZ, src[1].reg.data_type, component_count, src1_id);
+        if (dst[0].reg.data_type == VKD3D_DATA_UINT64)
+            uint_max_id = spirv_compiler_get_constant_uint64_vector(compiler, UINT64_MAX, component_count);
+        else
+            uint_max_id = spirv_compiler_get_constant_uint_vector(compiler, 0xffffffff, component_count);
 
         val_id = vkd3d_spirv_build_op_tr2(builder, &builder->function_stream, div_op, type_id, src0_id, src1_id);
         /* The SPIR-V spec says: "The resulting value is undefined if Operand 2 is 0." */
@@ -7109,16 +7342,18 @@ static void spirv_compiler_emit_int_div(struct spirv_compiler *compiler,
     {
         if (!component_count || dst[0].write_mask != dst[1].write_mask)
         {
-            component_count = vkd3d_write_mask_component_count(dst[1].write_mask);
+            component_count = vsir_write_mask_component_count(dst[1].write_mask);
             type_id = spirv_compiler_get_type_id_for_dst(compiler, &dst[1]);
 
             src0_id = spirv_compiler_emit_load_src(compiler, &src[0], dst[1].write_mask);
             src1_id = spirv_compiler_emit_load_src(compiler, &src[1], dst[1].write_mask);
 
             condition_id = spirv_compiler_emit_int_to_bool(compiler,
-                    VKD3D_SHADER_CONDITIONAL_OP_NZ, component_count, src1_id);
-            uint_max_id = spirv_compiler_get_constant_uint_vector(compiler,
-                    0xffffffff, component_count);
+                    VKD3D_SHADER_CONDITIONAL_OP_NZ, src[1].reg.data_type, component_count, src1_id);
+            if (dst[1].reg.data_type == VKD3D_DATA_UINT64)
+                uint_max_id = spirv_compiler_get_constant_uint64_vector(compiler, UINT64_MAX, component_count);
+            else
+                uint_max_id = spirv_compiler_get_constant_uint_vector(compiler, 0xffffffff, component_count);
         }
 
         val_id = vkd3d_spirv_build_op_tr2(builder, &builder->function_stream, mod_op, type_id, src0_id, src1_id);
@@ -7147,7 +7382,7 @@ static void spirv_compiler_emit_ftoi(struct spirv_compiler *compiler,
      * as a signed integer, but Direct3D expects the result to saturate,
      * and for NaN to yield zero. */
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     src_type_id = spirv_compiler_get_type_id_for_reg(compiler, &src->reg, dst->write_mask);
     dst_type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
     src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
@@ -7200,7 +7435,7 @@ static void spirv_compiler_emit_ftou(struct spirv_compiler *compiler,
      * as an unsigned integer, but Direct3D expects the result to saturate,
      * and for NaN to yield zero. */
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     src_type_id = spirv_compiler_get_type_id_for_reg(compiler, &src->reg, dst->write_mask);
     dst_type_id = spirv_compiler_get_type_id_for_dst(compiler, dst);
     src_id = spirv_compiler_emit_load_src(compiler, src, dst->write_mask);
@@ -7232,13 +7467,13 @@ static void spirv_compiler_emit_ftou(struct spirv_compiler *compiler,
 static void spirv_compiler_emit_bitfield_instruction(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
-    uint32_t src_ids[4], constituents[VKD3D_VEC4_SIZE], type_id, mask_id;
+    uint32_t src_ids[4], constituents[VKD3D_VEC4_SIZE], type_id, mask_id, size_id, max_count_id;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     const struct vkd3d_shader_dst_param *dst = instruction->dst;
     const struct vkd3d_shader_src_param *src = instruction->src;
     enum vkd3d_shader_component_type component_type;
     unsigned int i, j, k, src_count;
-    DWORD write_mask;
+    uint32_t write_mask;
     SpvOp op;
 
     src_count = instruction->src_count;
@@ -7247,6 +7482,7 @@ static void spirv_compiler_emit_bitfield_instruction(struct spirv_compiler *comp
     component_type = vkd3d_component_type_from_data_type(dst->reg.data_type);
     type_id = vkd3d_spirv_get_type_id(builder, component_type, 1);
     mask_id = spirv_compiler_get_constant_uint(compiler, 0x1f);
+    size_id = spirv_compiler_get_constant_uint(compiler, 0x20);
 
     switch (instruction->handler_idx)
     {
@@ -7275,6 +7511,9 @@ static void spirv_compiler_emit_bitfield_instruction(struct spirv_compiler *comp
         {
             src_ids[j] = vkd3d_spirv_build_op_and(builder, type_id, src_ids[j], mask_id);
         }
+        max_count_id = vkd3d_spirv_build_op_isub(builder, type_id, size_id, src_ids[src_count - 2]);
+        src_ids[src_count - 1] = vkd3d_spirv_build_op_glsl_std450_umin(builder, type_id,
+                src_ids[src_count - 1], max_count_id);
 
         constituents[k++] = vkd3d_spirv_build_op_trv(builder, &builder->function_stream,
                 op, type_id, src_ids, src_count);
@@ -7291,8 +7530,8 @@ static void spirv_compiler_emit_f16tof32(struct spirv_compiler *compiler,
     const struct vkd3d_shader_dst_param *dst = instruction->dst;
     const struct vkd3d_shader_src_param *src = instruction->src;
     uint32_t components[VKD3D_VEC4_SIZE];
+    uint32_t write_mask;
     unsigned int i, j;
-    DWORD write_mask;
 
     instr_set_id = vkd3d_spirv_get_glsl_std450_instr_set(builder);
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, 2);
@@ -7324,8 +7563,8 @@ static void spirv_compiler_emit_f32tof16(struct spirv_compiler *compiler,
     const struct vkd3d_shader_dst_param *dst = instruction->dst;
     const struct vkd3d_shader_src_param *src = instruction->src;
     uint32_t components[VKD3D_VEC4_SIZE];
+    uint32_t write_mask;
     unsigned int i, j;
-    DWORD write_mask;
 
     instr_set_id = vkd3d_spirv_get_glsl_std450_instr_set(builder);
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT, 2);
@@ -7387,7 +7626,7 @@ static void spirv_compiler_emit_comparison_instruction(struct spirv_compiler *co
             return;
     }
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
 
     src0_id = spirv_compiler_emit_load_src(compiler, &src[0], dst->write_mask);
     src1_id = spirv_compiler_emit_load_src(compiler, &src[1], dst->write_mask);
@@ -7409,7 +7648,7 @@ static uint32_t spirv_compiler_emit_conditional_branch(struct spirv_compiler *co
     uint32_t condition_id, merge_block_id;
 
     condition_id = spirv_compiler_emit_load_src(compiler, src, VKD3DSP_WRITEMASK_0);
-    condition_id = spirv_compiler_emit_int_to_bool(compiler, instruction->flags, 1, condition_id);
+    condition_id = spirv_compiler_emit_int_to_bool(compiler, instruction->flags, src->reg.data_type, 1, condition_id);
 
     merge_block_id = vkd3d_spirv_alloc_id(builder);
 
@@ -7445,16 +7684,39 @@ static void spirv_compiler_emit_retc(struct spirv_compiler *compiler,
     vkd3d_spirv_build_op_label(builder, merge_block_id);
 }
 
-static void spirv_compiler_emit_kill(struct spirv_compiler *compiler,
-        const struct vkd3d_shader_instruction *instruction)
+static uint32_t spirv_compiler_get_discard_function_id(struct spirv_compiler *compiler)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
-    uint32_t target_id, merge_block_id;
 
-    target_id = vkd3d_spirv_alloc_id(builder);
-    merge_block_id = spirv_compiler_emit_conditional_branch(compiler, instruction, target_id);
+    if (!compiler->discard_function_id)
+        compiler->discard_function_id = vkd3d_spirv_alloc_id(builder);
 
-    vkd3d_spirv_build_op_label(builder, target_id);
+    return compiler->discard_function_id;
+}
+
+static void spirv_compiler_emit_discard_function(struct spirv_compiler *compiler)
+{
+    uint32_t void_id, bool_id, function_type_id, condition_id, target_block_id, merge_block_id;
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+
+    vkd3d_spirv_build_op_name(builder, compiler->discard_function_id, "discard");
+
+    void_id = vkd3d_spirv_get_op_type_void(builder);
+    bool_id = vkd3d_spirv_get_op_type_bool(builder);
+    function_type_id = vkd3d_spirv_get_op_type_function(builder, void_id, &bool_id, 1);
+
+    vkd3d_spirv_build_op_function(builder, void_id, compiler->discard_function_id,
+            SpvFunctionControlMaskNone, function_type_id);
+    condition_id = vkd3d_spirv_build_op_function_parameter(builder, bool_id);
+
+    vkd3d_spirv_build_op_label(builder, vkd3d_spirv_alloc_id(builder));
+
+    target_block_id = vkd3d_spirv_alloc_id(builder);
+    merge_block_id = vkd3d_spirv_alloc_id(builder);
+    vkd3d_spirv_build_op_selection_merge(builder, merge_block_id, SpvSelectionControlMaskNone);
+    vkd3d_spirv_build_op_branch_conditional(builder, condition_id, target_block_id, merge_block_id);
+
+    vkd3d_spirv_build_op_label(builder, target_block_id);
 
     if (spirv_compiler_is_target_extension_supported(compiler,
             VKD3D_SHADER_SPIRV_EXTENSION_EXT_DEMOTE_TO_HELPER_INVOCATION))
@@ -7469,381 +7731,151 @@ static void spirv_compiler_emit_kill(struct spirv_compiler *compiler,
     }
 
     vkd3d_spirv_build_op_label(builder, merge_block_id);
+    vkd3d_spirv_build_op_return(builder);
+    vkd3d_spirv_build_op_function_end(builder);
 }
 
-static struct vkd3d_control_flow_info *spirv_compiler_push_control_flow_level(
-        struct spirv_compiler *compiler)
+static void spirv_compiler_emit_discard(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_instruction *instruction)
 {
-    if (!vkd3d_array_reserve((void **)&compiler->control_flow_info, &compiler->control_flow_info_size,
-            compiler->control_flow_depth + 1, sizeof(*compiler->control_flow_info)))
-    {
-        ERR("Failed to allocate control flow info structure.\n");
-        return NULL;
-    }
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    const struct vkd3d_shader_src_param *src = instruction->src;
+    uint32_t condition_id, void_id;
 
-    return &compiler->control_flow_info[compiler->control_flow_depth++];
+    /* discard is not a block terminator in VSIR, and emitting it as such in SPIR-V would cause
+     * a mismatch between the VSIR structure and the SPIR-V one, which would cause problems if
+     * structurisation is necessary. Therefore we emit it as a function call. */
+    condition_id = spirv_compiler_emit_load_src(compiler, src, VKD3DSP_WRITEMASK_0);
+    condition_id = spirv_compiler_emit_int_to_bool(compiler,
+            instruction->flags, src->reg.data_type, 1, condition_id);
+    void_id = vkd3d_spirv_get_op_type_void(builder);
+    vkd3d_spirv_build_op_function_call(builder, void_id, spirv_compiler_get_discard_function_id(compiler),
+            &condition_id, 1);
 }
 
-static void spirv_compiler_pop_control_flow_level(struct spirv_compiler *compiler)
+static bool spirv_compiler_init_blocks(struct spirv_compiler *compiler, unsigned int block_count)
 {
-    struct vkd3d_control_flow_info *cf_info;
+    compiler->block_count = block_count;
 
-    assert(compiler->control_flow_depth);
+    if (!(compiler->block_label_ids = vkd3d_calloc(block_count, sizeof(*compiler->block_label_ids))))
+        return false;
 
-    cf_info = &compiler->control_flow_info[--compiler->control_flow_depth];
-    memset(cf_info, 0, sizeof(*cf_info));
+    return true;
 }
 
-static struct vkd3d_control_flow_info *spirv_compiler_find_innermost_loop(
-        struct spirv_compiler *compiler)
+static void spirv_compiler_emit_label(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_instruction *instruction)
 {
-    int depth;
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    const struct vkd3d_shader_src_param *src = instruction->src;
+    unsigned int block_id = src->reg.idx[0].offset;
+    uint32_t label_id;
 
-    for (depth = compiler->control_flow_depth - 1; depth >= 0; --depth)
-    {
-        if (compiler->control_flow_info[depth].current_block == VKD3D_BLOCK_LOOP)
-            return &compiler->control_flow_info[depth];
-    }
+    label_id = spirv_compiler_get_label_id(compiler, block_id);
+    vkd3d_spirv_build_op_label(builder, label_id);
 
-    return NULL;
+    --block_id;
+    if (block_id < compiler->block_name_count && compiler->block_names[block_id])
+        vkd3d_spirv_build_op_name(builder, label_id, compiler->block_names[block_id]);
+
+    spirv_compiler_initialise_block(compiler);
 }
 
-static struct vkd3d_control_flow_info *spirv_compiler_find_innermost_breakable_cf_construct(
-        struct spirv_compiler *compiler)
+static void spirv_compiler_emit_merge(struct spirv_compiler *compiler,
+        uint32_t merge_block_id, uint32_t continue_block_id)
 {
-    int depth;
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+
+    if (!merge_block_id)
+        return;
 
-    for (depth = compiler->control_flow_depth - 1; depth >= 0; --depth)
+    merge_block_id = spirv_compiler_get_label_id(compiler, merge_block_id);
+    if (!continue_block_id)
     {
-        if (compiler->control_flow_info[depth].current_block == VKD3D_BLOCK_LOOP
-                || compiler->control_flow_info[depth].current_block == VKD3D_BLOCK_SWITCH)
-            return &compiler->control_flow_info[depth];
+        vkd3d_spirv_build_op_selection_merge(builder, merge_block_id, SpvSelectionControlMaskNone);
+    }
+    else
+    {
+        continue_block_id = spirv_compiler_get_label_id(compiler, continue_block_id);
+        vkd3d_spirv_build_op_loop_merge(builder, merge_block_id, continue_block_id, SpvLoopControlMaskNone);
     }
-
-    return NULL;
 }
 
-static int spirv_compiler_emit_control_flow_instruction(struct spirv_compiler *compiler,
+static void spirv_compiler_emit_branch(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
-    uint32_t loop_header_block_id, loop_body_block_id, continue_block_id;
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     const struct vkd3d_shader_src_param *src = instruction->src;
-    uint32_t merge_block_id, val_id, condition_id, true_label;
-    struct vkd3d_control_flow_info *cf_info;
-
-    cf_info = compiler->control_flow_depth
-            ? &compiler->control_flow_info[compiler->control_flow_depth - 1] : NULL;
+    uint32_t condition_id;
 
-    switch (instruction->handler_idx)
+    if (vsir_register_is_label(&src[0].reg))
     {
-        case VKD3DSIH_IF:
-            if (!(cf_info = spirv_compiler_push_control_flow_level(compiler)))
-                return VKD3D_ERROR_OUT_OF_MEMORY;
-
-            val_id = spirv_compiler_emit_load_src(compiler, src, VKD3DSP_WRITEMASK_0);
-            condition_id = spirv_compiler_emit_int_to_bool(compiler, instruction->flags, 1, val_id);
-
-            true_label = vkd3d_spirv_alloc_id(builder);
-            merge_block_id = vkd3d_spirv_alloc_id(builder);
-            vkd3d_spirv_build_op_selection_merge(builder, merge_block_id, SpvSelectionControlMaskNone);
-            cf_info->u.if_.stream_location = vkd3d_spirv_stream_current_location(&builder->function_stream);
-            vkd3d_spirv_build_op_branch_conditional(builder, condition_id, true_label, merge_block_id);
-
-            vkd3d_spirv_build_op_label(builder, true_label);
-
-            cf_info->u.if_.id = compiler->branch_id;
-            cf_info->u.if_.merge_block_id = merge_block_id;
-            cf_info->u.if_.else_block_id = 0;
-            cf_info->inside_block = true;
-            cf_info->current_block = VKD3D_BLOCK_IF;
-
-            vkd3d_spirv_build_op_name(builder, merge_block_id, "branch%u_merge", compiler->branch_id);
-            vkd3d_spirv_build_op_name(builder, true_label, "branch%u_true", compiler->branch_id);
-            ++compiler->branch_id;
-            break;
-
-        case VKD3DSIH_ELSE:
-            assert(compiler->control_flow_depth);
-            assert(cf_info->current_block == VKD3D_BLOCK_IF);
-
-            if (cf_info->inside_block)
-                vkd3d_spirv_build_op_branch(builder, cf_info->u.if_.merge_block_id);
-
-            cf_info->u.if_.else_block_id = vkd3d_spirv_alloc_id(builder);
-            vkd3d_spirv_as_op_branch_conditional(&builder->function_stream,
-                    cf_info->u.if_.stream_location)->false_label = cf_info->u.if_.else_block_id;
-            vkd3d_spirv_build_op_name(builder,
-                    cf_info->u.if_.else_block_id, "branch%u_false", cf_info->u.if_.id);
-            vkd3d_spirv_build_op_label(builder, cf_info->u.if_.else_block_id);
-            cf_info->inside_block = true;
-            break;
-
-        case VKD3DSIH_ENDIF:
-            assert(compiler->control_flow_depth);
-            assert(cf_info->current_block == VKD3D_BLOCK_IF);
-
-            if (cf_info->inside_block)
-                vkd3d_spirv_build_op_branch(builder, cf_info->u.if_.merge_block_id);
-
-            vkd3d_spirv_build_op_label(builder, cf_info->u.if_.merge_block_id);
-
-            spirv_compiler_pop_control_flow_level(compiler);
-            break;
-
-        case VKD3DSIH_LOOP:
-            if (!(cf_info = spirv_compiler_push_control_flow_level(compiler)))
-                return VKD3D_ERROR_OUT_OF_MEMORY;
-
-            loop_header_block_id = vkd3d_spirv_alloc_id(builder);
-            loop_body_block_id = vkd3d_spirv_alloc_id(builder);
-            continue_block_id = vkd3d_spirv_alloc_id(builder);
-            merge_block_id = vkd3d_spirv_alloc_id(builder);
-
-            vkd3d_spirv_build_op_branch(builder, loop_header_block_id);
-            vkd3d_spirv_build_op_label(builder, loop_header_block_id);
-            vkd3d_spirv_build_op_loop_merge(builder, merge_block_id, continue_block_id, SpvLoopControlMaskNone);
-            vkd3d_spirv_build_op_branch(builder, loop_body_block_id);
-
-            vkd3d_spirv_build_op_label(builder, loop_body_block_id);
-
-            cf_info->u.loop.header_block_id = loop_header_block_id;
-            cf_info->u.loop.continue_block_id = continue_block_id;
-            cf_info->u.loop.merge_block_id = merge_block_id;
-            cf_info->current_block = VKD3D_BLOCK_LOOP;
-            cf_info->inside_block = true;
-
-            vkd3d_spirv_build_op_name(builder, loop_header_block_id, "loop%u_header", compiler->loop_id);
-            vkd3d_spirv_build_op_name(builder, loop_body_block_id, "loop%u_body", compiler->loop_id);
-            vkd3d_spirv_build_op_name(builder, continue_block_id, "loop%u_continue", compiler->loop_id);
-            vkd3d_spirv_build_op_name(builder, merge_block_id, "loop%u_merge", compiler->loop_id);
-            ++compiler->loop_id;
-            break;
-
-        case VKD3DSIH_ENDLOOP:
-            assert(compiler->control_flow_depth);
-            assert(cf_info->current_block == VKD3D_BLOCK_LOOP);
-
-            /* The loop block may have already been ended by an unconditional
-             * break instruction right before the end of the loop. */
-            if (cf_info->inside_block)
-                vkd3d_spirv_build_op_branch(builder, cf_info->u.loop.continue_block_id);
-
-            vkd3d_spirv_build_op_label(builder, cf_info->u.loop.continue_block_id);
-            vkd3d_spirv_build_op_branch(builder, cf_info->u.loop.header_block_id);
-            vkd3d_spirv_build_op_label(builder, cf_info->u.loop.merge_block_id);
-
-            spirv_compiler_pop_control_flow_level(compiler);
-            break;
-
-        case VKD3DSIH_SWITCH:
-            if (!(cf_info = spirv_compiler_push_control_flow_level(compiler)))
-                return VKD3D_ERROR_OUT_OF_MEMORY;
-
-            merge_block_id = vkd3d_spirv_alloc_id(builder);
-
-            assert(src->reg.data_type == VKD3D_DATA_INT);
-            val_id = spirv_compiler_emit_load_src(compiler, src, VKD3DSP_WRITEMASK_0);
-
-            vkd3d_spirv_build_op_selection_merge(builder, merge_block_id, SpvSelectionControlMaskNone);
-
-            cf_info->u.switch_.id = compiler->switch_id;
-            cf_info->u.switch_.merge_block_id = merge_block_id;
-            cf_info->u.switch_.stream_location = vkd3d_spirv_stream_current_location(&builder->function_stream);
-            cf_info->u.switch_.selector_id = val_id;
-            cf_info->u.switch_.case_blocks = NULL;
-            cf_info->u.switch_.case_blocks_size = 0;
-            cf_info->u.switch_.case_block_count = 0;
-            cf_info->u.switch_.default_block_id = 0;
-            cf_info->inside_block = false;
-            cf_info->current_block = VKD3D_BLOCK_SWITCH;
-
-            vkd3d_spirv_build_op_name(builder, merge_block_id, "switch%u_merge", compiler->switch_id);
-
-            ++compiler->switch_id;
-
-            if (!vkd3d_array_reserve((void **)&cf_info->u.switch_.case_blocks, &cf_info->u.switch_.case_blocks_size,
-                    10, sizeof(*cf_info->u.switch_.case_blocks)))
-                return VKD3D_ERROR_OUT_OF_MEMORY;
-
-            break;
-
-        case VKD3DSIH_ENDSWITCH:
-            assert(compiler->control_flow_depth);
-            assert(cf_info->current_block == VKD3D_BLOCK_SWITCH);
-            assert(!cf_info->inside_block);
-
-            if (!cf_info->u.switch_.default_block_id)
-                cf_info->u.switch_.default_block_id = cf_info->u.switch_.merge_block_id;
-
-            vkd3d_spirv_build_op_label(builder, cf_info->u.switch_.merge_block_id);
-
-            /* The OpSwitch instruction is inserted when the endswitch
-             * instruction is processed because we do not know the number
-             * of case statements in advance.*/
-            vkd3d_spirv_begin_function_stream_insertion(builder, cf_info->u.switch_.stream_location);
-            vkd3d_spirv_build_op_switch(builder, cf_info->u.switch_.selector_id,
-                    cf_info->u.switch_.default_block_id, cf_info->u.switch_.case_blocks,
-                    cf_info->u.switch_.case_block_count);
-            vkd3d_spirv_end_function_stream_insertion(builder);
-
-            vkd3d_free(cf_info->u.switch_.case_blocks);
-            spirv_compiler_pop_control_flow_level(compiler);
-            break;
-
-        case VKD3DSIH_CASE:
-        {
-            uint32_t label_id, value;
-
-            assert(compiler->control_flow_depth);
-            assert(cf_info->current_block == VKD3D_BLOCK_SWITCH);
-
-            if (src->swizzle != VKD3D_SHADER_SWIZZLE(X, X, X, X))
-            {
-                WARN("Unexpected src swizzle %#x.\n", src->swizzle);
-                spirv_compiler_warning(compiler, VKD3D_SHADER_WARNING_SPV_INVALID_SWIZZLE,
-                        "The swizzle for a switch case value is not scalar.");
-            }
-            assert(src->reg.type == VKD3DSPR_IMMCONST);
-            value = *src->reg.u.immconst_uint;
-
-            if (!vkd3d_array_reserve((void **)&cf_info->u.switch_.case_blocks, &cf_info->u.switch_.case_blocks_size,
-                    2 * (cf_info->u.switch_.case_block_count + 1), sizeof(*cf_info->u.switch_.case_blocks)))
-                return VKD3D_ERROR_OUT_OF_MEMORY;
-
-            label_id = vkd3d_spirv_alloc_id(builder);
-            if (cf_info->inside_block) /* fall-through */
-                vkd3d_spirv_build_op_branch(builder, label_id);
-
-            cf_info->u.switch_.case_blocks[2 * cf_info->u.switch_.case_block_count + 0] = value;
-            cf_info->u.switch_.case_blocks[2 * cf_info->u.switch_.case_block_count + 1] = label_id;
-            ++cf_info->u.switch_.case_block_count;
-
-            vkd3d_spirv_build_op_label(builder, label_id);
-            cf_info->inside_block = true;
-            vkd3d_spirv_build_op_name(builder, label_id, "switch%u_case%u", cf_info->u.switch_.id, value);
-            break;
-        }
-
-        case VKD3DSIH_DEFAULT:
-            assert(compiler->control_flow_depth);
-            assert(cf_info->current_block == VKD3D_BLOCK_SWITCH);
-            assert(!cf_info->u.switch_.default_block_id);
-
-            cf_info->u.switch_.default_block_id = vkd3d_spirv_alloc_id(builder);
-            if (cf_info->inside_block) /* fall-through */
-                vkd3d_spirv_build_op_branch(builder, cf_info->u.switch_.default_block_id);
-
-            vkd3d_spirv_build_op_label(builder, cf_info->u.switch_.default_block_id);
-            vkd3d_spirv_build_op_name(builder, cf_info->u.switch_.default_block_id,
-                    "switch%u_default", cf_info->u.switch_.id);
-            cf_info->inside_block = true;
-            break;
-
-        case VKD3DSIH_BREAK:
-        {
-            struct vkd3d_control_flow_info *breakable_cf_info;
-
-            assert(compiler->control_flow_depth);
-
-            if (!(breakable_cf_info = spirv_compiler_find_innermost_breakable_cf_construct(compiler)))
-            {
-                FIXME("Unhandled break instruction.\n");
-                return VKD3D_ERROR_INVALID_SHADER;
-            }
-
-            if (breakable_cf_info->current_block == VKD3D_BLOCK_LOOP)
-            {
-                vkd3d_spirv_build_op_branch(builder, breakable_cf_info->u.loop.merge_block_id);
-            }
-            else if (breakable_cf_info->current_block == VKD3D_BLOCK_SWITCH)
-            {
-                /* The current case block may have already been ended by an
-                 * unconditional continue instruction. */
-                if (breakable_cf_info->inside_block)
-                    vkd3d_spirv_build_op_branch(builder, breakable_cf_info->u.switch_.merge_block_id);
-            }
-
-            cf_info->inside_block = false;
-            break;
-        }
-
-        case VKD3DSIH_BREAKP:
-        {
-            struct vkd3d_control_flow_info *loop_cf_info;
-
-            assert(compiler->control_flow_depth);
-
-            if (!(loop_cf_info = spirv_compiler_find_innermost_loop(compiler)))
-            {
-                ERR("Invalid 'breakc' instruction outside loop.\n");
-                return VKD3D_ERROR_INVALID_SHADER;
-            }
-
-            merge_block_id = spirv_compiler_emit_conditional_branch(compiler,
-                    instruction, loop_cf_info->u.loop.merge_block_id);
-            vkd3d_spirv_build_op_label(builder, merge_block_id);
-            break;
-        }
-
-        case VKD3DSIH_CONTINUE:
+        if (instruction->src_count > 1)
         {
-            struct vkd3d_control_flow_info *loop_cf_info;
-
-            assert(compiler->control_flow_depth);
-
-            if (!(loop_cf_info = spirv_compiler_find_innermost_loop(compiler)))
-            {
-                ERR("Invalid 'continue' instruction outside loop.\n");
-                return VKD3D_ERROR_INVALID_SHADER;
-            }
-
-            vkd3d_spirv_build_op_branch(builder, loop_cf_info->u.loop.continue_block_id);
-
-            cf_info->inside_block = false;
-            break;
+            /* Loop merge only. Must have a merge block and a continue block. */
+            spirv_compiler_emit_merge(compiler, src[1].reg.idx[0].offset, src[2].reg.idx[0].offset);
         }
+        vkd3d_spirv_build_op_branch(builder, spirv_compiler_get_label_id(compiler, src[0].reg.idx[0].offset));
+        return;
+    }
 
-        case VKD3DSIH_CONTINUEP:
-        {
-            struct vkd3d_control_flow_info *loop_cf_info;
-
-            if (!(loop_cf_info = spirv_compiler_find_innermost_loop(compiler)))
-            {
-                ERR("Invalid 'continuec' instruction outside loop.\n");
-                return VKD3D_ERROR_INVALID_SHADER;
-            }
+    if (!vkd3d_swizzle_is_scalar(src->swizzle))
+    {
+        WARN("Unexpected src swizzle %#x.\n", src->swizzle);
+        spirv_compiler_warning(compiler, VKD3D_SHADER_WARNING_SPV_INVALID_SWIZZLE,
+                "The swizzle for a branch condition value is not scalar.");
+    }
 
-            merge_block_id = spirv_compiler_emit_conditional_branch(compiler,
-                    instruction, loop_cf_info->u.loop.continue_block_id);
-            vkd3d_spirv_build_op_label(builder, merge_block_id);
-            break;
-        }
+    condition_id = spirv_compiler_emit_load_src(compiler, &src[0], VKD3DSP_WRITEMASK_0);
+    condition_id = spirv_compiler_emit_int_to_bool(compiler,
+            VKD3D_SHADER_CONDITIONAL_OP_NZ, src[0].reg.data_type, 1, condition_id);
+    /* Emit the merge immediately before the branch instruction. */
+    spirv_compiler_emit_merge(compiler, src[3].reg.idx[0].offset,
+            (instruction->src_count > 4) ? src[4].reg.idx[0].offset : 0);
+    vkd3d_spirv_build_op_branch_conditional(builder, condition_id,
+            spirv_compiler_get_label_id(compiler, src[1].reg.idx[0].offset),
+            spirv_compiler_get_label_id(compiler, src[2].reg.idx[0].offset));
+}
 
-        case VKD3DSIH_RET:
-            spirv_compiler_emit_return(compiler, instruction);
+static void spirv_compiler_emit_switch(struct spirv_compiler *compiler,
+        const struct vkd3d_shader_instruction *instruction)
+{
+    struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
+    const struct vkd3d_shader_src_param *src = instruction->src;
+    uint32_t val_id, default_id;
+    unsigned int i, word_count;
+    uint32_t *cases;
 
-            if (cf_info)
-                cf_info->inside_block = false;
-            else
-                compiler->main_block_open = false;
-            break;
+    if (!vkd3d_swizzle_is_scalar(src[0].swizzle))
+    {
+        WARN("Unexpected src swizzle %#x.\n", src[0].swizzle);
+        spirv_compiler_warning(compiler, VKD3D_SHADER_WARNING_SPV_INVALID_SWIZZLE,
+                "The swizzle for a switch value is not scalar.");
+    }
 
-        case VKD3DSIH_RETP:
-            spirv_compiler_emit_retc(compiler, instruction);
-            break;
+    word_count = instruction->src_count - 3;
+    if (!(cases = vkd3d_calloc(word_count, sizeof(*cases))))
+    {
+        spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_OUT_OF_MEMORY,
+                "Failed to allocate %u words for switch cases.", word_count);
+        return;
+    }
 
-        case VKD3DSIH_DISCARD:
-        case VKD3DSIH_TEXKILL:
-            spirv_compiler_emit_kill(compiler, instruction);
-            break;
+    val_id = spirv_compiler_emit_load_src(compiler, &src[0], VKD3DSP_WRITEMASK_0);
+    default_id = spirv_compiler_get_label_id(compiler, src[1].reg.idx[0].offset);
+    /* No instructions may occur between the merge and the switch. */
+    spirv_compiler_emit_merge(compiler, src[2].reg.idx[0].offset, 0);
 
-        default:
-            ERR("Unexpected instruction %#x.\n", instruction->handler_idx);
-            break;
+    src = &src[3];
+    for (i = 0; i < word_count; i += 2)
+    {
+        cases[i] = src[i].reg.u.immconst_u32[0];
+        cases[i + 1] = spirv_compiler_get_label_id(compiler, src[i + 1].reg.idx[0].offset);
     }
 
-    return VKD3D_OK;
+    vkd3d_spirv_build_op_switch(builder, val_id, default_id, cases, word_count / 2u);
+
+    vkd3d_free(cases);
 }
 
 static void spirv_compiler_emit_deriv_instruction(struct spirv_compiler *compiler,
@@ -8090,7 +8122,7 @@ static void spirv_compiler_emit_ld(struct spirv_compiler *compiler,
     unsigned int image_operand_count = 0;
     struct vkd3d_shader_image image;
     uint32_t image_operands[2];
-    DWORD coordinate_mask;
+    uint32_t coordinate_mask;
     bool multisample;
 
     multisample = instruction->handler_idx == VKD3DSIH_LD2DMS;
@@ -8164,7 +8196,7 @@ static void spirv_compiler_emit_sample(struct spirv_compiler *compiler,
     unsigned int image_operand_count = 0;
     struct vkd3d_shader_image image;
     uint32_t image_operands[3];
-    DWORD coordinate_mask;
+    uint32_t coordinate_mask;
     SpvOp op;
 
     resource = &src[1];
@@ -8280,7 +8312,7 @@ static void spirv_compiler_emit_gather4(struct spirv_compiler *compiler,
     struct vkd3d_shader_image image;
     unsigned int component_idx;
     uint32_t image_operands[1];
-    DWORD coordinate_mask;
+    uint32_t coordinate_mask;
     bool extended_offset;
 
     if (instruction->handler_idx == VKD3DSIH_GATHER4_C
@@ -8325,7 +8357,7 @@ static void spirv_compiler_emit_gather4(struct spirv_compiler *compiler,
     }
     else
     {
-        component_idx = vkd3d_swizzle_get_component(sampler->swizzle, 0);
+        component_idx = vsir_swizzle_get_component(sampler->swizzle, 0);
         /* Nvidia driver requires signed integer type. */
         component_id = spirv_compiler_get_constant(compiler,
                 VKD3D_SHADER_COMPONENT_INT, 1, &component_idx);
@@ -8340,13 +8372,13 @@ static void spirv_compiler_emit_gather4(struct spirv_compiler *compiler,
 
 static uint32_t spirv_compiler_emit_raw_structured_addressing(
         struct spirv_compiler *compiler, uint32_t type_id, unsigned int stride,
-        const struct vkd3d_shader_src_param *src0, DWORD src0_mask,
-        const struct vkd3d_shader_src_param *src1, DWORD src1_mask)
+        const struct vkd3d_shader_src_param *src0, uint32_t src0_mask,
+        const struct vkd3d_shader_src_param *src1, uint32_t src1_mask)
 {
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     const struct vkd3d_shader_src_param *offset;
     uint32_t structure_id = 0, offset_id;
-    DWORD offset_write_mask;
+    uint32_t offset_write_mask;
 
     if (stride)
     {
@@ -8403,7 +8435,7 @@ static void spirv_compiler_emit_ld_raw_structured_srv_uav(struct spirv_compiler
             if (!(dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
                 continue;
 
-            component_idx = vkd3d_swizzle_get_component(resource->swizzle, i);
+            component_idx = vsir_swizzle_get_component(resource->swizzle, i);
             coordinate_id = base_coordinate_id;
             if (component_idx)
                 coordinate_id = vkd3d_spirv_build_op_iadd(builder, type_id,
@@ -8435,7 +8467,7 @@ static void spirv_compiler_emit_ld_raw_structured_srv_uav(struct spirv_compiler
             if (!(dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
                 continue;
 
-            component_idx = vkd3d_swizzle_get_component(resource->swizzle, i);
+            component_idx = vsir_swizzle_get_component(resource->swizzle, i);
             coordinate_id = base_coordinate_id;
             if (component_idx)
                 coordinate_id = vkd3d_spirv_build_op_iadd(builder, type_id,
@@ -8447,7 +8479,6 @@ static void spirv_compiler_emit_ld_raw_structured_srv_uav(struct spirv_compiler
                     type_id, val_id, 0);
         }
     }
-    assert(dst->reg.data_type == VKD3D_DATA_UINT);
     spirv_compiler_emit_store_dst_components(compiler, dst, VKD3D_SHADER_COMPONENT_UINT, constituents);
 }
 
@@ -8479,7 +8510,7 @@ static void spirv_compiler_emit_ld_tgsm(struct spirv_compiler *compiler,
         if (!(dst->write_mask & (VKD3DSP_WRITEMASK_0 << i)))
             continue;
 
-        component_idx = vkd3d_swizzle_get_component(resource->swizzle, i);
+        component_idx = vsir_swizzle_get_component(resource->swizzle, i);
         coordinate_id = base_coordinate_id;
         if (component_idx)
             coordinate_id = vkd3d_spirv_build_op_iadd(builder, type_id,
@@ -8540,7 +8571,7 @@ static void spirv_compiler_emit_store_uav_raw_structured(struct spirv_compiler *
         assert(data->reg.data_type == VKD3D_DATA_UINT);
         val_id = spirv_compiler_emit_load_src(compiler, data, dst->write_mask);
 
-        component_count = vkd3d_write_mask_component_count(dst->write_mask);
+        component_count = vsir_write_mask_component_count(dst->write_mask);
         for (component_idx = 0; component_idx < component_count; ++component_idx)
         {
             data_id = component_count > 1 ?
@@ -8569,7 +8600,7 @@ static void spirv_compiler_emit_store_uav_raw_structured(struct spirv_compiler *
         assert(data->reg.data_type == VKD3D_DATA_UINT);
         val_id = spirv_compiler_emit_load_src(compiler, data, dst->write_mask);
 
-        component_count = vkd3d_write_mask_component_count(dst->write_mask);
+        component_count = vsir_write_mask_component_count(dst->write_mask);
         for (component_idx = 0; component_idx < component_count; ++component_idx)
         {
             /* Mesa Vulkan drivers require the texel parameter to be a vector. */
@@ -8613,7 +8644,7 @@ static void spirv_compiler_emit_store_tgsm(struct spirv_compiler *compiler,
     assert(data->reg.data_type == VKD3D_DATA_UINT);
     val_id = spirv_compiler_emit_load_src(compiler, data, dst->write_mask);
 
-    component_count = vkd3d_write_mask_component_count(dst->write_mask);
+    component_count = vsir_write_mask_component_count(dst->write_mask);
     for (component_idx = 0; component_idx < component_count; ++component_idx)
     {
         data_id = component_count > 1 ?
@@ -8655,7 +8686,7 @@ static void spirv_compiler_emit_ld_uav_typed(struct spirv_compiler *compiler,
     const struct vkd3d_shader_src_param *src = instruction->src;
     const struct vkd3d_symbol *resource_symbol;
     struct vkd3d_shader_image image;
-    DWORD coordinate_mask;
+    uint32_t coordinate_mask;
     uint32_t indices[2];
 
     resource_symbol = spirv_compiler_find_resource(compiler, &src[1].reg);
@@ -8698,7 +8729,7 @@ static void spirv_compiler_emit_store_uav_typed(struct spirv_compiler *compiler,
     const struct vkd3d_shader_src_param *src = instruction->src;
     const struct vkd3d_symbol *resource_symbol;
     struct vkd3d_shader_image image;
-    DWORD coordinate_mask;
+    uint32_t coordinate_mask;
     uint32_t indices[2];
 
     resource_symbol = spirv_compiler_find_resource(compiler, &dst->reg);
@@ -8864,7 +8895,7 @@ static void spirv_compiler_emit_atomic_instruction(struct spirv_compiler *compil
     struct vkd3d_shader_register_info reg_info;
     struct vkd3d_shader_image image;
     unsigned int structure_stride;
-    DWORD coordinate_mask;
+    uint32_t coordinate_mask;
     uint32_t operands[6];
     unsigned int i = 0;
     SpvScope scope;
@@ -9275,7 +9306,7 @@ static void spirv_compiler_emit_eval_attrib(struct spirv_compiler *compiler,
     }
 
     type_id = vkd3d_spirv_get_type_id(builder, VKD3D_SHADER_COMPONENT_FLOAT,
-            vkd3d_write_mask_component_count(register_info.write_mask));
+            vsir_write_mask_component_count(register_info.write_mask));
 
     instr_set_id = vkd3d_spirv_get_glsl_std450_instr_set(builder);
     val_id = vkd3d_spirv_build_op_ext_inst(builder, type_id, instr_set_id, op, src_ids, src_count);
@@ -9296,9 +9327,9 @@ static void spirv_compiler_emit_sync(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
     unsigned int memory_semantics = SpvMemorySemanticsAcquireReleaseMask;
-    unsigned int flags = instruction->flags;
     SpvScope execution_scope = SpvScopeMax;
     SpvScope memory_scope = SpvScopeDevice;
+    uint32_t flags = instruction->flags;
 
     if (flags & VKD3DSSF_GROUP_SHARED_MEMORY)
     {
@@ -9313,11 +9344,20 @@ static void spirv_compiler_emit_sync(struct spirv_compiler *compiler,
         flags &= ~VKD3DSSF_THREAD_GROUP;
     }
 
-    if (flags & VKD3DSSF_GLOBAL_UAV)
+    if (flags & (VKD3DSSF_THREAD_GROUP_UAV | VKD3DSSF_GLOBAL_UAV))
     {
-        memory_scope = SpvScopeDevice;
-        memory_semantics |= SpvMemorySemanticsImageMemoryMask;
-        flags &= ~VKD3DSSF_GLOBAL_UAV;
+        bool group_uav = flags & VKD3DSSF_THREAD_GROUP_UAV;
+        bool global_uav = flags & VKD3DSSF_GLOBAL_UAV;
+
+        if (group_uav && global_uav)
+        {
+            WARN("Invalid UAV sync flag combination; assuming global.\n");
+            spirv_compiler_warning(compiler, VKD3D_SHADER_WARNING_SPV_INVALID_UAV_FLAGS,
+                    "The flags for a UAV sync instruction are contradictory; assuming global sync.");
+        }
+        memory_scope = global_uav ? SpvScopeDevice : SpvScopeWorkgroup;
+        memory_semantics |= SpvMemorySemanticsUniformMemoryMask | SpvMemorySemanticsImageMemoryMask;
+        flags &= ~(VKD3DSSF_THREAD_GROUP_UAV | VKD3DSSF_GLOBAL_UAV);
     }
 
     if (flags)
@@ -9382,28 +9422,15 @@ static void spirv_compiler_emit_main_prolog(struct spirv_compiler *compiler)
 {
     spirv_compiler_emit_push_constant_buffers(compiler);
 
-    if (compiler->xfb_info && compiler->xfb_info->element_count
-            && compiler->shader_type != VKD3D_SHADER_TYPE_GEOMETRY)
+    if (compiler->emit_point_size)
         spirv_compiler_emit_point_size(compiler);
 }
 
-static bool is_dcl_instruction(enum vkd3d_shader_opcode handler_idx)
-{
-    return (VKD3DSIH_DCL <= handler_idx && handler_idx <= VKD3DSIH_DCL_VERTICES_OUT)
-            || handler_idx == VKD3DSIH_HS_DECLS;
-}
-
 static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         const struct vkd3d_shader_instruction *instruction)
 {
     int ret = VKD3D_OK;
 
-    if (!is_dcl_instruction(instruction->handler_idx) && !compiler->after_declarations_section)
-    {
-        compiler->after_declarations_section = true;
-        spirv_compiler_emit_main_prolog(compiler);
-    }
-
     switch (instruction->handler_idx)
     {
         case VKD3DSIH_DCL_GLOBAL_FLAGS:
@@ -9425,18 +9452,9 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DCL_INPUT:
             spirv_compiler_emit_dcl_input(compiler, instruction);
             break;
-        case VKD3DSIH_DCL_INPUT_PS_SGV:
-        case VKD3DSIH_DCL_INPUT_PS_SIV:
-        case VKD3DSIH_DCL_INPUT_SGV:
-        case VKD3DSIH_DCL_INPUT_SIV:
-            spirv_compiler_emit_dcl_input_sysval(compiler, instruction);
-            break;
         case VKD3DSIH_DCL_OUTPUT:
             spirv_compiler_emit_dcl_output(compiler, instruction);
             break;
-        case VKD3DSIH_DCL_OUTPUT_SIV:
-            spirv_compiler_emit_dcl_output_siv(compiler, instruction);
-            break;
         case VKD3DSIH_DCL_STREAM:
             spirv_compiler_emit_dcl_stream(compiler, instruction);
             break;
@@ -9500,6 +9518,8 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_INEG:
         case VKD3DSIH_ISHL:
         case VKD3DSIH_ISHR:
+        case VKD3DSIH_ISINF:
+        case VKD3DSIH_ISNAN:
         case VKD3DSIH_ITOD:
         case VKD3DSIH_ITOF:
         case VKD3DSIH_ITOI:
@@ -9513,6 +9533,9 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_XOR:
             ret = spirv_compiler_emit_alu_instruction(compiler, instruction);
             break;
+        case VKD3DSIH_ISFINITE:
+            spirv_compiler_emit_isfinite(compiler, instruction);
+            break;
         case VKD3DSIH_DFMA:
         case VKD3DSIH_DMAX:
         case VKD3DSIH_DMIN:
@@ -9533,6 +9556,7 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_ROUND_Z:
         case VKD3DSIH_RSQ:
         case VKD3DSIH_SQRT:
+        case VKD3DSIH_TAN:
         case VKD3DSIH_UMAX:
         case VKD3DSIH_UMIN:
             spirv_compiler_emit_ext_glsl_instruction(compiler, instruction);
@@ -9599,24 +9623,23 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_F32TOF16:
             spirv_compiler_emit_f32tof16(compiler, instruction);
             break;
-        case VKD3DSIH_BREAK:
-        case VKD3DSIH_BREAKP:
-        case VKD3DSIH_CASE:
-        case VKD3DSIH_CONTINUE:
-        case VKD3DSIH_CONTINUEP:
-        case VKD3DSIH_DEFAULT:
-        case VKD3DSIH_DISCARD:
-        case VKD3DSIH_ELSE:
-        case VKD3DSIH_ENDIF:
-        case VKD3DSIH_ENDLOOP:
-        case VKD3DSIH_ENDSWITCH:
-        case VKD3DSIH_IF:
-        case VKD3DSIH_LOOP:
         case VKD3DSIH_RET:
+            spirv_compiler_emit_return(compiler, instruction);
+            break;
         case VKD3DSIH_RETP:
-        case VKD3DSIH_SWITCH:
-        case VKD3DSIH_TEXKILL:
-            ret = spirv_compiler_emit_control_flow_instruction(compiler, instruction);
+            spirv_compiler_emit_retc(compiler, instruction);
+            break;
+        case VKD3DSIH_DISCARD:
+            spirv_compiler_emit_discard(compiler, instruction);
+            break;
+        case VKD3DSIH_LABEL:
+            spirv_compiler_emit_label(compiler, instruction);
+            break;
+        case VKD3DSIH_BRANCH:
+            spirv_compiler_emit_branch(compiler, instruction);
+            break;
+        case VKD3DSIH_SWITCH_MONOLITHIC:
+            spirv_compiler_emit_switch(compiler, instruction);
             break;
         case VKD3DSIH_DSX:
         case VKD3DSIH_DSX_COARSE:
@@ -9719,10 +9742,14 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
         case VKD3DSIH_DCL_CONSTANT_BUFFER:
         case VKD3DSIH_DCL_HS_MAX_TESSFACTOR:
         case VKD3DSIH_DCL_INPUT_CONTROL_POINT_COUNT:
+        case VKD3DSIH_DCL_INPUT_SGV:
+        case VKD3DSIH_DCL_INPUT_SIV:
+        case VKD3DSIH_DCL_INPUT_PS_SGV:
+        case VKD3DSIH_DCL_INPUT_PS_SIV:
+        case VKD3DSIH_DCL_OUTPUT_SIV:
         case VKD3DSIH_DCL_RESOURCE_RAW:
         case VKD3DSIH_DCL_RESOURCE_STRUCTURED:
         case VKD3DSIH_DCL_SAMPLER:
-        case VKD3DSIH_DCL_TEMPS:
         case VKD3DSIH_DCL_UAV_RAW:
         case VKD3DSIH_DCL_UAV_STRUCTURED:
         case VKD3DSIH_DCL_UAV_TYPED:
@@ -9740,6 +9767,30 @@ static int spirv_compiler_handle_instruction(struct spirv_compiler *compiler,
     return ret;
 }
 
+static void spirv_compiler_emit_io_declarations(struct spirv_compiler *compiler)
+{
+    for (unsigned int i = 0; i < compiler->input_signature.element_count; ++i)
+        spirv_compiler_emit_input(compiler, VKD3DSPR_INPUT, i);
+
+    for (unsigned int i = 0; i < compiler->output_signature.element_count; ++i)
+    {
+        /* PS outputs other than TARGET have dedicated registers and therefore
+         * go through spirv_compiler_emit_dcl_output() for now. */
+        if (compiler->shader_type == VKD3D_SHADER_TYPE_PIXEL
+                && compiler->output_signature.elements[i].sysval_semantic != VKD3D_SHADER_SV_TARGET)
+            continue;
+        spirv_compiler_emit_output(compiler, VKD3DSPR_OUTPUT, i);
+    }
+
+    for (unsigned int i = 0; i < compiler->patch_constant_signature.element_count; ++i)
+    {
+        if (compiler->shader_type == VKD3D_SHADER_TYPE_HULL)
+            spirv_compiler_emit_output(compiler, VKD3DSPR_PATCHCONST, i);
+        else
+            spirv_compiler_emit_input(compiler, VKD3DSPR_PATCHCONST, i);
+    }
+}
+
 static void spirv_compiler_emit_descriptor_declarations(struct spirv_compiler *compiler)
 {
     unsigned int i;
@@ -9793,24 +9844,28 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     struct vkd3d_spirv_builder *builder = &compiler->spirv_builder;
     struct vkd3d_shader_desc *shader_desc = &parser->shader_desc;
     struct vkd3d_shader_instruction_array instructions;
+    struct vsir_program *program = &parser->program;
     enum vkd3d_result result = VKD3D_OK;
     unsigned int i;
 
-    if (parser->shader_desc.temp_count)
-        spirv_compiler_emit_temps(compiler, parser->shader_desc.temp_count);
-    if (parser->shader_desc.ssa_count)
-        spirv_compiler_allocate_ssa_register_ids(compiler, parser->shader_desc.ssa_count);
+    if ((result = vkd3d_shader_normalise(parser, compile_info)) < 0)
+        return result;
+
+    if (program->temp_count)
+        spirv_compiler_emit_temps(compiler, program->temp_count);
+    if (program->ssa_count)
+        spirv_compiler_allocate_ssa_register_ids(compiler, program->ssa_count);
 
     spirv_compiler_emit_descriptor_declarations(compiler);
 
     compiler->location.column = 0;
     compiler->location.line = 1;
 
-    if ((result = vkd3d_shader_normalise(parser, compile_info)) < 0)
-        return result;
+    if (program->block_count && !spirv_compiler_init_blocks(compiler, program->block_count))
+        return VKD3D_ERROR_OUT_OF_MEMORY;
 
-    instructions = parser->instructions;
-    memset(&parser->instructions, 0, sizeof(parser->instructions));
+    instructions = program->instructions;
+    memset(&program->instructions, 0, sizeof(program->instructions));
 
     compiler->input_signature = shader_desc->input_signature;
     compiler->output_signature = shader_desc->output_signature;
@@ -9818,10 +9873,12 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     memset(&shader_desc->input_signature, 0, sizeof(shader_desc->input_signature));
     memset(&shader_desc->output_signature, 0, sizeof(shader_desc->output_signature));
     memset(&shader_desc->patch_constant_signature, 0, sizeof(shader_desc->patch_constant_signature));
-    compiler->use_vocp = parser->shader_desc.use_vocp;
+    compiler->use_vocp = program->use_vocp;
+    compiler->block_names = program->block_names;
+    compiler->block_name_count = program->block_name_count;
 
-    compiler->input_control_point_count = shader_desc->input_control_point_count;
-    compiler->output_control_point_count = shader_desc->output_control_point_count;
+    compiler->input_control_point_count = program->input_control_point_count;
+    compiler->output_control_point_count = program->output_control_point_count;
 
     if (compiler->shader_type != VKD3D_SHADER_TYPE_HULL)
         spirv_compiler_emit_shader_signature_outputs(compiler);
@@ -9837,9 +9894,6 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     if (result < 0)
         return result;
 
-    if (compiler->main_block_open)
-        vkd3d_spirv_build_op_return(builder);
-
     if (!is_in_default_phase(compiler))
         spirv_compiler_leave_shader_phase(compiler);
     else
@@ -9862,6 +9916,9 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
         }
     }
 
+    if (compiler->discard_function_id)
+        spirv_compiler_emit_discard_function(compiler);
+
     if (compiler->epilogue_function_id)
     {
         vkd3d_spirv_build_op_name(builder, compiler->epilogue_function_id, "epilogue");
@@ -9874,11 +9931,28 @@ static int spirv_compiler_generate_spirv(struct spirv_compiler *compiler,
     if (!vkd3d_spirv_compile_module(builder, spirv, spirv_compiler_get_entry_point_name(compiler)))
         return VKD3D_ERROR;
 
-    if (TRACE_ON())
+    if (TRACE_ON() || parser->config_flags & VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION)
     {
         enum vkd3d_shader_spirv_environment environment = spirv_compiler_get_target_environment(compiler);
-        vkd3d_spirv_dump(spirv, environment);
-        vkd3d_spirv_validate(spirv, environment);
+        struct vkd3d_string_buffer buffer;
+
+        if (TRACE_ON())
+            vkd3d_spirv_dump(spirv, environment);
+
+        vkd3d_string_buffer_init(&buffer);
+        if (!vkd3d_spirv_validate(&buffer, spirv, environment))
+        {
+            FIXME("Failed to validate SPIR-V binary.\n");
+            vkd3d_shader_trace_text(buffer.buffer, buffer.content_size);
+
+            if (compiler->config_flags & VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION)
+            {
+                spirv_compiler_error(compiler, VKD3D_SHADER_ERROR_SPV_INVALID_SHADER,
+                        "Execution generated an invalid shader, failing compilation:\n%s",
+                        buffer.buffer);
+            }
+        }
+        vkd3d_string_buffer_cleanup(&buffer);
     }
 
     if (compiler->failed)
@@ -9904,8 +9978,8 @@ int spirv_compile(struct vkd3d_shader_parser *parser,
     struct spirv_compiler *spirv_compiler;
     int ret;
 
-    if (!(spirv_compiler = spirv_compiler_create(&parser->shader_version, &parser->shader_desc,
-            compile_info, scan_descriptor_info, message_context, &parser->location)))
+    if (!(spirv_compiler = spirv_compiler_create(&parser->program.shader_version, &parser->shader_desc,
+            compile_info, scan_descriptor_info, message_context, &parser->location, parser->config_flags)))
     {
         ERR("Failed to create SPIR-V compiler.\n");
         return VKD3D_ERROR;
diff --git a/libs/vkd3d/libs/vkd3d-shader/tpf.c b/libs/vkd3d/libs/vkd3d-shader/tpf.c
index 80f8ab9..50146c2 100644
--- a/libs/vkd3d/libs/vkd3d-shader/tpf.c
+++ b/libs/vkd3d/libs/vkd3d-shader/tpf.c
@@ -711,7 +711,7 @@ static struct vkd3d_shader_sm4_parser *vkd3d_shader_sm4_parser(struct vkd3d_shad
 
 static bool shader_is_sm_5_1(const struct vkd3d_shader_sm4_parser *sm4)
 {
-    const struct vkd3d_shader_version *version = &sm4->p.shader_version;
+    const struct vkd3d_shader_version *version = &sm4->p.program.shader_version;
 
     return version->major >= 5 && version->minor >= 1;
 }
@@ -742,8 +742,7 @@ static bool shader_sm4_read_register_space(struct vkd3d_shader_sm4_parser *priv,
 static void shader_sm4_read_conditional_op(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_UINT,
-            (struct vkd3d_shader_src_param *)&ins->src[0]);
+    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_UINT, &ins->src[0]);
     ins->flags = (opcode_token & VKD3D_SM4_CONDITIONAL_NZ) ?
             VKD3D_SHADER_CONDITIONAL_OP_NZ : VKD3D_SHADER_CONDITIONAL_OP_Z;
 }
@@ -751,8 +750,7 @@ static void shader_sm4_read_conditional_op(struct vkd3d_shader_instruction *ins,
 static void shader_sm4_read_case_condition(struct vkd3d_shader_instruction *ins, uint32_t opcode,
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_UINT,
-            (struct vkd3d_shader_src_param *)&ins->src[0]);
+    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_UINT, &ins->src[0]);
     if (ins->src[0].reg.type != VKD3DSPR_IMMCONST)
     {
         FIXME("Switch case value is not a 32-bit constant.\n");
@@ -792,11 +790,13 @@ static void shader_sm4_read_shader_data(struct vkd3d_shader_instruction *ins, ui
         ins->handler_idx = VKD3DSIH_INVALID;
         return;
     }
+    icb->register_idx = 0;
     icb->data_type = VKD3D_DATA_FLOAT;
     icb->component_count = VKD3D_VEC4_SIZE;
     icb->element_count = icb_size / VKD3D_VEC4_SIZE;
+    icb->is_null = false;
     memcpy(icb->data, tokens, sizeof(*tokens) * icb_size);
-    shader_instruction_array_add_icb(&priv->p.instructions, icb);
+    shader_instruction_array_add_icb(&priv->p.program.instructions, icb);
     ins->declaration.icb = icb;
 }
 
@@ -821,7 +821,7 @@ static void shader_sm4_read_dcl_resource(struct vkd3d_shader_instruction *ins, u
     const uint32_t *end = &tokens[token_count];
     enum vkd3d_sm4_data_type data_type;
     enum vkd3d_data_type reg_data_type;
-    DWORD components;
+    uint32_t components;
     unsigned int i;
 
     resource_type = (opcode_token & VKD3D_SM4_RESOURCE_TYPE_MASK) >> VKD3D_SM4_RESOURCE_TYPE_SHIFT;
@@ -918,10 +918,12 @@ static void shader_sm4_read_dcl_index_range(struct vkd3d_shader_instruction *ins
         uint32_t opcode_token, const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
     struct vkd3d_shader_index_range *index_range = &ins->declaration.index_range;
-    unsigned int i, register_idx, register_count, write_mask;
+    unsigned int i, register_idx, register_count;
+    const struct shader_signature *signature;
     enum vkd3d_shader_register_type type;
     struct sm4_index_range_array *ranges;
     unsigned int *io_masks;
+    uint32_t write_mask;
 
     shader_sm4_read_dst_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_OPAQUE,
             &index_range->dst);
@@ -931,40 +933,38 @@ static void shader_sm4_read_dcl_index_range(struct vkd3d_shader_instruction *ins
     register_count = index_range->register_count;
     write_mask = index_range->dst.write_mask;
 
-    if (vkd3d_write_mask_component_count(write_mask) != 1)
-    {
-        WARN("Unhandled write mask %#x.\n", write_mask);
-        vkd3d_shader_parser_warning(&priv->p, VKD3D_SHADER_WARNING_TPF_UNHANDLED_INDEX_RANGE_MASK,
-                "Index range mask %#x is not scalar.", write_mask);
-    }
-
     switch ((type = index_range->dst.reg.type))
     {
         case VKD3DSPR_INPUT:
         case VKD3DSPR_INCONTROLPOINT:
             io_masks = priv->input_register_masks;
             ranges = &priv->input_index_ranges;
+            signature = &priv->p.shader_desc.input_signature;
             break;
         case VKD3DSPR_OUTPUT:
             if (sm4_parser_is_in_fork_or_join_phase(priv))
             {
                 io_masks = priv->patch_constant_register_masks;
                 ranges = &priv->patch_constant_index_ranges;
+                signature = &priv->p.shader_desc.patch_constant_signature;
             }
             else
             {
                 io_masks = priv->output_register_masks;
                 ranges = &priv->output_index_ranges;
+                signature = &priv->p.shader_desc.output_signature;
             }
             break;
         case VKD3DSPR_COLOROUT:
         case VKD3DSPR_OUTCONTROLPOINT:
             io_masks = priv->output_register_masks;
             ranges = &priv->output_index_ranges;
+            signature = &priv->p.shader_desc.output_signature;
             break;
         case VKD3DSPR_PATCHCONST:
             io_masks = priv->patch_constant_register_masks;
             ranges = &priv->patch_constant_index_ranges;
+            signature = &priv->p.shader_desc.patch_constant_signature;
             break;
 
         default:
@@ -1002,6 +1002,18 @@ static void shader_sm4_read_dcl_index_range(struct vkd3d_shader_instruction *ins
 
     for (i = 0; i < register_count; ++i)
     {
+        const struct signature_element *e = vsir_signature_find_element_for_reg(signature, register_idx + i, write_mask);
+        /* Index ranges should not contain non-arrayed sysvals. FXC tries to forbid this but it is buggy,
+         * and can emit a range containing a sysval if the sysval is not actually accessed. */
+        if (e && e->sysval_semantic && register_count > 1 && !vsir_sysval_semantic_is_tess_factor(e->sysval_semantic)
+                && !vsir_sysval_semantic_is_clip_cull(e->sysval_semantic))
+        {
+            WARN("Sysval %u included in an index range declaration.\n", e->sysval_semantic);
+            vkd3d_shader_parser_error(&priv->p, VKD3D_SHADER_ERROR_TPF_INVALID_INDEX_RANGE_DCL,
+                    "Index range base %u, count %u, mask %#x contains sysval %u.",
+                    register_idx, register_count, write_mask, e->sysval_semantic);
+            return;
+        }
         if ((io_masks[register_idx + i] & write_mask) != write_mask)
         {
             WARN("No matching declaration for index range base %u, count %u, mask %#x.\n",
@@ -1039,7 +1051,7 @@ static void shader_sm4_read_dcl_input_primitive(struct vkd3d_shader_instruction
     {
         ins->declaration.primitive_type.type = VKD3D_PT_PATCH;
         ins->declaration.primitive_type.patch_vertex_count = primitive_type - VKD3D_SM5_INPUT_PT_PATCH1 + 1;
-        priv->p.shader_desc.input_control_point_count = ins->declaration.primitive_type.patch_vertex_count;
+        priv->p.program.input_control_point_count = ins->declaration.primitive_type.patch_vertex_count;
     }
     else if (primitive_type >= ARRAY_SIZE(input_primitive_type_table))
     {
@@ -1048,7 +1060,7 @@ static void shader_sm4_read_dcl_input_primitive(struct vkd3d_shader_instruction
     else
     {
         ins->declaration.primitive_type.type = input_primitive_type_table[primitive_type].vkd3d_type;
-        priv->p.shader_desc.input_control_point_count = input_primitive_type_table[primitive_type].control_point_count;
+        priv->p.program.input_control_point_count = input_primitive_type_table[primitive_type].control_point_count;
     }
 
     if (ins->declaration.primitive_type.type == VKD3D_PT_UNDEFINED)
@@ -1060,7 +1072,7 @@ static void shader_sm4_read_declaration_count(struct vkd3d_shader_instruction *i
 {
     ins->declaration.count = *tokens;
     if (opcode == VKD3D_SM4_OP_DCL_TEMPS)
-        priv->p.shader_desc.temp_count = max(priv->p.shader_desc.temp_count, *tokens);
+        priv->p.program.temp_count = max(priv->p.program.temp_count, *tokens);
 }
 
 static void shader_sm4_read_declaration_dst(struct vkd3d_shader_instruction *ins, uint32_t opcode,
@@ -1116,6 +1128,7 @@ static void shader_sm4_read_dcl_indexable_temp(struct vkd3d_shader_instruction *
     ins->declaration.indexable_temp.alignment = 0;
     ins->declaration.indexable_temp.data_type = VKD3D_DATA_FLOAT;
     ins->declaration.indexable_temp.component_count = *tokens;
+    ins->declaration.indexable_temp.has_function_scope = false;
 }
 
 static void shader_sm4_read_dcl_global_flags(struct vkd3d_shader_instruction *ins, uint32_t opcode,
@@ -1127,9 +1140,8 @@ static void shader_sm4_read_dcl_global_flags(struct vkd3d_shader_instruction *in
 static void shader_sm5_read_fcall(struct vkd3d_shader_instruction *ins, uint32_t opcode, uint32_t opcode_token,
         const uint32_t *tokens, unsigned int token_count, struct vkd3d_shader_sm4_parser *priv)
 {
-    struct vkd3d_shader_src_param *src_params = (struct vkd3d_shader_src_param *)ins->src;
-    src_params[0].reg.u.fp_body_idx = *tokens++;
-    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_OPAQUE, &src_params[0]);
+    ins->src[0].reg.u.fp_body_idx = *tokens++;
+    shader_sm4_read_src_param(priv, &tokens, &tokens[token_count], VKD3D_DATA_OPAQUE, &ins->src[0]);
 }
 
 static void shader_sm5_read_dcl_function_body(struct vkd3d_shader_instruction *ins, uint32_t opcode,
@@ -1162,9 +1174,9 @@ static void shader_sm5_read_control_point_count(struct vkd3d_shader_instruction
             >> VKD3D_SM5_CONTROL_POINT_COUNT_SHIFT;
 
     if (opcode == VKD3D_SM5_OP_DCL_INPUT_CONTROL_POINT_COUNT)
-        priv->p.shader_desc.input_control_point_count = ins->declaration.count;
+        priv->p.program.input_control_point_count = ins->declaration.count;
     else
-        priv->p.shader_desc.output_control_point_count = ins->declaration.count;
+        priv->p.program.output_control_point_count = ins->declaration.count;
 }
 
 static void shader_sm5_read_dcl_tessellator_domain(struct vkd3d_shader_instruction *ins, uint32_t opcode,
@@ -1720,7 +1732,7 @@ static void shader_sm4_destroy(struct vkd3d_shader_parser *parser)
 {
     struct vkd3d_shader_sm4_parser *sm4 = vkd3d_shader_sm4_parser(parser);
 
-    shader_instruction_array_destroy(&parser->instructions);
+    vsir_program_cleanup(&parser->program);
     free_shader_desc(&parser->shader_desc);
     vkd3d_free(sm4);
 }
@@ -1759,11 +1771,11 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
     const struct vkd3d_sm4_register_type_info *register_type_info;
     enum vkd3d_shader_register_type vsir_register_type;
     enum vkd3d_sm4_register_precision precision;
+    uint32_t token, order, extended, addressing;
     enum vkd3d_sm4_register_type register_type;
     enum vkd3d_sm4_extended_operand_type type;
-    enum vkd3d_sm4_register_modifier m;
     enum vkd3d_sm4_dimension sm4_dimension;
-    uint32_t token, order, extended;
+    enum vkd3d_sm4_register_modifier m;
 
     if (*ptr >= end)
     {
@@ -1861,7 +1873,7 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
 
     if (order >= 1)
     {
-        DWORD addressing = (token & VKD3D_SM4_ADDRESSING_MASK0) >> VKD3D_SM4_ADDRESSING_SHIFT0;
+        addressing = (token & VKD3D_SM4_ADDRESSING_MASK0) >> VKD3D_SM4_ADDRESSING_SHIFT0;
         if (!(shader_sm4_read_reg_idx(priv, ptr, end, addressing, &param->idx[0])))
         {
             ERR("Failed to read register index.\n");
@@ -1871,7 +1883,7 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
 
     if (order >= 2)
     {
-        DWORD addressing = (token & VKD3D_SM4_ADDRESSING_MASK1) >> VKD3D_SM4_ADDRESSING_SHIFT1;
+        addressing = (token & VKD3D_SM4_ADDRESSING_MASK1) >> VKD3D_SM4_ADDRESSING_SHIFT1;
         if (!(shader_sm4_read_reg_idx(priv, ptr, end, addressing, &param->idx[1])))
         {
             ERR("Failed to read register index.\n");
@@ -1881,7 +1893,7 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
 
     if (order >= 3)
     {
-        DWORD addressing = (token & VKD3D_SM4_ADDRESSING_MASK2) >> VKD3D_SM4_ADDRESSING_SHIFT2;
+        addressing = (token & VKD3D_SM4_ADDRESSING_MASK2) >> VKD3D_SM4_ADDRESSING_SHIFT2;
         if (!(shader_sm4_read_reg_idx(priv, ptr, end, addressing, &param->idx[2])))
         {
             ERR("Failed to read register index.\n");
@@ -1900,19 +1912,19 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
 
     if (register_type == VKD3D_SM4_RT_IMMCONST || register_type == VKD3D_SM4_RT_IMMCONST64)
     {
-        unsigned int dword_count;
+        unsigned int u32_count;
 
         switch (param->dimension)
         {
             case VSIR_DIMENSION_SCALAR:
-                dword_count = 1 + (register_type == VKD3D_SM4_RT_IMMCONST64);
-                if (end - *ptr < dword_count)
+                u32_count = 1 + (register_type == VKD3D_SM4_RT_IMMCONST64);
+                if (end - *ptr < u32_count)
                 {
                     WARN("Invalid ptr %p, end %p.\n", *ptr, end);
                     return false;
                 }
-                memcpy(param->u.immconst_uint, *ptr, dword_count * sizeof(DWORD));
-                *ptr += dword_count;
+                memcpy(param->u.immconst_u32, *ptr, u32_count * sizeof(uint32_t));
+                *ptr += u32_count;
                 break;
 
             case VSIR_DIMENSION_VEC4:
@@ -1921,7 +1933,7 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
                     WARN("Invalid ptr %p, end %p.\n", *ptr, end);
                     return false;
                 }
-                memcpy(param->u.immconst_uint, *ptr, VKD3D_VEC4_SIZE * sizeof(DWORD));
+                memcpy(param->u.immconst_u32, *ptr, VKD3D_VEC4_SIZE * sizeof(uint32_t));
                 *ptr += 4;
                 break;
 
@@ -1930,6 +1942,15 @@ static bool shader_sm4_read_param(struct vkd3d_shader_sm4_parser *priv, const ui
                 break;
         }
     }
+    else if (register_type == VKD3D_SM4_RT_IMMCONSTBUFFER)
+    {
+        if (param->idx_count != 1)
+        {
+            WARN("Unexpected idx count %u.\n", param->idx_count);
+            vkd3d_shader_parser_error(&priv->p, VKD3D_SHADER_ERROR_TPF_INVALID_REGISTER_INDEX_COUNT,
+                    "Invalid index count %u for immediate const buffer register; expected count 1.", param->idx_count);
+        }
+    }
     else if (!shader_is_sm_5_1(priv) && vsir_register_is_descriptor(param))
     {
         /* SM5.1 places a symbol identifier in idx[0] and moves
@@ -1970,10 +1991,10 @@ static uint32_t swizzle_from_sm4(uint32_t s)
 static uint32_t swizzle_to_sm4(uint32_t s)
 {
     uint32_t ret = 0;
-    ret |= ((vkd3d_swizzle_get_component(s, 0)) & 0x3);
-    ret |= ((vkd3d_swizzle_get_component(s, 1)) & 0x3) << 2;
-    ret |= ((vkd3d_swizzle_get_component(s, 2)) & 0x3) << 4;
-    ret |= ((vkd3d_swizzle_get_component(s, 3)) & 0x3) << 6;
+    ret |= ((vsir_swizzle_get_component(s, 0)) & 0x3);
+    ret |= ((vsir_swizzle_get_component(s, 1)) & 0x3) << 2;
+    ret |= ((vsir_swizzle_get_component(s, 2)) & 0x3) << 4;
+    ret |= ((vsir_swizzle_get_component(s, 3)) & 0x3) << 6;
     return ret;
 }
 
@@ -1999,15 +2020,15 @@ static bool register_is_control_point_input(const struct vkd3d_shader_register *
 {
     return reg->type == VKD3DSPR_INCONTROLPOINT || reg->type == VKD3DSPR_OUTCONTROLPOINT
             || (reg->type == VKD3DSPR_INPUT && (priv->phase == VKD3DSIH_HS_CONTROL_POINT_PHASE
-            || priv->p.shader_version.type == VKD3D_SHADER_TYPE_GEOMETRY));
+            || priv->p.program.shader_version.type == VKD3D_SHADER_TYPE_GEOMETRY));
 }
 
-static unsigned int mask_from_swizzle(unsigned int swizzle)
+static uint32_t mask_from_swizzle(uint32_t swizzle)
 {
-    return (1u << vkd3d_swizzle_get_component(swizzle, 0))
-            | (1u << vkd3d_swizzle_get_component(swizzle, 1))
-            | (1u << vkd3d_swizzle_get_component(swizzle, 2))
-            | (1u << vkd3d_swizzle_get_component(swizzle, 3));
+    return (1u << vsir_swizzle_get_component(swizzle, 0))
+            | (1u << vsir_swizzle_get_component(swizzle, 1))
+            | (1u << vsir_swizzle_get_component(swizzle, 2))
+            | (1u << vsir_swizzle_get_component(swizzle, 3));
 }
 
 static bool shader_sm4_validate_input_output_register(struct vkd3d_shader_sm4_parser *priv,
@@ -2066,7 +2087,7 @@ static bool shader_sm4_read_src_param(struct vkd3d_shader_sm4_parser *priv, cons
         const uint32_t *end, enum vkd3d_data_type data_type, struct vkd3d_shader_src_param *src_param)
 {
     unsigned int dimension, mask;
-    DWORD token;
+    uint32_t token;
 
     if (*ptr >= end)
     {
@@ -2153,7 +2174,7 @@ static bool shader_sm4_read_dst_param(struct vkd3d_shader_sm4_parser *priv, cons
     enum vkd3d_sm4_swizzle_type swizzle_type;
     enum vkd3d_shader_src_modifier modifier;
     unsigned int dimension, swizzle;
-    DWORD token;
+    uint32_t token;
 
     if (*ptr >= end)
     {
@@ -2219,7 +2240,7 @@ static bool shader_sm4_read_dst_param(struct vkd3d_shader_sm4_parser *priv, cons
     }
 
     if (data_type == VKD3D_DATA_DOUBLE)
-        dst_param->write_mask = vkd3d_write_mask_64_from_32(dst_param->write_mask);
+        dst_param->write_mask = vsir_write_mask_64_from_32(dst_param->write_mask);
     /* Some scalar registers are declared with no write mask in shader bytecode. */
     if (!dst_param->write_mask && shader_sm4_is_scalar_register(&dst_param->reg))
         dst_param->write_mask = VKD3DSP_WRITEMASK_0;
@@ -2233,7 +2254,7 @@ static bool shader_sm4_read_dst_param(struct vkd3d_shader_sm4_parser *priv, cons
     return true;
 }
 
-static void shader_sm4_read_instruction_modifier(DWORD modifier, struct vkd3d_shader_instruction *ins)
+static void shader_sm4_read_instruction_modifier(uint32_t modifier, struct vkd3d_shader_instruction *ins)
 {
     enum vkd3d_sm4_instruction_modifier modifier_type = modifier & VKD3D_SM4_MODIFIER_MASK;
 
@@ -2241,7 +2262,7 @@ static void shader_sm4_read_instruction_modifier(DWORD modifier, struct vkd3d_sh
     {
         case VKD3D_SM4_MODIFIER_AOFFIMMI:
         {
-            static const DWORD recognized_bits = VKD3D_SM4_INSTRUCTION_MODIFIER
+            static const uint32_t recognized_bits = VKD3D_SM4_INSTRUCTION_MODIFIER
                     | VKD3D_SM4_MODIFIER_MASK
                     | VKD3D_SM4_AOFFIMMI_U_MASK
                     | VKD3D_SM4_AOFFIMMI_V_MASK
@@ -2269,7 +2290,7 @@ static void shader_sm4_read_instruction_modifier(DWORD modifier, struct vkd3d_sh
 
         case VKD3D_SM5_MODIFIER_DATA_TYPE:
         {
-            DWORD components = (modifier & VKD3D_SM5_MODIFIER_DATA_TYPE_MASK) >> VKD3D_SM5_MODIFIER_DATA_TYPE_SHIFT;
+            uint32_t components = (modifier & VKD3D_SM5_MODIFIER_DATA_TYPE_MASK) >> VKD3D_SM5_MODIFIER_DATA_TYPE_SHIFT;
             unsigned int i;
 
             for (i = 0; i < VKD3D_VEC4_SIZE; i++)
@@ -2325,9 +2346,9 @@ static void shader_sm4_read_instruction(struct vkd3d_shader_sm4_parser *sm4, str
     struct vkd3d_shader_src_param *src_params;
     const uint32_t **ptr = &sm4->ptr;
     unsigned int i, len;
-    size_t remaining;
     const uint32_t *p;
-    DWORD precise;
+    uint32_t precise;
+    size_t remaining;
 
     if (*ptr >= sm4->end)
     {
@@ -2533,6 +2554,16 @@ static bool shader_sm4_init(struct vkd3d_shader_sm4_parser *sm4, const uint32_t
     return true;
 }
 
+static void uninvert_used_masks(struct shader_signature *signature)
+{
+    for (unsigned int i = 0; i < signature->element_count; ++i)
+    {
+        struct signature_element *e = &signature->elements[i];
+
+        e->used_mask = e->mask & ~e->used_mask;
+    }
+}
+
 static bool shader_sm4_parser_validate_signature(struct vkd3d_shader_sm4_parser *sm4,
         const struct shader_signature *signature, unsigned int *masks, const char *name)
 {
@@ -2628,6 +2659,12 @@ int vkd3d_shader_sm4_parser_create(const struct vkd3d_shader_compile_info *compi
         return VKD3D_ERROR_INVALID_ARGUMENT;
     }
 
+    /* DXBC stores used masks inverted for output signatures, for some reason.
+     * We return them un-inverted. */
+    uninvert_used_masks(&shader_desc->output_signature);
+    if (sm4->p.program.shader_version.type == VKD3D_SHADER_TYPE_HULL)
+        uninvert_used_masks(&shader_desc->patch_constant_signature);
+
     if (!shader_sm4_parser_validate_signature(sm4, &shader_desc->input_signature,
             sm4->input_register_masks, "Input")
             || !shader_sm4_parser_validate_signature(sm4, &shader_desc->output_signature,
@@ -2639,7 +2676,7 @@ int vkd3d_shader_sm4_parser_create(const struct vkd3d_shader_compile_info *compi
         return VKD3D_ERROR_INVALID_SHADER;
     }
 
-    instructions = &sm4->p.instructions;
+    instructions = &sm4->p.program.instructions;
     while (sm4->ptr != sm4->end)
     {
         if (!shader_instruction_array_reserve(instructions, instructions->count + 1))
@@ -2660,7 +2697,8 @@ int vkd3d_shader_sm4_parser_create(const struct vkd3d_shader_compile_info *compi
         }
         ++instructions->count;
     }
-    if (sm4->p.shader_version.type == VKD3D_SHADER_TYPE_HULL && !sm4->has_control_point_phase && !sm4->p.failed)
+    if (sm4->p.program.shader_version.type == VKD3D_SHADER_TYPE_HULL
+            && !sm4->has_control_point_phase && !sm4->p.failed)
         shader_sm4_validate_default_phase_index_ranges(sm4);
 
     if (!sm4->p.failed)
@@ -2769,6 +2807,8 @@ bool hlsl_sm4_usage_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_semant
         {"position",                    false, VKD3D_SHADER_TYPE_PIXEL,     D3D_NAME_POSITION},
         {"sv_position",                 false, VKD3D_SHADER_TYPE_PIXEL,     D3D_NAME_POSITION},
         {"sv_isfrontface",              false, VKD3D_SHADER_TYPE_PIXEL,     D3D_NAME_IS_FRONT_FACE},
+        {"sv_rendertargetarrayindex",   false, VKD3D_SHADER_TYPE_PIXEL,     D3D_NAME_RENDER_TARGET_ARRAY_INDEX},
+        {"sv_viewportarrayindex",       false, VKD3D_SHADER_TYPE_PIXEL,     D3D_NAME_VIEWPORT_ARRAY_INDEX},
 
         {"color",                       true,  VKD3D_SHADER_TYPE_PIXEL,     D3D_NAME_TARGET},
         {"depth",                       true,  VKD3D_SHADER_TYPE_PIXEL,     D3D_NAME_DEPTH},
@@ -2777,9 +2817,12 @@ bool hlsl_sm4_usage_from_semantic(struct hlsl_ctx *ctx, const struct hlsl_semant
 
         {"sv_position",                 false, VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_UNDEFINED},
         {"sv_vertexid",                 false, VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_VERTEX_ID},
+        {"sv_instanceid",               false, VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_INSTANCE_ID},
 
         {"position",                    true,  VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_POSITION},
         {"sv_position",                 true,  VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_POSITION},
+        {"sv_rendertargetarrayindex",   true,  VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_RENDER_TARGET_ARRAY_INDEX},
+        {"sv_viewportarrayindex",       true,  VKD3D_SHADER_TYPE_VERTEX,    D3D_NAME_VIEWPORT_ARRAY_INDEX},
     };
     bool needs_compat_mapping = ascii_strncasecmp(semantic->name, "sv_", 3);
 
@@ -3842,7 +3885,7 @@ static void sm4_src_from_constant_value(struct vkd3d_shader_src_param *src,
     if (width == 1)
     {
         src->reg.dimension = VSIR_DIMENSION_SCALAR;
-        src->reg.u.immconst_uint[0] = value->u[0].u;
+        src->reg.u.immconst_u32[0] = value->u[0].u;
     }
     else
     {
@@ -3852,9 +3895,9 @@ static void sm4_src_from_constant_value(struct vkd3d_shader_src_param *src,
         for (i = 0; i < 4; ++i)
         {
             if ((map_writemask & (1u << i)) && (j < width))
-                src->reg.u.immconst_uint[i] = value->u[j++].u;
+                src->reg.u.immconst_u32[i] = value->u[j++].u;
             else
-                src->reg.u.immconst_uint[i] = 0;
+                src->reg.u.immconst_u32[i] = 0;
         }
     }
 }
@@ -4049,12 +4092,12 @@ static void sm4_write_src_register(const struct tpf_writer *tpf, const struct vk
 
     if (src->reg.type == VKD3DSPR_IMMCONST)
     {
-        put_u32(buffer, src->reg.u.immconst_uint[0]);
+        put_u32(buffer, src->reg.u.immconst_u32[0]);
         if (src->reg.dimension == VSIR_DIMENSION_VEC4)
         {
-            put_u32(buffer, src->reg.u.immconst_uint[1]);
-            put_u32(buffer, src->reg.u.immconst_uint[2]);
-            put_u32(buffer, src->reg.u.immconst_uint[3]);
+            put_u32(buffer, src->reg.u.immconst_u32[1]);
+            put_u32(buffer, src->reg.u.immconst_u32[2]);
+            put_u32(buffer, src->reg.u.immconst_u32[3]);
         }
     }
 }
@@ -4589,7 +4632,7 @@ static void write_sm4_ld(const struct tpf_writer *tpf, const struct hlsl_ir_node
             memset(&instr.srcs[2], 0, sizeof(instr.srcs[2]));
             reg->type = VKD3DSPR_IMMCONST;
             reg->dimension = VSIR_DIMENSION_SCALAR;
-            reg->u.immconst_uint[0] = index->value.u[0].u;
+            reg->u.immconst_u32[0] = index->value.u[0].u;
         }
         else if (tpf->ctx->profile->major_version == 4 && tpf->ctx->profile->minor_version == 0)
         {
@@ -4750,7 +4793,7 @@ static void write_sm4_cast_from_bool(const struct tpf_writer *tpf, const struct
     sm4_src_from_node(tpf, &instr.srcs[0], arg, instr.dsts[0].write_mask);
     instr.srcs[1].reg.type = VKD3DSPR_IMMCONST;
     instr.srcs[1].reg.dimension = VSIR_DIMENSION_SCALAR;
-    instr.srcs[1].reg.u.immconst_uint[0] = mask;
+    instr.srcs[1].reg.u.immconst_u32[0] = mask;
     instr.src_count = 2;
 
     write_sm4_instruction(tpf, &instr);
@@ -5460,7 +5503,7 @@ static void write_sm4_loop(const struct tpf_writer *tpf, const struct hlsl_ir_lo
 
 static void write_sm4_gather(const struct tpf_writer *tpf, const struct hlsl_ir_node *dst,
         const struct hlsl_deref *resource, const struct hlsl_deref *sampler,
-        const struct hlsl_ir_node *coords, DWORD swizzle, const struct hlsl_ir_node *texel_offset)
+        const struct hlsl_ir_node *coords, uint32_t swizzle, const struct hlsl_ir_node *texel_offset)
 {
     struct vkd3d_shader_src_param *src;
     struct sm4_instruction instr;
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
index 8fd8945..1b7ea8d 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_main.c
@@ -23,6 +23,8 @@
 #include <stdio.h>
 #include <math.h>
 
+/* VKD3D_DEBUG_ENV_NAME("VKD3D_SHADER_DEBUG"); */
+
 static inline int char_to_int(char c)
 {
     if ('0' <= c && c <= '9')
@@ -305,6 +307,16 @@ void vkd3d_shader_vwarning(struct vkd3d_shader_message_context *context, const s
     vkd3d_string_buffer_printf(&context->messages, "\n");
 }
 
+void vkd3d_shader_warning(struct vkd3d_shader_message_context *context, const struct vkd3d_shader_location *location,
+        enum vkd3d_shader_error error, const char *format, ...)
+{
+    va_list args;
+
+    va_start(args, format);
+    vkd3d_shader_vwarning(context, location, error, format, args);
+    va_end(args);
+}
+
 void vkd3d_shader_verror(struct vkd3d_shader_message_context *context, const struct vkd3d_shader_location *location,
         enum vkd3d_shader_error error, const char *format, va_list args)
 {
@@ -371,13 +383,42 @@ size_t bytecode_put_bytes(struct vkd3d_bytecode_buffer *buffer, const void *byte
     return offset;
 }
 
-void set_u32(struct vkd3d_bytecode_buffer *buffer, size_t offset, uint32_t value)
+size_t bytecode_reserve_bytes(struct vkd3d_bytecode_buffer *buffer, size_t size)
+{
+    size_t offset = bytecode_align(buffer);
+
+    if (buffer->status)
+        return offset;
+
+    if (!vkd3d_array_reserve((void **)&buffer->data, &buffer->capacity, offset + size, 1))
+    {
+        buffer->status = VKD3D_ERROR_OUT_OF_MEMORY;
+        return offset;
+    }
+
+    memset(buffer->data + offset, 0, size);
+    buffer->size = offset + size;
+    return offset;
+}
+
+static void bytecode_set_bytes(struct vkd3d_bytecode_buffer *buffer, size_t offset,
+        const void *value, size_t size)
 {
     if (buffer->status)
         return;
 
-    assert(vkd3d_bound_range(offset, sizeof(value), buffer->size));
-    memcpy(buffer->data + offset, &value, sizeof(value));
+    assert(vkd3d_bound_range(offset, size, buffer->size));
+    memcpy(buffer->data + offset, value, size);
+}
+
+void set_u32(struct vkd3d_bytecode_buffer *buffer, size_t offset, uint32_t value)
+{
+    bytecode_set_bytes(buffer, offset, &value, sizeof(value));
+}
+
+void set_string(struct vkd3d_bytecode_buffer *buffer, size_t offset, const char *string, size_t length)
+{
+    bytecode_set_bytes(buffer, offset, string, length);
 }
 
 static void vkd3d_shader_dump_blob(const char *path, const char *profile,
@@ -498,10 +539,9 @@ bool vkd3d_shader_parser_init(struct vkd3d_shader_parser *parser,
     parser->location.source_name = source_name;
     parser->location.line = 1;
     parser->location.column = 0;
-    parser->shader_version = *version;
     parser->ops = ops;
     parser->config_flags = vkd3d_shader_init_config_flags();
-    return shader_instruction_array_init(&parser->instructions, instruction_reserve);
+    return vsir_program_init(&parser->program, version, instruction_reserve);
 }
 
 void VKD3D_PRINTF_FUNC(3, 4) vkd3d_shader_parser_error(struct vkd3d_shader_parser *parser,
@@ -888,6 +928,21 @@ static void vkd3d_shader_scan_combined_sampler_declaration(
             &semantic->resource.range, semantic->resource_type, VKD3D_SHADER_RESOURCE_DATA_FLOAT);
 }
 
+static const struct vkd3d_shader_descriptor_info1 *find_descriptor(
+        const struct vkd3d_shader_scan_descriptor_info1 *info,
+        enum vkd3d_shader_descriptor_type type, unsigned int register_id)
+{
+    for (unsigned int i = 0; i < info->descriptor_count; ++i)
+    {
+        const struct vkd3d_shader_descriptor_info1 *d = &info->descriptors[i];
+
+        if (d->type == type && d->register_id == register_id)
+            return d;
+    }
+
+    return NULL;
+}
+
 static void vkd3d_shader_scan_combined_sampler_usage(struct vkd3d_shader_scan_context *context,
         const struct vkd3d_shader_register *resource, const struct vkd3d_shader_register *sampler)
 {
@@ -913,7 +968,6 @@ static void vkd3d_shader_scan_combined_sampler_usage(struct vkd3d_shader_scan_co
 
     if (vkd3d_shader_ver_ge(context->version, 5, 1))
     {
-        const struct vkd3d_shader_scan_descriptor_info1 *info = context->scan_descriptor_info;
         const struct vkd3d_shader_descriptor_info1 *d;
         bool dynamic_resource, dynamic_sampler;
 
@@ -928,30 +982,13 @@ static void vkd3d_shader_scan_combined_sampler_usage(struct vkd3d_shader_scan_co
         if (dynamic_resource || dynamic_sampler)
             return;
 
-        for (i = 0; i < info->descriptor_count; ++i)
-        {
-            d = &info->descriptors[i];
-            if (d->type != VKD3D_SHADER_DESCRIPTOR_TYPE_SRV)
-                continue;
-            if (d->register_id != resource->idx[0].offset)
-                continue;
+        if ((d = find_descriptor(context->scan_descriptor_info,
+                VKD3D_SHADER_DESCRIPTOR_TYPE_SRV, resource->idx[0].offset)))
             resource_space = d->register_space;
-            break;
-        }
 
-        if (sampler)
-        {
-            for (i = 0; i < info->descriptor_count; ++i)
-            {
-                d = &info->descriptors[i];
-                if (d->type != VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER)
-                    continue;
-                if (d->register_id != sampler->idx[0].offset)
-                    continue;
-                sampler_space = d->register_space;
-                break;
-            }
-        }
+        if (sampler && (d = find_descriptor(context->scan_descriptor_info,
+                VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER, sampler->idx[0].offset)))
+            sampler_space = d->register_space;
     }
 
     for (i = 0; i < info->combined_sampler_count; ++i)
@@ -979,7 +1016,7 @@ static void vkd3d_shader_scan_combined_sampler_usage(struct vkd3d_shader_scan_co
 static void vkd3d_shader_scan_resource_declaration(struct vkd3d_shader_scan_context *context,
         const struct vkd3d_shader_resource *resource, enum vkd3d_shader_resource_type resource_type,
         enum vkd3d_shader_resource_data_type resource_data_type,
-        unsigned int sample_count, unsigned int structure_stride, bool raw)
+        unsigned int sample_count, unsigned int structure_stride, bool raw, uint32_t flags)
 {
     struct vkd3d_shader_descriptor_info1 *d;
     enum vkd3d_shader_descriptor_type type;
@@ -995,6 +1032,8 @@ static void vkd3d_shader_scan_resource_declaration(struct vkd3d_shader_scan_cont
     d->structure_stride = structure_stride;
     if (raw)
         d->flags |= VKD3D_SHADER_DESCRIPTOR_INFO_FLAG_RAW_BUFFER;
+    if (type == VKD3D_SHADER_DESCRIPTOR_TYPE_UAV)
+        d->uav_flags = flags;
 }
 
 static void vkd3d_shader_scan_typed_resource_declaration(struct vkd3d_shader_scan_context *context,
@@ -1053,7 +1092,7 @@ static void vkd3d_shader_scan_typed_resource_declaration(struct vkd3d_shader_sca
     }
 
     vkd3d_shader_scan_resource_declaration(context, &semantic->resource,
-            semantic->resource_type, resource_data_type, semantic->sample_count, 0, false);
+            semantic->resource_type, resource_data_type, semantic->sample_count, 0, false, instruction->flags);
 }
 
 static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *context,
@@ -1074,6 +1113,9 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
             vkd3d_shader_scan_sampler_declaration(context, instruction);
             break;
         case VKD3DSIH_DCL:
+            if (instruction->declaration.semantic.resource_type == VKD3D_SHADER_RESOURCE_NONE)
+                break;
+
             if (instruction->declaration.semantic.resource.reg.reg.type == VKD3DSPR_COMBINED_SAMPLER)
             {
                 vkd3d_shader_scan_combined_sampler_declaration(context, &instruction->declaration.semantic);
@@ -1086,15 +1128,16 @@ static int vkd3d_shader_scan_instruction(struct vkd3d_shader_scan_context *conte
         case VKD3DSIH_DCL_RESOURCE_RAW:
         case VKD3DSIH_DCL_UAV_RAW:
             vkd3d_shader_scan_resource_declaration(context, &instruction->declaration.raw_resource.resource,
-                    VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_SHADER_RESOURCE_DATA_UINT, 0, 0, true);
+                    VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_SHADER_RESOURCE_DATA_UINT, 0, 0, true, instruction->flags);
             break;
         case VKD3DSIH_DCL_RESOURCE_STRUCTURED:
         case VKD3DSIH_DCL_UAV_STRUCTURED:
             vkd3d_shader_scan_resource_declaration(context, &instruction->declaration.structured_resource.resource,
                     VKD3D_SHADER_RESOURCE_BUFFER, VKD3D_SHADER_RESOURCE_DATA_UINT, 0,
-                    instruction->declaration.structured_resource.byte_stride, false);
+                    instruction->declaration.structured_resource.byte_stride, false, instruction->flags);
             break;
         case VKD3DSIH_IF:
+        case VKD3DSIH_IFC:
             cf_info = vkd3d_shader_scan_push_cf_info(context);
             cf_info->type = VKD3D_SHADER_BLOCK_IF;
             cf_info->inside_block = true;
@@ -1361,17 +1404,15 @@ static int scan_with_parser(const struct vkd3d_shader_compile_info *compile_info
             descriptor_info1 = &local_descriptor_info1;
     }
 
-    vkd3d_shader_scan_context_init(&context, &parser->shader_version, compile_info,
+    vkd3d_shader_scan_context_init(&context, &parser->program.shader_version, compile_info,
             descriptor_info1, combined_sampler_info, message_context);
 
     if (TRACE_ON())
-    {
-        vkd3d_shader_trace(&parser->instructions, &parser->shader_version);
-    }
+        vkd3d_shader_trace(&parser->program);
 
-    for (i = 0; i < parser->instructions.count; ++i)
+    for (i = 0; i < parser->program.instructions.count; ++i)
     {
-        instruction = &parser->instructions.elements[i];
+        instruction = &parser->program.instructions.elements[i];
         if ((ret = vkd3d_shader_scan_instruction(&context, instruction)) < 0)
             break;
     }
@@ -1541,17 +1582,16 @@ static int vkd3d_shader_parser_compile(struct vkd3d_shader_parser *parser,
 
     scan_info = *compile_info;
 
-    if ((ret = scan_with_parser(&scan_info, message_context, &scan_descriptor_info, parser)) < 0)
-        return ret;
-
     switch (compile_info->target_type)
     {
         case VKD3D_SHADER_TARGET_D3D_ASM:
-            ret = vkd3d_dxbc_binary_to_text(&parser->instructions, &parser->shader_version, compile_info, out);
+            ret = vkd3d_dxbc_binary_to_text(&parser->program, compile_info, out, VSIR_ASM_D3D);
             break;
 
         case VKD3D_SHADER_TARGET_GLSL:
-            if (!(glsl_generator = vkd3d_glsl_generator_create(&parser->shader_version,
+            if ((ret = scan_with_parser(&scan_info, message_context, &scan_descriptor_info, parser)) < 0)
+                return ret;
+            if (!(glsl_generator = vkd3d_glsl_generator_create(&parser->program.shader_version,
                     message_context, &parser->location)))
             {
                 ERR("Failed to create GLSL generator.\n");
@@ -1559,21 +1599,24 @@ static int vkd3d_shader_parser_compile(struct vkd3d_shader_parser *parser,
                 return VKD3D_ERROR;
             }
 
-            ret = vkd3d_glsl_generator_generate(glsl_generator, parser, out);
+            ret = vkd3d_glsl_generator_generate(glsl_generator, &parser->program, out);
             vkd3d_glsl_generator_destroy(glsl_generator);
+            vkd3d_shader_free_scan_descriptor_info1(&scan_descriptor_info);
             break;
 
         case VKD3D_SHADER_TARGET_SPIRV_BINARY:
         case VKD3D_SHADER_TARGET_SPIRV_TEXT:
+            if ((ret = scan_with_parser(&scan_info, message_context, &scan_descriptor_info, parser)) < 0)
+                return ret;
             ret = spirv_compile(parser, &scan_descriptor_info, compile_info, out, message_context);
+            vkd3d_shader_free_scan_descriptor_info1(&scan_descriptor_info);
             break;
 
         default:
             /* Validation should prevent us from reaching this. */
-            assert(0);
+            vkd3d_unreachable();
     }
 
-    vkd3d_shader_free_scan_descriptor_info1(&scan_descriptor_info);
     return ret;
 }
 
@@ -1622,14 +1665,10 @@ static int compile_d3d_bytecode(const struct vkd3d_shader_compile_info *compile_
         return ret;
     }
 
-    if (compile_info->target_type == VKD3D_SHADER_TARGET_D3D_ASM)
-    {
-        ret = vkd3d_dxbc_binary_to_text(&parser->instructions, &parser->shader_version, compile_info, out);
-        vkd3d_shader_parser_destroy(parser);
-        return ret;
-    }
+    ret = vkd3d_shader_parser_compile(parser, compile_info, out, message_context);
 
-    return VKD3D_ERROR;
+    vkd3d_shader_parser_destroy(parser);
+    return ret;
 }
 
 static int compile_dxbc_dxil(const struct vkd3d_shader_compile_info *compile_info,
@@ -1903,10 +1942,15 @@ const enum vkd3d_shader_target_type *vkd3d_shader_get_supported_target_types(
     {
         VKD3D_SHADER_TARGET_D3D_BYTECODE,
         VKD3D_SHADER_TARGET_DXBC_TPF,
+        VKD3D_SHADER_TARGET_FX,
     };
 
     static const enum vkd3d_shader_target_type d3dbc_types[] =
     {
+        VKD3D_SHADER_TARGET_SPIRV_BINARY,
+#ifdef HAVE_SPIRV_TOOLS
+        VKD3D_SHADER_TARGET_SPIRV_TEXT,
+#endif
         VKD3D_SHADER_TARGET_D3D_ASM,
     };
 
@@ -2043,6 +2087,23 @@ bool shader_instruction_array_reserve(struct vkd3d_shader_instruction_array *ins
     return true;
 }
 
+bool shader_instruction_array_insert_at(struct vkd3d_shader_instruction_array *instructions,
+        unsigned int idx, unsigned int count)
+{
+    assert(idx <= instructions->count);
+
+    if (!shader_instruction_array_reserve(instructions, instructions->count + count))
+        return false;
+
+    memmove(&instructions->elements[idx + count], &instructions->elements[idx],
+            (instructions->count - idx) * sizeof(*instructions->elements));
+    memset(&instructions->elements[idx], 0, count * sizeof(*instructions->elements));
+
+    instructions->count += count;
+
+    return true;
+}
+
 bool shader_instruction_array_add_icb(struct vkd3d_shader_instruction_array *instructions,
         struct vkd3d_shader_immediate_constant_buffer *icb)
 {
diff --git a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
index a93fa71..fd0f2f0 100644
--- a/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
+++ b/libs/vkd3d/libs/vkd3d-shader/vkd3d_shader_private.h
@@ -91,13 +91,15 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_SPV_INVALID_REGISTER_TYPE        = 2001,
     VKD3D_SHADER_ERROR_SPV_INVALID_DESCRIPTOR_BINDING   = 2002,
     VKD3D_SHADER_ERROR_SPV_DESCRIPTOR_IDX_UNSUPPORTED   = 2003,
-    VKD3D_SHADER_ERROR_SPV_STENCIL_EXPORT_UNSUPPORTED   = 2004,
+    VKD3D_SHADER_ERROR_SPV_UNSUPPORTED_FEATURE          = 2004,
     VKD3D_SHADER_ERROR_SPV_OUT_OF_MEMORY                = 2005,
     VKD3D_SHADER_ERROR_SPV_INVALID_TYPE                 = 2006,
     VKD3D_SHADER_ERROR_SPV_INVALID_HANDLER              = 2007,
     VKD3D_SHADER_ERROR_SPV_NOT_IMPLEMENTED              = 2008,
+    VKD3D_SHADER_ERROR_SPV_INVALID_SHADER               = 2009,
 
     VKD3D_SHADER_WARNING_SPV_INVALID_SWIZZLE            = 2300,
+    VKD3D_SHADER_WARNING_SPV_INVALID_UAV_FLAGS          = 2301,
 
     VKD3D_SHADER_ERROR_RS_OUT_OF_MEMORY                 = 3000,
     VKD3D_SHADER_ERROR_RS_INVALID_VERSION               = 3001,
@@ -196,6 +198,7 @@ enum vkd3d_shader_error
     VKD3D_SHADER_WARNING_DXIL_ENTRY_POINT_MISMATCH      = 8306,
     VKD3D_SHADER_WARNING_DXIL_INVALID_MASK              = 8307,
     VKD3D_SHADER_WARNING_DXIL_INVALID_OPERATION         = 8308,
+    VKD3D_SHADER_WARNING_DXIL_IGNORING_ATTACHMENT       = 8309,
 
     VKD3D_SHADER_ERROR_VSIR_NOT_IMPLEMENTED             = 9000,
     VKD3D_SHADER_ERROR_VSIR_INVALID_HANDLER             = 9001,
@@ -213,7 +216,8 @@ enum vkd3d_shader_error
     VKD3D_SHADER_ERROR_VSIR_DUPLICATE_DCL_TEMPS         = 9013,
     VKD3D_SHADER_ERROR_VSIR_INVALID_DCL_TEMPS           = 9014,
     VKD3D_SHADER_ERROR_VSIR_INVALID_INDEX               = 9015,
-    VKD3D_SHADER_ERROR_VSIR_INVALID_INSTRUCTION_NESTING = 9016,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_CONTROL_FLOW        = 9016,
+    VKD3D_SHADER_ERROR_VSIR_INVALID_SSA_USAGE           = 9017,
 
     VKD3D_SHADER_WARNING_VSIR_DYNAMIC_DESCRIPTOR_ARRAY  = 9300,
 };
@@ -235,6 +239,7 @@ enum vkd3d_shader_opcode
     VKD3DSIH_BEM,
     VKD3DSIH_BFI,
     VKD3DSIH_BFREV,
+    VKD3DSIH_BRANCH,
     VKD3DSIH_BREAK,
     VKD3DSIH_BREAKC,
     VKD3DSIH_BREAKP,
@@ -388,8 +393,11 @@ enum vkd3d_shader_opcode
     VKD3DSIH_IMUL,
     VKD3DSIH_INE,
     VKD3DSIH_INEG,
+    VKD3DSIH_ISFINITE,
     VKD3DSIH_ISHL,
     VKD3DSIH_ISHR,
+    VKD3DSIH_ISINF,
+    VKD3DSIH_ISNAN,
     VKD3DSIH_ITOD,
     VKD3DSIH_ITOF,
     VKD3DSIH_ITOI,
@@ -432,6 +440,7 @@ enum vkd3d_shader_opcode
     VKD3DSIH_NRM,
     VKD3DSIH_OR,
     VKD3DSIH_PHASE,
+    VKD3DSIH_PHI,
     VKD3DSIH_POW,
     VKD3DSIH_RCP,
     VKD3DSIH_REP,
@@ -469,7 +478,9 @@ enum vkd3d_shader_opcode
     VKD3DSIH_SUB,
     VKD3DSIH_SWAPC,
     VKD3DSIH_SWITCH,
+    VKD3DSIH_SWITCH_MONOLITHIC,
     VKD3DSIH_SYNC,
+    VKD3DSIH_TAN,
     VKD3DSIH_TEX,
     VKD3DSIH_TEXBEM,
     VKD3DSIH_TEXBEML,
@@ -618,6 +629,11 @@ static inline bool data_type_is_bool(enum vkd3d_data_type data_type)
     return data_type == VKD3D_DATA_BOOL;
 }
 
+static inline bool data_type_is_64_bit(enum vkd3d_data_type data_type)
+{
+    return data_type == VKD3D_DATA_DOUBLE || data_type == VKD3D_DATA_UINT64;
+}
+
 enum vsir_dimension
 {
     VSIR_DIMENSION_NONE,
@@ -716,6 +732,7 @@ enum vkd3d_shader_sync_flags
 {
     VKD3DSSF_THREAD_GROUP        = 0x1,
     VKD3DSSF_GROUP_SHARED_MEMORY = 0x2,
+    VKD3DSSF_THREAD_GROUP_UAV    = 0x4,
     VKD3DSSF_GLOBAL_UAV          = 0x8,
 };
 
@@ -740,6 +757,7 @@ enum vkd3d_tessellator_domain
 #define VKD3DSI_RESINFO_UINT            0x2
 #define VKD3DSI_SAMPLE_INFO_UINT        0x1
 #define VKD3DSI_SAMPLER_COMPARISON_MODE 0x1
+#define VKD3DSI_SHIFT_UNMASKED          0x1
 
 #define VKD3DSI_PRECISE_X         0x100
 #define VKD3DSI_PRECISE_Y         0x200
@@ -793,10 +811,12 @@ struct vkd3d_shader_version
 
 struct vkd3d_shader_immediate_constant_buffer
 {
+    unsigned int register_idx;
     enum vkd3d_data_type data_type;
     /* total count is element_count * component_count */
     unsigned int element_count;
     unsigned int component_count;
+    bool is_null;
     uint32_t data[];
 };
 
@@ -807,12 +827,13 @@ struct vkd3d_shader_indexable_temp
     unsigned int alignment;
     enum vkd3d_data_type data_type;
     unsigned int component_count;
+    bool has_function_scope;
     const struct vkd3d_shader_immediate_constant_buffer *initialiser;
 };
 
 struct vkd3d_shader_register_index
 {
-    const struct vkd3d_shader_src_param *rel_addr;
+    struct vkd3d_shader_src_param *rel_addr;
     unsigned int offset;
     /* address is known to fall within the object (for optimisation) */
     bool is_in_bounds;
@@ -831,10 +852,10 @@ struct vkd3d_shader_register
     unsigned int alignment;
     union
     {
-        DWORD immconst_uint[VKD3D_VEC4_SIZE];
-        float immconst_float[VKD3D_VEC4_SIZE];
-        uint64_t immconst_uint64[VKD3D_DVEC2_SIZE];
-        double immconst_double[VKD3D_DVEC2_SIZE];
+        uint32_t immconst_u32[VKD3D_VEC4_SIZE];
+        float immconst_f32[VKD3D_VEC4_SIZE];
+        uint64_t immconst_u64[VKD3D_DVEC2_SIZE];
+        double immconst_f64[VKD3D_DVEC2_SIZE];
         unsigned fp_body_idx;
     } u;
 };
@@ -861,17 +882,21 @@ struct vkd3d_shader_dst_param
 {
     struct vkd3d_shader_register reg;
     uint32_t write_mask;
-    DWORD modifiers;
-    DWORD shift;
+    uint32_t modifiers;
+    unsigned int shift;
 };
 
 struct vkd3d_shader_src_param
 {
     struct vkd3d_shader_register reg;
-    DWORD swizzle;
+    uint32_t swizzle;
     enum vkd3d_shader_src_modifier modifiers;
 };
 
+void vsir_src_param_init(struct vkd3d_shader_src_param *param, enum vkd3d_shader_register_type reg_type,
+        enum vkd3d_data_type data_type, unsigned int idx_count);
+void vsir_src_param_init_label(struct vkd3d_shader_src_param *param, unsigned int label_id);
+
 struct vkd3d_shader_index_range
 {
     struct vkd3d_shader_dst_param dst;
@@ -945,6 +970,9 @@ enum vkd3d_shader_input_sysval_semantic
     VKD3D_SIV_LINE_DENSITY_TESS_FACTOR     = 22,
 };
 
+#define SM1_COLOR_REGISTER_OFFSET 8
+#define SM1_RASTOUT_REGISTER_OFFSET 10
+
 #define SIGNATURE_TARGET_LOCATION_UNUSED (~0u)
 
 struct signature_element
@@ -998,17 +1026,10 @@ struct vkd3d_shader_desc
     struct shader_signature output_signature;
     struct shader_signature patch_constant_signature;
 
-    unsigned int input_control_point_count, output_control_point_count;
-
-    uint32_t temp_count;
-    unsigned int ssa_count;
-
     struct
     {
         uint32_t used, external;
     } flat_constant_count[3];
-
-    bool use_vocp;
 };
 
 struct vkd3d_shader_register_semantic
@@ -1110,11 +1131,11 @@ struct vkd3d_shader_instruction
 {
     struct vkd3d_shader_location location;
     enum vkd3d_shader_opcode handler_idx;
-    DWORD flags;
+    uint32_t flags;
     unsigned int dst_count;
     unsigned int src_count;
-    const struct vkd3d_shader_dst_param *dst;
-    const struct vkd3d_shader_src_param *src;
+    struct vkd3d_shader_dst_param *dst;
+    struct vkd3d_shader_src_param *src;
     struct vkd3d_shader_texel_offset texel_offset;
     enum vkd3d_shader_resource_type resource_type;
     unsigned int resource_stride;
@@ -1171,6 +1192,22 @@ static inline bool register_is_constant(const struct vkd3d_shader_register *reg)
     return (reg->type == VKD3DSPR_IMMCONST || reg->type == VKD3DSPR_IMMCONST64);
 }
 
+static inline bool register_is_scalar_constant_zero(const struct vkd3d_shader_register *reg)
+{
+    return register_is_constant(reg) && reg->dimension == VSIR_DIMENSION_SCALAR
+            && (data_type_is_64_bit(reg->data_type) ? !reg->u.immconst_u64[0] : !reg->u.immconst_u32[0]);
+}
+
+static inline bool vsir_register_is_label(const struct vkd3d_shader_register *reg)
+{
+    return reg->type == VKD3DSPR_LABEL;
+}
+
+static inline bool register_is_ssa(const struct vkd3d_shader_register *reg)
+{
+    return reg->type == VKD3DSPR_SSA;
+}
+
 struct vkd3d_shader_param_node
 {
     struct vkd3d_shader_param_node *next;
@@ -1217,6 +1254,8 @@ struct vkd3d_shader_instruction_array
 
 bool shader_instruction_array_init(struct vkd3d_shader_instruction_array *instructions, unsigned int reserve);
 bool shader_instruction_array_reserve(struct vkd3d_shader_instruction_array *instructions, unsigned int reserve);
+bool shader_instruction_array_insert_at(struct vkd3d_shader_instruction_array *instructions,
+        unsigned int idx, unsigned int count);
 bool shader_instruction_array_add_icb(struct vkd3d_shader_instruction_array *instructions,
         struct vkd3d_shader_immediate_constant_buffer *icb);
 bool shader_instruction_array_clone_instruction(struct vkd3d_shader_instruction_array *instructions,
@@ -1228,6 +1267,24 @@ enum vkd3d_shader_config_flags
     VKD3D_SHADER_CONFIG_FLAG_FORCE_VALIDATION = 0x00000001,
 };
 
+struct vsir_program
+{
+    struct vkd3d_shader_version shader_version;
+    struct vkd3d_shader_instruction_array instructions;
+
+    unsigned int input_control_point_count, output_control_point_count;
+    unsigned int block_count;
+    unsigned int temp_count;
+    unsigned int ssa_count;
+    bool use_vocp;
+
+    const char **block_names;
+    size_t block_name_count;
+};
+
+bool vsir_program_init(struct vsir_program *program, const struct vkd3d_shader_version *version, unsigned int reserve);
+void vsir_program_cleanup(struct vsir_program *program);
+
 struct vkd3d_shader_parser
 {
     struct vkd3d_shader_message_context *message_context;
@@ -1235,9 +1292,8 @@ struct vkd3d_shader_parser
     bool failed;
 
     struct vkd3d_shader_desc shader_desc;
-    struct vkd3d_shader_version shader_version;
     const struct vkd3d_shader_parser_ops *ops;
-    struct vkd3d_shader_instruction_array instructions;
+    struct vsir_program program;
 
     uint64_t config_flags;
 };
@@ -1259,13 +1315,13 @@ void vkd3d_shader_parser_warning(struct vkd3d_shader_parser *parser,
 static inline struct vkd3d_shader_dst_param *shader_parser_get_dst_params(
         struct vkd3d_shader_parser *parser, unsigned int count)
 {
-    return shader_dst_param_allocator_get(&parser->instructions.dst_params, count);
+    return shader_dst_param_allocator_get(&parser->program.instructions.dst_params, count);
 }
 
 static inline struct vkd3d_shader_src_param *shader_parser_get_src_params(
         struct vkd3d_shader_parser *parser, unsigned int count)
 {
-    return shader_src_param_allocator_get(&parser->instructions.src_params, count);
+    return shader_src_param_allocator_get(&parser->program.instructions.src_params, count);
 }
 
 static inline void vkd3d_shader_parser_destroy(struct vkd3d_shader_parser *parser)
@@ -1286,6 +1342,7 @@ struct vkd3d_shader_descriptor_info1
     unsigned int buffer_size;
     unsigned int structure_stride;
     unsigned int count;
+    uint32_t uav_flags;
 };
 
 struct vkd3d_shader_scan_descriptor_info1
@@ -1294,8 +1351,7 @@ struct vkd3d_shader_scan_descriptor_info1
     unsigned int descriptor_count;
 };
 
-void vkd3d_shader_trace(const struct vkd3d_shader_instruction_array *instructions,
-        const struct vkd3d_shader_version *shader_version);
+void vkd3d_shader_trace(const struct vsir_program *program);
 
 const char *shader_get_type_prefix(enum vkd3d_shader_type type);
 
@@ -1311,9 +1367,15 @@ struct vkd3d_string_buffer_cache
     size_t count, max_count, capacity;
 };
 
-enum vkd3d_result vkd3d_dxbc_binary_to_text(const struct vkd3d_shader_instruction_array *instructions,
-        const struct vkd3d_shader_version *shader_version, const struct vkd3d_shader_compile_info *compile_info,
-        struct vkd3d_shader_code *out);
+enum vsir_asm_dialect
+{
+    VSIR_ASM_VSIR,
+    VSIR_ASM_D3D,
+};
+
+enum vkd3d_result vkd3d_dxbc_binary_to_text(const struct vsir_program *program,
+        const struct vkd3d_shader_compile_info *compile_info,
+        struct vkd3d_shader_code *out, enum vsir_asm_dialect dialect);
 void vkd3d_string_buffer_cleanup(struct vkd3d_string_buffer *buffer);
 struct vkd3d_string_buffer *vkd3d_string_buffer_get(struct vkd3d_string_buffer_cache *list);
 void vkd3d_string_buffer_init(struct vkd3d_string_buffer *buffer);
@@ -1338,7 +1400,9 @@ struct vkd3d_bytecode_buffer
 /* Align to the next 4-byte offset, and return that offset. */
 size_t bytecode_align(struct vkd3d_bytecode_buffer *buffer);
 size_t bytecode_put_bytes(struct vkd3d_bytecode_buffer *buffer, const void *bytes, size_t size);
+size_t bytecode_reserve_bytes(struct vkd3d_bytecode_buffer *buffer, size_t size);
 void set_u32(struct vkd3d_bytecode_buffer *buffer, size_t offset, uint32_t value);
+void set_string(struct vkd3d_bytecode_buffer *buffer, size_t offset, const char *string, size_t length);
 
 static inline size_t put_u32(struct vkd3d_bytecode_buffer *buffer, uint32_t value)
 {
@@ -1382,6 +1446,8 @@ void vkd3d_shader_verror(struct vkd3d_shader_message_context *context, const str
         enum vkd3d_shader_error error, const char *format, va_list args);
 void vkd3d_shader_vnote(struct vkd3d_shader_message_context *context, const struct vkd3d_shader_location *location,
         enum vkd3d_shader_log_level level, const char *format, va_list args);
+void vkd3d_shader_warning(struct vkd3d_shader_message_context *context, const struct vkd3d_shader_location *location,
+        enum vkd3d_shader_error error, const char *format, ...) VKD3D_PRINTF_FUNC(4, 5);
 void vkd3d_shader_vwarning(struct vkd3d_shader_message_context *context, const struct vkd3d_shader_location *location,
         enum vkd3d_shader_error error, const char *format, va_list args);
 
@@ -1409,7 +1475,7 @@ struct vkd3d_glsl_generator;
 struct vkd3d_glsl_generator *vkd3d_glsl_generator_create(const struct vkd3d_shader_version *version,
         struct vkd3d_shader_message_context *message_context, const struct vkd3d_shader_location *location);
 int vkd3d_glsl_generator_generate(struct vkd3d_glsl_generator *generator,
-        struct vkd3d_shader_parser *parser, struct vkd3d_shader_code *out);
+        struct vsir_program *program, struct vkd3d_shader_code *out);
 void vkd3d_glsl_generator_destroy(struct vkd3d_glsl_generator *generator);
 
 #define SPIRV_MAX_SRC_COUNT 6
@@ -1427,7 +1493,7 @@ int preproc_lexer_parse(const struct vkd3d_shader_compile_info *compile_info,
 int hlsl_compile_shader(const struct vkd3d_shader_code *hlsl, const struct vkd3d_shader_compile_info *compile_info,
         struct vkd3d_shader_code *out, struct vkd3d_shader_message_context *message_context);
 
-void vsir_validate(struct vkd3d_shader_parser *parser);
+enum vkd3d_result vsir_validate(struct vkd3d_shader_parser *parser);
 
 static inline enum vkd3d_shader_component_type vkd3d_component_type_from_data_type(
         enum vkd3d_data_type data_type)
@@ -1444,6 +1510,8 @@ static inline enum vkd3d_shader_component_type vkd3d_component_type_from_data_ty
             return VKD3D_SHADER_COMPONENT_INT;
         case VKD3D_DATA_DOUBLE:
             return VKD3D_SHADER_COMPONENT_DOUBLE;
+        case VKD3D_DATA_UINT64:
+            return VKD3D_SHADER_COMPONENT_UINT64;
         case VKD3D_DATA_BOOL:
             return VKD3D_SHADER_COMPONENT_BOOL;
         default:
@@ -1505,7 +1573,7 @@ static inline enum vkd3d_shader_input_sysval_semantic vkd3d_siv_from_sysval(enum
     return vkd3d_siv_from_sysval_indexed(sysval, 0);
 }
 
-static inline unsigned int vkd3d_write_mask_get_component_idx(DWORD write_mask)
+static inline unsigned int vsir_write_mask_get_component_idx(uint32_t write_mask)
 {
     unsigned int i;
 
@@ -1520,7 +1588,7 @@ static inline unsigned int vkd3d_write_mask_get_component_idx(DWORD write_mask)
     return 0;
 }
 
-static inline unsigned int vkd3d_write_mask_component_count(DWORD write_mask)
+static inline unsigned int vsir_write_mask_component_count(uint32_t write_mask)
 {
     unsigned int count = vkd3d_popcount(write_mask & VKD3DSP_WRITEMASK_ALL);
     assert(1 <= count && count <= VKD3D_VEC4_SIZE);
@@ -1533,32 +1601,30 @@ static inline unsigned int vkd3d_write_mask_from_component_count(unsigned int co
     return (VKD3DSP_WRITEMASK_0 << component_count) - 1;
 }
 
-static inline unsigned int vkd3d_write_mask_64_from_32(DWORD write_mask32)
+static inline uint32_t vsir_write_mask_64_from_32(uint32_t write_mask32)
 {
-    unsigned int write_mask64 = write_mask32 | (write_mask32 >> 1);
+    uint32_t write_mask64 = write_mask32 | (write_mask32 >> 1);
     return (write_mask64 & VKD3DSP_WRITEMASK_0) | ((write_mask64 & VKD3DSP_WRITEMASK_2) >> 1);
 }
 
-static inline unsigned int vkd3d_write_mask_32_from_64(unsigned int write_mask64)
+static inline uint32_t vsir_write_mask_32_from_64(uint32_t write_mask64)
 {
-    unsigned int write_mask32 = (write_mask64 | (write_mask64 << 1))
+    uint32_t write_mask32 = (write_mask64 | (write_mask64 << 1))
             & (VKD3DSP_WRITEMASK_0 | VKD3DSP_WRITEMASK_2);
     return write_mask32 | (write_mask32 << 1);
 }
 
-static inline unsigned int vkd3d_swizzle_get_component(DWORD swizzle,
-        unsigned int idx)
+static inline unsigned int vsir_swizzle_get_component(uint32_t swizzle, unsigned int idx)
 {
     return (swizzle >> VKD3D_SHADER_SWIZZLE_SHIFT(idx)) & VKD3D_SHADER_SWIZZLE_MASK;
 }
 
-static inline unsigned int vkd3d_swizzle_get_component64(DWORD swizzle,
-        unsigned int idx)
+static inline unsigned int vsir_swizzle_get_component64(uint32_t swizzle, unsigned int idx)
 {
     return ((swizzle >> VKD3D_SHADER_SWIZZLE_SHIFT(idx * 2)) & VKD3D_SHADER_SWIZZLE_MASK) / 2u;
 }
 
-static inline unsigned int vkd3d_compact_swizzle(unsigned int swizzle, unsigned int write_mask)
+static inline unsigned int vkd3d_compact_swizzle(uint32_t swizzle, uint32_t write_mask)
 {
     unsigned int i, compacted_swizzle = 0;
 
@@ -1567,7 +1633,7 @@ static inline unsigned int vkd3d_compact_swizzle(unsigned int swizzle, unsigned
         if (write_mask & (VKD3DSP_WRITEMASK_0 << i))
         {
             compacted_swizzle <<= VKD3D_SHADER_SWIZZLE_SHIFT(1);
-            compacted_swizzle |= vkd3d_swizzle_get_component(swizzle, i);
+            compacted_swizzle |= vsir_swizzle_get_component(swizzle, i);
         }
     }
 
diff --git a/libs/vkd3d/libs/vkd3d/command.c b/libs/vkd3d/libs/vkd3d/command.c
index 15c8317..3cf58e0 100644
--- a/libs/vkd3d/libs/vkd3d/command.c
+++ b/libs/vkd3d/libs/vkd3d/command.c
@@ -313,7 +313,7 @@ static void vkd3d_wait_for_gpu_fence(struct vkd3d_fence_worker *worker,
 
     TRACE("Signaling fence %p value %#"PRIx64".\n", waiting_fence->fence, waiting_fence->value);
     if (FAILED(hr = d3d12_fence_signal(waiting_fence->fence, waiting_fence->value, waiting_fence->u.vk_fence, false)))
-        ERR("Failed to signal D3D12 fence, hr %#x.\n", hr);
+        ERR("Failed to signal d3d12 fence, hr %s.\n", debugstr_hresult(hr));
 
     d3d12_fence_decref(waiting_fence->fence);
 
@@ -926,7 +926,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_fence_QueryInterface(ID3D12Fence1 *iface,
 static ULONG STDMETHODCALLTYPE d3d12_fence_AddRef(ID3D12Fence1 *iface)
 {
     struct d3d12_fence *fence = impl_from_ID3D12Fence1(iface);
-    ULONG refcount = InterlockedIncrement(&fence->refcount);
+    unsigned int refcount = vkd3d_atomic_increment_u32(&fence->refcount);
 
     TRACE("%p increasing refcount to %u.\n", fence, refcount);
 
@@ -935,13 +935,13 @@ static ULONG STDMETHODCALLTYPE d3d12_fence_AddRef(ID3D12Fence1 *iface)
 
 static void d3d12_fence_incref(struct d3d12_fence *fence)
 {
-    InterlockedIncrement(&fence->internal_refcount);
+    vkd3d_atomic_increment_u32(&fence->internal_refcount);
 }
 
 static ULONG STDMETHODCALLTYPE d3d12_fence_Release(ID3D12Fence1 *iface)
 {
     struct d3d12_fence *fence = impl_from_ID3D12Fence1(iface);
-    ULONG refcount = InterlockedDecrement(&fence->refcount);
+    unsigned int refcount = vkd3d_atomic_decrement_u32(&fence->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", fence, refcount);
 
@@ -953,24 +953,24 @@ static ULONG STDMETHODCALLTYPE d3d12_fence_Release(ID3D12Fence1 *iface)
 
 static void d3d12_fence_decref(struct d3d12_fence *fence)
 {
-    ULONG internal_refcount = InterlockedDecrement(&fence->internal_refcount);
+    struct d3d12_device *device;
 
-    if (!internal_refcount)
-    {
-        struct d3d12_device *device = fence->device;
+    if (vkd3d_atomic_decrement_u32(&fence->internal_refcount))
+        return;
 
-        vkd3d_private_store_destroy(&fence->private_store);
+    device = fence->device;
 
-        d3d12_fence_destroy_vk_objects(fence);
+    vkd3d_private_store_destroy(&fence->private_store);
 
-        vkd3d_free(fence->events);
-        vkd3d_free(fence->semaphores);
-        vkd3d_mutex_destroy(&fence->mutex);
-        vkd3d_cond_destroy(&fence->null_event_cond);
-        vkd3d_free(fence);
+    d3d12_fence_destroy_vk_objects(fence);
 
-        d3d12_device_release(device);
-    }
+    vkd3d_free(fence->events);
+    vkd3d_free(fence->semaphores);
+    vkd3d_mutex_destroy(&fence->mutex);
+    vkd3d_cond_destroy(&fence->null_event_cond);
+    vkd3d_free(fence);
+
+    d3d12_device_release(device);
 }
 
 static HRESULT STDMETHODCALLTYPE d3d12_fence_GetPrivateData(ID3D12Fence1 *iface,
@@ -1635,7 +1635,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_allocator_QueryInterface(ID3D12Co
 static ULONG STDMETHODCALLTYPE d3d12_command_allocator_AddRef(ID3D12CommandAllocator *iface)
 {
     struct d3d12_command_allocator *allocator = impl_from_ID3D12CommandAllocator(iface);
-    ULONG refcount = InterlockedIncrement(&allocator->refcount);
+    unsigned int refcount = vkd3d_atomic_increment_u32(&allocator->refcount);
 
     TRACE("%p increasing refcount to %u.\n", allocator, refcount);
 
@@ -1645,7 +1645,7 @@ static ULONG STDMETHODCALLTYPE d3d12_command_allocator_AddRef(ID3D12CommandAlloc
 static ULONG STDMETHODCALLTYPE d3d12_command_allocator_Release(ID3D12CommandAllocator *iface)
 {
     struct d3d12_command_allocator *allocator = impl_from_ID3D12CommandAllocator(iface);
-    ULONG refcount = InterlockedDecrement(&allocator->refcount);
+    unsigned int refcount = vkd3d_atomic_decrement_u32(&allocator->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", allocator, refcount);
 
@@ -2320,7 +2320,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_list_QueryInterface(ID3D12Graphic
 static ULONG STDMETHODCALLTYPE d3d12_command_list_AddRef(ID3D12GraphicsCommandList5 *iface)
 {
     struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
-    ULONG refcount = InterlockedIncrement(&list->refcount);
+    unsigned int refcount = vkd3d_atomic_increment_u32(&list->refcount);
 
     TRACE("%p increasing refcount to %u.\n", list, refcount);
 
@@ -2335,7 +2335,7 @@ static void vkd3d_pipeline_bindings_cleanup(struct vkd3d_pipeline_bindings *bind
 static ULONG STDMETHODCALLTYPE d3d12_command_list_Release(ID3D12GraphicsCommandList5 *iface)
 {
     struct d3d12_command_list *list = impl_from_ID3D12GraphicsCommandList5(iface);
-    ULONG refcount = InterlockedDecrement(&list->refcount);
+    unsigned int refcount = vkd3d_atomic_decrement_u32(&list->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", list, refcount);
 
@@ -2644,6 +2644,8 @@ static bool d3d12_command_list_update_compute_pipeline(struct d3d12_command_list
 {
     const struct vkd3d_vk_device_procs *vk_procs = &list->device->vk_procs;
 
+    vkd3d_cond_signal(&list->device->worker_cond);
+
     if (list->current_pipeline != VK_NULL_HANDLE)
         return true;
 
@@ -2665,6 +2667,8 @@ static bool d3d12_command_list_update_graphics_pipeline(struct d3d12_command_lis
     VkRenderPass vk_render_pass;
     VkPipeline vk_pipeline;
 
+    vkd3d_cond_signal(&list->device->worker_cond);
+
     if (list->current_pipeline != VK_NULL_HANDLE)
         return true;
 
@@ -3266,7 +3270,8 @@ static void d3d12_command_list_bind_descriptor_heap(struct d3d12_command_list *l
     {
         VkDescriptorSet vk_descriptor_set = heap->vk_descriptor_sets[set].vk_set;
 
-        if (!vk_descriptor_set)
+        /* Null vk_set_layout means set 0 uses mutable descriptors, and this set is unused. */
+        if (!vk_descriptor_set || !list->device->vk_descriptor_heap_layouts[set].vk_set_layout)
             continue;
 
         VK_CALL(vkCmdBindDescriptorSets(list->vk_command_buffer, bindings->vk_bind_point, rs->vk_pipeline_layout,
@@ -3701,7 +3706,7 @@ static void d3d12_command_list_copy_incompatible_texture_region(struct d3d12_com
             buffer_image_copy.imageExtent.height * buffer_image_copy.imageExtent.depth * layer_count;
     if (FAILED(hr = d3d12_command_list_allocate_transfer_buffer(list, buffer_size, &transfer_buffer)))
     {
-        ERR("Failed to allocate transfer buffer, hr %#x.\n", hr);
+        ERR("Failed to allocate transfer buffer, hr %s.\n", debugstr_hresult(hr));
         return;
     }
 
@@ -6225,7 +6230,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_queue_QueryInterface(ID3D12Comman
 static ULONG STDMETHODCALLTYPE d3d12_command_queue_AddRef(ID3D12CommandQueue *iface)
 {
     struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
-    ULONG refcount = InterlockedIncrement(&command_queue->refcount);
+    unsigned int refcount = vkd3d_atomic_increment_u32(&command_queue->refcount);
 
     TRACE("%p increasing refcount to %u.\n", command_queue, refcount);
 
@@ -6267,7 +6272,7 @@ static void d3d12_command_queue_op_array_destroy(struct d3d12_command_queue_op_a
 static ULONG STDMETHODCALLTYPE d3d12_command_queue_Release(ID3D12CommandQueue *iface)
 {
     struct d3d12_command_queue *command_queue = impl_from_ID3D12CommandQueue(iface);
-    ULONG refcount = InterlockedDecrement(&command_queue->refcount);
+    unsigned int refcount = vkd3d_atomic_decrement_u32(&command_queue->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", command_queue, refcount);
 
@@ -6508,7 +6513,7 @@ static void STDMETHODCALLTYPE d3d12_command_queue_CopyTileMappings(ID3D12Command
     if (!(op = d3d12_command_queue_op_array_require_space(&command_queue->op_queue)))
     {
         ERR("Failed to add op.\n");
-        return;
+        goto unlock_mutex;
     }
     op->opcode = VKD3D_CS_OP_COPY_MAPPINGS;
     op->u.copy_mappings.dst_resource = dst_resource_impl;
@@ -6520,6 +6525,7 @@ static void STDMETHODCALLTYPE d3d12_command_queue_CopyTileMappings(ID3D12Command
 
     d3d12_command_queue_submit_locked(command_queue);
 
+unlock_mutex:
     vkd3d_mutex_unlock(&command_queue->op_mutex);
 }
 
@@ -6558,7 +6564,7 @@ static void d3d12_command_queue_submit_locked(struct d3d12_command_queue *queue)
     if (queue->op_queue.count == 1 && !queue->is_flushing)
     {
         if (FAILED(hr = d3d12_command_queue_flush_ops_locked(queue, &flushed_any)))
-            ERR("Cannot flush queue, hr %#x.\n", hr);
+            ERR("Failed to flush queue, hr %s.\n", debugstr_hresult(hr));
     }
 }
 
@@ -7436,7 +7442,7 @@ static HRESULT STDMETHODCALLTYPE d3d12_command_signature_QueryInterface(ID3D12Co
 static ULONG STDMETHODCALLTYPE d3d12_command_signature_AddRef(ID3D12CommandSignature *iface)
 {
     struct d3d12_command_signature *signature = impl_from_ID3D12CommandSignature(iface);
-    ULONG refcount = InterlockedIncrement(&signature->refcount);
+    unsigned int refcount = vkd3d_atomic_increment_u32(&signature->refcount);
 
     TRACE("%p increasing refcount to %u.\n", signature, refcount);
 
@@ -7446,7 +7452,7 @@ static ULONG STDMETHODCALLTYPE d3d12_command_signature_AddRef(ID3D12CommandSigna
 static ULONG STDMETHODCALLTYPE d3d12_command_signature_Release(ID3D12CommandSignature *iface)
 {
     struct d3d12_command_signature *signature = impl_from_ID3D12CommandSignature(iface);
-    ULONG refcount = InterlockedDecrement(&signature->refcount);
+    unsigned int refcount = vkd3d_atomic_decrement_u32(&signature->refcount);
 
     TRACE("%p decreasing refcount to %u.\n", signature, refcount);
 
diff --git a/libs/vkd3d/libs/vkd3d/device.c b/libs/vkd3d/libs/vkd3d/device.c
index 5c801ca..2b85581 100644
--- a/libs/vkd3d/libs/vkd3d/device.c
+++ b/libs/vkd3d/libs/vkd3d/device.c
@@ -94,9 +94,11 @@ static const struct vkd3d_optional_extension_info optional_device_extensions[] =
     VK_EXTENSION(EXT_DEBUG_MARKER, EXT_debug_marker),
     VK_EXTENSION(EXT_DEPTH_CLIP_ENABLE, EXT_depth_clip_enable),
     VK_EXTENSION(EXT_DESCRIPTOR_INDEXING, EXT_descriptor_indexing),
+    VK_EXTENSION(EXT_MUTABLE_DESCRIPTOR_TYPE, EXT_mutable_descriptor_type),
     VK_EXTENSION(EXT_ROBUSTNESS_2, EXT_robustness2),
     VK_EXTENSION(EXT_SHADER_DEMOTE_TO_HELPER_INVOCATION, EXT_shader_demote_to_helper_invocation),
     VK_EXTENSION(EXT_SHADER_STENCIL_EXPORT, EXT_shader_stencil_export),
+    VK_EXTENSION(EXT_SHADER_VIEWPORT_INDEX_LAYER, EXT_shader_viewport_index_layer),
     VK_EXTENSION(EXT_TEXEL_BUFFER_ALIGNMENT, EXT_texel_buffer_alignment),
     VK_EXTENSION(EXT_TRANSFORM_FEEDBACK, EXT_transform_feedback),
     VK_EXTENSION(EXT_VERTEX_ATTRIBUTE_DIVISOR, EXT_vertex_attribute_divisor),
@@ -106,13 +108,32 @@ static HRESULT vkd3d_create_vk_descriptor_heap_layout(struct d3d12_device *devic
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     VkDescriptorSetLayoutBindingFlagsCreateInfoEXT flags_info;
+    VkMutableDescriptorTypeCreateInfoEXT mutable_info;
+    VkMutableDescriptorTypeListEXT type_list;
     VkDescriptorSetLayoutCreateInfo set_desc;
     VkDescriptorBindingFlagsEXT set_flags;
     VkDescriptorSetLayoutBinding binding;
     VkResult vr;
 
+    static const VkDescriptorType descriptor_types[] =
+    {
+        VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER,
+        VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER,
+        VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE,
+        VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER,
+        VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
+    };
+
+    if (device->vk_info.EXT_mutable_descriptor_type && index && index != VKD3D_SET_INDEX_UAV_COUNTER
+            && device->vk_descriptor_heap_layouts[index].applicable_heap_type == D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV)
+    {
+        device->vk_descriptor_heap_layouts[index].vk_set_layout = VK_NULL_HANDLE;
+        return S_OK;
+    }
+
     binding.binding = 0;
-    binding.descriptorType = device->vk_descriptor_heap_layouts[index].type;
+    binding.descriptorType = (device->vk_info.EXT_mutable_descriptor_type && !index)
+            ? VK_DESCRIPTOR_TYPE_MUTABLE_EXT : device->vk_descriptor_heap_layouts[index].type;
     binding.descriptorCount = device->vk_descriptor_heap_layouts[index].count;
     binding.stageFlags = VK_SHADER_STAGE_ALL;
     binding.pImmutableSamplers = NULL;
@@ -132,6 +153,17 @@ static HRESULT vkd3d_create_vk_descriptor_heap_layout(struct d3d12_device *devic
     flags_info.bindingCount = 1;
     flags_info.pBindingFlags = &set_flags;
 
+    if (binding.descriptorType == VK_DESCRIPTOR_TYPE_MUTABLE_EXT)
+    {
+        type_list.descriptorTypeCount = ARRAY_SIZE(descriptor_types);
+        type_list.pDescriptorTypes = descriptor_types;
+        mutable_info.sType = VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT;
+        mutable_info.pNext = NULL;
+        mutable_info.mutableDescriptorTypeListCount = 1;
+        mutable_info.pMutableDescriptorTypeLists = &type_list;
+        flags_info.pNext = &mutable_info;
+    }
+
     if ((vr = VK_CALL(vkCreateDescriptorSetLayout(device->vk_device, &set_desc, NULL,
             &device->vk_descriptor_heap_layouts[index].vk_set_layout))) < 0)
     {
@@ -562,7 +594,7 @@ static HRESULT vkd3d_instance_init(struct vkd3d_instance *instance,
 
     if (FAILED(hr = vkd3d_init_vk_global_procs(instance, create_info->pfn_vkGetInstanceProcAddr)))
     {
-        ERR("Failed to initialize Vulkan global procs, hr %#x.\n", hr);
+        ERR("Failed to initialise Vulkan global procs, hr %s.\n", debugstr_hresult(hr));
         return hr;
     }
 
@@ -642,7 +674,7 @@ static HRESULT vkd3d_instance_init(struct vkd3d_instance *instance,
 
     if (FAILED(hr = vkd3d_load_vk_instance_procs(&instance->vk_procs, vk_global_procs, vk_instance)))
     {
-        ERR("Failed to load instance procs, hr %#x.\n", hr);
+        ERR("Failed to load instance procs, hr %s.\n", debugstr_hresult(hr));
         if (instance->vk_procs.vkDestroyInstance)
             instance->vk_procs.vkDestroyInstance(vk_instance, NULL);
         if (instance->libvulkan)
@@ -763,6 +795,7 @@ struct vkd3d_physical_device_info
     VkPhysicalDeviceTransformFeedbackFeaturesEXT xfb_features;
     VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT vertex_divisor_features;
     VkPhysicalDeviceTimelineSemaphoreFeaturesKHR timeline_semaphore_features;
+    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT mutable_features;
 
     VkPhysicalDeviceFeatures2 features2;
 };
@@ -780,6 +813,7 @@ static void vkd3d_physical_device_info_init(struct vkd3d_physical_device_info *i
     VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *buffer_alignment_features;
     VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *demote_features;
     VkPhysicalDeviceTimelineSemaphoreFeaturesKHR *timeline_semaphore_features;
+    VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT *mutable_features;
     VkPhysicalDeviceDepthClipEnableFeaturesEXT *depth_clip_features;
     VkPhysicalDeviceMaintenance3Properties *maintenance3_properties;
     VkPhysicalDeviceTransformFeedbackPropertiesEXT *xfb_properties;
@@ -800,6 +834,7 @@ static void vkd3d_physical_device_info_init(struct vkd3d_physical_device_info *i
     vertex_divisor_features = &info->vertex_divisor_features;
     vertex_divisor_properties = &info->vertex_divisor_properties;
     timeline_semaphore_features = &info->timeline_semaphore_features;
+    mutable_features = &info->mutable_features;
     xfb_features = &info->xfb_features;
     xfb_properties = &info->xfb_properties;
 
@@ -823,6 +858,8 @@ static void vkd3d_physical_device_info_init(struct vkd3d_physical_device_info *i
     vk_prepend_struct(&info->features2, vertex_divisor_features);
     timeline_semaphore_features->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR;
     vk_prepend_struct(&info->features2, timeline_semaphore_features);
+    mutable_features->sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT;
+    vk_prepend_struct(&info->features2, mutable_features);
 
     if (vulkan_info->KHR_get_physical_device_properties2)
         VK_CALL(vkGetPhysicalDeviceFeatures2KHR(physical_device, &info->features2));
@@ -1510,8 +1547,6 @@ static HRESULT vkd3d_init_device_caps(struct d3d12_device *device,
     device->feature_options.StandardSwizzle64KBSupported = FALSE;
     device->feature_options.CrossNodeSharingTier = D3D12_CROSS_NODE_SHARING_TIER_NOT_SUPPORTED;
     device->feature_options.CrossAdapterRowMajorTextureSupported = FALSE;
-    /* SPV_EXT_shader_viewport_index_layer */
-    device->feature_options.VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation = FALSE;
     device->feature_options.ResourceHeapTier = D3D12_RESOURCE_HEAP_TIER_2;
 
     /* Shader Model 6 support. */
@@ -1594,6 +1629,8 @@ static HRESULT vkd3d_init_device_caps(struct d3d12_device *device,
         vulkan_info->EXT_shader_demote_to_helper_invocation = false;
     if (!physical_device_info->texel_buffer_alignment_features.texelBufferAlignment)
         vulkan_info->EXT_texel_buffer_alignment = false;
+    if (!physical_device_info->mutable_features.mutableDescriptorType)
+        vulkan_info->EXT_mutable_descriptor_type = false;
     if (!physical_device_info->timeline_semaphore_features.timelineSemaphore)
         vulkan_info->KHR_timeline_semaphore = false;
 
@@ -1615,6 +1652,8 @@ static HRESULT vkd3d_init_device_caps(struct d3d12_device *device,
     vkd3d_free(vk_extensions);
 
     device->feature_options.PSSpecifiedStencilRefSupported = vulkan_info->EXT_shader_stencil_export;
+    device->feature_options.VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation =
+            vulkan_info->EXT_shader_viewport_index_layer;
 
     vkd3d_init_feature_level(vulkan_info, features, &device->feature_options);
     if (vulkan_info->max_feature_level < create_info->minimum_feature_level)
@@ -1640,6 +1679,10 @@ static HRESULT vkd3d_init_device_caps(struct d3d12_device *device,
         vulkan_info->shader_extensions[vulkan_info->shader_extension_count++]
                 = VKD3D_SHADER_SPIRV_EXTENSION_EXT_STENCIL_EXPORT;
 
+    if (vulkan_info->EXT_shader_viewport_index_layer)
+        vulkan_info->shader_extensions[vulkan_info->shader_extension_count++]
+                = VKD3D_SHADER_SPIRV_EXTENSION_EXT_VIEWPORT_INDEX_LAYER;
+
     /* Disable unused Vulkan features. */
     features->shaderTessellationAndGeometryPointSize = VK_FALSE;
 
@@ -2028,7 +2071,7 @@ static HRESULT vkd3d_create_vk_device(struct d3d12_device *device,
 
     if (FAILED(hr = vkd3d_load_vk_device_procs(&device->vk_procs, vk_procs, vk_device)))
     {
-        ERR("Failed to load device procs, hr %#x.\n", hr);
+        ERR("Failed to load device procs, hr %s.\n", debugstr_hresult(hr));
         if (device->vk_procs.vkDestroyDevice)
             device->vk_procs.vkDestroyDevice(vk_device, NULL);
         return hr;
@@ -2038,7 +2081,7 @@ static HRESULT vkd3d_create_vk_device(struct d3d12_device *device,
 
     if (FAILED(hr = d3d12_device_create_vkd3d_queues(device, &device_queue_info)))
     {
-        ERR("Failed to create queues, hr %#x.\n", hr);
+        ERR("Failed to create queues, hr %s.\n", debugstr_hresult(hr));
         device->vk_procs.vkDestroyDevice(vk_device, NULL);
         return hr;
     }
@@ -2056,7 +2099,7 @@ static HRESULT d3d12_device_init_pipeline_cache(struct d3d12_device *device)
     VkPipelineCacheCreateInfo cache_info;
     VkResult vr;
 
-    vkd3d_mutex_init(&device->mutex);
+    vkd3d_mutex_init(&device->pipeline_cache_mutex);
 
     cache_info.sType = VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO;
     cache_info.pNext = NULL;
@@ -2080,7 +2123,7 @@ static void d3d12_device_destroy_pipeline_cache(struct d3d12_device *device)
     if (device->vk_pipeline_cache)
         VK_CALL(vkDestroyPipelineCache(device->vk_device, device->vk_pipeline_cache, NULL));
 
-    vkd3d_mutex_destroy(&device->mutex);
+    vkd3d_mutex_destroy(&device->pipeline_cache_mutex);
 }
 
 #define VKD3D_VA_FALLBACK_BASE      0x8000000000000000ull
@@ -2495,6 +2538,28 @@ static ULONG STDMETHODCALLTYPE d3d12_device_AddRef(ID3D12Device5 *iface)
     return refcount;
 }
 
+static HRESULT device_worker_stop(struct d3d12_device *device)
+{
+    HRESULT hr;
+
+    TRACE("device %p.\n", device);
+
+    vkd3d_mutex_lock(&device->worker_mutex);
+
+    device->worker_should_exit = true;
+    vkd3d_cond_signal(&device->worker_cond);
+
+    vkd3d_mutex_unlock(&device->worker_mutex);
+
+    if (FAILED(hr = vkd3d_join_thread(device->vkd3d_instance, &device->worker_thread)))
+        return hr;
+
+    vkd3d_mutex_destroy(&device->worker_mutex);
+    vkd3d_cond_destroy(&device->worker_cond);
+
+    return S_OK;
+}
+
 static ULONG STDMETHODCALLTYPE d3d12_device_Release(ID3D12Device5 *iface)
 {
     struct d3d12_device *device = impl_from_ID3D12Device5(iface);
@@ -2520,6 +2585,9 @@ static ULONG STDMETHODCALLTYPE d3d12_device_Release(ID3D12Device5 *iface)
         d3d12_device_destroy_vkd3d_queues(device);
         vkd3d_desc_object_cache_cleanup(&device->view_desc_cache);
         vkd3d_desc_object_cache_cleanup(&device->cbuffer_desc_cache);
+        if (device->use_vk_heaps)
+            device_worker_stop(device);
+        vkd3d_free(device->heaps);
         VK_CALL(vkDestroyDevice(device->vk_device, NULL));
         if (device->parent)
             IUnknown_Release(device->parent);
@@ -4251,6 +4319,40 @@ struct d3d12_device *unsafe_impl_from_ID3D12Device5(ID3D12Device5 *iface)
     return impl_from_ID3D12Device5(iface);
 }
 
+static void *device_worker_main(void *arg)
+{
+    struct d3d12_descriptor_heap *heap;
+    struct d3d12_device *device = arg;
+    size_t i;
+
+    vkd3d_set_thread_name("device_worker");
+
+    vkd3d_mutex_lock(&device->worker_mutex);
+
+    while (!device->worker_should_exit)
+    {
+        for (i = 0; i < device->heap_count; ++i)
+        {
+            /* Descriptor updates are not written to Vulkan descriptor sets until a command list
+             * is submitted to a queue, while the client is free to write d3d12 descriptors earlier,
+             * from any thread. This causes a delay right before command list execution, so
+             * handling these updates in a worker thread can speed up execution significantly. */
+            heap = device->heaps[i];
+            if (heap->dirty_list_head == UINT_MAX)
+                continue;
+            vkd3d_mutex_lock(&heap->vk_sets_mutex);
+            d3d12_desc_flush_vk_heap_updates_locked(heap, device);
+            vkd3d_mutex_unlock(&heap->vk_sets_mutex);
+        }
+
+        vkd3d_cond_wait(&device->worker_cond, &device->worker_mutex);
+    }
+
+    vkd3d_mutex_unlock(&device->worker_mutex);
+
+    return NULL;
+}
+
 static HRESULT d3d12_device_init(struct d3d12_device *device,
         struct vkd3d_instance *instance, const struct vkd3d_device_create_info *create_info)
 {
@@ -4270,6 +4372,14 @@ static HRESULT d3d12_device_init(struct d3d12_device *device,
 
     device->vk_device = VK_NULL_HANDLE;
 
+    device->heaps = NULL;
+    device->heap_capacity = 0;
+    device->heap_count = 0;
+    memset(&device->worker_thread, 0, sizeof(device->worker_thread));
+    device->worker_should_exit = false;
+    vkd3d_mutex_init(&device->worker_mutex);
+    vkd3d_cond_init(&device->worker_cond);
+
     if (FAILED(hr = vkd3d_create_vk_device(device, create_info)))
         goto out_free_instance;
 
@@ -4291,6 +4401,13 @@ static HRESULT d3d12_device_init(struct d3d12_device *device,
     if (FAILED(hr = vkd3d_vk_descriptor_heap_layouts_init(device)))
         goto out_cleanup_uav_clear_state;
 
+    if (device->use_vk_heaps && FAILED(hr = vkd3d_create_thread(device->vkd3d_instance,
+            device_worker_main, device, &device->worker_thread)))
+    {
+        WARN("Failed to create worker thread, hr %s.\n", debugstr_hresult(hr));
+        goto out_cleanup_descriptor_heap_layouts;
+    }
+
     vkd3d_render_pass_cache_init(&device->render_pass_cache);
     vkd3d_gpu_va_allocator_init(&device->gpu_va_allocator);
     vkd3d_time_domains_init(device);
@@ -4308,6 +4425,8 @@ static HRESULT d3d12_device_init(struct d3d12_device *device,
 
     return S_OK;
 
+out_cleanup_descriptor_heap_layouts:
+    vkd3d_vk_descriptor_heap_layouts_cleanup(device);
 out_cleanup_uav_clear_state:
     vkd3d_uav_clear_state_cleanup(&device->uav_clear_state, device);
 out_destroy_null_resources:
@@ -4361,6 +4480,40 @@ void d3d12_device_mark_as_removed(struct d3d12_device *device, HRESULT reason,
     device->removed_reason = reason;
 }
 
+HRESULT d3d12_device_add_descriptor_heap(struct d3d12_device *device, struct d3d12_descriptor_heap *heap)
+{
+    vkd3d_mutex_lock(&device->worker_mutex);
+
+    if (!vkd3d_array_reserve((void **)&device->heaps, &device->heap_capacity, device->heap_count + 1,
+            sizeof(*device->heaps)))
+    {
+        vkd3d_mutex_unlock(&device->worker_mutex);
+        return E_OUTOFMEMORY;
+    }
+    device->heaps[device->heap_count++] = heap;
+
+    vkd3d_mutex_unlock(&device->worker_mutex);
+
+    return S_OK;
+}
+
+void d3d12_device_remove_descriptor_heap(struct d3d12_device *device, struct d3d12_descriptor_heap *heap)
+{
+    size_t i;
+
+    vkd3d_mutex_lock(&device->worker_mutex);
+
+    for (i = 0; i < device->heap_count; ++i)
+    {
+        if (device->heaps[i] == heap)
+        {
+            device->heaps[i] = device->heaps[--device->heap_count];
+            break;
+        }
+    }
+
+    vkd3d_mutex_unlock(&device->worker_mutex);
+}
 
 #ifdef _WIN32
 struct thread_data
@@ -4403,7 +4556,7 @@ HRESULT vkd3d_create_thread(struct vkd3d_instance *instance,
         thread_data->data = data;
         if (!(thread->handle = CreateThread(NULL, 0, call_thread_main, thread_data, 0, NULL)))
         {
-            ERR("Failed to create thread, error %d.\n", GetLastError());
+            ERR("Failed to create thread, error %lu.\n", GetLastError());
             vkd3d_free(thread_data);
             hr = E_FAIL;
         }
@@ -4429,7 +4582,7 @@ HRESULT vkd3d_join_thread(struct vkd3d_instance *instance, union vkd3d_thread_ha
     if (instance->join_thread)
     {
         if (FAILED(hr = instance->join_thread(thread->handle)))
-            ERR("Failed to join thread, hr %#x.\n", hr);
+            ERR("Failed to join thread, hr %s.\n", debugstr_hresult(hr));
     }
     else
     {
diff --git a/libs/vkd3d/libs/vkd3d/resource.c b/libs/vkd3d/libs/vkd3d/resource.c
index abbdfbe..a360b0e 100644
--- a/libs/vkd3d/libs/vkd3d/resource.c
+++ b/libs/vkd3d/libs/vkd3d/resource.c
@@ -22,7 +22,7 @@
 #define VKD3D_NULL_BUFFER_SIZE 16
 #define VKD3D_NULL_VIEW_FORMAT DXGI_FORMAT_R8G8B8A8_UNORM
 
-LONG64 object_global_serial_id;
+uint64_t object_global_serial_id;
 
 static inline bool is_cpu_accessible_heap(const D3D12_HEAP_PROPERTIES *properties)
 {
@@ -2470,12 +2470,14 @@ static void d3d12_desc_write_vk_heap_null_descriptor(struct d3d12_descriptor_hea
 {
     const struct vkd3d_vk_device_procs *vk_procs = &device->vk_procs;
     struct d3d12_descriptor_heap_vk_set *descriptor_set;
-    enum vkd3d_vk_descriptor_set_index set;
+    enum vkd3d_vk_descriptor_set_index set, end;
     unsigned int i = writes->count;
 
+    end = device->vk_info.EXT_mutable_descriptor_type ? VKD3D_SET_INDEX_UNIFORM_BUFFER
+            : VKD3D_SET_INDEX_STORAGE_IMAGE;
     /* Binding a shader with the wrong null descriptor type works in Windows.
      * To support that here we must write one to all applicable Vulkan sets. */
-    for (set = VKD3D_SET_INDEX_UNIFORM_BUFFER; set <= VKD3D_SET_INDEX_STORAGE_IMAGE; ++set)
+    for (set = VKD3D_SET_INDEX_UNIFORM_BUFFER; set <= end; ++set)
     {
         descriptor_set = &descriptor_heap->vk_descriptor_sets[set];
         writes->vk_descriptor_writes[i].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
@@ -2632,20 +2634,18 @@ void d3d12_desc_flush_vk_heap_updates_locked(struct d3d12_descriptor_heap *descr
     for (; i != UINT_MAX; i = next)
     {
         src = &descriptors[i];
-        next = (int)src->next >> 1;
+        next = vkd3d_atomic_exchange(&src->next, 0);
+        next = (int)next >> 1;
 
+        /* A race exists here between updating src->next and getting the current object. The best
+         * we can do is get the object last, which may result in a harmless rewrite later. */
         u.object = d3d12_desc_get_object_ref(src, device);
 
         if (!u.object)
-        {
-            vkd3d_atomic_exchange(&src->next, 0);
             continue;
-        }
 
         writes.held_refs[writes.held_ref_count++] = u.object;
         d3d12_desc_write_vk_heap(descriptor_heap, i, &writes, u.object, device);
-
-        vkd3d_atomic_exchange(&src->next, 0);
     }
 
     /* Avoid thunk calls wherever possible. */
@@ -3446,6 +3446,7 @@ static void vkd3d_create_null_uav(struct d3d12_desc *descriptor,
     vkd3d_desc.miplevel_count = 1;
     vkd3d_desc.layer_idx = 0;
     vkd3d_desc.layer_count = 1;
+    vkd3d_desc.vk_image_aspect = VK_IMAGE_ASPECT_COLOR_BIT;
     vkd3d_desc.components.r = VK_COMPONENT_SWIZZLE_R;
     vkd3d_desc.components.g = VK_COMPONENT_SWIZZLE_G;
     vkd3d_desc.components.b = VK_COMPONENT_SWIZZLE_B;
@@ -3663,11 +3664,27 @@ static VkSamplerAddressMode vk_address_mode_from_d3d12(const struct d3d12_device
     }
 }
 
+static VkBorderColor vk_border_colour_from_d3d12(D3D12_STATIC_BORDER_COLOR colour)
+{
+    switch (colour)
+    {
+        case D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK:
+            return VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
+        case D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK:
+            return VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK;
+        case D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE:
+            return VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;
+        default:
+            FIXME("Unhandled border colour %#x.\n", colour);
+            return VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
+    }
+}
+
 static VkResult d3d12_create_sampler(struct d3d12_device *device, D3D12_FILTER filter,
         D3D12_TEXTURE_ADDRESS_MODE address_u, D3D12_TEXTURE_ADDRESS_MODE address_v,
         D3D12_TEXTURE_ADDRESS_MODE address_w, float mip_lod_bias, unsigned int max_anisotropy,
-        D3D12_COMPARISON_FUNC comparison_func, float min_lod, float max_lod,
-        VkSampler *vk_sampler)
+        D3D12_COMPARISON_FUNC comparison_func, D3D12_STATIC_BORDER_COLOR border_colour,
+        float min_lod, float max_lod, VkSampler *vk_sampler)
 {
     const struct vkd3d_vk_device_procs *vk_procs;
     struct VkSamplerCreateInfo sampler_desc;
@@ -3697,15 +3714,48 @@ static VkResult d3d12_create_sampler(struct d3d12_device *device, D3D12_FILTER f
     sampler_desc.maxLod = max_lod;
     sampler_desc.borderColor = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
     sampler_desc.unnormalizedCoordinates = VK_FALSE;
+
+    if (address_u == D3D12_TEXTURE_ADDRESS_MODE_BORDER || address_v == D3D12_TEXTURE_ADDRESS_MODE_BORDER
+            || address_w == D3D12_TEXTURE_ADDRESS_MODE_BORDER)
+        sampler_desc.borderColor = vk_border_colour_from_d3d12(border_colour);
+
     if ((vr = VK_CALL(vkCreateSampler(device->vk_device, &sampler_desc, NULL, vk_sampler))) < 0)
         WARN("Failed to create Vulkan sampler, vr %d.\n", vr);
 
     return vr;
 }
 
+static D3D12_STATIC_BORDER_COLOR d3d12_static_border_colour(const float *colour)
+{
+    unsigned int i;
+
+    static const struct
+    {
+        float colour[4];
+        D3D12_STATIC_BORDER_COLOR static_colour;
+    }
+    colours[] =
+    {
+        {{0.0f, 0.0f, 0.0f, 0.0f}, D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK},
+        {{0.0f, 0.0f, 0.0f, 1.0f}, D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK},
+        {{1.0f, 1.0f, 1.0f, 1.0f}, D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE},
+    };
+
+    for (i = 0; i < ARRAY_SIZE(colours); ++i)
+    {
+        if (!memcmp(colour, colours[i].colour, sizeof(colours[i].colour)))
+            return colours[i].static_colour;
+    }
+
+    FIXME("Unhandled border colour {%.8e, %.8e, %.8e, %.8e}.\n", colour[0], colour[1], colour[2], colour[3]);
+
+    return D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
+}
+
 void d3d12_desc_create_sampler(struct d3d12_desc *sampler,
         struct d3d12_device *device, const D3D12_SAMPLER_DESC *desc)
 {
+    D3D12_STATIC_BORDER_COLOR static_colour = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
     struct vkd3d_view *view;
 
     if (!desc)
@@ -3717,8 +3767,7 @@ void d3d12_desc_create_sampler(struct d3d12_desc *sampler,
     if (desc->AddressU == D3D12_TEXTURE_ADDRESS_MODE_BORDER
             || desc->AddressV == D3D12_TEXTURE_ADDRESS_MODE_BORDER
             || desc->AddressW == D3D12_TEXTURE_ADDRESS_MODE_BORDER)
-        FIXME("Ignoring border color {%.8e, %.8e, %.8e, %.8e}.\n",
-                desc->BorderColor[0], desc->BorderColor[1], desc->BorderColor[2], desc->BorderColor[3]);
+        static_colour = d3d12_static_border_colour(desc->BorderColor);
 
     if (!(view = vkd3d_view_create(VKD3D_DESCRIPTOR_MAGIC_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLER,
             VKD3D_VIEW_TYPE_SAMPLER, device)))
@@ -3726,9 +3775,9 @@ void d3d12_desc_create_sampler(struct d3d12_desc *sampler,
     view->v.u.vk_sampler = VK_NULL_HANDLE;
     view->v.format = NULL;
 
-    if (d3d12_create_sampler(device, desc->Filter, desc->AddressU,
-            desc->AddressV, desc->AddressW, desc->MipLODBias, desc->MaxAnisotropy,
-            desc->ComparisonFunc, desc->MinLOD, desc->MaxLOD, &view->v.u.vk_sampler) < 0)
+    if (d3d12_create_sampler(device, desc->Filter, desc->AddressU, desc->AddressV,
+            desc->AddressW, desc->MipLODBias, desc->MaxAnisotropy, desc->ComparisonFunc,
+            static_colour, desc->MinLOD, desc->MaxLOD, &view->v.u.vk_sampler) < 0)
     {
         vkd3d_view_decref(view, device);
         return;
@@ -3742,14 +3791,9 @@ HRESULT vkd3d_create_static_sampler(struct d3d12_device *device,
 {
     VkResult vr;
 
-    if (desc->AddressU == D3D12_TEXTURE_ADDRESS_MODE_BORDER
-            || desc->AddressV == D3D12_TEXTURE_ADDRESS_MODE_BORDER
-            || desc->AddressW == D3D12_TEXTURE_ADDRESS_MODE_BORDER)
-        FIXME("Ignoring border %#x.\n", desc->BorderColor);
-
-    vr = d3d12_create_sampler(device, desc->Filter, desc->AddressU,
-            desc->AddressV, desc->AddressW, desc->MipLODBias, desc->MaxAnisotropy,
-            desc->ComparisonFunc, desc->MinLOD, desc->MaxLOD, vk_sampler);
+    vr = d3d12_create_sampler(device, desc->Filter, desc->AddressU, desc->AddressV,
+            desc->AddressW, desc->MipLODBias, desc->MaxAnisotropy, desc->ComparisonFunc,
+            desc->BorderColor, desc->MinLOD, desc->MaxLOD, vk_sampler);
     return hresult_from_vk_result(vr);
 }
 
@@ -3997,6 +4041,9 @@ static ULONG STDMETHODCALLTYPE d3d12_descriptor_heap_Release(ID3D12DescriptorHea
             {
                 struct d3d12_desc *descriptors = (struct d3d12_desc *)heap->descriptors;
 
+                if (heap->use_vk_heaps)
+                    d3d12_device_remove_descriptor_heap(device, heap);
+
                 for (i = 0; i < heap->desc.NumDescriptors; ++i)
                 {
                     d3d12_desc_destroy(&descriptors[i], device);
@@ -4175,9 +4222,11 @@ static HRESULT d3d12_descriptor_heap_create_descriptor_pool(struct d3d12_descrip
 
     for (set = 0, pool_desc.poolSizeCount = 0; set < ARRAY_SIZE(device->vk_descriptor_heap_layouts); ++set)
     {
-        if (device->vk_descriptor_heap_layouts[set].applicable_heap_type == desc->Type)
+        if (device->vk_descriptor_heap_layouts[set].applicable_heap_type == desc->Type
+                && device->vk_descriptor_heap_layouts[set].vk_set_layout)
         {
-            pool_sizes[pool_desc.poolSizeCount].type = device->vk_descriptor_heap_layouts[set].type;
+            pool_sizes[pool_desc.poolSizeCount].type = (device->vk_info.EXT_mutable_descriptor_type && !set)
+                    ? VK_DESCRIPTOR_TYPE_MUTABLE_EXT : device->vk_descriptor_heap_layouts[set].type;
             pool_sizes[pool_desc.poolSizeCount++].descriptorCount = desc->NumDescriptors;
         }
     }
@@ -4203,6 +4252,16 @@ static HRESULT d3d12_descriptor_heap_create_descriptor_set(struct d3d12_descript
     VkDescriptorSetAllocateInfo set_desc;
     VkResult vr;
 
+    if (!device->vk_descriptor_heap_layouts[set].vk_set_layout)
+    {
+        /* Set 0 uses mutable descriptors, and this set is unused. */
+        if (!descriptor_heap->vk_descriptor_sets[0].vk_set)
+            d3d12_descriptor_heap_create_descriptor_set(descriptor_heap, device, 0);
+        descriptor_set->vk_set = descriptor_heap->vk_descriptor_sets[0].vk_set;
+        descriptor_set->vk_type = device->vk_descriptor_heap_layouts[set].type;
+        return S_OK;
+    }
+
     set_desc.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO;
     set_desc.pNext = &set_size;
     set_desc.descriptorPool = descriptor_heap->vk_descriptor_pool;
@@ -4255,7 +4314,7 @@ static HRESULT d3d12_descriptor_heap_init(struct d3d12_descriptor_heap *descript
 
     descriptor_heap->ID3D12DescriptorHeap_iface.lpVtbl = &d3d12_descriptor_heap_vtbl;
     descriptor_heap->refcount = 1;
-    descriptor_heap->serial_id = InterlockedIncrement64(&object_global_serial_id);
+    descriptor_heap->serial_id = vkd3d_atomic_increment_u64(&object_global_serial_id);
 
     descriptor_heap->desc = *desc;
 
@@ -4320,6 +4379,12 @@ HRESULT d3d12_descriptor_heap_create(struct d3d12_device *device,
             dst[i].next = 0;
         }
         object->dirty_list_head = UINT_MAX;
+
+        if (object->use_vk_heaps && FAILED(hr = d3d12_device_add_descriptor_heap(device, object)))
+        {
+            vkd3d_free(object);
+            return hr;
+        }
     }
     else
     {
@@ -4858,7 +4923,7 @@ HRESULT vkd3d_init_null_resources(struct vkd3d_null_resources *null_resources,
     return vkd3d_init_null_resources_data(null_resources, device);
 
 fail:
-    ERR("Failed to initialize NULL resources, hr %#x.\n", hr);
+    ERR("Failed to initialise NULL resources, hr %s.\n", debugstr_hresult(hr));
     vkd3d_destroy_null_resources(null_resources, device);
     return hr;
 }
diff --git a/libs/vkd3d/libs/vkd3d/state.c b/libs/vkd3d/libs/vkd3d/state.c
index fc3187f..5f383d2 100644
--- a/libs/vkd3d/libs/vkd3d/state.c
+++ b/libs/vkd3d/libs/vkd3d/state.c
@@ -515,7 +515,7 @@ static HRESULT d3d12_root_signature_init_push_constants(struct d3d12_root_signat
         assert(p->ShaderVisibility <= D3D12_SHADER_VISIBILITY_PIXEL);
         push_constants[p->ShaderVisibility].stageFlags = use_vk_heaps ? VK_SHADER_STAGE_ALL
                 : stage_flags_from_visibility(p->ShaderVisibility);
-        push_constants[p->ShaderVisibility].size += p->u.Constants.Num32BitValues * sizeof(uint32_t);
+        push_constants[p->ShaderVisibility].size += align(p->u.Constants.Num32BitValues, 4) * sizeof(uint32_t);
     }
     if (push_constants[D3D12_SHADER_VISIBILITY_ALL].size)
     {
@@ -564,7 +564,7 @@ static HRESULT d3d12_root_signature_init_push_constants(struct d3d12_root_signat
 
         idx = push_constant_count == 1 ? 0 : p->ShaderVisibility;
         offset = push_constants_offset[idx];
-        push_constants_offset[idx] += p->u.Constants.Num32BitValues * sizeof(uint32_t);
+        push_constants_offset[idx] += align(p->u.Constants.Num32BitValues, 4) * sizeof(uint32_t);
 
         root_signature->parameters[i].parameter_type = p->ParameterType;
         root_constant->stage_flags = push_constant_count == 1
@@ -848,7 +848,20 @@ static void vkd3d_descriptor_heap_binding_from_descriptor_range(const struct d3d
     const struct vkd3d_device_descriptor_limits *descriptor_limits = &root_signature->device->vk_info.descriptor_limits;
     unsigned int descriptor_set_size;
 
-    switch (range->type)
+    if (root_signature->device->vk_info.EXT_mutable_descriptor_type)
+    {
+        if (range->type == VKD3D_SHADER_DESCRIPTOR_TYPE_SAMPLER)
+        {
+            binding->set = VKD3D_SET_INDEX_SAMPLER;
+            descriptor_set_size = descriptor_limits->sampler_max_descriptors;
+        }
+        else
+        {
+            binding->set = 0;
+            descriptor_set_size = descriptor_limits->sampled_image_max_descriptors;
+        }
+    }
+    else switch (range->type)
     {
         case VKD3D_SHADER_DESCRIPTOR_TYPE_SRV:
             binding->set = is_buffer ? VKD3D_SET_INDEX_UNIFORM_TEXEL_BUFFER : VKD3D_SET_INDEX_SAMPLED_IMAGE;
@@ -1368,8 +1381,14 @@ static unsigned int d3d12_root_signature_copy_descriptor_set_layouts(const struc
 
     if (device->use_vk_heaps)
     {
+        VkDescriptorSetLayout mutable_layout = device->vk_descriptor_heap_layouts[0].vk_set_layout;
+
         for (set = 0; set < ARRAY_SIZE(device->vk_descriptor_heap_layouts); ++set)
-            vk_set_layouts[i++] = device->vk_descriptor_heap_layouts[set].vk_set_layout;
+        {
+            VkDescriptorSetLayout vk_set_layout = device->vk_descriptor_heap_layouts[set].vk_set_layout;
+            /* All layouts must be valid, so if null, just set it to the mutable one. */
+            vk_set_layouts[i++] = vk_set_layout ? vk_set_layout : mutable_layout;
+        }
     }
 
     return i;
@@ -1691,7 +1710,7 @@ HRESULT vkd3d_render_pass_cache_find(struct vkd3d_render_pass_cache *cache,
     HRESULT hr = S_OK;
     unsigned int i;
 
-    vkd3d_mutex_lock(&device->mutex);
+    vkd3d_mutex_lock(&device->pipeline_cache_mutex);
 
     for (i = 0; i < cache->render_pass_count; ++i)
     {
@@ -1708,7 +1727,7 @@ HRESULT vkd3d_render_pass_cache_find(struct vkd3d_render_pass_cache *cache,
     if (!found)
         hr = vkd3d_render_pass_cache_create_pass_locked(cache, device, key, vk_render_pass);
 
-    vkd3d_mutex_unlock(&device->mutex);
+    vkd3d_mutex_unlock(&device->pipeline_cache_mutex);
 
     return hr;
 }
@@ -2129,6 +2148,18 @@ static inline unsigned int typed_uav_compile_option(const struct d3d12_device *d
             : VKD3D_SHADER_COMPILE_OPTION_TYPED_UAV_READ_FORMAT_R32;
 }
 
+static unsigned int feature_flags_compile_option(const struct d3d12_device *device)
+{
+    unsigned int flags = 0;
+
+    if (device->feature_options1.Int64ShaderOps)
+        flags |= VKD3D_SHADER_COMPILE_OPTION_FEATURE_INT64;
+    if (device->feature_options.DoublePrecisionFloatShaderOps)
+        flags |= VKD3D_SHADER_COMPILE_OPTION_FEATURE_FLOAT64;
+
+    return flags;
+}
+
 static HRESULT create_shader_stage(struct d3d12_device *device,
         struct VkPipelineShaderStageCreateInfo *stage_desc, enum VkShaderStageFlagBits stage,
         const D3D12_SHADER_BYTECODE *code, const struct vkd3d_shader_interface_info *shader_interface)
@@ -2145,6 +2176,7 @@ static HRESULT create_shader_stage(struct d3d12_device *device,
         {VKD3D_SHADER_COMPILE_OPTION_API_VERSION, VKD3D_SHADER_API_VERSION_1_10},
         {VKD3D_SHADER_COMPILE_OPTION_TYPED_UAV, typed_uav_compile_option(device)},
         {VKD3D_SHADER_COMPILE_OPTION_WRITE_TESS_GEOM_POINT_SIZE, 0},
+        {VKD3D_SHADER_COMPILE_OPTION_FEATURE, feature_flags_compile_option(device)},
     };
 
     stage_desc->sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
@@ -2240,7 +2272,7 @@ static HRESULT vkd3d_create_compute_pipeline(struct d3d12_device *device,
     VK_CALL(vkDestroyShaderModule(device->vk_device, pipeline_info.stage.module, NULL));
     if (vr < 0)
     {
-        WARN("Failed to create Vulkan compute pipeline, hr %#x.\n", hr);
+        WARN("Failed to create Vulkan compute pipeline, hr %s.\n", debugstr_hresult(hr));
         return hresult_from_vk_result(vr);
     }
 
@@ -2368,7 +2400,7 @@ static HRESULT d3d12_pipeline_state_find_and_init_uav_counters(struct d3d12_pipe
     }
 
     if (FAILED(hr = d3d12_pipeline_state_init_uav_counters(state, device, root_signature, &shader_info, stage_flags)))
-        WARN("Failed to create descriptor set layout for UAV counters, hr %#x.\n", hr);
+        WARN("Failed to create descriptor set layout for UAV counters, hr %s.\n", debugstr_hresult(hr));
 
     vkd3d_shader_free_scan_descriptor_info(&shader_info);
 
@@ -2442,7 +2474,7 @@ static HRESULT d3d12_pipeline_state_init_compute(struct d3d12_pipeline_state *st
     if (FAILED(hr = vkd3d_create_compute_pipeline(device, &desc->cs, &shader_interface,
             vk_pipeline_layout, &state->u.compute.vk_pipeline)))
     {
-        WARN("Failed to create Vulkan compute pipeline, hr %#x.\n", hr);
+        WARN("Failed to create Vulkan compute pipeline, hr %s.\n", debugstr_hresult(hr));
         d3d12_pipeline_uav_counter_state_cleanup(&state->uav_counters, device);
         return hr;
     }
@@ -3615,7 +3647,7 @@ static VkPipeline d3d12_pipeline_state_find_compiled_pipeline(const struct d3d12
 
     *vk_render_pass = VK_NULL_HANDLE;
 
-    vkd3d_mutex_lock(&device->mutex);
+    vkd3d_mutex_lock(&device->pipeline_cache_mutex);
 
     LIST_FOR_EACH_ENTRY(current, &graphics->compiled_pipelines, struct vkd3d_compiled_pipeline, entry)
     {
@@ -3627,7 +3659,7 @@ static VkPipeline d3d12_pipeline_state_find_compiled_pipeline(const struct d3d12
         }
     }
 
-    vkd3d_mutex_unlock(&device->mutex);
+    vkd3d_mutex_unlock(&device->pipeline_cache_mutex);
 
     return vk_pipeline;
 }
@@ -3646,7 +3678,7 @@ static bool d3d12_pipeline_state_put_pipeline_to_cache(struct d3d12_pipeline_sta
     compiled_pipeline->vk_pipeline = vk_pipeline;
     compiled_pipeline->vk_render_pass = vk_render_pass;
 
-    vkd3d_mutex_lock(&device->mutex);
+    vkd3d_mutex_lock(&device->pipeline_cache_mutex);
 
     LIST_FOR_EACH_ENTRY(current, &graphics->compiled_pipelines, struct vkd3d_compiled_pipeline, entry)
     {
@@ -3661,7 +3693,7 @@ static bool d3d12_pipeline_state_put_pipeline_to_cache(struct d3d12_pipeline_sta
     if (compiled_pipeline)
         list_add_tail(&graphics->compiled_pipelines, &compiled_pipeline->entry);
 
-    vkd3d_mutex_unlock(&device->mutex);
+    vkd3d_mutex_unlock(&device->pipeline_cache_mutex);
     return compiled_pipeline;
 }
 
@@ -3996,14 +4028,14 @@ HRESULT vkd3d_uav_clear_state_init(struct vkd3d_uav_clear_state *state, struct d
         if (FAILED(hr = vkd3d_create_descriptor_set_layout(device, 0,
                 1, false, &set_binding, set_layouts[i].set_layout)))
         {
-            ERR("Failed to create descriptor set layout %u, hr %#x.\n", i, hr);
+            ERR("Failed to create descriptor set layout %u, hr %s.\n", i, debugstr_hresult(hr));
             goto fail;
         }
 
         if (FAILED(hr = vkd3d_create_pipeline_layout(device, 1, set_layouts[i].set_layout,
                 1, &push_constant_range, set_layouts[i].pipeline_layout)))
         {
-            ERR("Failed to create pipeline layout %u, hr %#x.\n", i, hr);
+            ERR("Failed to create pipeline layout %u, hr %s.\n", i, debugstr_hresult(hr));
             goto fail;
         }
     }
@@ -4041,7 +4073,7 @@ HRESULT vkd3d_uav_clear_state_init(struct vkd3d_uav_clear_state *state, struct d
         vkd3d_shader_free_shader_code(&dxbc);
         if (FAILED(hr))
         {
-            ERR("Failed to create compute pipeline %u, hr %#x.\n", i, hr);
+            ERR("Failed to create compute pipeline %u, hr %s.\n", i, debugstr_hresult(hr));
             goto fail;
         }
     }
diff --git a/libs/vkd3d/libs/vkd3d/utils.c b/libs/vkd3d/libs/vkd3d/utils.c
index 9b28068..7519712 100644
--- a/libs/vkd3d/libs/vkd3d/utils.c
+++ b/libs/vkd3d/libs/vkd3d/utils.c
@@ -539,6 +539,7 @@ bool is_valid_feature_level(D3D_FEATURE_LEVEL feature_level)
 {
     static const D3D_FEATURE_LEVEL valid_feature_levels[] =
     {
+        D3D_FEATURE_LEVEL_12_2,
         D3D_FEATURE_LEVEL_12_1,
         D3D_FEATURE_LEVEL_12_0,
         D3D_FEATURE_LEVEL_11_1,
@@ -548,6 +549,7 @@ bool is_valid_feature_level(D3D_FEATURE_LEVEL feature_level)
         D3D_FEATURE_LEVEL_9_3,
         D3D_FEATURE_LEVEL_9_2,
         D3D_FEATURE_LEVEL_9_1,
+        D3D_FEATURE_LEVEL_1_0_CORE,
     };
     unsigned int i;
 
@@ -681,7 +683,7 @@ const char *debug_vk_extent_3d(VkExtent3D extent)
 
 const char *debug_vk_queue_flags(VkQueueFlags flags)
 {
-    char buffer[120];
+    char buffer[159];
 
     buffer[0] = '\0';
 #define FLAG_TO_STR(f) if (flags & f) { strcat(buffer, " | "#f); flags &= ~f; }
@@ -689,6 +691,10 @@ const char *debug_vk_queue_flags(VkQueueFlags flags)
     FLAG_TO_STR(VK_QUEUE_COMPUTE_BIT)
     FLAG_TO_STR(VK_QUEUE_TRANSFER_BIT)
     FLAG_TO_STR(VK_QUEUE_SPARSE_BINDING_BIT)
+    FLAG_TO_STR(VK_QUEUE_PROTECTED_BIT)
+#undef FLAG_TO_STR
+#define FLAG_TO_STR(f, n) if (flags & f) { strcat(buffer, " | "#n); flags &= ~f; }
+    FLAG_TO_STR(0x20, VK_QUEUE_VIDEO_DECODE_BIT_KHR)
 #undef FLAG_TO_STR
     if (flags)
         FIXME("Unrecognized flag(s) %#x.\n", flags);
@@ -727,10 +733,8 @@ const char *debug_vk_memory_property_flags(VkMemoryPropertyFlags flags)
     FLAG_TO_STR(VK_MEMORY_PROPERTY_HOST_CACHED_BIT)
     FLAG_TO_STR(VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT)
     FLAG_TO_STR(VK_MEMORY_PROPERTY_PROTECTED_BIT)
-#undef FLAG_TO_STR
-#define FLAG_TO_STR(f, n) if (flags & f) { strcat(buffer, " | "#n); flags &= ~f; }
-    FLAG_TO_STR(0x40, VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD)
-    FLAG_TO_STR(0x80, VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD)
+    FLAG_TO_STR(VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD)
+    FLAG_TO_STR(VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD)
 #undef FLAG_TO_STR
     if (flags)
         FIXME("Unrecognized flag(s) %#x.\n", flags);
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_main.c b/libs/vkd3d/libs/vkd3d/vkd3d_main.c
index 245edb5..0139de5 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_main.c
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_main.c
@@ -60,7 +60,7 @@ HRESULT vkd3d_create_device(const struct vkd3d_device_create_info *create_info,
     }
     else if (FAILED(hr = vkd3d_create_instance(create_info->instance_create_info, &instance)))
     {
-        WARN("Failed to create instance, hr %#x.\n", hr);
+        WARN("Failed to create instance, hr %s.\n", debugstr_hresult(hr));
         return E_FAIL;
     }
 
@@ -456,7 +456,7 @@ HRESULT vkd3d_serialize_root_signature(const D3D12_ROOT_SIGNATURE_DESC *desc,
         if (error_blob && messages)
         {
             if (FAILED(hr = vkd3d_blob_create(messages, strlen(messages), error_blob)))
-                ERR("Failed to create error blob, hr %#x.\n", hr);
+                ERR("Failed to create error blob, hr %s.\n", debugstr_hresult(hr));
         }
         return hresult_from_vkd3d_result(ret);
     }
@@ -464,7 +464,7 @@ HRESULT vkd3d_serialize_root_signature(const D3D12_ROOT_SIGNATURE_DESC *desc,
 
     if (FAILED(hr = vkd3d_blob_create((void *)dxbc.code, dxbc.size, blob)))
     {
-        WARN("Failed to create blob object, hr %#x.\n", hr);
+        WARN("Failed to create blob object, hr %s.\n", debugstr_hresult(hr));
         vkd3d_shader_free_shader_code(&dxbc);
     }
     return hr;
@@ -497,7 +497,7 @@ HRESULT vkd3d_serialize_versioned_root_signature(const D3D12_VERSIONED_ROOT_SIGN
         if (error_blob && messages)
         {
             if (FAILED(hr = vkd3d_blob_create(messages, strlen(messages), error_blob)))
-                ERR("Failed to create error blob, hr %#x.\n", hr);
+                ERR("Failed to create error blob, hr %s.\n", debugstr_hresult(hr));
         }
         return hresult_from_vkd3d_result(ret);
     }
@@ -505,7 +505,7 @@ HRESULT vkd3d_serialize_versioned_root_signature(const D3D12_VERSIONED_ROOT_SIGN
 
     if (FAILED(hr = vkd3d_blob_create((void *)dxbc.code, dxbc.size, blob)))
     {
-        WARN("Failed to create blob object, hr %#x.\n", hr);
+        WARN("Failed to create blob object, hr %s.\n", debugstr_hresult(hr));
         vkd3d_shader_free_shader_code(&dxbc);
     }
     return hr;
diff --git a/libs/vkd3d/libs/vkd3d/vkd3d_private.h b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
index f06f564..a6d5b94 100644
--- a/libs/vkd3d/libs/vkd3d/vkd3d_private.h
+++ b/libs/vkd3d/libs/vkd3d/vkd3d_private.h
@@ -55,7 +55,7 @@
 
 #define VKD3D_MAX_COMPATIBLE_FORMAT_COUNT 6u
 #define VKD3D_MAX_QUEUE_FAMILY_COUNT      3u
-#define VKD3D_MAX_SHADER_EXTENSIONS       3u
+#define VKD3D_MAX_SHADER_EXTENSIONS       4u
 #define VKD3D_MAX_SHADER_STAGES           5u
 #define VKD3D_MAX_VK_SYNC_OBJECTS         4u
 #define VKD3D_MAX_DEVICE_BLOCKED_QUEUES  16u
@@ -67,7 +67,7 @@
  * this number to prevent excessive pool memory use. */
 #define VKD3D_MAX_VIRTUAL_HEAP_DESCRIPTORS_PER_TYPE (16 * 1024u)
 
-extern LONG64 object_global_serial_id;
+extern uint64_t object_global_serial_id;
 
 struct d3d12_command_list;
 struct d3d12_device;
@@ -133,9 +133,11 @@ struct vkd3d_vulkan_info
     bool EXT_debug_marker;
     bool EXT_depth_clip_enable;
     bool EXT_descriptor_indexing;
+    bool EXT_mutable_descriptor_type;
     bool EXT_robustness2;
     bool EXT_shader_demote_to_helper_invocation;
     bool EXT_shader_stencil_export;
+    bool EXT_shader_viewport_index_layer;
     bool EXT_texel_buffer_alignment;
     bool EXT_transform_feedback;
     bool EXT_vertex_attribute_divisor;
@@ -248,7 +250,7 @@ static inline void vkd3d_cond_broadcast(struct vkd3d_cond *cond)
 static inline void vkd3d_cond_wait(struct vkd3d_cond *cond, struct vkd3d_mutex *lock)
 {
     if (!SleepConditionVariableCS(&cond->cond, &lock->lock, INFINITE))
-        ERR("Could not sleep on the condition variable, error %u.\n", GetLastError());
+        ERR("Could not sleep on the condition variable, error %lu.\n", GetLastError());
 }
 
 static inline void vkd3d_cond_destroy(struct vkd3d_cond *cond)
@@ -619,8 +621,8 @@ struct vkd3d_signaled_semaphore
 struct d3d12_fence
 {
     ID3D12Fence1 ID3D12Fence1_iface;
-    LONG internal_refcount;
-    LONG refcount;
+    unsigned int internal_refcount;
+    unsigned int refcount;
 
     D3D12_FENCE_FLAGS flags;
 
@@ -1363,7 +1365,7 @@ struct vkd3d_buffer
 struct d3d12_command_allocator
 {
     ID3D12CommandAllocator ID3D12CommandAllocator_iface;
-    LONG refcount;
+    unsigned int refcount;
 
     D3D12_COMMAND_LIST_TYPE type;
     VkQueueFlags vk_queue_flags;
@@ -1464,7 +1466,7 @@ enum vkd3d_pipeline_bind_point
 struct d3d12_command_list
 {
     ID3D12GraphicsCommandList5 ID3D12GraphicsCommandList5_iface;
-    LONG refcount;
+    unsigned int refcount;
 
     D3D12_COMMAND_LIST_TYPE type;
     VkQueueFlags vk_queue_flags;
@@ -1620,7 +1622,7 @@ struct d3d12_command_queue_op_array
 struct d3d12_command_queue
 {
     ID3D12CommandQueue ID3D12CommandQueue_iface;
-    LONG refcount;
+    unsigned int refcount;
 
     D3D12_COMMAND_QUEUE_DESC desc;
 
@@ -1655,7 +1657,7 @@ HRESULT d3d12_command_queue_create(struct d3d12_device *device,
 struct d3d12_command_signature
 {
     ID3D12CommandSignature ID3D12CommandSignature_iface;
-    LONG refcount;
+    unsigned int refcount;
     unsigned int internal_refcount;
 
     D3D12_COMMAND_SIGNATURE_DESC desc;
@@ -1757,9 +1759,23 @@ struct d3d12_device
 
     struct vkd3d_gpu_va_allocator gpu_va_allocator;
 
-    struct vkd3d_mutex mutex;
     struct vkd3d_desc_object_cache view_desc_cache;
     struct vkd3d_desc_object_cache cbuffer_desc_cache;
+
+    VkDescriptorPoolSize vk_pool_sizes[VKD3D_DESCRIPTOR_POOL_COUNT];
+    unsigned int vk_pool_count;
+    struct vkd3d_vk_descriptor_heap_layout vk_descriptor_heap_layouts[VKD3D_SET_INDEX_COUNT];
+    bool use_vk_heaps;
+
+    struct d3d12_descriptor_heap **heaps;
+    size_t heap_capacity;
+    size_t heap_count;
+    union vkd3d_thread_handle worker_thread;
+    struct vkd3d_mutex worker_mutex;
+    struct vkd3d_cond worker_cond;
+    bool worker_should_exit;
+
+    struct vkd3d_mutex pipeline_cache_mutex;
     struct vkd3d_render_pass_cache render_pass_cache;
     VkPipelineCache vk_pipeline_cache;
 
@@ -1799,11 +1815,6 @@ struct d3d12_device
     const struct vkd3d_format_compatibility_list *format_compatibility_lists;
     struct vkd3d_null_resources null_resources;
     struct vkd3d_uav_clear_state uav_clear_state;
-
-    VkDescriptorPoolSize vk_pool_sizes[VKD3D_DESCRIPTOR_POOL_COUNT];
-    unsigned int vk_pool_count;
-    struct vkd3d_vk_descriptor_heap_layout vk_descriptor_heap_layouts[VKD3D_SET_INDEX_COUNT];
-    bool use_vk_heaps;
 };
 
 HRESULT d3d12_device_create(struct vkd3d_instance *instance,
@@ -1813,6 +1824,8 @@ bool d3d12_device_is_uma(struct d3d12_device *device, bool *coherent);
 void d3d12_device_mark_as_removed(struct d3d12_device *device, HRESULT reason,
         const char *message, ...) VKD3D_PRINTF_FUNC(3, 4);
 struct d3d12_device *unsafe_impl_from_ID3D12Device5(ID3D12Device5 *iface);
+HRESULT d3d12_device_add_descriptor_heap(struct d3d12_device *device, struct d3d12_descriptor_heap *heap);
+void d3d12_device_remove_descriptor_heap(struct d3d12_device *device, struct d3d12_descriptor_heap *heap);
 
 static inline HRESULT d3d12_device_query_interface(struct d3d12_device *device, REFIID iid, void **object)
 {
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index 9a88656..f7e9021 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -63,6 +63,7 @@ AddReg=\
     Debugger,\
     DirectX,\
     Fonts,\
+    KeyboardLayouts,\
     MCI,\
     Misc,\
     OLE,\
@@ -86,6 +87,7 @@ AddReg=\
     Debugger,\
     DirectX,\
     Fonts,\
+    KeyboardLayouts,\
     MCI,\
     Misc,\
     OLE,\
@@ -111,6 +113,7 @@ AddReg=\
     Debugger,\
     DirectX,\
     Fonts,\
+    KeyboardLayouts,\
     MCI,\
     Misc,\
     OLE,\
@@ -156,6 +159,7 @@ AddReg=\
     CurrentVersionWow64.ntx86,\
     Debugger,\
     DirectX,\
+    KeyboardLayouts,\
     MCI,\
     Misc,\
     Tapi,\
@@ -284,6 +288,7 @@ HKCR,chm.file\shell\open\command,,2,"""%10%\hh.exe"" ""%1"""
 HKCR,cplfile,,2,"Control Panel Item"
 HKCR,cplfile\shell\cplopen,,2,"Open with Control Panel"
 HKCR,cplfile\shell\cplopen\command,,2,"rundll32.exe shell32.dll,Control_RunDLL ""%1"",%*"
+HKCR,Directory\Background\shellex\ContextMenuHandlers\New,,16
 HKCR,DirectShow,,16
 HKCR,exefile,,2,"Application"
 HKCR,exefile\DefaultIcon,,2,"%1"
@@ -375,7 +380,7 @@ HKLM,%CurrentVersion%\Explorer\DriveIcons,,16
 HKLM,%CurrentVersion%\Explorer\KindMap,,16
 HKLM,%CurrentVersion%\Group Policy,,16
 HKLM,%CurrentVersion%\Installer,"InstallerLocation",,"%11%"
-HKLM,%CurrentVersion%\Policies\System,"EnableLUA",0x10003,0
+HKLM,%CurrentVersion%\Policies\System,"EnableLUA",0x10001,1
 HKLM,%CurrentVersion%\PreviewHandlers,,16
 HKLM,%CurrentVersion%\Run,,16
 HKLM,%CurrentVersion%\Setup,"BootDir",,"%30%"
@@ -584,6 +589,49 @@ HKLM,Software\Microsoft\Rpc\SecurityService,68,2,"netlogon.dll"
 HKLM,Software\Microsoft\Rpc\SecurityService,9,2,"secur32.dll"
 HKLM,Software\Microsoft\Shared Tools\MSInfo,,16
 HKLM,Software\Microsoft\SystemCertificates,,16
+HKLM,Software\Microsoft\SystemCertificates\CA\Certificates\23340A0167398E341C5890709FD30EED44FC1964,"Blob",1,\
+    03,00,00,00,01,00,00,00,14,00,00,00,23,34,0a,01,67,39,8e,34,1c,58,90,70,9f,d3,0e,ed,44,fc,19,64,20,00,00,\
+    00,01,00,00,00,81,05,00,00,30,82,05,7d,30,82,03,65,a0,03,02,01,02,02,09,00,87,0d,26,f3,cb,4a,11,1b,30,0d,\
+    06,09,2a,86,48,86,f7,0d,01,01,0d,05,00,30,55,31,0b,30,09,06,03,55,04,06,13,02,55,53,31,13,30,11,06,03,55,\
+    04,08,0c,0a,53,6f,6d,65,2d,53,74,61,74,65,31,0d,30,0b,06,03,55,04,0a,0c,04,57,69,6e,65,31,22,30,20,06,03,\
+    55,04,03,0c,19,49,6e,76,61,6c,69,64,20,64,75,6d,6d,79,20,63,65,72,74,69,66,69,63,61,74,65,30,1e,17,0d,31,\
+    36,30,33,31,33,30,32,31,33,33,31,5a,17,0d,31,36,30,33,31,32,30,32,31,33,33,31,5a,30,55,31,0b,30,09,06,03,\
+    55,04,06,13,02,55,53,31,13,30,11,06,03,55,04,08,0c,0a,53,6f,6d,65,2d,53,74,61,74,65,31,0d,30,0b,06,03,55,\
+    04,0a,0c,04,57,69,6e,65,31,22,30,20,06,03,55,04,03,0c,19,49,6e,76,61,6c,69,64,20,64,75,6d,6d,79,20,63,65,\
+    72,74,69,66,69,63,61,74,65,30,82,02,22,30,0d,06,09,2a,86,48,86,f7,0d,01,01,01,05,00,03,82,02,0f,00,30,82,\
+    02,0a,02,82,02,01,00,ec,26,db,20,a6,25,fc,6d,d7,7f,35,45,2a,bd,26,9a,6c,a7,f3,4c,e7,d4,1b,c1,44,bf,13,61,\
+    9c,93,9f,ff,f2,89,d7,aa,52,d0,e0,d3,41,99,00,a5,82,0e,71,e2,f7,22,0c,9c,3a,21,e1,b2,ba,a8,e2,0b,6f,7c,7c,\
+    fb,92,c4,98,9f,01,dd,17,b4,f7,ac,ab,75,40,fb,b8,1d,7c,4f,c2,ac,6f,d5,ed,38,b6,b5,dd,73,fe,3d,21,f7,fd,81,\
+    e6,af,fe,85,a4,0b,9c,d2,d2,7f,fd,45,3e,7f,80,ce,69,69,38,e1,5c,9c,bc,fd,4c,8b,64,78,f7,45,56,53,8f,97,aa,\
+    98,3a,49,37,2e,45,a6,dc,04,fc,89,26,71,fd,15,24,3b,66,5c,3d,fe,7f,ef,25,b3,01,94,a1,8f,83,5d,b0,d7,d5,1c,\
+    8e,14,b2,95,f5,52,28,50,ab,81,74,0e,0f,5f,61,fe,4b,03,e0,c4,98,3a,f9,01,c7,f0,c9,66,12,d9,60,17,a9,1e,6b,\
+    2d,91,6b,de,95,96,58,f5,81,21,af,d1,7f,99,01,cb,e6,1d,cf,d3,0f,1e,70,4b,de,2b,2c,fe,1f,1d,d8,76,32,74,8d,\
+    bc,4f,0c,33,6d,3b,9f,ba,15,16,28,70,44,6b,da,c5,85,11,4f,bd,4c,00,b4,f1,03,93,89,18,63,1d,ec,3e,ad,6a,b1,\
+    fc,07,f7,65,7c,bf,6a,c8,e7,2a,19,40,0a,55,59,39,63,b1,b8,a8,95,20,62,ae,97,82,af,d6,b1,97,ce,ba,29,19,9f,\
+    dd,c8,63,a0,80,34,e5,a0,c5,f6,b2,95,b1,8e,34,39,34,08,cb,24,70,a7,fb,8e,34,2c,e4,41,77,ea,05,3b,30,5e,71,\
+    b9,64,9f,bf,a6,db,d8,ef,5e,42,9c,4e,5d,47,68,a5,23,15,4f,07,3c,d3,ea,62,ff,af,4c,08,e7,9b,2b,9c,0a,69,f7,\
+    3e,ab,8a,05,40,d2,17,7e,0f,c8,37,2b,e2,62,25,f7,e9,e0,d7,8f,18,ff,46,f9,35,3f,2d,d6,3e,cf,e2,fd,08,0d,1f,\
+    63,ff,80,75,50,3b,a9,44,11,c8,b4,ae,a4,24,17,e3,0d,8a,a5,d3,56,37,97,99,91,c1,62,f9,75,a6,77,e0,25,f6,a4,\
+    9c,83,36,bb,4a,c5,82,c4,86,03,2f,dd,6f,c4,45,ec,fe,d0,51,d6,e0,d2,6a,da,00,30,24,c0,8e,e8,a1,ce,4c,7f,bb,\
+    54,09,05,9e,2b,93,95,c8,ac,39,12,29,56,4e,b0,20,36,9c,a3,b6,cb,46,59,a3,2b,62,2c,2d,57,02,03,01,00,01,a3,\
+    50,30,4e,30,1d,06,03,55,1d,0e,04,16,04,14,d1,85,39,b7,9b,05,e7,f9,54,12,91,68,ed,93,ec,63,eb,d3,8f,14,30,\
+    1f,06,03,55,1d,23,04,18,30,16,80,14,d1,85,39,b7,9b,05,e7,f9,54,12,91,68,ed,93,ec,63,eb,d3,8f,14,30,0c,06,\
+    03,55,1d,13,04,05,30,03,01,01,ff,30,0d,06,09,2a,86,48,86,f7,0d,01,01,0d,05,00,03,82,02,01,00,be,a7,cf,6e,\
+    e7,3d,5d,f2,38,0c,f9,69,85,fe,79,25,cf,c5,5b,d3,4e,4b,ec,20,16,1b,46,1a,d9,a4,a1,84,24,9a,4d,0d,44,70,83,\
+    be,e3,af,5b,ac,c4,31,e3,d5,f8,cc,af,71,11,2d,ea,a8,44,20,81,8b,e3,f6,da,77,6a,f6,15,f3,11,78,78,76,4f,6d,\
+    b6,8c,a5,27,41,0a,16,b6,c8,56,dc,a6,a2,0a,e2,87,e9,ab,f0,05,8b,61,7c,a7,03,2f,30,cc,dd,21,7e,48,43,10,cd,\
+    aa,9e,37,69,7c,3e,2f,7b,c1,0c,78,80,aa,18,92,95,a0,2a,9e,2f,a6,33,6b,91,8d,fb,f1,47,16,ec,87,86,7a,26,d3,\
+    57,a9,89,37,76,86,76,9b,96,bf,f1,2a,e3,62,2a,bc,66,7b,91,62,fb,a2,7e,16,c6,6e,84,08,49,b0,9d,5d,42,b7,64,\
+    39,1f,49,a6,a2,98,bc,ca,57,e5,f5,91,c0,6b,6c,94,56,68,34,00,96,25,1d,e5,bb,9e,2f,1a,dd,c2,27,e4,49,f2,54,\
+    68,0a,e3,1b,4c,01,14,0d,64,8c,d6,ab,73,af,51,b6,fe,af,0a,b6,c1,99,36,97,f8,44,48,64,d3,c0,ab,d9,a8,da,06,\
+    1a,27,c3,24,cf,7a,30,12,38,20,6c,71,ea,57,fa,b6,24,23,42,3d,be,07,f9,d7,de,b2,91,20,a6,57,79,06,60,42,cb,\
+    73,2b,98,ea,49,78,ee,47,71,a5,1c,f1,f9,8f,78,49,ad,6f,21,72,1a,d2,90,02,59,01,7d,f1,cd,c7,43,4c,f4,6c,90,\
+    59,38,bf,46,92,09,24,3b,51,2b,49,2a,a7,f9,7c,96,44,e6,ed,8e,7d,85,64,6b,ca,7b,e3,af,bd,73,ae,17,31,52,2a,\
+    9f,a3,3b,dd,3d,33,59,26,7c,6d,46,ff,5b,dd,3c,82,dd,d1,3d,9c,31,2a,82,7e,85,ce,ef,a6,34,98,96,87,7a,2b,a0,\
+    a5,5a,9c,2a,5c,f4,79,36,b4,85,87,eb,fd,7e,94,83,40,b0,4f,d7,03,c1,df,75,37,30,4f,46,6b,29,b5,0f,b7,4f,19,\
+    73,79,dd,ee,2d,2c,c8,1f,72,ee,63,4a,32,85,33,57,1d,f5,89,53,4f,b2,1e,20,9b,11,e4,43,99,15,65,c4,a0,ec,cf,\
+    d3,0f,d6,b2,2c,8c,a7,6d,5f,11,2f,0e,e4,f7,e9,d4,13,db,fb,f6,0a,51,ac,6c,08,ef,d6,cb,81,86,53,36,a8,a0,02,\
+    de,31,47,56,db,65,f1,7e,3a,c8,69,5b,69,ab,34,3e,48,a3
 HKLM,Software\Microsoft\TermServLicensing,,16
 HKLM,Software\Microsoft\Transaction Server,,16
 HKLM,Software\Microsoft\WBEM,"Installation Directory",2,"%11%\wbem"
@@ -629,6 +677,211 @@ HKCU,Software\Microsoft\Windows\Shell\Associations\UrlAssociations\ftp\UserChoic
 HKCU,Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice,"ProgId",,"http"
 HKCU,Software\Microsoft\Windows\Shell\Associations\UrlAssociations\https\UserChoice,"ProgId",,"https"
 
+[KeyboardLayouts]
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000401,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000404,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000405,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000406,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000407,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000040f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000410,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000411,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000412,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000413,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000414,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000415,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000416,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000418,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000419,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000041f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000420,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000422,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000423,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000424,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000425,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000426,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000427,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000428,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000429,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000042f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000432,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000438,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000439,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000043a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000043b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000043f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000440,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000442,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000444,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000445,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000446,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000447,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000448,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000449,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000044e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000450,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000451,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000452,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000453,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000454,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000045a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000045b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000045c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000461,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000463,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000465,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000468,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000046f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000470,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000474,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000475,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000480,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000481,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000485,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000488,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000492,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000804,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000807,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000809,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000080a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000080c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000813,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000816,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000081a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000082c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000083b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000843,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000850,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000085d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000085f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000c04,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000c0c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00000c1a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00001004,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00001009,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000100c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000105f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00001404,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00001809,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0000201a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00004009,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010401,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010405,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010407,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001040a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001040e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010410,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010415,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010416,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010418,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010419,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001041b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001041e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001041f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010426,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010427,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001042b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001042c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001042e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001042f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010439,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001043a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001043b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010444,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010445,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010451,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010453,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001045a,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001045b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001045c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001045d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010465,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010480,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001080c,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001083b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010850,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00010c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00011009,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0001105f,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00011809,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020401,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020405,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002040d,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020418,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020419,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002041e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020422,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020426,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020427,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002042b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002042e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020445,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0002083b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00020c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0003041e,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\0003042b,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00030c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040402,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040437,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00040c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00050408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00050409,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00050429,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00060408,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00070c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00080c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00090c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000a0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000b0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000c0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000d0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000e0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\000f0c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00100c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00110c00,,16
+HKLM,SYSTEM\CurrentControlSet\Control\Keyboard Layouts\00120c00,,16
+
 [OLE]
 HKLM,"Software\Microsoft\OLE","EnableDCOM",,"Y"
 HKLM,"Software\Microsoft\OLE","EnableRemoteConnect",,"N"
@@ -2211,6 +2464,7 @@ HKLM,%CurrentVersion%\Telephony\Country List\998,"SameAreaRule",,"G"
 11,,explorer.exe
 11,,iexplore.exe
 11,,notepad.exe
+11,,win32k.sys
 11,,winetest.exe,-
 ; themes
 10,resources\themes\light,light.msstyles
diff --git a/programs/cmd/builtins.c b/programs/cmd/builtins.c
index ca703af..fcc3a54 100644
--- a/programs/cmd/builtins.c
+++ b/programs/cmd/builtins.c
@@ -31,6 +31,9 @@
 #include "wcmd.h"
 #include <shellapi.h>
 #include "wine/debug.h"
+#include "winternl.h"
+#include "winioctl.h"
+#include "ntifs.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(cmd);
 
@@ -4907,11 +4910,11 @@ void WCMD_assoc (const WCHAR *args, BOOL assoc) {
         /* If nothing after '=' then clear value - only valid for ASSOC */
         if (*newValue == 0x00) {
 
-          if (assoc) rc = RegDeleteKeyW(key, args);
-          if (assoc && rc == ERROR_SUCCESS) {
+          rc = RegDeleteTreeW(key, args);
+          if (rc == ERROR_SUCCESS) {
             WINE_TRACE("HKCR Key '%s' deleted\n", wine_dbgstr_w(args));
 
-          } else if (assoc && rc != ERROR_FILE_NOT_FOUND) {
+          } else if (rc != ERROR_FILE_NOT_FOUND) {
             WCMD_print_error();
             errorlevel = 2;
 
@@ -5003,6 +5006,49 @@ void WCMD_color (void) {
   }
 }
 
+BOOL WCMD_create_junction(WCHAR *link, WCHAR *target) {
+    static INT struct_size = offsetof(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0]);
+    static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
+    INT buffer_size, data_size, string_len, prefix_len;
+    WCHAR *subst_dest, *print_dest, *string;
+    REPARSE_DATA_BUFFER *buffer;
+    UNICODE_STRING nt_name;
+    NTSTATUS status;
+    HANDLE hlink;
+    DWORD dwret;
+    BOOL ret;
+
+    if (!CreateDirectoryW(link, NULL ))
+        return FALSE;
+    hlink = CreateFileW(link, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (hlink == INVALID_HANDLE_VALUE)
+        return FALSE;
+    status = RtlDosPathNameToNtPathName_U_WithStatus(target, &nt_name, NULL, NULL);
+    if (status)
+        return FALSE;
+    prefix_len = strlen("\\??\\");
+    string = nt_name.Buffer;
+    string_len = lstrlenW( &string[prefix_len] );
+    data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
+    buffer_size = struct_size + data_size;
+    buffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_size );
+    buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+    buffer->ReparseDataLength = struct_size - header_size + data_size;
+    buffer->MountPointReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
+    buffer->MountPointReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
+    buffer->MountPointReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
+    subst_dest = &buffer->MountPointReparseBuffer.PathBuffer[0];
+    print_dest = &buffer->MountPointReparseBuffer.PathBuffer[prefix_len + string_len + 1];
+    lstrcpyW(subst_dest, string);
+    lstrcpyW(print_dest, &string[prefix_len]);
+    RtlFreeUnicodeString(&nt_name );
+    ret = DeviceIoControl(hlink, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_size, NULL, 0,
+                          &dwret, 0 );
+    HeapFree(GetProcessHeap(), 0, buffer);
+    return ret;
+}
+
 /****************************************************************************
  * WCMD_mklink
  */
@@ -5051,7 +5097,7 @@ void WCMD_mklink(WCHAR *args)
     else if(!junction)
         ret = CreateSymbolicLinkW(file1, file2, isdir);
     else
-        WINE_TRACE("Juction links currently not supported.\n");
+        ret = WCMD_create_junction(file1, file2);
 
     if(!ret)
         WCMD_output_stderr(WCMD_LoadMessage(WCMD_READFAIL), file1);
diff --git a/programs/cmd/directory.c b/programs/cmd/directory.c
index 709bbb5..f553f34 100644
--- a/programs/cmd/directory.c
+++ b/programs/cmd/directory.c
@@ -23,6 +23,8 @@
 
 #include "wcmd.h"
 #include "wine/debug.h"
+#include "winioctl.h"
+#include "ntifs.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(cmd);
 
@@ -377,6 +379,65 @@ static DIRECTORY_STACK *WCMD_list_directory (DIRECTORY_STACK *inputparms, int le
             WCMD_output(L"%1!*s!", cur_width - tmp_width, L"");
         }
 
+      } else if (fd[i].dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
+        if (!bare) {
+           const WCHAR *type;
+
+           switch(fd[i].dwReserved0) {
+           case IO_REPARSE_TAG_MOUNT_POINT:
+              type = L"<JUNCTION>";
+              break;
+           case IO_REPARSE_TAG_SYMLINK:
+           default:
+              type = (fd[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? L"<SYMLINKD>" : L"<SYMLINK>";
+              break;
+           }
+           WCMD_output (L"%1!10s!  %2!8s!  %3!-14s!", datestring, timestring, type);
+           if (shortname) WCMD_output (L"%1!-13s!", fd[i].cAlternateFileName);
+           if (usernames) WCMD_output (L"%1!-23s!", username);
+           WCMD_output(L"%1",fd[i].cFileName);
+           if (fd[i].dwReserved0) {
+              REPARSE_DATA_BUFFER *buffer = NULL;
+              WCHAR *target = NULL;
+              INT buffer_len;
+              HANDLE hlink;
+              DWORD dwret;
+              BOOL bret;
+
+              lstrcpyW(string, inputparms->dirName);
+              lstrcatW(string, fd[i].cFileName);
+              hlink = CreateFileW(string, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                                  FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+              buffer_len = sizeof(*buffer) + 2*MAX_PATH*sizeof(WCHAR);
+              buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
+              bret = DeviceIoControl(hlink, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer,
+                                     buffer_len, &dwret, 0);
+              if (bret) {
+                 INT offset;
+                 switch(buffer->ReparseTag) {
+                 case IO_REPARSE_TAG_MOUNT_POINT:
+                    offset = buffer->MountPointReparseBuffer.PrintNameOffset/sizeof(WCHAR);
+                    target = &buffer->MountPointReparseBuffer.PathBuffer[offset];
+                    break;
+                 case IO_REPARSE_TAG_SYMLINK:
+                    offset = buffer->SymbolicLinkReparseBuffer.PrintNameOffset/sizeof(WCHAR);
+                    target = &buffer->SymbolicLinkReparseBuffer.PathBuffer[offset];
+                    break;
+                 }
+              }
+              CloseHandle(hlink);
+              if (target) WCMD_output(L" [%1]", target);
+              HeapFree(GetProcessHeap(), 0, buffer);
+           }
+        } else {
+           if (!((lstrcmpW(fd[i].cFileName, L".") == 0) ||
+                 (lstrcmpW(fd[i].cFileName, L"..") == 0))) {
+              WCMD_output (L"%1%2", recurse?inputparms->dirName : L"", fd[i].cFileName);
+           } else {
+              addNewLine = FALSE;
+           }
+        }
+
       } else if (fd[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
         dir_count++;
 
diff --git a/programs/cmd/tests/test_builtins.cmd b/programs/cmd/tests/test_builtins.cmd
index 510a1ba..b51e601 100644
--- a/programs/cmd/tests/test_builtins.cmd
+++ b/programs/cmd/tests/test_builtins.cmd
@@ -2540,6 +2540,12 @@ echo echo +++>> tmp.cmd
 echo ftype footype>> tmp.cmd
 cmd /c tmp.cmd
 
+echo --- testing association
+ftype footype=cmd.exe /c "echo '%%1'"
+echo dummy>test.foo
+test.foo
+del test.foo
+
 echo --- resetting association
 assoc .foo=
 
@@ -2571,6 +2577,9 @@ echo .foo=footype
 echo footype=foo_opencmd
 echo +++
 echo footype=foo_opencmd
+echo --- testing association
+echo footype=cmd.exe /c "echo '%%1'"
+echo Skipped as not enough permissions
 echo --- resetting association
 echo original value
 
diff --git a/programs/cmd/tests/test_builtins.cmd.exp b/programs/cmd/tests/test_builtins.cmd.exp
index 0f48a82..8ae0279 100644
--- a/programs/cmd/tests/test_builtins.cmd.exp
+++ b/programs/cmd/tests/test_builtins.cmd.exp
@@ -1488,8 +1488,11 @@ footype=foo_opencmd
 footype=foo_opencmd
 +++
 footype=foo_opencmd
+--- testing association
+footype=cmd.exe /c "echo '%1'"
+'@drive@@path@foobar\test.foo'@or_broken@Skipped as not enough permissions
 --- resetting association
-@todo_wine@original value@or_broken@buggyXP@or_broken@!WINE_FOO!
+original value@or_broken@buggyXP@or_broken@!WINE_FOO!
 ------------ Testing CALL ------------
 --- external script
 foo@space@
diff --git a/programs/cmd/wcmdmain.c b/programs/cmd/wcmdmain.c
index 843fef8..43f5811 100644
--- a/programs/cmd/wcmdmain.c
+++ b/programs/cmd/wcmdmain.c
@@ -1153,8 +1153,10 @@ void WCMD_run_program (WCHAR *command, BOOL called)
 
     /* 1. If extension supplied, see if that file exists */
     if (extensionsupplied) {
-      if (GetFileAttributesW(thisDir) != INVALID_FILE_ATTRIBUTES) {
+      DWORD attribs = GetFileAttributesW(thisDir);
+      if (attribs != INVALID_FILE_ATTRIBUTES && !(attribs&FILE_ATTRIBUTE_DIRECTORY)) {
         found = TRUE;
+        WINE_TRACE("Found as file with extension as '%s'\n", wine_dbgstr_w(thisDir));
       }
     }
 
@@ -1184,6 +1186,7 @@ void WCMD_run_program (WCHAR *command, BOOL called)
           }
 
           if (GetFileAttributesW(thisDir) != INVALID_FILE_ATTRIBUTES) {
+            WINE_TRACE("Found via search and pathext as '%s'\n", wine_dbgstr_w(thisDir));
             found = TRUE;
             thisExt = NULL;
           }
@@ -1205,52 +1208,115 @@ void WCMD_run_program (WCHAR *command, BOOL called)
       /* Special case BAT and CMD */
       if (ext && (!wcsicmp(ext, L".bat") || !wcsicmp(ext, L".cmd"))) {
         BOOL oldinteractive = interactive;
+        WINE_TRACE("Calling batch program\n");
         interactive = FALSE;
         WCMD_batch (thisDir, command, called, NULL, INVALID_HANDLE_VALUE);
         interactive = oldinteractive;
+        WINE_TRACE("Back from call to batch program\n");
         return;
-      } else {
+      }
 
-        /* thisDir contains the file to be launched, but with what?
-           eg. a.exe will require a.exe to be launched, a.html may be iexplore */
-        hinst = FindExecutableW (thisDir, NULL, temp);
-        if ((INT_PTR)hinst < 32)
-          console = 0;
-        else
-          console = SHGetFileInfoW(temp, 0, &psfi, sizeof(psfi), SHGFI_EXETYPE);
-
-        ZeroMemory (&st, sizeof(STARTUPINFOW));
-        st.cb = sizeof(STARTUPINFOW);
-        init_msvcrt_io_block(&st);
-
-        /* Launch the process and if a CUI wait on it to complete
-           Note: Launching internal wine processes cannot specify a full path to exe */
-        status = CreateProcessW(thisDir,
-                                command, NULL, NULL, TRUE, 0, NULL, NULL, &st, &pe);
-        free(st.lpReserved2);
-        if ((opt_c || opt_k) && !opt_s && !status
-            && GetLastError()==ERROR_FILE_NOT_FOUND && command[0]=='\"') {
-          /* strip first and last quote WCHARacters and try again */
-          WCMD_strip_quotes(command);
-          opt_s = TRUE;
-          WCMD_run_program(command, called);
+      /* Calculate what program will be launched, and whether it is a
+         console application or not. Note the program may be different
+         from the parameter (eg running a .txt file will launch notepad.exe) */
+      hinst = FindExecutableW (thisDir, NULL, temp);
+      if ((INT_PTR)hinst < 32)
+        console = 0;   /* Assume not console app by default */
+      else
+        console = SHGetFileInfoW(temp, 0, &psfi, sizeof(psfi), SHGFI_EXETYPE);
+
+
+      /* If it is not a .com or .exe, try to launch through ShellExecuteExW
+         which takes into account the association for the extension.        */
+      if (ext && (wcsicmp(ext, L".exe") && wcsicmp(ext, L".com"))) {
+
+        SHELLEXECUTEINFOW shexw;
+        BOOL              rc;
+        WCHAR            *rawarg;
+
+        WCMD_parameter(command, 1, &rawarg, FALSE, TRUE);
+        WINE_TRACE("Launching via ShellExecuteEx\n");
+        memset(&shexw, 0x00, sizeof(shexw));
+        shexw.cbSize   = sizeof(SHELLEXECUTEINFOW);
+        shexw.fMask    = SEE_MASK_NO_CONSOLE |      /* Run in same console as currently using       */
+                         SEE_MASK_NOCLOSEPROCESS;   /* We need a process handle to possibly wait on */
+        shexw.lpFile   = thisDir;
+        shexw.lpParameters = rawarg;
+        shexw.nShow    = SW_SHOWNORMAL;
+
+        /* Try to launch the binary or its associated program */
+        rc = ShellExecuteExW(&shexw);
+
+        if (rc && (INT_PTR)shexw.hInstApp >= 32) {
+
+          WINE_TRACE("Successfully launched\n");
+
+          /* It worked... Always wait when non-interactive (cmd /c or in
+             batch program), or for console applications                  */
+          if (!interactive || (console && !HIWORD(console))) {
+            WINE_TRACE("Waiting for process to end\n");
+            WaitForSingleObject (shexw.hProcess, INFINITE);
+          }
+
+          GetExitCodeProcess (shexw.hProcess, &errorlevel);
+          if (errorlevel == STILL_ACTIVE) {
+            WINE_TRACE("Process still running, but returning anyway\n");
+            errorlevel = 0;
+          } else {
+            WINE_TRACE("Process ended, errorlevel %ld\n", errorlevel);
+          }
+
+          CloseHandle(pe.hProcess);
           return;
+
         }
+      }
 
-        if (!status)
-          break;
+      /* If its a .exe or .com or the shellexecute failed due to no association,
+         CreateProcess directly                                                  */
+      ZeroMemory (&st, sizeof(STARTUPINFOW));
+      st.cb = sizeof(STARTUPINFOW);
+      init_msvcrt_io_block(&st);
+
+      /* Launch the process and if a CUI wait on it to complete
+         Note: Launching internal wine processes cannot specify a full path to exe */
+      WINE_TRACE("Launching via CreateProcess\n");
+      status = CreateProcessW(thisDir,
+                              command, NULL, NULL, TRUE, 0, NULL, NULL, &st, &pe);
+      free(st.lpReserved2);
+      if ((opt_c || opt_k) && !opt_s && !status
+          && GetLastError()==ERROR_FILE_NOT_FOUND && command[0]=='\"') {
+        /* strip first and last quote WCHARacters and try again */
+        WCMD_strip_quotes(command);
+        opt_s = TRUE;
+        WCMD_run_program(command, called);
+        return;
+      }
 
-        /* Always wait when non-interactive (cmd /c or in batch program),
-           or for console applications                                    */
-        if (!interactive || (console && !HIWORD(console)))
-            WaitForSingleObject (pe.hProcess, INFINITE);
-        GetExitCodeProcess (pe.hProcess, &errorlevel);
-        if (errorlevel == STILL_ACTIVE) errorlevel = 0;
+      if (!status) {
+        WINE_TRACE("Failed to launch via CreateProcess, rc %d (%ld)\n",
+                   status, GetLastError());
+        break;
+      }
 
-        CloseHandle(pe.hProcess);
-        CloseHandle(pe.hThread);
-        return;
+      /* Always wait when non-interactive (cmd /c or in batch program),
+         or for console applications                                    */
+      if (!interactive || (console && !HIWORD(console))) {
+          WINE_TRACE("Waiting for process to end\n");
+          WaitForSingleObject (pe.hProcess, INFINITE);
       }
+
+      GetExitCodeProcess (pe.hProcess, &errorlevel);
+      if (errorlevel == STILL_ACTIVE) {
+        WINE_TRACE("Process still running, but returning anyway\n");
+        errorlevel = 0;
+      } else {
+        WINE_TRACE("Process ended, errorlevel %ld\n", errorlevel);
+      }
+
+      CloseHandle(pe.hProcess);
+      CloseHandle(pe.hThread);
+      return;
     }
   }
 
diff --git a/programs/explorer/desktop.c b/programs/explorer/desktop.c
index 9a58f13..081b1fc 100644
--- a/programs/explorer/desktop.c
+++ b/programs/explorer/desktop.c
@@ -844,6 +844,7 @@ static BOOL get_default_enable_shell( const WCHAR *name )
 static void load_graphics_driver( const WCHAR *driver, GUID *guid )
 {
     static const WCHAR device_keyW[] = L"System\\CurrentControlSet\\Control\\Video\\{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\\0000";
+    static const WCHAR video_keyW[]  = L"System\\CurrentControlSet\\Control\\Video\\0000";
 
     WCHAR buffer[MAX_PATH], libname[32], *name, *next;
     WCHAR key[ARRAY_SIZE( device_keyW ) + 39];
@@ -900,6 +901,10 @@ static void load_graphics_driver( const WCHAR *driver, GUID *guid )
 
     TRACE( "display %s driver %s\n", debugstr_guid(guid), debugstr_w(libname) );
 
+    /* create video key first without REG_OPTION_VOLATILE attribute */
+    if (!RegCreateKeyExW( HKEY_LOCAL_MACHINE, video_keyW, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkey, NULL ))
+        RegCloseKey( hkey );
+
     swprintf( key, ARRAY_SIZE(key), device_keyW, guid->Data1, guid->Data2, guid->Data3,
               guid->Data4[0], guid->Data4[1], guid->Data4[2], guid->Data4[3],
               guid->Data4[4], guid->Data4[5], guid->Data4[6], guid->Data4[7] );
diff --git a/programs/where/Makefile.in b/programs/where/Makefile.in
index bca4259..125c550 100644
--- a/programs/where/Makefile.in
+++ b/programs/where/Makefile.in
@@ -1,4 +1,5 @@
 MODULE    = where.exe
+IMPORTS   = shlwapi
 
 EXTRADLLFLAGS = -mconsole -municode
 
diff --git a/programs/where/main.c b/programs/where/main.c
index 6f90a22..bcabb81 100644
--- a/programs/where/main.c
+++ b/programs/where/main.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2020 Louis Lenders
+ * Copyright 2023 Alex Henrie
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -16,18 +17,127 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <windows.h>
+#include <fileapi.h>
+#include <shlwapi.h>
+
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(where);
 
+static BOOL found;
+
+static void search(const WCHAR *search_path, const WCHAR *pattern)
+{
+    static const WCHAR *extensions[] = {L"", L".bat", L".cmd", L".com", L".exe"};
+    WCHAR glob[MAX_PATH];
+    WCHAR match_path[MAX_PATH];
+    WIN32_FIND_DATAW match;
+    HANDLE handle;
+    BOOL more;
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(extensions); i++)
+    {
+        if (wcslen(search_path) + 1 + wcslen(pattern) + wcslen(extensions[i]) + 1 > ARRAY_SIZE(glob))
+        {
+            ERR("Path too long\n");
+            return;
+        }
+        /* Treat the extension as part of the pattern */
+        wcscpy(glob, search_path);
+        wcscat(glob, L"\\");
+        wcscat(glob, pattern);
+        wcscat(glob, extensions[i]);
+
+        handle = FindFirstFileExW(glob, FindExInfoBasic, &match, 0, NULL, 0);
+        more = (handle != INVALID_HANDLE_VALUE);
+
+        while (more)
+        {
+            if (PathCombineW(match_path, search_path, match.cFileName))
+            {
+                printf("%ls\n", match_path);
+                found = TRUE;
+            }
+            more = FindNextFileW(handle, &match);
+        }
+    }
+}
+
 int __cdecl wmain(int argc, WCHAR *argv[])
 {
+    WCHAR *pattern, *colon, *search_paths, *semicolon, *search_path;
     int i;
 
-    WINE_FIXME("stub:");
     for (i = 0; i < argc; i++)
-        WINE_FIXME(" %s", wine_dbgstr_w(argv[i]));
-    WINE_FIXME("\n");
+    {
+        if (argv[i][0] == '/')
+        {
+            FIXME("Unsupported option %ls\n", argv[i]);
+            return 1;
+        }
+    }
+
+    for (i = 1; i < argc; i++)
+    {
+        pattern = argv[i];
+        colon = wcsrchr(pattern, ':');
+
+        /* Check for a set of search paths prepended to the pattern */
+        if (colon)
+        {
+            *colon = 0;
+            search_paths = pattern;
+            pattern = colon + 1;
+        }
+        else
+        {
+            DWORD len = GetEnvironmentVariableW(L"PATH", NULL, 0);
+            search_paths = malloc(len * sizeof(WCHAR));
+            if (!search_paths)
+            {
+                ERR("Out of memory\n");
+                return 1;
+            }
+            GetEnvironmentVariableW(L"PATH", search_paths, len);
+        }
+
+        if (wcspbrk(pattern, L"\\/\r\n"))
+        {
+            /* Silently ignore invalid patterns */
+            if (!colon) free(search_paths);
+            continue;
+        }
+
+        if (!colon)
+        {
+            /* If the search paths were not explicitly specified, search the current directory first */
+            WCHAR current_dir[MAX_PATH];
+            if (GetCurrentDirectoryW(ARRAY_SIZE(current_dir), current_dir))
+                search(current_dir, pattern);
+        }
+
+        search_path = search_paths;
+        do
+        {
+            semicolon = wcschr(search_path, ';');
+            if (semicolon)
+                *semicolon = 0;
+            if (*search_path)
+                search(search_path, pattern);
+            search_path = semicolon + 1;
+        }
+        while (semicolon);
+
+        if (!colon) free(search_paths);
+    }
+
+    if (!found)
+    {
+        fputs("File not found\n", stderr);
+        return 1;
+    }
 
     return 0;
 }
diff --git a/programs/wineboot/Makefile.in b/programs/wineboot/Makefile.in
index 7c61102..b3f3d96 100644
--- a/programs/wineboot/Makefile.in
+++ b/programs/wineboot/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = wineboot.exe
 IMPORTS   = uuid advapi32 ws2_32 kernelbase
-DELAYIMPORTS = shell32 shlwapi version user32 setupapi newdev
+DELAYIMPORTS = shell32 shlwapi version user32 setupapi newdev wininet
 
 EXTRADLLFLAGS = -mconsole
 
diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index c16446c..1287abf 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -77,6 +77,7 @@
 #include <shlwapi.h>
 #include <shellapi.h>
 #include <setupapi.h>
+#include <wininet.h>
 #include <newdev.h>
 #include "resource.h"
 
@@ -875,16 +876,116 @@ static void create_hardware_registry_keys(void)
     free( power_info );
 }
 
+struct dyndata_enum_key{
+    WCHAR id[9];
+    WCHAR hardwarekey[64];
+    char  problem[4];
+    char  status[4];
+    char  allocation[12];
+    char  child[4];
+    char  sibling[4];
+    char  parent[4];
+};
+
+static struct dyndata_enum_key predefined_enums[] =
+{
+    {
+        {'C','2','9','A','2','3','D','0',0},
+        {'H','T','R','E','E','\\','R','O','O','T','\\','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4e, 0x08, 0x08, 0x1a},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x40, 0x5a, 0x9a, 0xc2},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00}
+    },
+    {
+        {'C','2','9','A','5','A','4','0',0},
+        {'H','T','R','E','E','\\','R','E','S','E','R','V','E','D','\\','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4e, 0x08, 0x08, 0x18},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x60, 0x5c, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','C','6','0',0},
+        {'R','O','O','T','\\','N','E','T','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4f, 0x6a, 0x08, 0x18},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0xf0, 0x93, 0x9b, 0xc2},
+        {0xc0, 0x5d, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','D','C','0',0},
+        {'R','O','O','T','\\','P','R','O','C','E','S','S','O','R','_','U','P','D','A','T','E','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0xcf, 0x6a, 0x88, 0x19},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x20, 0x5f, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','F','2','0',0},
+        {'R','O','O','T','\\','S','W','E','N','U','M','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0xcf, 0x6a, 0x88, 0x19},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x20, 0x5f, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    }
+};
+
+/* add entry to HKEY_DYN_DATA\Config Manager\Enum */
+static void add_dynamic_enum_keys(HKEY key, struct dyndata_enum_key *entry)
+{
+    static const WCHAR HardWareKeyW[] = {'H','a','r','d','W','a','r','e','K','e','y',0};
+    static const WCHAR ProblemW[]     = {'P','r','o','b','l','e','m',0};
+    static const WCHAR StatusW[]      = {'S','t','a','t','u','s',0};
+    static const WCHAR AllocationW[]  = {'A','l','l','o','c','a','t','i','o','n',0};
+    static const WCHAR ChildW[]       = {'C','h','i','l','d',0};
+    static const WCHAR SiblingW[]     = {'S','i','b','l','i','n','g',0};
+    static const WCHAR ParentW[]      = {'P','a','r','e','n','t',0};
+
+    HKEY subkey;
+
+    if (!entry)
+        return;
+
+    if (RegCreateKeyExW( key, entry->id, 0, NULL, 0, KEY_WRITE, NULL, &subkey, NULL ))
+        return;
+
+    set_reg_value( subkey, HardWareKeyW, entry->hardwarekey );
+    RegSetValueExW( subkey, ProblemW,    0, REG_BINARY, (const BYTE *)entry->problem,    sizeof(entry->problem) );
+    RegSetValueExW( subkey, StatusW,     0, REG_BINARY, (const BYTE *)entry->status,     sizeof(entry->status) );
+    RegSetValueExW( subkey, AllocationW, 0, REG_BINARY, (const BYTE *)entry->allocation, sizeof(entry->allocation) );
+    RegSetValueExW( subkey, ChildW,      0, REG_BINARY, (const BYTE *)entry->child,      sizeof(entry->child) );
+    RegSetValueExW( subkey, SiblingW,    0, REG_BINARY, (const BYTE *)entry->sibling,    sizeof(entry->sibling) );
+    RegSetValueExW( subkey, ParentW,     0, REG_BINARY, (const BYTE *)entry->parent,     sizeof(entry->parent) );
+
+    RegCloseKey( subkey );
+}
 
 /* create the DynData registry keys */
 static void create_dynamic_registry_keys(void)
 {
     HKEY key;
+    int entry;
 
     if (!RegCreateKeyExW( HKEY_DYN_DATA, L"PerfStats\\StatData", 0, NULL, 0, KEY_WRITE, NULL, &key, NULL ))
         RegCloseKey( key );
     if (!RegCreateKeyExW( HKEY_DYN_DATA, L"Config Manager\\Enum", 0, NULL, 0, KEY_WRITE, NULL, &key, NULL ))
+    {
+        for (entry = 0; entry < sizeof(predefined_enums) / sizeof(predefined_enums[0]); entry++)
+            add_dynamic_enum_keys( key, &predefined_enums[entry] );
+
         RegCloseKey( key );
+    }
 }
 
 /* create the platform-specific environment registry keys */
@@ -1031,6 +1132,13 @@ static void create_volatile_environment_registry_key(void)
     RegCloseKey( hkey );
 }
 
+static void create_proxy_settings(void)
+{
+    HINTERNET inet;
+    inet = InternetOpenA( "Wine", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );
+    if (inet) InternetCloseHandle( inet );
+}
+
 /* Performs the rename operations dictated in %SystemRoot%\Wininit.ini.
  * Returns FALSE if there was an error, or otherwise if all is ok.
  */
@@ -1843,6 +1951,7 @@ int __cdecl main( int argc, char *argv[] )
     if (init || update) update_wineprefix( update );
 
     create_volatile_environment_registry_key();
+    create_proxy_settings();
 
     ProcessRunKeys( HKEY_LOCAL_MACHINE, L"RunOnce", TRUE, TRUE );
 
diff --git a/programs/winecfg/Makefile.in b/programs/winecfg/Makefile.in
index 780f0e7..1105a99 100644
--- a/programs/winecfg/Makefile.in
+++ b/programs/winecfg/Makefile.in
@@ -9,9 +9,11 @@ SOURCES = \
 	audio.c \
 	drive.c \
 	driveui.c \
+	input.c \
 	libraries.c \
 	logo.svg \
 	main.c \
+	staging.c \
 	theme.c \
 	winecfg.c \
 	winecfg.man.in \
diff --git a/programs/winecfg/libraries.c b/programs/winecfg/libraries.c
index 09fd397..760258c 100644
--- a/programs/winecfg/libraries.c
+++ b/programs/winecfg/libraries.c
@@ -658,6 +658,18 @@ LibrariesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
                         else
                             set_controls_from_selection(hDlg);
                         break;
+            case CBN_DBLCLK:
+                if (LOWORD(wParam) == IDC_DLLS_LIST)
+                {
+                    int index;
+                    POINT p;
+                    if (GetCursorPos(&p) && ScreenToClient((HWND)lParam, &p))
+                    {
+                        index = SendDlgItemMessageW(hDlg, IDC_DLLS_LIST, LB_ITEMFROMPOINT, 0, MAKELPARAM(p.x, p.y));
+                        if (!HIWORD(index)) on_edit_click(hDlg);
+                    }
+                }
+                break;
 		}
 		break;
 	}
diff --git a/programs/winecfg/main.c b/programs/winecfg/main.c
index 2697383..b733b11 100644
--- a/programs/winecfg/main.c
+++ b/programs/winecfg/main.c
@@ -58,7 +58,7 @@ PropSheetCallback (HWND hWnd, UINT uMsg, LPARAM lParam)
     return 0;
 }
 
-#define NUM_PROPERTY_PAGES 7
+#define NUM_PROPERTY_PAGES 9
 
 static INT_PTR
 doPropertySheet (HINSTANCE hInstance, HWND hOwner)
@@ -139,6 +139,26 @@ doPropertySheet (HINSTANCE hInstance, HWND hOwner)
     psp[pg].lParam = 0;
     pg++;
 
+    psp[pg].dwSize = sizeof (PROPSHEETPAGEW);
+    psp[pg].dwFlags = PSP_USETITLE;
+    psp[pg].hInstance = hInstance;
+    psp[pg].pszTemplate = MAKEINTRESOURCEW (IDD_STAGING);
+    psp[pg].pszIcon = NULL;
+    psp[pg].pfnDlgProc = StagingDlgProc;
+    psp[pg].pszTitle =  load_string (IDS_TAB_STAGING);
+    psp[pg].lParam = 0;
+    pg++;
+
+    psp[pg].dwSize = sizeof (PROPSHEETPAGEW);
+    psp[pg].dwFlags = PSP_USETITLE;
+    psp[pg].hInstance = hInstance;
+    psp[pg].pszTemplate = MAKEINTRESOURCEW (IDD_INPUT_CONFIG);
+    psp[pg].pszIcon = NULL;
+    psp[pg].pfnDlgProc = InputDlgProc;
+    psp[pg].pszTitle =  load_string (IDS_TAB_INPUT);
+    psp[pg].lParam = 0;
+    pg++;
+
     /*
      * Fill out the (General) PROPSHEETPAGE data structure 
      * for the property sheet
diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index cd7eaaf..803a0fc 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -45,6 +45,8 @@
 #define IDS_SHELL_FOLDER                16
 #define IDS_LINKS_TO                    17
 #define IDS_WINECFG_TITLE_APP           18   /* App specific title */
+#define IDS_TAB_STAGING                 19
+#define IDS_TAB_INPUT                   20
 #define IDI_WINECFG                     100
 #define IDI_LOGO                        102
 #define IDD_ABOUTCFG                    107
@@ -54,6 +56,8 @@
 #define IDD_DLLCFG                      111
 #define IDD_DRIVECFG                    112
 #define IDD_DESKTOP_INTEGRATION         115
+#define IDD_STAGING                     116
+#define IDD_INPUT_CONFIG                117
 #define IDC_WINVER                      1012
 #define IDC_DESKTOP_WIDTH               1023
 #define IDC_DESKTOP_HEIGHT              1024
@@ -124,7 +128,6 @@
 /* graphics */
 #define IDC_ENABLE_MANAGED              1100
 #define IDC_ENABLE_DECORATED            1101
-#define IDC_FULLSCREEN_GRAB             1102
 
 #define IDC_RES_TRACKBAR                1107
 #define IDC_RES_DPIEDIT                 1108
@@ -213,6 +216,13 @@
 #define IDC_SYSPARAMS_MENU_HIGHLIGHT    8430
 #define IDC_SYSPARAMS_MENUBAR           8431
 
+/* Staging tab */
+#define IDC_ENABLE_CSMT                 9001
+#define IDC_ENABLE_VAAPI                9002
+#define IDC_ENABLE_EAX                  9003
+#define IDC_ENABLE_HIDEWINE             9004
+#define IDC_ENABLE_GTK3                 9005
+
 /* About tab */
 #define IDC_ABT_OWNER                8432
 #define IDC_ABT_ORG                  8433
@@ -221,3 +231,10 @@
 #define IDC_ABT_TITLE_TEXT           8436
 #define IDC_ABT_WEB_LINK             8437
 #define IDC_ABT_LICENSE_TEXT         8438
+
+/* input tab */
+#define IDC_FULLSCREEN_GRAB             1501
+#define IDC_KEYBOARD_LAYOUT             1502
+#define IDC_KEYBOARD_SCANCODE_DETECT    1503
+
+#define IDS_INPUT_AUTO_DETECT_LAYOUT    8501
diff --git a/programs/winecfg/winecfg.h b/programs/winecfg/winecfg.h
index f3f3ad2..b832344 100644
--- a/programs/winecfg/winecfg.h
+++ b/programs/winecfg/winecfg.h
@@ -74,6 +74,9 @@ WCHAR *keypath(const WCHAR *section);
 BOOL initialize(HINSTANCE hInstance);
 extern HKEY config_key;
 
+/* winex11 registry */
+void convert_x11_desktop_key(void);
+
 /* hack for the property sheet control  */
 void set_window_title(HWND dialog);
 
@@ -85,7 +88,9 @@ INT_PTR CALLBACK AppDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
 INT_PTR CALLBACK LibrariesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AudioDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK ThemeDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
+INT_PTR CALLBACK StagingDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AboutDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
+INT_PTR CALLBACK InputDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 
 /* Windows version management */
 BOOL set_winver_from_string(const WCHAR *version);
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 779a2f9..4370d9b 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -38,7 +38,9 @@ BEGIN
     IDS_TAB_GRAPHICS        "Graphics"
     IDS_TAB_DESKTOP_INTEGRATION "Desktop Integration"
     IDS_TAB_AUDIO           "Audio"
+    IDS_TAB_STAGING         "Staging"
     IDS_TAB_ABOUT           "About"
+    IDS_TAB_INPUT           "Input"
     IDS_WINECFG_TITLE       "Wine configuration"
     IDS_WINECFG_TITLE_APP   "Wine configuration for %s"
     IDS_THEMEFILE           "Theme files (*.msstyles; *.theme)"
@@ -134,6 +136,11 @@ BEGIN
     IDC_SYSPARAMS_MENUBAR           "Menu Bar"
 END
 
+STRINGTABLE
+BEGIN
+    IDS_INPUT_AUTO_DETECT_LAYOUT  "(Auto detect)"
+END
+
 IDD_ABOUTCFG DIALOGEX 0, 0, 260, 220
 STYLE WS_CHILD
 FONT 8, "MS Shell Dlg"
@@ -170,22 +177,21 @@ IDD_GRAPHCFG DIALOG  0, 0, 260, 220
 STYLE WS_CHILD | WS_DISABLED
 FONT 8, "MS Shell Dlg"
 BEGIN
-    GROUPBOX    "Window settings",IDC_STATIC,8,4,244,84
-    CONTROL     "Automatically capture the &mouse in full-screen windows",IDC_FULLSCREEN_GRAB,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,20,230,10
-    CONTROL     "Allow the window manager to &decorate the windows",IDC_ENABLE_DECORATED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,32,230,10
-    CONTROL     "Allow the &window manager to control the windows",IDC_ENABLE_MANAGED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,44,230,10
+    GROUPBOX    "Window settings",IDC_STATIC,8,4,244,72
+    CONTROL     "Allow the window manager to &decorate the windows",IDC_ENABLE_DECORATED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,20,230,10
+    CONTROL     "Allow the &window manager to control the windows",IDC_ENABLE_MANAGED,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,32,230,10
     CONTROL     "&Emulate a virtual desktop",IDC_ENABLE_DESKTOP,"Button",
-                BS_AUTOCHECKBOX | WS_TABSTOP,15,56,230,10
-    LTEXT       "Desktop &size:",IDC_DESKTOP_SIZE,15,70,64,16,WS_DISABLED
-    LTEXT       "#msgctxt#do not translate#X",IDC_DESKTOP_BY,129,70,8,8,WS_DISABLED
-    EDITTEXT    IDC_DESKTOP_WIDTH,84,68,40,12,ES_AUTOHSCROLL | ES_NUMBER | WS_DISABLED
-    EDITTEXT    IDC_DESKTOP_HEIGHT,137,68,40,12,ES_AUTOHSCROLL | ES_NUMBER | WS_DISABLED
-
-    GROUPBOX    "Screen resolution",IDC_STATIC,8,95,244,84
-    CONTROL     "", IDC_RES_TRACKBAR, "msctls_trackbar32",WS_TABSTOP,12,105,171,15
-    EDITTEXT    IDC_RES_DPIEDIT,188,105,23,13,ES_NUMBER|WS_TABSTOP
-    LTEXT       "#msgctxt#unit: dots/inch#dpi",IDC_STATIC,215,107,30,8
-    LTEXT       "This is a sample text using 10 point Tahoma",IDC_RES_FONT_PREVIEW,15,124,230,49
+                BS_AUTOCHECKBOX | WS_TABSTOP,15,44,230,10
+    LTEXT       "Desktop &size:",IDC_DESKTOP_SIZE,15,58,64,16,WS_DISABLED
+    LTEXT       "#msgctxt#do not translate#X",IDC_DESKTOP_BY,129,58,8,8,WS_DISABLED
+    EDITTEXT    IDC_DESKTOP_WIDTH,84,56,40,12,ES_AUTOHSCROLL | ES_NUMBER | WS_DISABLED
+    EDITTEXT    IDC_DESKTOP_HEIGHT,137,56,40,12,ES_AUTOHSCROLL | ES_NUMBER | WS_DISABLED
+
+    GROUPBOX    "Screen resolution",IDC_STATIC,8,83,244,84
+    CONTROL     "", IDC_RES_TRACKBAR, "msctls_trackbar32",WS_TABSTOP,12,93,171,15
+    EDITTEXT    IDC_RES_DPIEDIT,188,93,23,13,ES_NUMBER|WS_TABSTOP
+    LTEXT       "#msgctxt#unit: dots/inch#dpi",IDC_STATIC,215,95,30,8
+    LTEXT       "This is a sample text using 10 point Tahoma",IDC_RES_FONT_PREVIEW,15,112,230,49
 END
 
 IDD_DLLCFG DIALOG  0, 0, 260, 220
@@ -318,6 +324,32 @@ BEGIN
     PUSHBUTTON      "B&rowse...",IDC_BROWSE_SFPATH,195,195,50,13,WS_DISABLED
 END
 
+IDD_STAGING DIALOG  0, 0, 260, 220
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX    "Staging settings",IDC_STATIC,8,4,244,210
+    LTEXT       "The following settings are experimental and may break stuff!\nMake sure to reset them again in case of a problem.",IDC_STATIC,16,16,230,16
+    CONTROL     "Enable &CSMT for better graphic performance (deprecated)",IDC_ENABLE_CSMT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,40,230,8
+    CONTROL     "Enable &VAAPI as backend for DXVA2 GPU decoding",IDC_ENABLE_VAAPI,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,55,230,8
+    CONTROL     "Enable Environmental Audio E&xtensions (EAX)",IDC_ENABLE_EAX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,70,230,8
+    CONTROL     "&Hide Wine version from applications",IDC_ENABLE_HIDEWINE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,85,230,8
+    CONTROL     "Enable &GTK3 Theming",IDC_ENABLE_GTK3,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,100,230,8
+END
+
+IDD_INPUT_CONFIG DIALOG  0, 0, 260, 220
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX    "Mouse settings",IDC_STATIC,8,4,244,64
+    CONTROL     "Automatically capture the &mouse in full-screen windows",IDC_FULLSCREEN_GRAB,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,20,230,10
+
+    GROUPBOX    "Keyboard settings",IDC_STATIC,8,70,244,64
+    LTEXT       "&Layout:",IDC_STATIC,15,82,230,8
+    COMBOBOX    IDC_KEYBOARD_LAYOUT,110,80,135,60,CBS_DROPDOWNLIST | CBS_HASSTRINGS | CBS_SORT | WS_VSCROLL | WS_TABSTOP
+    CONTROL     "Enable keyboard scancode auto-detection",IDC_KEYBOARD_SCANCODE_DETECT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,96,230,10
+END
+
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
 
 /* @makedep: winecfg.ico */
diff --git a/programs/winecfg/x11drvdlg.c b/programs/winecfg/x11drvdlg.c
index aea5271..2f73956 100644
--- a/programs/winecfg/x11drvdlg.c
+++ b/programs/winecfg/x11drvdlg.c
@@ -46,7 +46,7 @@ static const UINT dpi_values[] = { 96, 120, 144, 168, 192, 216, 240, 288, 336, 3
 static BOOL updating_ui;
 
 /* convert the x11 desktop key to the new explorer config */
-static void convert_x11_desktop_key(void)
+void convert_x11_desktop_key(void)
 {
     WCHAR *buf;
 
@@ -138,13 +138,6 @@ static void init_dialog(HWND dialog)
         SendDlgItemMessageW(dialog, IDC_DESKTOP_HEIGHT, EM_LIMITTEXT, RES_MAXLEN, 0);
     }
 
-    buf = get_reg_key(config_key, keypath(L"X11 Driver"), L"GrabFullscreen", L"N");
-    if (IS_OPTION_TRUE(*buf))
-	CheckDlgButton(dialog, IDC_FULLSCREEN_GRAB, BST_CHECKED);
-    else
-	CheckDlgButton(dialog, IDC_FULLSCREEN_GRAB, BST_UNCHECKED);
-    free(buf);
-
     buf = get_reg_key(config_key, keypath(L"X11 Driver"), L"Managed", L"Y");
     if (IS_OPTION_TRUE(*buf))
 	CheckDlgButton(dialog, IDC_ENABLE_MANAGED, BST_CHECKED);
@@ -219,14 +212,6 @@ static void on_enable_decorated_clicked(HWND dialog) {
     }
 }
 
-static void on_fullscreen_grab_clicked(HWND dialog)
-{
-    if (IsDlgButtonChecked(dialog, IDC_FULLSCREEN_GRAB) == BST_CHECKED)
-        set_reg_key(config_key, keypath(L"X11 Driver"), L"GrabFullscreen", L"Y");
-    else
-        set_reg_key(config_key, keypath(L"X11 Driver"), L"GrabFullscreen", L"N");
-}
-
 static INT read_logpixels_reg(void)
 {
     DWORD dwLogPixels;
@@ -382,7 +367,6 @@ GraphDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
 			case IDC_ENABLE_DESKTOP: on_enable_desktop_clicked(hDlg); break;
                         case IDC_ENABLE_MANAGED: on_enable_managed_clicked(hDlg); break;
                         case IDC_ENABLE_DECORATED: on_enable_decorated_clicked(hDlg); break;
-			case IDC_FULLSCREEN_GRAB:  on_fullscreen_grab_clicked(hDlg); break;
 		    }
 		    break;
 		}
diff --git a/programs/winedbg/info.c b/programs/winedbg/info.c
index 5e724af..7b5151d 100644
--- a/programs/winedbg/info.c
+++ b/programs/winedbg/info.c
@@ -688,6 +688,103 @@ WCHAR* fetch_thread_description(DWORD tid)
     return desc;
 }
 
+static BOOL read_process_memory(HANDLE process, const void *ptr, void *buffer, SIZE_T length)
+{
+    SIZE_T read;
+    return ReadProcessMemory(process, ptr, buffer, length, &read) && (read == length);
+}
+
+static BOOL get_process_cmdline(HANDLE process, PEB *peb, UNICODE_STRING *cmdline)
+{
+    RTL_USER_PROCESS_PARAMETERS *params;
+
+    if (!read_process_memory(process, &peb->ProcessParameters, &params, sizeof(params)))
+        return FALSE;
+
+    if (!read_process_memory(process, &params->CommandLine, cmdline, sizeof(*cmdline)))
+        return FALSE;
+
+    return TRUE;
+}
+
+static BOOL get_process_cmdline_wow64(HANDLE process, PEB *peb, UNICODE_STRING *cmdline)
+{
+    DWORD params;
+    struct
+    {
+        USHORT Length;
+        USHORT MaximumLength;
+        DWORD  Buffer;
+    } cmdline32;
+
+    /* &peb->ProcessParameters */
+    if (!read_process_memory(process, (char *)peb + 0x10, &params, sizeof(params)))
+        return FALSE;
+
+    /* &params->CommandLine */
+    if (!read_process_memory(process, (char *)(DWORD_PTR)params + 0x40, &cmdline32, sizeof(cmdline32)))
+        return FALSE;
+
+    cmdline->Length = cmdline32.Length;
+    cmdline->MaximumLength = cmdline32.MaximumLength;
+    cmdline->Buffer = (WCHAR *)(DWORD_PTR)cmdline32.Buffer;
+    return TRUE;
+}
+
+static char *get_process_args(DWORD pid)
+{
+    PROCESS_BASIC_INFORMATION info;
+    BOOL self_wow64, process_wow64;
+    UNICODE_STRING cmdline;
+    WCHAR *tempW = NULL;
+    char *args = NULL;
+    HANDLE process;
+    DWORD len;
+    BOOL ret;
+
+    if (!(process = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ, FALSE, pid)))
+        return FALSE;
+    if (NtQueryInformationProcess(process, ProcessBasicInformation, &info, sizeof(info), NULL))
+        goto done;
+
+    IsWow64Process(GetCurrentProcess(), &self_wow64);
+    if (!IsWow64Process(process, &process_wow64))
+        goto done;
+
+    if (process_wow64 == self_wow64)
+        ret = get_process_cmdline(process, info.PebBaseAddress, &cmdline);
+    else if (!self_wow64 && process_wow64)
+        ret = get_process_cmdline_wow64(process, info.PebBaseAddress, &cmdline);
+    else
+        ret = FALSE; /* can't read process args of 64-bit process with 32-bit winedbg */
+
+    if (!ret) goto done;
+
+    /* protect against malicious content */
+    if (cmdline.Length > 4096 || (cmdline.Length & 1))
+        goto done;
+
+    if (!(tempW = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cmdline.Length + 2)))
+        goto done;
+    if (!read_process_memory(process, cmdline.Buffer, tempW, cmdline.Length))
+        goto done;
+
+    if (!(len = WideCharToMultiByte(CP_ACP, 0, tempW, -1, NULL, 0, NULL, NULL)))
+        goto done;
+    if (!(args = HeapAlloc(GetProcessHeap(), 0, len)))
+        goto done;
+    if (!WideCharToMultiByte(CP_ACP, 0, tempW, -1, args, len, NULL, NULL))
+    {
+        HeapFree(GetProcessHeap(), 0, args);
+        args = NULL;
+    }
+
+done:
+    HeapFree(GetProcessHeap(), 0, tempW);
+    CloseHandle(process);
+    return args;
+}
+
 void info_win32_threads(void)
 {
     HANDLE snap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
@@ -717,6 +814,7 @@ void info_win32_threads(void)
 		{
                     PROCESSENTRY32W pcs_entry;
                     const WCHAR* exename;
+                    char *args;
 
                     p = dbg_get_process(entry.th32OwnerProcessID);
                     if (p)
@@ -726,8 +824,13 @@ void info_win32_threads(void)
                     else
                         exename = L"";
 
-		    dbg_printf("%08lx%s %ls\n",
-                               entry.th32OwnerProcessID, p ? " (D)" : "", exename);
+                    dbg_printf("%08lx%s %ls\n", entry.th32OwnerProcessID, p ? " (D)" : "", exename);
+                    args = get_process_args(entry.th32OwnerProcessID);
+                    if (args)
+                    {
+                        dbg_printf("\t[%s]\n", args);
+                        HeapFree(GetProcessHeap(), 0, args);
+                    }
                     lastProcessId = entry.th32OwnerProcessID;
 		}
                 dbg_printf("\t%08lx %4ld%s ",
diff --git a/programs/winedevice/device.c b/programs/winedevice/device.c
index bb58508..9b4395f 100644
--- a/programs/winedevice/device.c
+++ b/programs/winedevice/device.c
@@ -122,8 +122,16 @@ static DWORD WINAPI service_handler( DWORD ctrl, DWORD event_type, LPVOID event_
 
 static void WINAPI ServiceMain( DWORD argc, LPWSTR *argv )
 {
+    static const WCHAR ntoskrnlW[] = L"C:\\windows\\system32\\ntoskrnl.exe";
+    static const WCHAR win32kW[]   = L"C:\\windows\\system32\\win32k.sys";
+    static const WCHAR dxgkrnlW[]  = L"C:\\windows\\system32\\drivers\\dxgkrnl.sys";
+    static const WCHAR dxgmms1W[]  = L"C:\\windows\\system32\\drivers\\dxgmms1.sys";
+    static const WCHAR *stubs[] = { win32kW, dxgkrnlW, dxgmms1W };
     WCHAR driver_dir[MAX_PATH];
     const WCHAR *service_group = (argc >= 2) ? argv[1] : argv[0];
+    LDR_DATA_TABLE_ENTRY *ldr;
+    ULONG_PTR magic;
+    int i;
 
     if (!(stop_event = CreateEventW( NULL, TRUE, FALSE, NULL )))
         return;
@@ -136,6 +144,24 @@ static void WINAPI ServiceMain( DWORD argc, LPWSTR *argv )
     wcscat( driver_dir, L"\\drivers" );
     AddDllDirectory( driver_dir );
 
+    /* Load some default drivers (required by anticheat drivers) */
+    for (i = 0; i < sizeof(stubs)/sizeof(stubs[0]); i++)
+    {
+        if (!LoadLibraryW( stubs[i] ))
+            ERR( "Failed to load %s\n", debugstr_w( stubs[i] ) );
+    }
+
+    /* ntoskrnl.exe must be the first module */
+    LdrLockLoaderLock( 0, NULL, &magic );
+    if (!LdrFindEntryForAddress( GetModuleHandleW( ntoskrnlW ), &ldr ))
+    {
+        RemoveEntryList( &ldr->InLoadOrderLinks );
+        InsertHeadList( &NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList, &ldr->InLoadOrderLinks );
+        RemoveEntryList( &ldr->InMemoryOrderLinks );
+        InsertHeadList( &NtCurrentTeb()->Peb->LdrData->InMemoryOrderModuleList, &ldr->InMemoryOrderLinks );
+    }
+    LdrUnlockLoaderLock( 0, magic );
+
     TRACE( "starting service group %s\n", wine_dbgstr_w(service_group) );
     set_service_status( service_handle, SERVICE_RUNNING,
                         SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN );
diff --git a/programs/wscript/main.c b/programs/wscript/main.c
index 1257118..befb97a 100644
--- a/programs/wscript/main.c
+++ b/programs/wscript/main.c
@@ -393,6 +393,10 @@ static BOOL set_host_properties(const WCHAR *prop)
         wshInteractive = VARIANT_FALSE;
     else if(wcsicmp(prop, L"nologo") == 0)
         WINE_FIXME("ignored %s switch\n", debugstr_w(L"nologo"));
+    else if(wcsicmp(prop, L"d") == 0)
+        WINE_FIXME("ignored %s switch\n", debugstr_w(L"d"));
+   else if(wcsicmp(prop, L"u") == 0)
+        WINE_FIXME("ignored %s switch\n", debugstr_w(L"u"));
     else
     {
         WINE_FIXME("unsupported switch %s\n", debugstr_w(prop));
diff --git a/server/Makefile.in b/server/Makefile.in
index 7b46b92..b164193 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -11,6 +11,7 @@ SOURCES = \
 	debugger.c \
 	device.c \
 	directory.c \
+	esync.c \
 	event.c \
 	fd.c \
 	file.c \
@@ -30,6 +31,7 @@ SOURCES = \
 	region.c \
 	registry.c \
 	request.c \
+	scheduler.c \
 	semaphore.c \
 	serial.c \
 	signal.c \
diff --git a/server/async.c b/server/async.c
index 9cb251d..337bba8 100644
--- a/server/async.c
+++ b/server/async.c
@@ -77,6 +77,7 @@ static const struct object_ops async_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     async_signaled,            /* signaled */
+    NULL,                      /* get_esync_fd */
     async_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -676,6 +677,7 @@ static const struct object_ops iosb_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
diff --git a/server/atom.c b/server/atom.c
index ff0799f..d9824de 100644
--- a/server/atom.c
+++ b/server/atom.c
@@ -79,6 +79,7 @@ static const struct object_ops atom_table_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/change.c b/server/change.c
index 843e495..ec61711 100644
--- a/server/change.c
+++ b/server/change.c
@@ -112,6 +112,7 @@ static const struct object_ops dir_ops =
     add_queue,                /* add_queue */
     remove_queue,             /* remove_queue */
     default_fd_signaled,      /* signaled */
+    default_fd_get_esync_fd,  /* get_esync_fd */
     no_satisfied,             /* satisfied */
     no_signal,                /* signal */
     dir_get_fd,               /* get_fd */
@@ -324,39 +325,17 @@ static struct fd *dir_get_fd( struct object *obj )
     return (struct fd *)grab_object( dir->fd );
 }
 
-static int get_dir_unix_fd( struct dir *dir )
-{
-    return get_unix_fd( dir->fd );
-}
-
 static struct security_descriptor *dir_get_sd( struct object *obj )
 {
     struct dir *dir = (struct dir *)obj;
-    int unix_fd;
-    struct stat st;
     struct security_descriptor *sd;
-    assert( obj->ops == &dir_ops );
-
-    unix_fd = get_dir_unix_fd( dir );
-
-    if (unix_fd == -1 || fstat( unix_fd, &st ) == -1)
-        return obj->sd;
+    struct fd *fd;
 
-    /* mode and uid the same? if so, no need to re-generate security descriptor */
-    if (obj->sd &&
-        (st.st_mode & (S_IRWXU|S_IRWXO)) == (dir->mode & (S_IRWXU|S_IRWXO)) &&
-        (st.st_uid == dir->uid))
-        return obj->sd;
-
-    sd = mode_to_sd( st.st_mode,
-                     security_unix_uid_to_sid( st.st_uid ),
-                     token_get_primary_group( current->process->token ));
-    if (!sd) return obj->sd;
+    assert( obj->ops == &dir_ops );
 
-    dir->mode = st.st_mode;
-    dir->uid = st.st_uid;
-    free( obj->sd );
-    obj->sd = sd;
+    fd = dir_get_fd( obj );
+    sd = get_file_sd( obj, fd, &dir->mode, &dir->uid );
+    release_object( fd );
     return sd;
 }
 
@@ -364,48 +343,15 @@ static int dir_set_sd( struct object *obj, const struct security_descriptor *sd,
                        unsigned int set_info )
 {
     struct dir *dir = (struct dir *)obj;
-    const struct sid *owner;
-    struct stat st;
-    mode_t mode;
-    int unix_fd;
+    struct fd *fd;
+    int ret;
 
     assert( obj->ops == &dir_ops );
 
-    unix_fd = get_dir_unix_fd( dir );
-
-    if (unix_fd == -1 || fstat( unix_fd, &st ) == -1) return 1;
-
-    if (set_info & OWNER_SECURITY_INFORMATION)
-    {
-        owner = sd_get_owner( sd );
-        if (!owner)
-        {
-            set_error( STATUS_INVALID_SECURITY_DESCR );
-            return 0;
-        }
-        if (!obj->sd || !equal_sid( owner, sd_get_owner( obj->sd ) ))
-        {
-            /* FIXME: get Unix uid and call fchown */
-        }
-    }
-    else if (obj->sd)
-        owner = sd_get_owner( obj->sd );
-    else
-        owner = token_get_owner( current->process->token );
-
-    if (set_info & DACL_SECURITY_INFORMATION)
-    {
-        /* keep the bits that we don't map to access rights in the ACL */
-        mode = st.st_mode & (S_ISUID|S_ISGID|S_ISVTX);
-        mode |= sd_to_mode( sd, owner );
-
-        if (((st.st_mode ^ mode) & (S_IRWXU|S_IRWXG|S_IRWXO)) && fchmod( unix_fd, mode ) == -1)
-        {
-            file_set_error();
-            return 0;
-        }
-    }
-    return 1;
+    fd = dir_get_fd( obj );
+    ret = set_file_sd( obj, fd, &dir->mode, &dir->uid, sd, set_info );
+    release_object( fd );
+    return ret;
 }
 
 static struct change_record *get_first_change_record( struct dir *dir )
@@ -1133,7 +1079,8 @@ static void dir_add_to_existing_notify( struct dir *dir )
 
 #endif  /* HAVE_SYS_INOTIFY_H */
 
-struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode )
+struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode,
+                               const struct security_descriptor *sd )
 {
     struct dir *dir;
 
@@ -1153,6 +1100,11 @@ struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode )
     dir->client_process = NULL;
     set_fd_user( fd, &dir_fd_ops, &dir->obj );
 
+    if (sd) dir_set_sd( &dir->obj, sd, OWNER_SECURITY_INFORMATION |
+                                       GROUP_SECURITY_INFORMATION |
+                                       DACL_SECURITY_INFORMATION |
+                                       SACL_SECURITY_INFORMATION );
+
     dir_add_to_existing_notify( dir );
 
     return &dir->obj;
diff --git a/server/clipboard.c b/server/clipboard.c
index 8118a46..8b265f2 100644
--- a/server/clipboard.c
+++ b/server/clipboard.c
@@ -76,6 +76,7 @@ static const struct object_ops clipboard_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/completion.c b/server/completion.c
index 6933195..3d4be86 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -75,6 +75,7 @@ static const struct object_ops completion_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     completion_signaled,       /* signaled */
+    NULL,                      /* get_esync_fd */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/console.c b/server/console.c
index b64283b..dbd4a97 100644
--- a/server/console.c
+++ b/server/console.c
@@ -41,6 +41,7 @@
 #include "wincon.h"
 #include "winternl.h"
 #include "wine/condrv.h"
+#include "esync.h"
 
 struct screen_buffer;
 
@@ -81,6 +82,7 @@ static const struct object_ops console_ops =
     console_add_queue,                /* add_queue */
     remove_queue,                     /* remove_queue */
     console_signaled,                 /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_get_fd,                   /* get_fd */
@@ -130,20 +132,22 @@ struct console_host_ioctl
 
 struct console_server
 {
-    struct object         obj;            /* object header */
-    struct fd            *fd;             /* pseudo-fd for ioctls */
-    struct console       *console;        /* attached console */
-    struct list           queue;          /* ioctl queue */
-    struct list           read_queue;     /* blocking read queue */
+    struct object         obj;         /* object header */
+    struct fd            *fd;          /* pseudo-fd for ioctls */
+    struct console       *console;     /* attached console */
+    struct list           queue;       /* ioctl queue */
+    struct list           read_queue;  /* blocking read queue */
     unsigned int          busy : 1;       /* flag if server processing an ioctl */
     unsigned int          once_input : 1; /* flag if input thread has already been requested */
-    int                   term_fd;        /* UNIX terminal fd */
-    struct termios        termios;        /* original termios */
+    int                   term_fd;     /* UNIX terminal fd */
+    struct termios        termios;     /* original termios */
+    int                   esync_fd;
 };
 
 static void console_server_dump( struct object *obj, int verbose );
 static void console_server_destroy( struct object *obj );
 static int console_server_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int console_server_get_esync_fd( struct object *obj, enum esync_type *type );
 static struct fd *console_server_get_fd( struct object *obj );
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
                                                 unsigned int attr, struct object *root );
@@ -158,6 +162,7 @@ static const struct object_ops console_server_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     console_server_signaled,          /* signaled */
+    console_server_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_server_get_fd,            /* get_fd */
@@ -227,6 +232,7 @@ static const struct object_ops screen_buffer_ops =
     screen_buffer_add_queue,          /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     NULL,                             /* satisfied */
     no_signal,                        /* signal */
     screen_buffer_get_fd,             /* get_fd */
@@ -276,6 +282,7 @@ static const struct object_ops console_device_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -313,6 +320,7 @@ static const struct object_ops console_input_ops =
     console_input_add_queue,          /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_input_get_fd,             /* get_fd */
@@ -370,6 +378,7 @@ static const struct object_ops console_output_ops =
     console_output_add_queue,         /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_output_get_fd,            /* get_fd */
@@ -428,6 +437,7 @@ static const struct object_ops console_connection_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_connection_get_fd,        /* get_fd */
@@ -590,6 +600,8 @@ static void disconnect_console_server( struct console_server *server )
         list_remove( &call->entry );
         console_host_ioctl_terminate( call, STATUS_CANCELLED );
     }
+    if (do_esync())
+        esync_clear( server->esync_fd );
     while (!list_empty( &server->read_queue ))
     {
         struct console_host_ioctl *call = LIST_ENTRY( list_head( &server->read_queue ), struct console_host_ioctl, entry );
@@ -872,6 +884,7 @@ static void console_server_destroy( struct object *obj )
     assert( obj->ops == &console_server_ops );
     disconnect_console_server( server );
     if (server->fd) release_object( server->fd );
+    if (do_esync()) close( server->esync_fd );
 }
 
 static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
@@ -913,6 +926,13 @@ static int console_server_signaled( struct object *obj, struct wait_queue_entry
     return !server->console || !list_empty( &server->queue );
 }
 
+static int console_server_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct console_server *server = (struct console_server*)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return server->esync_fd;
+}
+
 static struct fd *console_server_get_fd( struct object* obj )
 {
     struct console_server *server = (struct console_server*)obj;
@@ -944,6 +964,10 @@ static struct object *create_console_server( void )
         return NULL;
     }
     allow_fd_caching(server->fd);
+    server->esync_fd = -1;
+
+    if (do_esync())
+        server->esync_fd = esync_create_fd( 0, 0 );
 
     return &server->obj;
 }
@@ -1557,6 +1581,8 @@ DECL_HANDLER(get_next_console_request)
         /* set result of previous ioctl */
         ioctl = LIST_ENTRY( list_head( &server->queue ), struct console_host_ioctl, entry );
         list_remove( &ioctl->entry );
+        if (do_esync() && list_empty( &server->queue ))
+            esync_clear( server->esync_fd );
     }
 
     if (ioctl)
@@ -1642,6 +1668,8 @@ DECL_HANDLER(get_next_console_request)
     {
         set_error( STATUS_PENDING );
     }
+    if (do_esync() && list_empty( &server->queue ))
+        esync_clear( server->esync_fd );
 
     release_object( server );
 }
diff --git a/server/debugger.c b/server/debugger.c
index 48adb24..d85a200 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -86,6 +86,7 @@ static const struct object_ops debug_event_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     debug_event_signaled,          /* signaled */
+    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -114,6 +115,7 @@ static const struct object_ops debug_obj_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     debug_obj_signaled,            /* signaled */
+    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/device.c b/server/device.c
index 436dac6..c45d010 100644
--- a/server/device.c
+++ b/server/device.c
@@ -38,6 +38,7 @@
 #include "handle.h"
 #include "request.h"
 #include "process.h"
+#include "esync.h"
 
 /* IRP object */
 
@@ -66,6 +67,7 @@ static const struct object_ops irp_call_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     NULL,                             /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -92,10 +94,12 @@ struct device_manager
     struct list            requests;       /* list of pending irps across all devices */
     struct irp_call       *current_call;   /* call currently executed on client side */
     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
+    int                    esync_fd;       /* esync file descriptor */
 };
 
 static void device_manager_dump( struct object *obj, int verbose );
 static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type );
 static void device_manager_destroy( struct object *obj );
 
 static const struct object_ops device_manager_ops =
@@ -106,6 +110,7 @@ static const struct object_ops device_manager_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     device_manager_signaled,          /* signaled */
+    device_manager_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -163,6 +168,7 @@ static const struct object_ops device_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -215,6 +221,7 @@ static const struct object_ops device_file_ops =
     add_queue,                        /* add_queue */
     remove_queue,                     /* remove_queue */
     default_fd_signaled,              /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     device_file_get_fd,               /* get_fd */
@@ -747,6 +754,9 @@ static void delete_file( struct device_file *file )
     /* terminate all pending requests */
     LIST_FOR_EACH_ENTRY_SAFE( irp, next, &file->requests, struct irp_call, dev_entry )
     {
+        if (do_esync() && file->device->manager && list_empty( &file->device->manager->requests ))
+            esync_clear( file->device->manager->esync_fd );
+
         list_remove( &irp->mgr_entry );
         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
     }
@@ -782,6 +792,13 @@ static int device_manager_signaled( struct object *obj, struct wait_queue_entry
     return !list_empty( &manager->requests );
 }
 
+static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct device_manager *manager = (struct device_manager *)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return manager->esync_fd;
+}
+
 static void device_manager_destroy( struct object *obj )
 {
     struct device_manager *manager = (struct device_manager *)obj;
@@ -816,6 +833,9 @@ static void device_manager_destroy( struct object *obj )
         assert( !irp->file && !irp->async );
         release_object( irp );
     }
+
+    if (do_esync())
+        close( manager->esync_fd );
 }
 
 static struct device_manager *create_device_manager(void)
@@ -828,6 +848,9 @@ static struct device_manager *create_device_manager(void)
         list_init( &manager->devices );
         list_init( &manager->requests );
         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
+
+        if (do_esync())
+            manager->esync_fd = esync_create_fd( 0, 0 );
     }
     return manager;
 }
@@ -1017,6 +1040,9 @@ DECL_HANDLER(get_next_device_request)
                 /* we already own the object if it's only on manager queue */
                 if (irp->file) grab_object( irp );
                 manager->current_call = irp;
+
+                if (do_esync() && list_empty( &manager->requests ))
+                    esync_clear( manager->esync_fd );
             }
             else close_handle( current->process, reply->next );
         }
diff --git a/server/directory.c b/server/directory.c
index 23d7eb0..bc161b9 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -69,6 +69,7 @@ static const struct object_ops object_type_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -119,6 +120,7 @@ static const struct object_ops directory_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/event.c b/server/event.c
index f1b79b1..f4ca3e4 100644
--- a/server/event.c
+++ b/server/event.c
@@ -35,6 +35,7 @@
 #include "thread.h"
 #include "request.h"
 #include "security.h"
+#include "esync.h"
 
 static const WCHAR event_name[] = {'E','v','e','n','t'};
 
@@ -56,13 +57,16 @@ struct event
     struct list    kernel_object;   /* list of kernel object pointers */
     int            manual_reset;    /* is it a manual reset event? */
     int            signaled;        /* event has been signaled */
+    int            esync_fd;        /* esync file descriptor */
 };
 
 static void event_dump( struct object *obj, int verbose );
 static int event_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry );
+static int event_get_esync_fd( struct object *obj, enum esync_type *type );
 static int event_signal( struct object *obj, unsigned int access);
 static struct list *event_get_kernel_obj_list( struct object *obj );
+static void event_destroy( struct object *obj );
 
 static const struct object_ops event_ops =
 {
@@ -72,6 +76,7 @@ static const struct object_ops event_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     event_signaled,            /* signaled */
+    event_get_esync_fd,        /* get_esync_fd */
     event_satisfied,           /* satisfied */
     event_signal,              /* signal */
     no_get_fd,                 /* get_fd */
@@ -85,7 +90,7 @@ static const struct object_ops event_ops =
     no_open_file,              /* open_file */
     event_get_kernel_obj_list, /* get_kernel_obj_list */
     no_close_handle,           /* close_handle */
-    no_destroy                 /* destroy */
+    event_destroy              /* destroy */
 };
 
 
@@ -119,6 +124,7 @@ static const struct object_ops keyed_event_ops =
     add_queue,                   /* add_queue */
     remove_queue,                /* remove_queue */
     keyed_event_signaled,        /* signaled */
+    NULL,                        /* get_esync_fd */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
@@ -150,6 +156,9 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
             list_init( &event->kernel_object );
             event->manual_reset = manual_reset;
             event->signaled     = initial_state;
+
+            if (do_esync())
+                event->esync_fd = esync_create_fd( initial_state, 0 );
         }
     }
     return event;
@@ -157,6 +166,10 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
 
 struct event *get_event_obj( struct process *process, obj_handle_t handle, unsigned int access )
 {
+    struct object *obj;
+    if (do_esync() && (obj = get_handle_obj( process, handle, access, &esync_ops)))
+        return (struct event *)obj; /* even though it's not an event */
+
     return (struct event *)get_handle_obj( process, handle, access, &event_ops );
 }
 
@@ -170,6 +183,12 @@ static void pulse_event( struct event *event )
 
 void set_event( struct event *event )
 {
+    if (do_esync() && event->obj.ops == &esync_ops)
+    {
+        esync_set_event( (struct esync *)event );
+        return;
+    }
+
     event->signaled = 1;
     /* wake up all waiters if manual reset, a single one otherwise */
     wake_up( &event->obj, !event->manual_reset );
@@ -177,7 +196,15 @@ void set_event( struct event *event )
 
 void reset_event( struct event *event )
 {
+    if (do_esync() && event->obj.ops == &esync_ops)
+    {
+        esync_reset_event( (struct esync *)event );
+        return;
+    }
     event->signaled = 0;
+
+    if (do_esync())
+        esync_clear( event->esync_fd );
 }
 
 static void event_dump( struct object *obj, int verbose )
@@ -195,6 +222,13 @@ static int event_signaled( struct object *obj, struct wait_queue_entry *entry )
     return event->signaled;
 }
 
+static int event_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct event *event = (struct event *)obj;
+    *type = event->manual_reset ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
+    return event->esync_fd;
+}
+
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct event *event = (struct event *)obj;
@@ -223,6 +257,14 @@ static struct list *event_get_kernel_obj_list( struct object *obj )
     return &event->kernel_object;
 }
 
+static void event_destroy( struct object *obj )
+{
+    struct event *event = (struct event *)obj;
+
+    if (do_esync())
+        close( event->esync_fd );
+}
+
 struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
                                         unsigned int attr, const struct security_descriptor *sd )
 {
diff --git a/server/fd.c b/server/fd.c
index 8576882..f34a39e 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -31,6 +31,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <libgen.h>
 #include <poll.h>
 #ifdef HAVE_LINUX_MAJOR_H
 #include <linux/major.h>
@@ -96,11 +97,16 @@
 #include "handle.h"
 #include "process.h"
 #include "request.h"
+#include "esync.h"
 
 #include "winternl.h"
 #include "winioctl.h"
 #include "ddk/wdm.h"
 
+#if !defined(O_SYMLINK) && defined(O_PATH)
+# define O_SYMLINK (O_NOFOLLOW | O_PATH)
+#endif
+
 #if defined(HAVE_SYS_EPOLL_H) && defined(HAVE_EPOLL_CREATE)
 # include <sys/epoll.h>
 # define USE_EPOLL
@@ -156,6 +162,7 @@ struct fd
     struct completion   *completion;  /* completion object attached to this fd */
     apc_param_t          comp_key;    /* completion key to set in completion events */
     unsigned int         comp_flags;  /* completion flags */
+    int                  esync_fd;    /* esync file descriptor */
 };
 
 static void fd_dump( struct object *obj, int verbose );
@@ -169,6 +176,7 @@ static const struct object_ops fd_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -210,6 +218,7 @@ static const struct object_ops device_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -250,6 +259,7 @@ static const struct object_ops inode_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -292,6 +302,7 @@ static const struct object_ops file_lock_ops =
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     file_lock_signaled,         /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -1115,6 +1126,59 @@ static void inode_dump( struct object *obj, int verbose )
     fprintf( stderr, "\n" );
 }
 
+/* recursively delete everything in a directory */
+static int rmdir_recursive( int dir_fd, const char *pathname )
+{
+    int ret = 0, tmp_fd;
+    struct dirent *p;
+    struct stat st;
+    DIR *d;
+
+    tmp_fd = openat( dir_fd, pathname, O_DIRECTORY|O_RDONLY|O_NONBLOCK|O_CLOEXEC );
+    d = fdopendir( tmp_fd );
+    if (!d)
+    {
+        close( tmp_fd );
+        return -1;
+    }
+
+    while (!ret && (p = readdir( d )))
+    {
+        if (!strcmp( p->d_name, "." ) || !strcmp( p->d_name, ".." ))
+            continue;
+        if (!fstatat( dirfd(d), p->d_name, &st, AT_SYMLINK_NOFOLLOW ))
+        {
+            if (S_ISDIR( st.st_mode ))
+                ret = rmdir_recursive( dirfd(d), p->d_name );
+            else
+                ret = unlinkat( dirfd(d), p->d_name, 0 );
+        }
+    }
+    closedir( d );
+    return unlinkat( dir_fd, pathname, AT_REMOVEDIR );
+}
+
+/* determine whether a reparse point is meant to be a directory or a file */
+static int is_reparse_dir( const char *path, int *is_dir )
+{
+    char link_path[PATH_MAX], *p;
+    int ret;
+
+    if ((ret = readlink( path, link_path, sizeof(link_path) )) < 0)
+        return ret;
+    /* confirm that this file is a reparse point */
+    if (strncmp( link_path, ".REPARSE_POINT/", 15) != 0)
+        return -1;
+    /* skip past the reparse point indicator and the filename */
+    p = &link_path[15];
+    if ((p = strchr( p, '/' )) == NULL)
+        return -1;
+    p++;
+    /* read the flag indicating whether this reparse point is a directory */
+    if (is_dir) *is_dir = (*p == '.');
+    return 0;
+}
+
 static void inode_destroy( struct object *obj )
 {
     struct inode *inode = (struct inode *)obj;
@@ -1131,7 +1195,34 @@ static void inode_destroy( struct object *obj )
         list_remove( ptr );
         if (fd->unix_fd != -1) close( fd->unix_fd );
         if (fd->disp_flags & FILE_DISPOSITION_DELETE)
-            unlink_closed_fd( inode, fd );
+        {
+            /* make sure it is still the same file */
+            struct stat st;
+            if (!lstat( fd->unix_name, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
+            {
+                int is_reparse_point = (is_reparse_dir( fd->unix_name, NULL ) == 0);
+                if (S_ISDIR(st.st_mode)) rmdir( fd->unix_name );
+                else unlink_closed_fd( inode, fd );
+                /* remove reparse point metadata (if applicable) */
+                if (is_reparse_point)
+                {
+                    char tmp[PATH_MAX], metadata_path[PATH_MAX], *p;
+
+                    strcpy( tmp, fd->unix_name );
+                    p = dirname( tmp );
+                    if (p != tmp ) strcpy( tmp, p );
+                    strcpy( metadata_path, tmp );
+                    strcat( metadata_path, "/.REPARSE_POINT/" );
+                    strcpy( tmp, fd->unix_name );
+                    p = basename( tmp );
+                    if (p != tmp) strcpy( tmp, p );
+                    strcat( metadata_path, tmp );
+
+                    rmdir_recursive( AT_FDCWD, metadata_path );
+                    rmdir( dirname( metadata_path ) );
+                }
+            }
+        }
         free( fd->unix_name );
         free( fd );
     }
@@ -1565,6 +1656,9 @@ static void fd_destroy( struct object *obj )
         if (fd->unix_fd != -1) close( fd->unix_fd );
         free( fd->unix_name );
     }
+
+    if (do_esync())
+        close( fd->esync_fd );
 }
 
 /* check if the desired access is possible without violating */
@@ -1683,12 +1777,16 @@ static struct fd *alloc_fd_object(void)
     fd->poll_index = -1;
     fd->completion = NULL;
     fd->comp_flags = 0;
+    fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
     list_init( &fd->inode_entry );
     list_init( &fd->locks );
 
+    if (do_esync())
+        fd->esync_fd = esync_create_fd( 1, 0 );
+
     if ((fd->poll_index = add_poll_user( fd )) == -1)
     {
         release_object( fd );
@@ -1724,11 +1822,15 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     fd->completion = NULL;
     fd->comp_flags = 0;
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
+    fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
     list_init( &fd->inode_entry );
     list_init( &fd->locks );
+
+    if (do_esync())
+        fd->esync_fd = esync_create_fd( 0, 0 );
     return fd;
 }
 
@@ -1870,6 +1972,38 @@ void get_nt_name( struct fd *fd, struct unicode_str *name )
     name->len = fd->nt_namelen;
 }
 
+/* check whether a file is a symlink */
+int check_symlink( char *name )
+{
+    struct stat st;
+
+    lstat( name, &st );
+    return S_ISLNK( st.st_mode );
+}
+
+/* if flags does not contain O_SYMLINK then just use realpath */
+/* otherwise return the real path of the parent and append the filename of the symlink */
+char *normalize_path( const char *path, int flags )
+{
+    char tmp[PATH_MAX], resolved_path[PATH_MAX], *p;
+
+#if defined(O_SYMLINK)
+    if ((flags & O_SYMLINK) != O_SYMLINK)
+        return realpath( path, NULL );
+#endif
+
+    strcpy( tmp, path );
+    p = dirname( tmp );
+    if (p != tmp ) strcpy( tmp, p );
+    realpath( tmp, resolved_path );
+    strcat( resolved_path, "/" );
+    strcpy( tmp, path );
+    p = basename( tmp );
+    if (p != tmp) strcpy( tmp, p );
+    strcat( resolved_path, tmp );
+    return strdup( resolved_path );
+}
+
 /* open() wrapper that returns a struct fd with no fd user set */
 struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_name,
                     int flags, mode_t *mode, unsigned int access,
@@ -1881,6 +2015,8 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
     int root_fd = -1;
     int rw_mode;
     char *path;
+    int do_chmod = 0;
+    int created = (flags & O_CREAT);
 
     if (((options & FILE_DELETE_ON_CLOSE) && !(access & DELETE)) ||
         ((options & FILE_DIRECTORY_FILE) && (flags & O_TRUNC)))
@@ -1912,13 +2048,19 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
     /* create the directory if needed */
     if ((options & FILE_DIRECTORY_FILE) && (flags & O_CREAT))
     {
-        if (mkdir( name, *mode ) == -1)
+        if (mkdir( name, *mode | S_IRUSR ) != -1)
+        {
+            /* remove S_IRUSR later, after we have opened the directory */
+            do_chmod = !(*mode & S_IRUSR);
+        }
+        else
         {
             if (errno != EEXIST || (flags & O_EXCL))
             {
                 file_set_error();
                 goto error;
             }
+            created = 0;
         }
         flags &= ~(O_CREAT | O_EXCL | O_TRUNC);
     }
@@ -1930,6 +2072,15 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
     }
     else rw_mode = O_RDONLY;
 
+    if ((path = dup_fd_name( root, name )))
+    {
+#if defined(O_SYMLINK)
+        if (check_symlink( path ) && (options & FILE_OPEN_REPARSE_POINT) && !(flags & O_CREAT))
+            flags |= O_SYMLINK;
+#endif
+        free( path );
+    }
+
     if ((fd->unix_fd = open( name, rw_mode | (flags & ~O_TRUNC), *mode )) == -1)
     {
         /* if we tried to open a directory for write access, retry read-only */
@@ -1938,6 +2089,23 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
             if ((access & FILE_UNIX_WRITE_ACCESS) || (flags & O_CREAT))
                 fd->unix_fd = open( name, O_RDONLY | (flags & ~(O_TRUNC | O_CREAT | O_EXCL)), *mode );
         }
+        else if (errno == EACCES)
+        {
+            /* try to change permissions temporarily to open a file descriptor */
+            if (!(access & ((FILE_UNIX_WRITE_ACCESS | FILE_UNIX_READ_ACCESS | DELETE) & ~FILE_WRITE_ATTRIBUTES)) &&
+                !stat( name, &st ) && st.st_uid == getuid() &&
+                !chmod( name, st.st_mode | S_IRUSR ))
+            {
+                fd->unix_fd = open( name, O_RDONLY | (flags & ~(O_TRUNC | O_CREAT | O_EXCL)), *mode );
+                *mode = st.st_mode;
+                do_chmod = 1;
+            }
+            else
+            {
+                set_error( STATUS_ACCESS_DENIED );
+                goto error;
+            }
+        }
 
         if (fd->unix_fd == -1)
         {
@@ -1946,6 +2114,8 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
                 set_error( STATUS_OBJECT_NAME_INVALID );
             else
                 file_set_error();
+
+            if (do_chmod) chmod( name, *mode );
             goto error;
         }
     }
@@ -1954,21 +2124,23 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
     fd->unix_name = NULL;
     if ((path = dup_fd_name( root, name )))
     {
-        fd->unix_name = realpath( path, NULL );
+        fd->unix_name = normalize_path( path, flags );
         free( path );
     }
 
     closed_fd->unix_fd = fd->unix_fd;
     closed_fd->disp_flags = 0;
     closed_fd->unix_name = fd->unix_name;
+    if (do_chmod) chmod( name, *mode );
     fstat( fd->unix_fd, &st );
     *mode = st.st_mode;
 
     /* only bother with an inode for normal files and directories */
-    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode))
+    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode) || S_ISLNK(st.st_mode))
     {
         unsigned int err;
         struct inode *inode = get_inode( st.st_dev, st.st_ino, fd->unix_fd );
+        int is_link = S_ISLNK(st.st_mode), is_dir;
 
         if (!inode)
         {
@@ -1983,13 +2155,17 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
         list_add_head( &inode->open, &fd->inode_entry );
         closed_fd = NULL;
 
+        is_dir = S_ISDIR(st.st_mode);
+        if (is_link)
+            is_reparse_dir(fd->unix_name, &is_dir);
+
         /* check directory options */
-        if ((options & FILE_DIRECTORY_FILE) && !S_ISDIR(st.st_mode))
+        if ((options & FILE_DIRECTORY_FILE) && !is_dir)
         {
             set_error( STATUS_NOT_A_DIRECTORY );
             goto error;
         }
-        if ((options & FILE_NON_DIRECTORY_FILE) && S_ISDIR(st.st_mode))
+        if ((options & FILE_NON_DIRECTORY_FILE) && is_dir)
         {
             set_error( STATUS_FILE_IS_A_DIRECTORY );
             goto error;
@@ -2001,7 +2177,7 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
         }
 
         /* can't unlink files if we don't have permission to access */
-        if ((options & FILE_DELETE_ON_CLOSE) && !(flags & O_CREAT) &&
+        if ((options & FILE_DELETE_ON_CLOSE) && !created &&
             !(st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
         {
             set_error( STATUS_CANNOT_DELETE );
@@ -2140,6 +2316,9 @@ void set_fd_signaled( struct fd *fd, int signaled )
     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
     fd->signaled = signaled;
     if (signaled) wake_up( fd->user, 0 );
+
+    if (do_esync() && !signaled)
+        esync_clear( fd->esync_fd );
 }
 
 /* check if events are pending and if yes return which one(s) */
@@ -2165,6 +2344,15 @@ int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry )
     return ret;
 }
 
+int default_fd_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct fd *fd = get_obj_fd( obj );
+    int ret = fd->esync_fd;
+    *type = ESYNC_MANUAL_SERVER;
+    release_object( fd );
+    return ret;
+}
+
 int default_fd_get_poll_events( struct fd *fd )
 {
     int events = 0;
@@ -2436,6 +2624,7 @@ static struct fd *get_handle_fd_obj( struct process *process, obj_handle_t handl
 
 static int is_dir_empty( int fd )
 {
+    int dir_fd;
     DIR *dir;
     int empty;
     struct dirent *de;
@@ -2443,8 +2632,13 @@ static int is_dir_empty( int fd )
     if ((fd = dup( fd )) == -1)
         return -1;
 
-    if (!(dir = fdopendir( fd )))
+    /* use openat() so that if 'fd' was opened with O_SYMLINK we can still check the contents */
+    dir_fd = openat( fd, ".", O_RDONLY | O_DIRECTORY | O_NONBLOCK );
+    if (dir_fd == -1)
+        return -1;
+    if (!(dir = fdopendir( dir_fd )))
     {
+        close( dir_fd );
         close( fd );
         return -1;
     }
@@ -2456,6 +2650,7 @@ static int is_dir_empty( int fd )
         empty = 0;
     }
     closedir( dir );
+    close( dir_fd );
     return empty;
 }
 
@@ -2494,7 +2689,7 @@ static void set_fd_disposition( struct fd *fd, unsigned int flags )
             file_set_error();
             return;
         }
-        if (S_ISREG( st.st_mode ))  /* can't unlink files we don't have permission to write */
+        if (S_ISREG( st.st_mode ) || S_ISLNK( st.st_mode ))  /* can't unlink files we don't have permission to write */
         {
             if (!(flags & FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE) &&
                 !(st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
@@ -2578,7 +2773,7 @@ static void set_fd_name( struct fd *fd, struct fd *root, const char *nameptr, da
         goto failed;
     }
 
-    if (!stat( name, &st ))
+    if (!lstat( name, &st ))
     {
         if (!fstat( fd->unix_fd, &st2 ) && st.st_ino == st2.st_ino && st.st_dev == st2.st_dev)
         {
@@ -2594,7 +2789,7 @@ static void set_fd_name( struct fd *fd, struct fd *root, const char *nameptr, da
         }
 
         /* can't replace directories or special files */
-        if (!S_ISREG( st.st_mode ))
+        if (!S_ISREG( st.st_mode ) && !S_ISLNK( st.st_mode ))
         {
             set_error( STATUS_ACCESS_DENIED );
             goto failed;
@@ -2660,6 +2855,8 @@ static void set_fd_name( struct fd *fd, struct fd *root, const char *nameptr, da
     fd->nt_name = dup_nt_name( root, nt_name, &fd->nt_namelen );
     free( fd->unix_name );
     fd->closed->unix_name = fd->unix_name = realpath( name, NULL );
+    if (!fd->unix_name)
+        fd->closed->unix_name = fd->unix_name = dup_fd_name( root, name ); /* dangling symlink */
     free( name );
     if (!fd->unix_name)
         set_error( STATUS_NO_MEMORY );
diff --git a/server/file.c b/server/file.c
index 76c6878..828a21c 100644
--- a/server/file.c
+++ b/server/file.c
@@ -31,11 +31,22 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <time.h>
+#include <limits.h>
 #include <unistd.h>
 #ifdef HAVE_UTIME_H
 #include <utime.h>
 #endif
 #include <poll.h>
+#ifdef HAVE_ATTR_XATTR_H
+#undef XATTR_ADDITIONAL_OPTIONS
+#include <attr/xattr.h>
+#elif defined(HAVE_SYS_XATTR_H)
+#include <sys/xattr.h>
+#endif
+#ifdef HAVE_SYS_EXTATTR_H
+#undef XATTR_ADDITIONAL_OPTIONS
+#include <sys/extattr.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -63,6 +74,24 @@ struct type_descr file_type =
     },
 };
 
+#ifndef XATTR_USER_PREFIX
+#define XATTR_USER_PREFIX "user."
+#endif
+#ifndef XATTR_USER_PREFIX_LEN
+#define XATTR_USER_PREFIX_LEN (sizeof(XATTR_USER_PREFIX) - 1)
+#endif
+#ifndef XATTR_SIZE_MAX
+#define XATTR_SIZE_MAX    65536
+#endif
+
+/* We intentionally do not match the Samba 4 extended attribute for NT security descriptors (SDs):
+ *  1) Samba stores this information using an internal data structure (we use a flat NT SD).
+ *  2) Samba uses the attribute "security.NTACL".  This attribute is within a namespace that only
+ *     the administrator has write access to, which prohibits the user from copying the attributes
+ *     when copying a file and would require Wine to run with adminstrative privileges.
+ */
+#define WINE_XATTR_SD  XATTR_USER_PREFIX "wine.sd"
+
 struct file
 {
     struct object       obj;            /* object header */
@@ -94,6 +123,7 @@ static const struct object_ops file_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     file_get_fd,                  /* get_fd */
@@ -186,7 +216,8 @@ struct file *create_file_for_fd_obj( struct fd *fd, unsigned int access, unsigne
     return file;
 }
 
-static struct object *create_file_obj( struct fd *fd, unsigned int access, mode_t mode )
+static struct object *create_file_obj( struct fd *fd, unsigned int access, mode_t mode,
+                                       const struct security_descriptor *sd )
 {
     struct file *file = alloc_object( &file_ops );
 
@@ -198,6 +229,12 @@ static struct object *create_file_obj( struct fd *fd, unsigned int access, mode_
     list_init( &file->kernel_object );
     grab_object( fd );
     set_fd_user( fd, &file_fd_ops, &file->obj );
+
+    if (sd) file_set_sd( &file->obj, sd, OWNER_SECURITY_INFORMATION |
+                                         GROUP_SECURITY_INFORMATION |
+                                         DACL_SECURITY_INFORMATION |
+                                         SACL_SECURITY_INFORMATION );
+
     return &file->obj;
 }
 
@@ -207,6 +244,72 @@ int is_file_executable( const char *name )
     return len >= 4 && (!strcasecmp( name + len - 4, ".exe") || !strcasecmp( name + len - 4, ".com" ));
 }
 
+#ifdef HAVE_SYS_EXTATTR_H
+static inline int xattr_valid_namespace( const char *name )
+{
+    if (strncmp( XATTR_USER_PREFIX, name, XATTR_USER_PREFIX_LEN ) != 0)
+    {
+        errno = EPERM;
+        return 0;
+    }
+    return 1;
+}
+#endif
+
+static int xattr_fget( int filedes, const char *name, void *value, size_t size )
+{
+#if defined(XATTR_ADDITIONAL_OPTIONS)
+    return fgetxattr( filedes, name, value, size, 0, 0 );
+#elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
+    return fgetxattr( filedes, name, value, size );
+#elif defined(HAVE_SYS_EXTATTR_H)
+    if (!xattr_valid_namespace( name )) return -1;
+    return extattr_get_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
+                           value, size );
+#else
+    errno = ENOSYS;
+    return -1;
+#endif
+}
+
+static int xattr_fset( int filedes, const char *name, void *value, size_t size )
+{
+#if defined(XATTR_ADDITIONAL_OPTIONS)
+    return fsetxattr( filedes, name, value, size, 0, 0 );
+#elif defined(HAVE_SYS_XATTR_H) || defined(HAVE_ATTR_XATTR_H)
+    return fsetxattr( filedes, name, value, size, 0 );
+#elif defined(HAVE_SYS_EXTATTR_H)
+    if (!xattr_valid_namespace( name )) return -1;
+    return extattr_set_fd( filedes, EXTATTR_NAMESPACE_USER, &name[XATTR_USER_PREFIX_LEN],
+                           value, size );
+#else
+    errno = ENOSYS;
+    return -1;
+#endif
+}
+
+static void set_xattr_sd( int fd, const struct security_descriptor *sd )
+{
+    char buffer[XATTR_SIZE_MAX];
+    int present, len;
+    const struct acl *dacl;
+
+    /* there's no point in storing the security descriptor if there's no DACL */
+    if (!sd) return;
+    dacl = sd_get_dacl( sd, &present );
+    if (!present || !dacl) return;
+
+    len = 2 + sizeof(struct security_descriptor) + sd->owner_len +
+          sd->group_len + sd->sacl_len + sd->dacl_len;
+    if (len > XATTR_SIZE_MAX) return;
+
+    /* include the descriptor revision and resource manager control bits */
+    buffer[0] = SECURITY_DESCRIPTOR_REVISION;
+    buffer[1] = 0;
+    memcpy( &buffer[2], sd, len - 2 );
+    xattr_fset( fd, WINE_XATTR_SD, buffer, len );
+}
+
 static struct object *create_file( struct fd *root, const char *nameptr, data_size_t len,
                                    struct unicode_str nt_name,
                                    unsigned int access, unsigned int sharing, int create,
@@ -270,11 +373,11 @@ static struct object *create_file( struct fd *root, const char *nameptr, data_si
     if (!fd) goto done;
 
     if (S_ISDIR(mode))
-        obj = create_dir_obj( fd, access, mode );
+        obj = create_dir_obj( fd, access, mode, sd );
     else if (S_ISCHR(mode) && is_serial_fd( fd ))
         obj = create_serial( fd );
     else
-        obj = create_file_obj( fd, access, mode );
+        obj = create_file_obj( fd, access, mode, sd );
 
     release_object( fd );
 
@@ -294,6 +397,7 @@ static enum server_fd_type file_get_fd_type( struct fd *fd )
 {
     struct file *file = get_fd_user( fd );
 
+    if (S_ISLNK(file->mode)) return FD_TYPE_SYMLINK;
     if (S_ISREG(file->mode) || S_ISBLK(file->mode)) return FD_TYPE_FILE;
     if (S_ISDIR(file->mode)) return FD_TYPE_DIR;
     return FD_TYPE_CHAR;
@@ -387,37 +491,91 @@ struct security_descriptor *mode_to_sd( mode_t mode, const struct sid *user, con
     return sd;
 }
 
-static struct security_descriptor *file_get_sd( struct object *obj )
+/* Convert generic rights into standard access rights */
+static void convert_generic_sd( struct security_descriptor *sd )
+{
+    const struct acl *dacl;
+    int present;
+
+    dacl = sd_get_dacl( sd, &present );
+    if (present && dacl)
+    {
+        const struct ace *ace = (const struct ace *)(dacl + 1);
+        ULONG i;
+
+        for (i = 0; i < dacl->count; i++, ace = ace_next( ace ))
+        {
+            DWORD *mask = (DWORD *)(ace + 1);
+            *mask = map_access( *mask, &file_type.mapping );
+        }
+    }
+}
+
+static struct security_descriptor *get_xattr_sd( int fd )
 {
-    struct file *file = (struct file *)obj;
-    struct stat st;
-    int unix_fd;
     struct security_descriptor *sd;
+    char buffer[XATTR_SIZE_MAX];
+    int n;
 
-    assert( obj->ops == &file_ops );
+    n = xattr_fget( fd, WINE_XATTR_SD, buffer, sizeof(buffer) );
+    if (n == -1 || n < 2 + sizeof(struct security_descriptor)) return NULL;
 
-    unix_fd = get_file_unix_fd( file );
+    /* validate that we can handle the descriptor */
+    if (buffer[0] != SECURITY_DESCRIPTOR_REVISION || buffer[1] != 0 ||
+            !sd_is_valid( (struct security_descriptor *)&buffer[2], n - 2 ))
+        return NULL;
+
+    sd = mem_alloc( n - 2 );
+    if (sd)
+    {
+        memcpy( sd, &buffer[2], n - 2 );
+        convert_generic_sd( sd ); /* for backwards compatibility */
+    }
+    return sd;
+}
+
+struct security_descriptor *get_file_sd( struct object *obj, struct fd *fd, mode_t *mode,
+                                         uid_t *uid )
+{
+    int unix_fd = get_unix_fd( fd );
+    struct stat st;
+    struct security_descriptor *sd;
 
     if (unix_fd == -1 || fstat( unix_fd, &st ) == -1)
         return obj->sd;
 
     /* mode and uid the same? if so, no need to re-generate security descriptor */
-    if (obj->sd && (st.st_mode & (S_IRWXU|S_IRWXO)) == (file->mode & (S_IRWXU|S_IRWXO)) &&
-        (st.st_uid == file->uid))
+    if (obj->sd && (st.st_mode & (S_IRWXU|S_IRWXO)) == (*mode & (S_IRWXU|S_IRWXO)) &&
+        (st.st_uid == *uid))
         return obj->sd;
 
-    sd = mode_to_sd( st.st_mode,
-                     security_unix_uid_to_sid( st.st_uid ),
-                     token_get_primary_group( current->process->token ));
+    sd = get_xattr_sd( unix_fd );
+    if (!sd) sd = mode_to_sd( st.st_mode,
+                              security_unix_uid_to_sid( st.st_uid ),
+                              token_get_primary_group( current->process->token ));
     if (!sd) return obj->sd;
 
-    file->mode = st.st_mode;
-    file->uid = st.st_uid;
+    *mode = st.st_mode;
+    *uid = st.st_uid;
     free( obj->sd );
     obj->sd = sd;
     return sd;
 }
 
+static struct security_descriptor *file_get_sd( struct object *obj )
+{
+    struct file *file = (struct file *)obj;
+    struct security_descriptor *sd;
+    struct fd *fd;
+
+    assert( obj->ops == &file_ops );
+
+    fd = file_get_fd( obj );
+    sd = get_file_sd( obj, fd, &file->mode, &file->uid );
+    release_object( fd );
+    return sd;
+}
+
 static mode_t file_access_to_mode( unsigned int access )
 {
     mode_t mode = 0;
@@ -497,54 +655,75 @@ mode_t sd_to_mode( const struct security_descriptor *sd, const struct sid *owner
     return new_mode;
 }
 
-static int file_set_sd( struct object *obj, const struct security_descriptor *sd,
-                        unsigned int set_info )
+int set_file_sd( struct object *obj, struct fd *fd, mode_t *mode, uid_t *uid,
+                 const struct security_descriptor *sd, unsigned int set_info )
 {
-    struct file *file = (struct file *)obj;
-    const struct sid *owner;
+    struct security_descriptor *new_sd;
+    int unix_fd = get_unix_fd( fd );
+    const struct sid *owner, *group;
     struct stat st;
-    mode_t mode;
-    int unix_fd;
+    mode_t new_mode;
 
-    assert( obj->ops == &file_ops );
+    if (!set_info || unix_fd == -1 || fstat( unix_fd, &st ) == -1) return 1;
+    if (!obj->sd) get_file_sd( obj, fd, mode, uid );
 
-    unix_fd = get_file_unix_fd( file );
+    /* calculate the new sd, save to a temporary variable before assigning */
+    new_sd = set_sd_from_token_internal( sd, obj->sd, set_info, current->process->token );
+    if (new_sd)
+     {
+        /* convert generic rights into standard access rights */
+        convert_generic_sd( new_sd );
 
-    if (unix_fd == -1 || fstat( unix_fd, &st ) == -1) return 1;
+        if (set_info & OWNER_SECURITY_INFORMATION)
+         {
+            owner = sd_get_owner( new_sd );
+            assert( owner );
 
-    if (set_info & OWNER_SECURITY_INFORMATION)
-    {
-        owner = sd_get_owner( sd );
-        if (!owner)
-        {
-            set_error( STATUS_INVALID_SECURITY_DESCR );
-            return 0;
-        }
-        if (!obj->sd || !equal_sid( owner, sd_get_owner( obj->sd ) ))
-        {
-            /* FIXME: get Unix uid and call fchown */
-        }
-    }
-    else if (obj->sd)
-        owner = sd_get_owner( obj->sd );
-    else
-        owner = token_get_owner( current->process->token );
+            if (!obj->sd || !equal_sid( owner, sd_get_owner( obj->sd ) ))
+            {
+                /* FIXME: get Unix uid and call fchown */
+            }
+         }
 
-    /* group and sacl not supported */
+        if (set_info & GROUP_SECURITY_INFORMATION)
+         {
+            group = sd_get_group( new_sd );
+            assert( group );
 
-    if (set_info & DACL_SECURITY_INFORMATION)
-    {
-        /* keep the bits that we don't map to access rights in the ACL */
-        mode = st.st_mode & (S_ISUID|S_ISGID|S_ISVTX);
-        mode |= sd_to_mode( sd, owner );
+            if (!obj->sd || !equal_sid( group, sd_get_group( obj->sd ) ))
+            {
+                /* FIXME: get Unix uid and call fchown */
+            }
+         }
 
-        if (((st.st_mode ^ mode) & (S_IRWXU|S_IRWXG|S_IRWXO)) && fchmod( unix_fd, mode ) == -1)
+        if (set_info & DACL_SECURITY_INFORMATION)
         {
-            file_set_error();
-            return 0;
-        }
-    }
-    return 1;
+            owner = sd_get_owner( new_sd );
+            assert( owner );
+
+            /* keep the bits that we don't map to access rights in the ACL */
+            new_mode = st.st_mode & (S_ISUID|S_ISGID|S_ISVTX);
+            new_mode |= sd_to_mode( new_sd, owner );
+
+            if (((st.st_mode ^ new_mode) & (S_IRWXU|S_IRWXG|S_IRWXO)) && fchmod( unix_fd, new_mode ) == -1)
+            {
+                free( new_sd );
+                file_set_error();
+                return 0;
+            }
+
+            *mode = (*mode & S_IFMT) | new_mode;
+         }
+
+        /* extended attributes are set after the file mode, to ensure it stays in sync */
+        set_xattr_sd( unix_fd, new_sd );
+
+        free( obj->sd );
+        obj->sd = new_sd;
+        return 1;
+     }
+
+    return 0;
 }
 
 static struct object *file_lookup_name( struct object *obj, struct unicode_str *name,
@@ -583,6 +762,21 @@ static struct list *file_get_kernel_obj_list( struct object *obj )
     return &file->kernel_object;
 }
 
+static int file_set_sd( struct object *obj, const struct security_descriptor *sd,
+                        unsigned int set_info )
+{
+    struct file *file = (struct file *)obj;
+    struct fd *fd;
+    int ret;
+
+    assert( obj->ops == &file_ops );
+
+    fd = file_get_fd( obj );
+    ret = set_file_sd( obj, fd, &file->mode, &file->uid, sd, set_info );
+    release_object( fd );
+    return ret;
+}
+
 static void file_destroy( struct object *obj )
 {
     struct file *file = (struct file *)obj;
@@ -669,7 +863,10 @@ DECL_HANDLER(create_file)
     if ((file = create_file( root_fd, name, name_len, nt_name, req->access, req->sharing,
                              req->create, req->options, req->attrs, sd )))
     {
-        reply->handle = alloc_handle( current->process, file, req->access, objattr->attributes );
+        if (get_error() == STATUS_OBJECT_NAME_EXISTS)
+            reply->handle = alloc_handle( current->process, file, req->access, objattr->attributes );
+        else
+            reply->handle = alloc_handle_no_access_check( current->process, file, req->access, objattr->attributes );
         release_object( file );
     }
     if (root_fd) release_object( root_fd );
diff --git a/server/file.h b/server/file.h
index 39a833c..4914ea2 100644
--- a/server/file.h
+++ b/server/file.h
@@ -108,6 +108,7 @@ extern char *dup_fd_name( struct fd *root, const char *name ) __WINE_DEALLOC(fre
 extern void get_nt_name( struct fd *fd, struct unicode_str *name );
 
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
+extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
 extern int default_fd_get_poll_events( struct fd *fd );
 extern void default_poll_event( struct fd *fd, int event );
 extern void fd_cancel_async( struct fd *fd, struct async *async );
@@ -169,6 +170,10 @@ extern void file_set_error(void);
 extern struct security_descriptor *mode_to_sd( mode_t mode, const struct sid *user, const struct sid *group );
 extern mode_t sd_to_mode( const struct security_descriptor *sd, const struct sid *owner );
 extern int is_file_executable( const char *name );
+extern int set_file_sd( struct object *obj, struct fd *fd, mode_t *mode, uid_t *uid,
+                        const struct security_descriptor *sd, unsigned int set_info );
+extern struct security_descriptor *get_file_sd( struct object *obj, struct fd *fd, mode_t *mode,
+                                                uid_t *uid );
 
 /* file mapping functions */
 
@@ -206,7 +211,8 @@ extern struct object *create_unix_device( struct object *root, const struct unic
 
 extern void do_change_notify( int unix_fd );
 extern void sigio_callback(void);
-extern struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode );
+extern struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode,
+                                      const struct security_descriptor *sd );
 extern struct dir *get_dir_obj( struct process *process, obj_handle_t handle, unsigned int access );
 
 /* completion */
diff --git a/server/handle.c b/server/handle.c
index 0595fdb..d41c7e8 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -126,6 +126,7 @@ static const struct object_ops handle_table_ops =
     no_add_queue,                    /* add_queue */
     NULL,                            /* remove_queue */
     NULL,                            /* signaled */
+    NULL,                            /* get_esync_fd */
     NULL,                            /* satisfied */
     no_signal,                       /* signal */
     no_get_fd,                       /* get_fd */
diff --git a/server/hook.c b/server/hook.c
index 5abdf39..da351d6 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -80,6 +80,7 @@ static const struct object_ops hook_table_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/mailslot.c b/server/mailslot.c
index 2d8697e..4cf9b73 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -74,6 +74,7 @@ static const struct object_ops mailslot_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     default_fd_signaled,       /* signaled */
+    NULL,                      /* get_esync_fd */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     mailslot_get_fd,           /* get_fd */
@@ -133,6 +134,7 @@ static const struct object_ops mail_writer_ops =
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
     NULL,                       /* satisfied */
     no_signal,                  /* signal */
     mail_writer_get_fd,         /* get_fd */
@@ -196,6 +198,7 @@ static const struct object_ops mailslot_device_ops =
     no_add_queue,                   /* add_queue */
     NULL,                           /* remove_queue */
     NULL,                           /* signaled */
+    NULL,                           /* get_esync_fd */
     no_satisfied,                   /* satisfied */
     no_signal,                      /* signal */
     no_get_fd,                      /* get_fd */
@@ -226,6 +229,7 @@ static const struct object_ops mailslot_device_file_ops =
     add_queue,                              /* add_queue */
     remove_queue,                           /* remove_queue */
     default_fd_signaled,                    /* signaled */
+    NULL,                                   /* get_esync_fd */
     no_satisfied,                           /* satisfied */
     no_signal,                              /* signal */
     mailslot_device_file_get_fd,            /* get_fd */
diff --git a/server/main.c b/server/main.c
index 1248b92..5062d09 100644
--- a/server/main.c
+++ b/server/main.c
@@ -34,6 +34,7 @@
 #include "thread.h"
 #include "request.h"
 #include "unicode.h"
+#include "esync.h"
 
 /* command-line options */
 int debug_level = 0;
@@ -229,8 +230,12 @@ int main( int argc, char *argv[] )
     sock_init();
     open_master_socket();
 
+    if (do_esync())
+        esync_init();
+
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
+    init_scheduler();
     init_signals();
     init_memory();
     init_directories( load_intl_file() );
diff --git a/server/mapping.c b/server/mapping.c
index f754078..94266e1 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -67,6 +67,7 @@ static const struct object_ops ranges_ops =
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -103,6 +104,7 @@ static const struct object_ops shared_map_ops =
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -176,6 +178,7 @@ static const struct object_ops mapping_ops =
     no_add_queue,                /* add_queue */
     NULL,                        /* remove_queue */
     NULL,                        /* signaled */
+    NULL,                        /* get_esync_fd */
     NULL,                        /* satisfied */
     no_signal,                   /* signal */
     mapping_get_fd,              /* get_fd */
diff --git a/server/mutex.c b/server/mutex.c
index af0efe7..4785a83 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -73,6 +73,7 @@ static const struct object_ops mutex_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     mutex_signaled,            /* signaled */
+    NULL,                      /* get_esync_fd */
     mutex_satisfied,           /* satisfied */
     mutex_signal,              /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/named_pipe.c b/server/named_pipe.c
index f3404a3..a90ec60 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -119,6 +119,7 @@ static const struct object_ops named_pipe_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -167,6 +168,7 @@ static const struct object_ops pipe_server_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    default_fd_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -211,6 +213,7 @@ static const struct object_ops pipe_client_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    default_fd_get_esync_fd,      /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -258,6 +261,7 @@ static const struct object_ops named_pipe_device_ops =
     no_add_queue,                     /* add_queue */
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
+    NULL,                             /* get_esync_fd */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -289,6 +293,7 @@ static const struct object_ops named_pipe_device_file_ops =
     add_queue,                               /* add_queue */
     remove_queue,                            /* remove_queue */
     default_fd_signaled,                     /* signaled */
+    NULL,                                    /* get_esync_fd */
     no_satisfied,                            /* satisfied */
     no_signal,                               /* signal */
     named_pipe_device_file_get_fd,           /* get_fd */
diff --git a/server/object.c b/server/object.c
index 89e541f..29f1ea9 100644
--- a/server/object.c
+++ b/server/object.c
@@ -548,8 +548,9 @@ struct security_descriptor *default_get_sd( struct object *obj )
     return obj->sd;
 }
 
-int set_sd_defaults_from_token( struct object *obj, const struct security_descriptor *sd,
-                                unsigned int set_info, struct token *token )
+struct security_descriptor *set_sd_from_token_internal( const struct security_descriptor *sd,
+                                                        const struct security_descriptor *old_sd,
+                                                        unsigned int set_info, struct token *token )
 {
     struct security_descriptor new_sd, *new_sd_ptr;
     int present;
@@ -558,8 +559,6 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
     struct acl *replaced_sacl = NULL;
     char *ptr;
 
-    if (!set_info) return 1;
-
     new_sd.control = sd->control & ~SE_SELF_RELATIVE;
 
     if (set_info & OWNER_SECURITY_INFORMATION && sd->owner_len)
@@ -567,10 +566,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
         owner = sd_get_owner( sd );
         new_sd.owner_len = sd->owner_len;
     }
-    else if (obj->sd && obj->sd->owner_len)
+    else if (old_sd && old_sd->owner_len)
     {
-        owner = sd_get_owner( obj->sd );
-        new_sd.owner_len = obj->sd->owner_len;
+        owner = sd_get_owner( old_sd );
+        new_sd.owner_len = old_sd->owner_len;
     }
     else if (token)
     {
@@ -584,10 +583,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
         group = sd_get_group( sd );
         new_sd.group_len = sd->group_len;
     }
-    else if (obj->sd && obj->sd->group_len)
+    else if (old_sd && old_sd->group_len)
     {
-        group = sd_get_group( obj->sd );
-        new_sd.group_len = obj->sd->group_len;
+        group = sd_get_group( old_sd );
+        new_sd.group_len = old_sd->group_len;
     }
     else if (token)
     {
@@ -605,20 +604,20 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
     else if (set_info & LABEL_SECURITY_INFORMATION && present)
     {
         const struct acl *old_sacl = NULL;
-        if (obj->sd && obj->sd->control & SE_SACL_PRESENT) old_sacl = sd_get_sacl( obj->sd, &present );
-        if (!(replaced_sacl = replace_security_labels( old_sacl, sacl ))) return 0;
+        if (old_sd && old_sd->control & SE_SACL_PRESENT) old_sacl = sd_get_sacl( old_sd, &present );
+        if (!(replaced_sacl = replace_security_labels( old_sacl, sacl ))) return NULL;
         new_sd.control |= SE_SACL_PRESENT;
         new_sd.sacl_len = replaced_sacl->size;
         sacl = replaced_sacl;
     }
     else
     {
-        if (obj->sd) sacl = sd_get_sacl( obj->sd, &present );
+        if (old_sd) sacl = sd_get_sacl( old_sd, &present );
 
-        if (obj->sd && present)
+        if (old_sd && present)
         {
             new_sd.control |= SE_SACL_PRESENT;
-            new_sd.sacl_len = obj->sd->sacl_len;
+            new_sd.sacl_len = old_sd->sacl_len;
         }
         else
             new_sd.sacl_len = 0;
@@ -632,12 +631,12 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
     }
     else
     {
-        if (obj->sd) dacl = sd_get_dacl( obj->sd, &present );
+        if (old_sd) dacl = sd_get_dacl( old_sd, &present );
 
-        if (obj->sd && present)
+        if (old_sd && present)
         {
             new_sd.control |= SE_DACL_PRESENT;
-            new_sd.dacl_len = obj->sd->dacl_len;
+            new_sd.dacl_len = old_sd->dacl_len;
         }
         else if (token)
         {
@@ -653,7 +652,7 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
     if (!ptr)
     {
         free( replaced_sacl );
-        return 0;
+        return NULL;
     }
     new_sd_ptr = (struct security_descriptor*)ptr;
 
@@ -668,9 +667,25 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
     memcpy( ptr, dacl, new_sd.dacl_len );
 
     free( replaced_sacl );
-    free( obj->sd );
-    obj->sd = new_sd_ptr;
-    return 1;
+    return new_sd_ptr;
+}
+
+int set_sd_defaults_from_token( struct object *obj, const struct security_descriptor *sd,
+                                unsigned int set_info, struct token *token )
+{
+    struct security_descriptor *new_sd;
+
+    if (!set_info) return 1;
+
+    new_sd = set_sd_from_token_internal( sd, obj->sd, set_info, token );
+    if (new_sd)
+    {
+        free( obj->sd );
+        obj->sd = new_sd;
+        return 1;
+    }
+
+    return 0;
 }
 
 /** Set the security descriptor using the current primary token for defaults. */
diff --git a/server/object.h b/server/object.h
index dfdd691..fc3eb33 100644
--- a/server/object.h
+++ b/server/object.h
@@ -78,6 +78,8 @@ struct object_ops
     void (*remove_queue)(struct object *,struct wait_queue_entry *);
     /* is object signaled? */
     int  (*signaled)(struct object *,struct wait_queue_entry *);
+    /* return the esync fd for this object */
+    int (*get_esync_fd)(struct object *, enum esync_type *type);
     /* wait satisfied */
     void (*satisfied)(struct object *,struct wait_queue_entry *);
     /* signal an object */
@@ -171,6 +173,9 @@ extern struct fd *no_get_fd( struct object *obj );
 extern unsigned int default_map_access( struct object *obj, unsigned int access );
 extern struct security_descriptor *default_get_sd( struct object *obj );
 extern int default_set_sd( struct object *obj, const struct security_descriptor *sd, unsigned int set_info );
+extern struct security_descriptor *set_sd_from_token_internal( const struct security_descriptor *sd,
+                                                               const struct security_descriptor *old_sd,
+                                                               unsigned int set_info, struct token *token );
 extern int set_sd_defaults_from_token( struct object *obj, const struct security_descriptor *sd,
                                        unsigned int set_info, struct token *token );
 extern WCHAR *no_get_full_name( struct object *obj, data_size_t *ret_len );
diff --git a/server/process.c b/server/process.c
index a0d5ea6..c27b896 100644
--- a/server/process.c
+++ b/server/process.c
@@ -63,6 +63,7 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
+#include "esync.h"
 
 /* process object */
 
@@ -95,6 +96,7 @@ static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static struct list *process_get_kernel_obj_list( struct object *obj );
 static void process_destroy( struct object *obj );
+static int process_get_esync_fd( struct object *obj, enum esync_type *type );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
 
 static const struct object_ops process_ops =
@@ -105,6 +107,7 @@ static const struct object_ops process_ops =
     add_queue,                   /* add_queue */
     remove_queue,                /* remove_queue */
     process_signaled,            /* signaled */
+    process_get_esync_fd,        /* get_esync_fd */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
@@ -156,6 +159,7 @@ static const struct object_ops startup_info_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     startup_info_signaled,         /* signaled */
+    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -217,6 +221,7 @@ static const struct object_ops job_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     job_signaled,                  /* signaled */
+    NULL,                          /* get_esync_fd */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -683,6 +688,7 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
     process->rawinput_mouse  = NULL;
     process->rawinput_kbd    = NULL;
     memset( &process->image_info, 0, sizeof(process->image_info) );
+    process->esync_fd        = -1;
     list_init( &process->kernel_object );
     list_init( &process->thread_list );
     list_init( &process->locks );
@@ -709,7 +715,7 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
     if (!parent)
     {
         process->handles = alloc_handle_table( process, 0 );
-        process->token = token_create_admin( TRUE, -1, TokenElevationTypeFull, default_session_id );
+        process->token = token_create_admin( TRUE, -1, TokenElevationTypeLimited, default_session_id );
         process->affinity = ~0;
     }
     else
@@ -739,6 +745,9 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
     if (!token_assign_label( process->token, &high_label_sid ))
         goto error;
 
+    if (do_esync())
+        process->esync_fd = esync_create_fd( 0, 0 );
+
     set_fd_events( process->msg_fd, POLLIN );  /* start listening to events */
     return process;
 
@@ -786,6 +795,7 @@ static void process_destroy( struct object *obj )
     free( process->rawinput_devices );
     free( process->dir_cache );
     free( process->image );
+    if (do_esync()) close( process->esync_fd );
 }
 
 /* dump a process on stdout for debugging purposes */
@@ -803,6 +813,13 @@ static int process_signaled( struct object *obj, struct wait_queue_entry *entry
     return !process->running_threads;
 }
 
+static int process_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct process *process = (struct process *)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return process->esync_fd;
+}
+
 static unsigned int process_map_access( struct object *obj, unsigned int access )
 {
     access = default_map_access( obj, access );
diff --git a/server/process.h b/server/process.h
index 97e0d45..a0a071d 100644
--- a/server/process.h
+++ b/server/process.h
@@ -85,6 +85,7 @@ struct process
     const struct rawinput_device *rawinput_kbd;   /* rawinput keyboard device, if any */
     struct list          kernel_object;   /* list of kernel object pointers */
     pe_image_info_t      image_info;      /* main exe image info */
+    int                  esync_fd;        /* esync file descriptor (signaled on exit) */
 };
 
 /* process functions */
diff --git a/server/protocol.def b/server/protocol.def
index 5d60e7f..a5e0a69 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -1430,6 +1430,7 @@ enum server_fd_type
 {
     FD_TYPE_INVALID,  /* invalid file (no associated fd) */
     FD_TYPE_FILE,     /* regular file */
+    FD_TYPE_SYMLINK,  /* symbolic link */
     FD_TYPE_DIR,      /* directory */
     FD_TYPE_SOCKET,   /* socket */
     FD_TYPE_SERIAL,   /* serial port */
@@ -1850,6 +1851,18 @@ struct process_info
 /* Flush a registry key */
 @REQ(flush_key)
     obj_handle_t hkey;         /* handle to the key */
+@REPLY
+    abstime_t   timestamp_counter; /* branch last change timestamp counter */
+    data_size_t total;             /* total length needed for data */
+    int         branch_count;      /* number of registry branches to flush */
+    VARARG(data,bytes);            /* registry data */
+@END
+
+
+/* Clear KEY_DIRTY after key flush */
+@REQ(flush_key_done)
+    abstime_t    timestamp_counter; /* timestamp counter returned from flush_key */
+    int          branch;            /* saved registry branch id */
 @END
 
 
@@ -1930,11 +1943,19 @@ struct process_info
 @END
 
 
-/* Save a registry branch to a file */
+/* Return full registry branch non-volatile data for saving */
 @REQ(save_registry)
-    obj_handle_t hkey;         /* key to save */
-    obj_handle_t file;         /* file to save to */
+    obj_handle_t hkey;  /* key to save */
+@REPLY
+    data_size_t  total; /* total length needed for data */
+    VARARG(data,bytes); /* registry data */
 @END
+enum prefix_type
+{
+    PREFIX_UNKNOWN,
+    PREFIX_32BIT,
+    PREFIX_64BIT,
+};
 
 
 /* Add a registry key change notification */
@@ -2156,6 +2177,7 @@ enum message_type
     int             new_y;
 @END
 #define SEND_HWMSG_INJECTED    0x01
+#define SEND_HWMSG_RAWINPUT    0x02
 
 
 /* Get a message from the current queue */
@@ -2625,6 +2647,13 @@ enum coords_relative
 @END
 
 
+/* Set the layer region */
+@REQ(set_layer_region)
+    user_handle_t  window;        /* handle to the window */
+    VARARG(region,rectangles);    /* list of rectangles for the region (in window coords) */
+@END
+
+
 /* Get the window update region */
 @REQ(get_update_region)
     user_handle_t  window;        /* handle to the window */
@@ -3873,7 +3902,6 @@ struct handle_info
     obj_handle_t handle;       /* process handle */
 @END
 
-
 /* Iterate thread list for process */
 @REQ(get_next_thread)
     obj_handle_t process;      /* process handle */
@@ -3884,3 +3912,56 @@ struct handle_info
 @REPLY
     obj_handle_t handle;       /* next thread handle */
 @END
+
+enum esync_type
+{
+    ESYNC_SEMAPHORE = 1,
+    ESYNC_AUTO_EVENT,
+    ESYNC_MANUAL_EVENT,
+    ESYNC_MUTEX,
+    ESYNC_AUTO_SERVER,
+    ESYNC_MANUAL_SERVER,
+    ESYNC_QUEUE,
+};
+
+/* Create a new eventfd-based synchronization object */
+@REQ(create_esync)
+    unsigned int access;        /* wanted access rights */
+    int          initval;       /* initial value */
+    int          type;          /* type of esync object */
+    int          max;           /* maximum count on a semaphore */
+    VARARG(objattr,object_attributes); /* object attributes */
+@REPLY
+    obj_handle_t handle;        /* handle to the object */
+    int          type;          /* actual type (may be different for events) */
+    unsigned int shm_idx;
+@END
+
+@REQ(open_esync)
+    unsigned int access;        /* wanted access rights */
+    unsigned int attributes;    /* object attributes */
+    obj_handle_t rootdir;       /* root directory */
+    int          type;          /* type of esync object (above) */
+    VARARG(name,unicode_str);   /* object name */
+@REPLY
+    obj_handle_t handle;        /* handle to the event */
+    int          type;          /* type of esync object (above) */
+    unsigned int shm_idx;       /* this object's index into the shm section */
+@END
+
+/* Retrieve the esync fd for an object. */
+@REQ(get_esync_fd)
+    obj_handle_t handle;        /* handle to the object */
+@REPLY
+    int          type;
+    unsigned int shm_idx;
+@END
+
+/* Notify the server that we are doing a message wait or done with one. */
+@REQ(esync_msgwait)
+    int          in_msgwait;    /* are we in a message wait? */
+@END
+
+/* Retrieve the fd to wait on for user APCs. */
+@REQ(get_esync_apc_fd)
+@END
diff --git a/server/queue.c b/server/queue.c
index cd913ae..ef06841 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -42,6 +42,7 @@
 #include "process.h"
 #include "request.h"
 #include "user.h"
+#include "esync.h"
 
 #define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
 #define WM_NCMOUSELAST  (WM_NCMOUSEFIRST+(WM_MOUSELAST-WM_MOUSEFIRST))
@@ -142,6 +143,9 @@ struct msg_queue
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
     int                    keystate_lock;   /* owns an input keystate lock */
+    unsigned int           ignore_post_msg; /* ignore post messages newer than this unique id */
+    int                    esync_fd;        /* esync file descriptor (signalled on message) */
+    int                    esync_in_msgwait; /* our thread is currently waiting on us */
 };
 
 struct hotkey
@@ -158,6 +162,7 @@ static void msg_queue_dump( struct object *obj, int verbose );
 static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_remove_queue( struct object *obj, struct wait_queue_entry *entry );
 static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
@@ -173,6 +178,7 @@ static const struct object_ops msg_queue_ops =
     msg_queue_add_queue,       /* add_queue */
     msg_queue_remove_queue,    /* remove_queue */
     msg_queue_signaled,        /* signaled */
+    msg_queue_get_esync_fd,    /* get_esync_fd */
     msg_queue_satisfied,       /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -210,6 +216,7 @@ static const struct object_ops thread_input_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -310,12 +317,18 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
         queue->keystate_lock   = 0;
+        queue->ignore_post_msg = 0;
+        queue->esync_fd        = -1;
+        queue->esync_in_msgwait = 0;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
         list_init( &queue->expired_timers );
         for (i = 0; i < NB_MSG_KINDS; i++) list_init( &queue->msg_list[i] );
 
+        if (do_esync())
+            queue->esync_fd = esync_create_fd( 0, 0 );
+
         thread->queue = queue;
     }
     if (new_input) release_object( new_input );
@@ -604,6 +617,9 @@ static inline void clear_queue_bits( struct msg_queue *queue, unsigned int bits
         if (queue->keystate_lock) unlock_input_keystate( queue->input );
         queue->keystate_lock = 0;
     }
+
+    if (do_esync() && !is_signaled( queue ))
+        esync_clear( queue->esync_fd );
 }
 
 /* check if message is matched by the filter */
@@ -647,13 +663,21 @@ static inline struct msg_queue *get_current_queue(void)
 }
 
 /* get a (pseudo-)unique id to tag hardware messages */
-static inline unsigned int get_unique_id(void)
+static inline unsigned int get_unique_hw_id(void)
 {
     static unsigned int id;
     if (!++id) id = 1;  /* avoid an id of 0 */
     return id;
 }
 
+/* get unique increasing id to tag post messages */
+static inline unsigned int get_unique_post_id(void)
+{
+    static unsigned int id;
+    if (!++id) id = 1;
+    return id;
+}
+
 /* try to merge a WM_MOUSEMOVE message with the last in the list; return 1 if successful */
 static int merge_mousemove( struct thread_input *input, const struct message *msg )
 {
@@ -964,7 +988,7 @@ static int match_window( user_handle_t win, user_handle_t msg_win )
 }
 
 /* retrieve a posted message */
-static int get_posted_message( struct msg_queue *queue, user_handle_t win,
+static int get_posted_message( struct msg_queue *queue, unsigned int ignore_msg, user_handle_t win,
                                unsigned int first, unsigned int last, unsigned int flags,
                                struct get_message_reply *reply )
 {
@@ -975,6 +999,7 @@ static int get_posted_message( struct msg_queue *queue, user_handle_t win,
     {
         if (!match_window( win, msg->win )) continue;
         if (!check_msg_filter( msg->msg, first, last )) continue;
+        if (ignore_msg && (int)(msg->unique_id - ignore_msg) >= 0) continue;
         goto found; /* found one */
     }
     return 0;
@@ -1082,6 +1107,10 @@ static int is_queue_hung( struct msg_queue *queue )
         if (get_wait_queue_thread(entry)->queue == queue)
             return 0;  /* thread is waiting on queue -> not hung */
     }
+
+    if (do_esync() && queue->esync_in_msgwait)
+        return 0;   /* thread is waiting on queue in absentia -> not hung */
+
     return 1;
 }
 
@@ -1137,6 +1166,13 @@ static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entr
     return ret || is_signaled( queue );
 }
 
+static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+    *type = ESYNC_QUEUE;
+    return queue->esync_fd;
+}
+
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct msg_queue *queue = (struct msg_queue *)obj;
@@ -1181,6 +1217,7 @@ static void msg_queue_destroy( struct object *obj )
     release_object( queue->input );
     if (queue->hooks) release_object( queue->hooks );
     if (queue->fd) release_object( queue->fd );
+    if (do_esync()) close( queue->esync_fd );
 }
 
 static void msg_queue_poll_event( struct fd *fd, int event )
@@ -1589,6 +1626,7 @@ found:
     msg->msg       = WM_HOTKEY;
     msg->wparam    = hotkey->id;
     msg->lparam    = ((hotkey->vkey & 0xffff) << 16) | modifiers;
+    msg->unique_id = get_unique_post_id();
 
     free( msg->data );
     msg->data      = NULL;
@@ -1859,7 +1897,7 @@ done:
 
 /* queue a hardware message for a mouse event */
 static int queue_mouse_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
-                                unsigned int origin, struct msg_queue *sender )
+                                unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
 {
     const struct rawinput_device *device;
     struct hardware_msg_data *msg_data;
@@ -1914,7 +1952,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         y = desktop->cursor.y;
     }
 
-    if ((foreground = get_foreground_thread( desktop, win )))
+    if ((req_flags & SEND_HWMSG_RAWINPUT) && (foreground = get_foreground_thread( desktop, win )))
     {
         memset( &raw_msg, 0, sizeof(raw_msg) );
         raw_msg.foreground = foreground;
@@ -1928,8 +1966,8 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
         msg_data->size                = sizeof(*msg_data);
         msg_data->flags               = flags;
         msg_data->rawinput.type       = RIM_TYPEMOUSE;
-        msg_data->rawinput.mouse.x    = x - desktop->cursor.x;
-        msg_data->rawinput.mouse.y    = y - desktop->cursor.y;
+        msg_data->rawinput.mouse.x    = (flags & MOUSEEVENTF_MOVE) ? input->mouse.x : 0;
+        msg_data->rawinput.mouse.y    = (flags & MOUSEEVENTF_MOVE) ? input->mouse.y : 0;
         msg_data->rawinput.mouse.data = input->mouse.data;
 
         enum_processes( queue_rawinput_message, &raw_msg );
@@ -1974,7 +2012,7 @@ static int queue_mouse_message( struct desktop *desktop, user_handle_t win, cons
 
 /* queue a hardware message for a keyboard event */
 static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, const hw_input_t *input,
-                                   unsigned int origin, struct msg_queue *sender )
+                                   unsigned int origin, struct msg_queue *sender, unsigned int req_flags )
 {
     struct hw_msg_source source = { IMDT_KEYBOARD, origin };
     const struct rawinput_device *device;
@@ -2052,7 +2090,7 @@ static int queue_keyboard_message( struct desktop *desktop, user_handle_t win, c
         break;
     }
 
-    if ((foreground = get_foreground_thread( desktop, win )))
+    if ((req_flags & SEND_HWMSG_RAWINPUT) && (foreground = get_foreground_thread( desktop, win )))
     {
         memset( &raw_msg, 0, sizeof(raw_msg) );
         raw_msg.foreground = foreground;
@@ -2146,6 +2184,9 @@ static void queue_custom_hardware_message( struct desktop *desktop, user_handle_
         msg_data->size     = sizeof(*msg_data) + report_size;
         msg_data->rawinput = input->hw.rawinput;
 
+        if (input->hw.msg == WM_INPUT && input->hw.rawinput.type == RIM_TYPEMOUSE)
+            msg_data->flags = input->hw.lparam;
+
         enum_processes( queue_rawinput_message, &raw_msg );
         return;
     }
@@ -2286,7 +2327,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
         }
 
         /* now we can return it */
-        if (!msg->unique_id) msg->unique_id = get_unique_id();
+        if (!msg->unique_id) msg->unique_id = get_unique_hw_id();
         reply->type   = MSG_HARDWARE;
         reply->win    = win;
         reply->msg    = msg_code;
@@ -2393,6 +2434,7 @@ void post_message( user_handle_t win, unsigned int message, lparam_t wparam, lpa
         msg->result    = NULL;
         msg->data      = NULL;
         msg->data_size = 0;
+        msg->unique_id = get_unique_post_id();
 
         get_message_defaults( thread->queue, &msg->x, &msg->y, &msg->time );
 
@@ -2559,6 +2601,9 @@ DECL_HANDLER(set_queue_mask)
             if (req->skip_wait) queue->wake_mask = queue->changed_mask = 0;
             else wake_up( &queue->obj, 0 );
         }
+
+        if (do_esync() && !is_signaled( queue ))
+            esync_clear( queue->esync_fd );
     }
 }
 
@@ -2572,6 +2617,9 @@ DECL_HANDLER(get_queue_status)
         reply->wake_bits    = queue->wake_bits;
         reply->changed_bits = queue->changed_bits;
         queue->changed_bits &= ~req->clear_bits;
+
+        if (do_esync() && !is_signaled( queue ))
+            esync_clear( queue->esync_fd );
     }
     else reply->wake_bits = reply->changed_bits = 0;
 }
@@ -2637,6 +2685,7 @@ DECL_HANDLER(send_message)
             set_queue_bits( recv_queue, QS_SENDMESSAGE );
             break;
         case MSG_POSTED:
+            msg->unique_id = get_unique_post_id();
             list_add_tail( &recv_queue->msg_list[POST_MESSAGE], &msg->entry );
             set_queue_bits( recv_queue, QS_POSTMESSAGE|QS_ALLPOSTMESSAGE );
             if (msg->msg == WM_HOTKEY)
@@ -2684,10 +2733,10 @@ DECL_HANDLER(send_hardware_message)
     switch (req->input.type)
     {
     case INPUT_MOUSE:
-        reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender );
+        reply->wait = queue_mouse_message( desktop, req->win, &req->input, origin, sender, req->flags );
         break;
     case INPUT_KEYBOARD:
-        reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender );
+        reply->wait = queue_keyboard_message( desktop, req->win, &req->input, origin, sender, req->flags );
         break;
     case INPUT_HARDWARE:
         queue_custom_hardware_message( desktop, req->win, origin, &req->input );
@@ -2755,12 +2804,12 @@ DECL_HANDLER(get_message)
 
     /* then check for posted messages */
     if ((filter & QS_POSTMESSAGE) &&
-        get_posted_message( queue, get_win, req->get_first, req->get_last, req->flags, reply ))
+        get_posted_message( queue, queue->ignore_post_msg, get_win, req->get_first, req->get_last, req->flags, reply ))
         return;
 
     if ((filter & QS_HOTKEY) && queue->hotkey_count &&
         req->get_first <= WM_HOTKEY && req->get_last >= WM_HOTKEY &&
-        get_posted_message( queue, get_win, WM_HOTKEY, WM_HOTKEY, req->flags, reply ))
+        get_posted_message( queue, queue->ignore_post_msg, get_win, WM_HOTKEY, WM_HOTKEY, req->flags, reply ))
         return;
 
     /* only check for quit messages if not posted messages pending */
@@ -2771,7 +2820,7 @@ DECL_HANDLER(get_message)
     if ((filter & QS_INPUT) &&
         filter_contains_hw_range( req->get_first, req->get_last ) &&
         get_hardware_message( current, req->hw_id, get_win, req->get_first, req->get_last, req->flags, reply ))
-        return;
+        goto found_msg;
 
     /* check for any internal driver message */
     if (get_hardware_message( current, req->hw_id, get_win, WM_WINE_FIRST_DRIVER_MSG,
@@ -2789,7 +2838,7 @@ DECL_HANDLER(get_message)
         reply->wparam = 0;
         reply->lparam = 0;
         get_message_defaults( queue, &reply->x, &reply->y, &reply->time );
-        return;
+        goto found_msg;
     }
 
     /* now check for timer */
@@ -2805,13 +2854,34 @@ DECL_HANDLER(get_message)
         get_message_defaults( queue, &reply->x, &reply->y, &reply->time );
         if (!(req->flags & PM_NOYIELD) && current->process->idle_event)
             set_event( current->process->idle_event );
-        return;
+        goto found_msg;
     }
 
+    /* if we previously skipped posted messages then check again */
+    if (queue->ignore_post_msg && (filter & QS_POSTMESSAGE) &&
+        get_posted_message( queue, 0, get_win, req->get_first, req->get_last, req->flags, reply ))
+        return;
+
+    if (queue->ignore_post_msg && (filter & QS_HOTKEY) && queue->hotkey_count &&
+        req->get_first <= WM_HOTKEY && req->get_last >= WM_HOTKEY &&
+        get_posted_message( queue, 0, get_win, WM_HOTKEY, WM_HOTKEY, req->flags, reply ))
+        return;
+
     if (get_win == -1 && current->process->idle_event) set_event( current->process->idle_event );
     queue->wake_mask = req->wake_mask;
     queue->changed_mask = req->changed_mask;
     set_error( STATUS_PENDING );  /* FIXME */
+
+    if (do_esync() && !is_signaled( queue ))
+        esync_clear( queue->esync_fd );
+
+    return;
+
+found_msg:
+    if (req->flags & PM_REMOVE)
+        queue->ignore_post_msg = 0;
+    else if (!queue->ignore_post_msg)
+        queue->ignore_post_msg = get_unique_post_id();
 }
 
 
@@ -2829,7 +2899,10 @@ DECL_HANDLER(reply_message)
 DECL_HANDLER(accept_hardware_message)
 {
     if (current->queue)
+    {
         release_hardware_message( current->queue, req->hw_id );
+        current->queue->ignore_post_msg = 0;
+    }
     else
         set_error( STATUS_ACCESS_DENIED );
 }
@@ -3508,3 +3581,18 @@ DECL_HANDLER(update_rawinput_devices)
     process->rawinput_mouse = find_rawinput_device( process, 1, 2 );
     process->rawinput_kbd = find_rawinput_device( process, 1, 6 );
 }
+
+DECL_HANDLER(esync_msgwait)
+{
+    struct msg_queue *queue = get_current_queue();
+
+    if (!queue) return;
+    queue->esync_in_msgwait = req->in_msgwait;
+
+    if (current->process->idle_event && !(queue->wake_mask & QS_SMRESULT))
+        set_event( current->process->idle_event );
+
+    /* and start/stop waiting on the driver */
+    if (queue->fd)
+        set_fd_events( queue->fd, req->in_msgwait ? POLLIN : 0 );
+}
diff --git a/server/registry.c b/server/registry.c
index da6a6d0..4fb4e85 100644
--- a/server/registry.c
+++ b/server/registry.c
@@ -90,6 +90,7 @@ struct key
     unsigned int      flags;       /* flags */
     timeout_t         modif;       /* last modification time */
     struct list       notify_list; /* list of notifications */
+    abstime_t         timestamp_counter; /* timestamp counter at last change */
 };
 
 /* key flags */
@@ -118,19 +119,18 @@ struct key_value
 #define MAX_NAME_LEN  256    /* max. length of a key name */
 #define MAX_VALUE_LEN 16383  /* max. length of a value name */
 
+static abstime_t change_timestamp_counter;
+
 /* the root of the registry tree */
 static struct key *root_key;
 
 static const timeout_t ticks_1601_to_1970 = (timeout_t)86400 * (369 * 365 + 89) * TICKS_PER_SEC;
-static const timeout_t save_period = 30 * -TICKS_PER_SEC;  /* delay between periodic saves */
-static struct timeout_user *save_timeout_user;  /* saving timer */
-static enum prefix_type { PREFIX_UNKNOWN, PREFIX_32BIT, PREFIX_64BIT } prefix_type;
+static enum prefix_type prefix_type;
 
 static const WCHAR wow6432node[] = {'W','o','w','6','4','3','2','N','o','d','e'};
 static const WCHAR symlink_value[] = {'S','y','m','b','o','l','i','c','L','i','n','k','V','a','l','u','e'};
 static const struct unicode_str symlink_str = { symlink_value, sizeof(symlink_value) };
 
-static void set_periodic_save_timer(void);
 static struct key_value *find_value( const struct key *key, const struct unicode_str *name, int *index );
 
 /* information about where to save a registry branch */
@@ -180,6 +180,7 @@ static const struct object_ops key_ops =
     no_add_queue,            /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
+    NULL,                    /* get_esync_fd */
     NULL,                    /* satisfied */
     no_signal,               /* signal */
     no_get_fd,               /* get_fd */
@@ -708,6 +709,7 @@ static struct key *create_key_object( struct object *parent, const struct unicod
             key->last_value  = -1;
             key->values      = NULL;
             key->modif       = modif;
+            key->timestamp_counter = 0;
             list_init( &key->notify_list );
 
             if (options & REG_OPTION_CREATE_LINK) key->flags |= KEY_SYMLINK;
@@ -728,23 +730,25 @@ static struct key *create_key_object( struct object *parent, const struct unicod
 /* mark a key and all its parents as dirty (modified) */
 static void make_dirty( struct key *key )
 {
+    ++change_timestamp_counter;
     while (key)
     {
         if (key->flags & (KEY_DIRTY|KEY_VOLATILE)) return;  /* nothing to do */
         key->flags |= KEY_DIRTY;
+        key->timestamp_counter = change_timestamp_counter;
         key = get_parent( key );
     }
 }
 
 /* mark a key and all its subkeys as clean (not modified) */
-static void make_clean( struct key *key )
+static void make_clean( struct key *key, abstime_t timestamp_counter )
 {
     int i;
 
     if (key->flags & KEY_VOLATILE) return;
     if (!(key->flags & KEY_DIRTY)) return;
-    key->flags &= ~KEY_DIRTY;
-    for (i = 0; i <= key->last_subkey; i++) make_clean( key->subkeys[i] );
+    if (key->timestamp_counter <= timestamp_counter) key->flags &= ~KEY_DIRTY;
+    for (i = 0; i <= key->last_subkey; i++) make_clean( key->subkeys[i], timestamp_counter );
 }
 
 /* go through all the notifications and send them if necessary */
@@ -1976,9 +1980,6 @@ void init_registry(void)
     release_object( hklm );
     release_object( hkcu );
 
-    /* start the periodic save timer */
-    set_periodic_save_timer();
-
     /* create windows directories */
 
     if (!mkdir( "drive_c/windows", 0777 ))
@@ -2001,6 +2002,7 @@ void init_registry(void)
 /* save a registry branch to a file */
 static void save_all_subkeys( struct key *key, FILE *f )
 {
+    /* Registry format in ntdll/registry.c:save_all_subkeys() should match. */
     fprintf( f, "WINE REGISTRY Version 2\n" );
     fprintf( f, ";; All keys relative to " );
     dump_path( key, NULL, f );
@@ -2019,29 +2021,104 @@ static void save_all_subkeys( struct key *key, FILE *f )
     save_subkeys( key, key, f );
 }
 
-/* save a registry branch to a file handle */
-static void save_registry( struct key *key, obj_handle_t handle )
+static data_size_t serialize_value( const struct key_value *value, char *buf )
 {
-    struct file *file;
-    int fd;
+    data_size_t size;
 
-    if (!(file = get_file_obj( current->process, handle, FILE_WRITE_DATA ))) return;
-    fd = dup( get_file_unix_fd( file ) );
-    release_object( file );
-    if (fd != -1)
+    size = sizeof(data_size_t) + value->namelen + sizeof(unsigned int) + sizeof(data_size_t) + value->len;
+    if (!buf) return size;
+
+    *(data_size_t *)buf = value->namelen;
+    buf += sizeof(data_size_t);
+    memcpy( buf, value->name, value->namelen );
+    buf += value->namelen;
+
+    *(unsigned int *)buf = value->type;
+    buf += sizeof(unsigned int);
+
+    *(data_size_t *)buf = value->len;
+    buf += sizeof(data_size_t);
+    memcpy( buf, value->data, value->len );
+
+    return size;
+}
+
+/* save a registry key with subkeys to a buffer */
+static data_size_t serialize_key( const struct key *key, char *buf )
+{
+    data_size_t size;
+    int subkey_count, i;
+
+    if (key->flags & KEY_VOLATILE) return 0;
+
+    size = sizeof(data_size_t) + key->obj.name->len + sizeof(data_size_t) + key->classlen + sizeof(int) + sizeof(int)
+           + sizeof(unsigned int) + sizeof(timeout_t);
+    for (i = 0; i <= key->last_value; i++)
+        size += serialize_value( &key->values[i], buf ? buf + size : NULL );
+    subkey_count = 0;
+    for (i = 0; i <= key->last_subkey; i++)
     {
-        FILE *f = fdopen( fd, "w" );
-        if (f)
-        {
-            save_all_subkeys( key, f );
-            if (fclose( f )) file_set_error();
-        }
-        else
-        {
-            file_set_error();
-            close( fd );
-        }
+        if (key->subkeys[i]->flags & KEY_VOLATILE) continue;
+        size += serialize_key( key->subkeys[i], buf ? buf + size : NULL );
+        ++subkey_count;
+    }
+    if (!buf) return size;
+
+    *(data_size_t *)buf = key->obj.name->len;
+    buf += sizeof(data_size_t);
+    memcpy( buf, key->obj.name->name, key->obj.name->len );
+    buf += key->obj.name->len;
+
+    *(data_size_t *)buf = key->classlen;
+    buf += sizeof(data_size_t);
+    memcpy( buf, key->class, key->classlen );
+    buf += key->classlen;
+
+    *(int *)buf = key->last_value + 1;
+    buf += sizeof(int);
+
+    *(int *)buf = subkey_count;
+    buf += sizeof(int);
+
+    *(unsigned int *)buf = key->flags & KEY_SYMLINK;
+    buf += sizeof(unsigned int);
+
+    *(timeout_t *)buf = key->modif;
+
+    return size;
+}
+
+/* save registry branch to buffer */
+static data_size_t save_registry( const struct key *key, char *buf )
+{
+    int *parent_count = NULL;
+    const struct key *parent;
+    data_size_t size;
+
+    size = sizeof(int) + sizeof(int);
+    if (buf)
+    {
+        *(int *)buf = prefix_type;
+        buf += sizeof(int);
+        parent_count = (int *)buf;
+        buf += sizeof(int);
+        *parent_count = 0;
     }
+
+    parent = key;
+    do
+    {
+        size += sizeof(data_size_t) + parent->obj.name->len;
+        if (!buf) continue;
+        ++*parent_count;
+        *(data_size_t *)buf = parent->obj.name->len;
+        buf += sizeof(data_size_t);
+        memcpy( buf, parent->obj.name->name, parent->obj.name->len );
+        buf += parent->obj.name->len;
+    } while ((parent = get_parent( parent )));
+
+    size += serialize_key( key, buf );
+    return size;
 }
 
 /* save a registry branch to a file */
@@ -2114,30 +2191,10 @@ static int save_branch( struct key *key, const char *path )
 
 done:
     free( tmp );
-    if (ret) make_clean( key );
+    if (ret) make_clean( key, key->timestamp_counter );
     return ret;
 }
 
-/* periodic saving of the registry */
-static void periodic_save( void *arg )
-{
-    int i;
-
-    if (fchdir( config_dir_fd ) == -1) return;
-    save_timeout_user = NULL;
-    for (i = 0; i < save_branch_count; i++)
-        save_branch( save_branch_info[i].key, save_branch_info[i].path );
-    if (fchdir( server_dir_fd ) == -1) fatal_error( "chdir to server dir: %s\n", strerror( errno ));
-    set_periodic_save_timer();
-}
-
-/* start the periodic save timer */
-static void set_periodic_save_timer(void)
-{
-    if (save_timeout_user) remove_timeout_user( save_timeout_user );
-    save_timeout_user = add_timeout_user( save_period, periodic_save, NULL );
-}
-
 /* save the modified registry branches to disk */
 void flush_registry(void)
 {
@@ -2162,6 +2219,36 @@ static int is_wow64_thread( struct thread *thread )
     return (is_machine_64bit( native_machine ) && !is_machine_64bit( thread->process->machine ));
 }
 
+/* find all the branches inside the specified key or the branch containing the key */
+static void find_branches_for_key( struct key *key, int *branches, int *branch_count )
+{
+    struct key *k;
+    int i;
+
+    *branch_count = 0;
+    for (i = 0; i < save_branch_count; i++)
+    {
+        k = save_branch_info[i].key;
+        while ((k = get_parent(k)))
+        {
+            if (k != key) continue;
+            branches[(*branch_count)++] = i;
+            break;
+        }
+    }
+
+    if (*branch_count) return;
+
+    do
+    {
+        for (i = 0; i < save_branch_count; i++)
+        {
+            if(key != save_branch_info[i].key) continue;
+            branches[(*branch_count)++] = i;
+            return;
+        }
+    } while ((key = get_parent( key )));
+}
 
 /* create a registry key */
 DECL_HANDLER(create_key)
@@ -2226,17 +2313,58 @@ DECL_HANDLER(delete_key)
     }
 }
 
-/* flush a registry key */
+/* return registry branches snaphot data for flushing key */
 DECL_HANDLER(flush_key)
 {
     struct key *key = get_hkey_obj( req->hkey, 0 );
-    if (key)
+    int branches[3], branch_count = 0, i, path_len;
+    char *data;
+
+    if (!key) return;
+
+    reply->total = 0;
+    reply->branch_count = 0;
+    if ((key->flags & KEY_DIRTY) && !(key->flags & KEY_VOLATILE))
+        find_branches_for_key( key, branches, &branch_count );
+    release_object( key );
+
+    reply->timestamp_counter = change_timestamp_counter;
+    for (i = 0; i < branch_count; ++i)
     {
-        /* we don't need to do anything here with the current implementation */
-        release_object( key );
+        if (!(save_branch_info[branches[i]].key->flags & KEY_DIRTY)) continue;
+        ++reply->branch_count;
+        path_len = strlen( save_branch_info[branches[i]].path ) + 1;
+        reply->total += sizeof(int) + sizeof(int) + path_len + save_registry( save_branch_info[branches[i]].key, NULL );
+    }
+    if (reply->total > get_reply_max_size())
+    {
+        set_error( STATUS_BUFFER_TOO_SMALL );
+        return;
+    }
+
+    if (!(data = set_reply_data_size( reply->total ))) return;
+
+    for (i = 0; i < branch_count; ++i)
+    {
+        if (!(save_branch_info[branches[i]].key->flags & KEY_DIRTY)) continue;
+        *(int *)data = branches[i];
+        data += sizeof(int);
+        path_len = strlen( save_branch_info[branches[i]].path ) + 1;
+        *(int *)data = path_len;
+        data += sizeof(int);
+        memcpy( data, save_branch_info[branches[i]].path, path_len );
+        data += path_len;
+        data += save_registry( save_branch_info[branches[i]].key, data );
     }
 }
 
+/* clear dirty state after successful registry branch flush */
+DECL_HANDLER(flush_key_done)
+{
+    if (req->branch < save_branch_count) make_clean( save_branch_info[req->branch].key, req->timestamp_counter );
+    else set_error( STATUS_INVALID_PARAMETER );
+}
+
 /* enumerate registry subkeys */
 DECL_HANDLER(enum_key)
 {
@@ -2370,6 +2498,7 @@ DECL_HANDLER(unload_registry)
 DECL_HANDLER(save_registry)
 {
     struct key *key;
+    char *data;
 
     if (!thread_single_check_privilege( current, SeBackupPrivilege ))
     {
@@ -2379,7 +2508,13 @@ DECL_HANDLER(save_registry)
 
     if ((key = get_hkey_obj( req->hkey, 0 )))
     {
-        save_registry( key, req->file );
+        reply->total = save_registry( key, NULL );
+        if (reply->total <= get_reply_max_size())
+        {
+            if ((data = set_reply_data_size( reply->total )))
+                save_registry( key, data );
+        }
+        else set_error( STATUS_BUFFER_TOO_SMALL );
         release_object( key );
     }
 }
diff --git a/server/request.c b/server/request.c
index 7021741..ca83fdb 100644
--- a/server/request.c
+++ b/server/request.c
@@ -90,6 +90,7 @@ static const struct object_ops master_socket_ops =
     no_add_queue,                  /* add_queue */
     NULL,                          /* remove_queue */
     NULL,                          /* signaled */
+    NULL,                          /* get_esync_fd */
     NULL,                          /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/semaphore.c b/server/semaphore.c
index 53b42a8..e3889f2 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -70,6 +70,7 @@ static const struct object_ops semaphore_ops =
     add_queue,                     /* add_queue */
     remove_queue,                  /* remove_queue */
     semaphore_signaled,            /* signaled */
+    NULL,                          /* get_esync_fd */
     semaphore_satisfied,           /* satisfied */
     semaphore_signal,              /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/serial.c b/server/serial.c
index d665eb7..11e204e 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -85,6 +85,7 @@ static const struct object_ops serial_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     serial_get_fd,                /* get_fd */
diff --git a/server/signal.c b/server/signal.c
index 19b76d4..55cd6aa 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -62,6 +62,7 @@ static const struct object_ops handler_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
diff --git a/server/sock.c b/server/sock.c
index c34fd3e..db990ea 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -453,6 +453,7 @@ static const struct object_ops sock_ops =
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
+    NULL,                         /* get_esync_fd */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     sock_get_fd,                  /* get_fd */
@@ -3554,6 +3555,7 @@ static const struct object_ops ifchange_ops =
     no_add_queue,            /* add_queue */
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
+    NULL,                    /* get_esync_fd */
     no_satisfied,            /* satisfied */
     no_signal,               /* signal */
     ifchange_get_fd,         /* get_fd */
@@ -3775,6 +3777,7 @@ static const struct object_ops socket_device_ops =
     no_add_queue,               /* add_queue */
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
diff --git a/server/symlink.c b/server/symlink.c
index dd28efd..c7f3441 100644
--- a/server/symlink.c
+++ b/server/symlink.c
@@ -71,6 +71,7 @@ static const struct object_ops symlink_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/thread.c b/server/thread.c
index 56f57ce..2ce94b4 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -50,6 +50,7 @@
 #include "request.h"
 #include "user.h"
 #include "security.h"
+#include "esync.h"
 
 
 /* thread queues */
@@ -96,6 +97,7 @@ static const struct object_ops thread_apc_ops =
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     thread_apc_signaled,        /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -138,6 +140,7 @@ static const struct object_ops context_ops =
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     context_signaled,           /* signaled */
+    NULL,                       /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -174,6 +177,7 @@ struct type_descr thread_type =
 
 static void dump_thread( struct object *obj, int verbose );
 static int thread_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int thread_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static struct list *thread_get_kernel_obj_list( struct object *obj );
@@ -187,6 +191,7 @@ static const struct object_ops thread_ops =
     add_queue,                  /* add_queue */
     remove_queue,               /* remove_queue */
     thread_signaled,            /* signaled */
+    thread_get_esync_fd,        /* get_esync_fd */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -226,6 +231,8 @@ static inline void init_thread_structure( struct thread *thread )
     thread->context         = NULL;
     thread->teb             = 0;
     thread->entry_point     = 0;
+    thread->esync_fd        = -1;
+    thread->esync_apc_fd    = -1;
     thread->system_regs     = 0;
     thread->queue           = NULL;
     thread->wait            = NULL;
@@ -246,6 +253,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->token           = NULL;
     thread->desc            = NULL;
     thread->desc_len        = 0;
+    thread->exit_poll       = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -372,6 +380,12 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
         }
     }
 
+    if (do_esync())
+    {
+        thread->esync_fd = esync_create_fd( 0, 0 );
+        thread->esync_apc_fd = esync_create_fd( 0, 0 );
+    }
+
     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
     add_process_thread( thread->process, thread );
     return thread;
@@ -448,8 +462,12 @@ static void destroy_thread( struct object *obj )
     list_remove( &thread->entry );
     cleanup_thread( thread );
     release_object( thread->process );
+    if (thread->exit_poll) remove_timeout_user( thread->exit_poll );
     if (thread->id) free_ptid( thread->id );
     if (thread->token) release_object( thread->token );
+
+    if (do_esync())
+        close( thread->esync_fd );
 }
 
 /* dump a thread on stdout for debugging purposes */
@@ -465,7 +483,14 @@ static void dump_thread( struct object *obj, int verbose )
 static int thread_signaled( struct object *obj, struct wait_queue_entry *entry )
 {
     struct thread *mythread = (struct thread *)obj;
-    return (mythread->state == TERMINATED);
+    return mythread->state == TERMINATED && !mythread->exit_poll;
+}
+
+static int thread_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct thread *thread = (struct thread *)obj;
+    *type = ESYNC_MANUAL_SERVER;
+    return thread->esync_fd;
 }
 
 static unsigned int thread_map_access( struct object *obj, unsigned int access )
@@ -622,7 +647,10 @@ static void set_thread_info( struct thread *thread,
         if ((req->priority >= min && req->priority <= max) ||
             req->priority == THREAD_PRIORITY_IDLE ||
             req->priority == THREAD_PRIORITY_TIME_CRITICAL)
+        {
             thread->priority = req->priority;
+            set_scheduler_priority( thread );
+        }
         else
             set_error( STATUS_INVALID_PARAMETER );
     }
@@ -1059,6 +1087,9 @@ void wake_up( struct object *obj, int max )
     struct list *ptr;
     int ret;
 
+    if (do_esync())
+        esync_wake_up( obj );
+
     LIST_FOR_EACH( ptr, &obj->wait_queue )
     {
         struct wait_queue_entry *entry = LIST_ENTRY( ptr, struct wait_queue_entry, entry );
@@ -1143,8 +1174,13 @@ static int queue_apc( struct process *process, struct thread *thread, struct thr
     grab_object( apc );
     list_add_tail( queue, &apc->entry );
     if (!list_prev( queue, &apc->entry ))  /* first one */
+    {
         wake_thread( thread );
 
+        if (do_esync() && queue == &thread->user_apc)
+            esync_wake_fd( thread->esync_apc_fd );
+    }
+
     return 1;
 }
 
@@ -1190,6 +1226,10 @@ static struct thread_apc *thread_dequeue_apc( struct thread *thread, int system
         apc = LIST_ENTRY( ptr, struct thread_apc, entry );
         list_remove( ptr );
     }
+
+    if (do_esync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
+        esync_clear( thread->esync_apc_fd );
+
     return apc;
 }
 
@@ -1266,6 +1306,26 @@ int thread_get_inflight_fd( struct thread *thread, int client )
     return -1;
 }
 
+static void check_terminated( void *arg )
+{
+    struct thread *thread = arg;
+    assert( thread->obj.ops == &thread_ops );
+    assert( thread->state == TERMINATED );
+
+    /* don't wake up until the thread is really dead, to avoid race conditions */
+    if (thread->unix_tid != -1 && !kill( thread->unix_tid, 0 ))
+    {
+        thread->exit_poll = add_timeout_user( -TICKS_PER_SEC / 1000, check_terminated, thread );
+        return;
+    }
+
+    /* grab reference since object can be destroyed while trying to wake up */
+    grab_object( &thread->obj );
+    thread->exit_poll = NULL;
+    wake_up( &thread->obj, 0 );
+    release_object( &thread->obj );
+}
+
 /* kill a thread on the spot */
 void kill_thread( struct thread *thread, int violent_death )
 {
@@ -1285,8 +1345,14 @@ void kill_thread( struct thread *thread, int violent_death )
     }
     kill_console_processes( thread, 0 );
     abandon_mutexes( thread );
-    wake_up( &thread->obj, 0 );
-    if (violent_death) send_thread_signal( thread, SIGQUIT );
+    if (do_esync())
+        esync_abandon_mutexes( thread );
+    if (violent_death)
+    {
+        send_thread_signal( thread, SIGQUIT );
+        check_terminated( thread );
+    }
+    else wake_up( &thread->obj, 0 );
     cleanup_thread( thread );
     remove_process_thread( thread->process, thread );
     release_object( thread );
diff --git a/server/thread.h b/server/thread.h
index 8dcf966..e5145f9 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -54,6 +54,8 @@ struct thread
     struct process        *process;
     thread_id_t            id;            /* thread id */
     struct list            mutex_list;    /* list of currently owned mutexes */
+    int                    esync_fd;      /* esync file descriptor (signalled on exit) */
+    int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
     unsigned int           system_regs;   /* which system regs have been set */
     struct msg_queue      *queue;         /* message queue */
     struct thread_wait    *wait;          /* current wait condition if sleeping */
@@ -90,6 +92,7 @@ struct thread
     struct list            kernel_object; /* list of kernel object pointers */
     data_size_t            desc_len;      /* thread description length in bytes */
     WCHAR                 *desc;          /* thread description string */
+    struct timeout_user   *exit_poll;     /* poll if the thread/process has exited already */
 };
 
 extern struct thread *current;
@@ -142,4 +145,9 @@ static inline void set_win32_error( unsigned int err ) { set_error( 0xc0010000 |
 
 static inline thread_id_t get_thread_id( struct thread *thread ) { return thread->id; }
 
+/* scheduler functions */
+
+extern void init_scheduler( void );
+extern void set_scheduler_priority( struct thread *thread );
+
 #endif  /* __WINE_SERVER_THREAD_H */
diff --git a/server/timer.c b/server/timer.c
index 96dc9d0..36645a2 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -35,6 +35,7 @@
 #include "file.h"
 #include "handle.h"
 #include "request.h"
+#include "esync.h"
 
 static const WCHAR timer_name[] = {'T','i','m','e','r'};
 
@@ -61,10 +62,12 @@ struct timer
     struct thread       *thread;    /* thread that set the APC function */
     client_ptr_t         callback;  /* callback APC function */
     client_ptr_t         arg;       /* callback argument */
+    int                  esync_fd;  /* esync file descriptor */
 };
 
 static void timer_dump( struct object *obj, int verbose );
 static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
+static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void timer_destroy( struct object *obj );
 
@@ -76,6 +79,7 @@ static const struct object_ops timer_ops =
     add_queue,                 /* add_queue */
     remove_queue,              /* remove_queue */
     timer_signaled,            /* signaled */
+    timer_get_esync_fd,        /* get_esync_fd */
     timer_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -110,6 +114,10 @@ static struct timer *create_timer( struct object *root, const struct unicode_str
             timer->period   = 0;
             timer->timeout  = NULL;
             timer->thread   = NULL;
+            timer->esync_fd = -1;
+
+            if (do_esync())
+                timer->esync_fd = esync_create_fd( 0, 0 );
         }
     }
     return timer;
@@ -181,6 +189,9 @@ static int set_timer( struct timer *timer, timeout_t expire, unsigned int period
     {
         period = 0;  /* period doesn't make any sense for a manual timer */
         timer->signaled = 0;
+
+        if (do_esync())
+            esync_clear( timer->esync_fd );
     }
     timer->when     = (expire <= 0) ? expire - monotonic_time : max( expire, current_time );
     timer->period   = period;
@@ -208,6 +219,13 @@ static int timer_signaled( struct object *obj, struct wait_queue_entry *entry )
     return timer->signaled;
 }
 
+static int timer_get_esync_fd( struct object *obj, enum esync_type *type )
+{
+    struct timer *timer = (struct timer *)obj;
+    *type = timer->manual ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
+    return timer->esync_fd;
+}
+
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct timer *timer = (struct timer *)obj;
@@ -222,6 +240,7 @@ static void timer_destroy( struct object *obj )
 
     if (timer->timeout) remove_timeout_user( timer->timeout );
     if (timer->thread) release_object( timer->thread );
+    if (do_esync()) close( timer->esync_fd );
 }
 
 /* create a timer */
diff --git a/server/token.c b/server/token.c
index 4df8d2e..8b4d2f0 100644
--- a/server/token.c
+++ b/server/token.c
@@ -143,6 +143,7 @@ static const struct object_ops token_ops =
     no_add_queue,              /* add_queue */
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/window.c b/server/window.c
index 242e93f..feac54e 100644
--- a/server/window.c
+++ b/server/window.c
@@ -71,6 +71,7 @@ struct window
     rectangle_t      surface_rect;    /* window surface rectangle (relative to parent client area) */
     rectangle_t      client_rect;     /* client rectangle (relative to parent client area) */
     struct region   *win_region;      /* region for shaped windows (relative to window rect) */
+    struct region   *layer_region;    /* region for layered windows (relative to window rect) */
     struct region   *update_region;   /* update region (relative to window rect) */
     unsigned int     style;           /* window style */
     unsigned int     ex_style;        /* window extended style */
@@ -107,6 +108,7 @@ static const struct object_ops window_ops =
     no_add_queue,             /* add_queue */
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
+    NULL,                     /* get_esync_fd */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -564,6 +566,7 @@ static struct window *create_window( struct window *parent, struct window *owner
     win->atom           = atom;
     win->last_active    = win->handle;
     win->win_region     = NULL;
+    win->layer_region   = NULL;
     win->update_region  = NULL;
     win->style          = 0;
     win->ex_style       = 0;
@@ -822,6 +825,9 @@ static int is_point_in_window( struct window *win, int *x, int *y, unsigned int
     if (win->win_region &&
         !point_in_region( win->win_region, *x - win->window_rect.left, *y - win->window_rect.top ))
         return 0;  /* not in window region */
+    if (win->layer_region &&
+        !point_in_region( win->layer_region, *x - win->window_rect.left, *y - win->window_rect.top ))
+        return 0;  /* not in layer mask region */
     return 1;
 }
 
@@ -1979,6 +1985,14 @@ static void set_window_region( struct window *win, struct region *region, int re
 }
 
 
+/* set the layer region */
+static void set_layer_region( struct window *win, struct region *region )
+{
+    if (win->layer_region) free_region( win->layer_region );
+    win->layer_region = region;
+}
+
+
 /* destroy a window */
 void free_window_handle( struct window *win )
 {
@@ -2042,6 +2056,7 @@ void free_window_handle( struct window *win )
     detach_window_thread( win );
 
     if (win->parent) set_parent_window( win, NULL );
+    if (win->layer_region) free_region( win->layer_region );
     free_user_handle( win->handle );
     win->handle = 0;
     release_object( win );
@@ -2699,6 +2714,24 @@ DECL_HANDLER(set_window_region)
 }
 
 
+/* set the layer region */
+DECL_HANDLER(set_layer_region)
+{
+    struct region *region = NULL;
+    struct window *win = get_window( req->window );
+
+    if (!win) return;
+
+    if (get_req_data_size())  /* no data means remove the region completely */
+    {
+        if (!(region = create_region_from_req_data( get_req_data(), get_req_data_size() )))
+            return;
+        if (win->ex_style & WS_EX_LAYOUTRTL) mirror_region( &win->window_rect, region );
+    }
+    set_layer_region( win, region );
+}
+
+
 /* get a window update region */
 DECL_HANDLER(get_update_region)
 {
diff --git a/server/winstation.c b/server/winstation.c
index 5903497..7692fbe 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -76,6 +76,7 @@ static const struct object_ops winstation_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -116,6 +117,7 @@ static const struct object_ops desktop_ops =
     no_add_queue,                 /* add_queue */
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
+    NULL,                         /* get_esync_fd */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/tools/make_specfiles b/tools/make_specfiles
index 0509d41..24fc63f 100755
--- a/tools/make_specfiles
+++ b/tools/make_specfiles
@@ -130,6 +130,7 @@ my @dll_groups =
  [
   "ntoskrnl.exe",
   "hal",
+  "win32k.sys",
  ],
  [
   "mscoree",
diff --git a/tools/widl/Makefile.in b/tools/widl/Makefile.in
index cde27db..da6d843 100644
--- a/tools/widl/Makefile.in
+++ b/tools/widl/Makefile.in
@@ -21,7 +21,8 @@ SOURCES = \
 	widl.c \
 	widl.man.in \
 	wpp.c \
-	write_msft.c
+	write_msft.c \
+	write_sltg.c
 
 widl_EXTRADEFS = \
 	-DINCLUDEDIR="\"${includedir}\"" \
diff --git a/tools/widl/register.c b/tools/widl/register.c
index 6c00dfa..c4f8175 100644
--- a/tools/widl/register.c
+++ b/tools/widl/register.c
@@ -316,7 +316,12 @@ void write_typelib_regscript( const statement_list_t *stmts )
         if (count && !strendswith( typelib_name, ".res" ))
             error( "Cannot store multiple typelibs into %s\n", typelib_name );
         else
-            create_msft_typelib( stmt->u.lib );
+        {
+            if (do_old_typelib)
+                create_sltg_typelib( stmt->u.lib );
+            else
+                create_msft_typelib( stmt->u.lib );
+        }
         count++;
     }
     if (count && strendswith( typelib_name, ".res" )) flush_output_resources( typelib_name );
diff --git a/tools/widl/typelib.h b/tools/widl/typelib.h
index 7df7d29..5d9f45a 100644
--- a/tools/widl/typelib.h
+++ b/tools/widl/typelib.h
@@ -83,4 +83,5 @@ enum VARENUM {
 extern unsigned short get_type_vt(type_t *t);
 
 extern int create_msft_typelib(typelib_t *typelib);
+extern int create_sltg_typelib(typelib_t *typelib);
 #endif
diff --git a/tools/widl/widl.c b/tools/widl/widl.c
index 9d3ea0c..08719bb 100644
--- a/tools/widl/widl.c
+++ b/tools/widl/widl.c
@@ -59,6 +59,7 @@ static const char usage[] =
 "   --nostdinc         Do not search the standard include path\n"
 "   --ns_prefix        Prefix namespaces with ABI namespace\n"
 "   --oldnames         Use old naming conventions\n"
+"   --oldtlb           Use old typelib (SLTG) format\n"
 "   -o, --output=NAME  Set the output file name\n"
 "   -Otype             Type of stubs to generate (-Os, -Oi, -Oif)\n"
 "   -p                 Generate proxy\n"
@@ -98,6 +99,7 @@ int do_everything = 1;
 static int preprocess_only = 0;
 int do_header = 0;
 int do_typelib = 0;
+int do_old_typelib = 0;
 int do_proxies = 0;
 int do_client = 0;
 int do_server = 0;
@@ -153,6 +155,7 @@ enum {
     DLLDATA_ONLY_OPTION,
     LOCAL_STUBS_OPTION,
     NOSTDINC_OPTION,
+    OLD_TYPELIB_OPTION,
     PACKING_OPTION,
     PREFIX_ALL_OPTION,
     PREFIX_CLIENT_OPTION,
@@ -179,6 +182,7 @@ static const struct long_option long_options[] = {
     { "nostdinc", 0, NOSTDINC_OPTION },
     { "ns_prefix", 0, RT_NS_PREFIX },
     { "oldnames", 0, OLDNAMES_OPTION },
+    { "oldtlb", 0, OLD_TYPELIB_OPTION },
     { "output", 0, 'o' },
     { "packing", 1, PACKING_OPTION },
     { "prefix-all", 1, PREFIX_ALL_OPTION },
@@ -259,6 +263,7 @@ static void set_everything(int x)
 {
   do_header = x;
   do_typelib = x;
+  do_old_typelib = x;
   do_proxies = x;
   do_client = x;
   do_server = x;
@@ -619,6 +624,9 @@ static void option_callback( int optc, char *optarg )
       do_everything = 0;
       do_typelib = 1;
       break;
+    case OLD_TYPELIB_OPTION:
+      do_old_typelib = 1;
+      break;
     case 'T':
       typelib_name = xstrdup(optarg);
       break;
diff --git a/tools/widl/widl.h b/tools/widl/widl.h
index 15ac74b..b5a4435 100644
--- a/tools/widl/widl.h
+++ b/tools/widl/widl.h
@@ -39,6 +39,7 @@ extern int pedantic;
 extern int do_everything;
 extern int do_header;
 extern int do_typelib;
+extern int do_old_typelib;
 extern int do_proxies;
 extern int do_client;
 extern int do_server;
